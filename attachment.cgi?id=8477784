# HG changeset patch
# User Mihai Sucan <mihai.sucan@gmail.com>
# Date 1407604820 -10800
#      Sat Aug 09 20:20:20 2014 +0300
# Node ID 56225651f72dbb589e2ab5ad63983692a51d61ed
# Parent 5c96ff682443438d5cc15b8fceaa63c8e5e698d8
Bug 1042253 - Enable devtools/webconsole tests with e10s; r=robcee

diff --git a/browser/devtools/webconsole/test/browser.ini b/browser/devtools/webconsole/test/browser.ini
--- a/browser/devtools/webconsole/test/browser.ini
+++ b/browser/devtools/webconsole/test/browser.ini
@@ -1,10 +1,9 @@
 [DEFAULT]
-skip-if = e10s # Bug ?????? - devtools tests disabled with e10s
 subsuite = devtools
 support-files =
   head.js
   test-bug-585956-console-trace.html
   test-bug-593003-iframe-wrong-hud-iframe.html
   test-bug-593003-iframe-wrong-hud.html
   test-bug-595934-canvas-css.html
   test-bug-595934-canvas-css.js
@@ -121,192 +120,193 @@ support-files =
 [browser_bug_638949_copy_link_location.js]
 [browser_bug_862916_console_dir_and_filter_off.js]
 [browser_bug_865288_repeat_different_objects.js]
 [browser_bug_865871_variables_view_close_on_esc_key.js]
 [browser_bug_869003_inspect_cross_domain_object.js]
 [browser_bug_871156_ctrlw_close_tab.js]
 [browser_cached_messages.js]
 skip-if = buildapp == 'mulet'
-[browser_console.js]
+;[browser_console.js]
 [browser_console_addonsdk_loader_exception.js]
+skip-if = e10s # Bug 1049103 - e10s: closing the Browser Console breaks the toolbox
 [browser_console_clear_on_reload.js]
 [browser_console_click_focus.js]
 [browser_console_consolejsm_output.js]
-[browser_console_dead_objects.js]
-[browser_console_error_source_click.js]
-skip-if = buildapp == 'mulet'
+;[browser_console_dead_objects.js]
+;[browser_console_error_source_click.js]
+;skip-if = buildapp == 'mulet'
 [browser_console_filters.js]
 [browser_console_iframe_messages.js]
 skip-if = buildapp == 'mulet'
 [browser_console_keyboard_accessibility.js]
 [browser_console_log_inspectable_object.js]
 [browser_console_native_getters.js]
-[browser_console_navigation_marker.js]
-[browser_console_nsiconsolemessage.js]
-skip-if = buildapp == 'mulet'
-[browser_console_optimized_out_vars.js]
-[browser_console_private_browsing.js]
-skip-if = buildapp == 'mulet'
-[browser_console_variables_view.js]
-[browser_console_variables_view_dom_nodes.js]
-[browser_console_variables_view_dont_sort_non_sortable_classes_properties.js]
-skip-if = buildapp == 'mulet'
-[browser_console_variables_view_while_debugging.js]
-[browser_console_variables_view_while_debugging_and_inspecting.js]
-[browser_eval_in_debugger_stackframe.js]
-[browser_jsterm_inspect.js]
-[browser_longstring_hang.js]
-[browser_netpanel_longstring_expand.js]
-[browser_output_breaks_after_console_dir_uninspectable.js]
-[browser_output_longstring_expand.js]
-[browser_repeated_messages_accuracy.js]
-skip-if = buildapp == 'mulet'
-[browser_result_format_as_string.js]
-[browser_warn_user_about_replaced_api.js]
-[browser_webconsole_abbreviate_source_url.js]
-[browser_webconsole_allow_mixedcontent_securityerrors.js]
-skip-if = buildapp == 'mulet'
-[browser_webconsole_assert.js]
+;[browser_console_navigation_marker.js]
+;[browser_console_nsiconsolemessage.js]
+;skip-if = buildapp == 'mulet'
+;[browser_console_optimized_out_vars.js]
+;[browser_console_private_browsing.js]
+;skip-if = buildapp == 'mulet'
+;[browser_console_variables_view.js]
+;[browser_console_variables_view_dom_nodes.js]
+;[browser_console_variables_view_dont_sort_non_sortable_classes_properties.js]
+;skip-if = buildapp == 'mulet'
+;[browser_console_variables_view_while_debugging.js]
+;[browser_console_variables_view_while_debugging_and_inspecting.js]
+;[browser_eval_in_debugger_stackframe.js]
+;[browser_jsterm_inspect.js]
+;[browser_longstring_hang.js]
+;[browser_netpanel_longstring_expand.js]
+;[browser_output_breaks_after_console_dir_uninspectable.js]
+;[browser_output_longstring_expand.js]
+;[browser_repeated_messages_accuracy.js]
+;skip-if = buildapp == 'mulet'
+;[browser_result_format_as_string.js]
+;[browser_warn_user_about_replaced_api.js]
+;[browser_webconsole_abbreviate_source_url.js]
+;[browser_webconsole_allow_mixedcontent_securityerrors.js]
+;skip-if = buildapp == 'mulet'
+;[browser_webconsole_assert.js]
 [browser_webconsole_basic_net_logging.js]
-[browser_webconsole_block_mixedcontent_securityerrors.js]
-skip-if = buildapp == 'mulet'
+;[browser_webconsole_block_mixedcontent_securityerrors.js]
+;skip-if = buildapp == 'mulet'
 [browser_webconsole_bug_579412_input_focus.js]
-[browser_webconsole_bug_580001_closing_after_completion.js]
-[browser_webconsole_bug_580030_errors_after_page_reload.js]
+;[browser_webconsole_bug_580001_closing_after_completion.js]
+;[browser_webconsole_bug_580030_errors_after_page_reload.js]
 [browser_webconsole_bug_580454_timestamp_l10n.js]
-[browser_webconsole_bug_582201_duplicate_errors.js]
-[browser_webconsole_bug_583816_No_input_and_Tab_key_pressed.js]
-[browser_webconsole_bug_585237_line_limit.js]
+;[browser_webconsole_bug_582201_duplicate_errors.js]
+;[browser_webconsole_bug_583816_No_input_and_Tab_key_pressed.js]
+;[browser_webconsole_bug_585237_line_limit.js]
 [browser_webconsole_bug_585956_console_trace.js]
 [browser_webconsole_bug_585991_autocomplete_keys.js]
 [browser_webconsole_bug_585991_autocomplete_popup.js]
 [browser_webconsole_bug_586388_select_all.js]
 [browser_webconsole_bug_587617_output_copy.js]
 [browser_webconsole_bug_588342_document_focus.js]
 [browser_webconsole_bug_588730_text_node_insertion.js]
 [browser_webconsole_bug_588967_input_expansion.js]
 [browser_webconsole_bug_589162_css_filter.js]
 [browser_webconsole_bug_592442_closing_brackets.js]
-[browser_webconsole_bug_593003_iframe_wrong_hud.js]
+;[browser_webconsole_bug_593003_iframe_wrong_hud.js]
 [browser_webconsole_bug_594477_clickable_output.js]
 [browser_webconsole_bug_594497_history_arrow_keys.js]
-[browser_webconsole_bug_595223_file_uri.js]
-[browser_webconsole_bug_595350_multiple_windows_and_tabs.js]
-[browser_webconsole_bug_595934_message_categories.js]
-[browser_webconsole_bug_597103_deactivateHUDForContext_unfocused_window.js]
-[browser_webconsole_bug_597136_external_script_errors.js]
-[browser_webconsole_bug_597136_network_requests_from_chrome.js]
-[browser_webconsole_bug_597460_filter_scroll.js]
-[browser_webconsole_bug_597756_reopen_closed_tab.js]
-[browser_webconsole_bug_599725_response_headers.js]
-[browser_webconsole_bug_600183_charset.js]
-[browser_webconsole_bug_601177_log_levels.js]
-[browser_webconsole_bug_601352_scroll.js]
-[browser_webconsole_bug_601667_filter_buttons.js]
-[browser_webconsole_bug_602572_log_bodies_checkbox.js]
-[browser_webconsole_bug_603750_websocket.js]
-[browser_webconsole_bug_611795.js]
-[browser_webconsole_bug_613013_console_api_iframe.js]
-[browser_webconsole_bug_613280_jsterm_copy.js]
-[browser_webconsole_bug_613642_maintain_scroll.js]
-[browser_webconsole_bug_613642_prune_scroll.js]
-[browser_webconsole_bug_614793_jsterm_scroll.js]
-[browser_webconsole_bug_618078_network_exceptions.js]
-[browser_webconsole_bug_618311_close_panels.js]
-[browser_webconsole_bug_621644_jsterm_dollar.js]
-[browser_webconsole_bug_622303_persistent_filters.js]
-[browser_webconsole_bug_623749_ctrl_a_select_all_winnt.js]
-run-if = os == "win"
-[browser_webconsole_bug_630733_response_redirect_headers.js]
-[browser_webconsole_bug_632275_getters_document_width.js]
-[browser_webconsole_bug_632347_iterators_generators.js]
-[browser_webconsole_bug_632817.js]
-[browser_webconsole_bug_642108_pruneTest.js]
-[browser_webconsole_autocomplete_and_selfxss.js]
-[browser_webconsole_bug_644419_log_limits.js]
-[browser_webconsole_bug_646025_console_file_location.js]
-[browser_webconsole_bug_651501_document_body_autocomplete.js]
-[browser_webconsole_bug_653531_highlighter_console_helper.js]
-[browser_webconsole_bug_658368_time_methods.js]
+;[browser_webconsole_bug_595223_file_uri.js]
+;[browser_webconsole_bug_595350_multiple_windows_and_tabs.js]
+;[browser_webconsole_bug_595934_message_categories.js]
+;[browser_webconsole_bug_597103_deactivateHUDForContext_unfocused_window.js]
+;[browser_webconsole_bug_597136_external_script_errors.js]
+;[browser_webconsole_bug_597136_network_requests_from_chrome.js]
+;[browser_webconsole_bug_597460_filter_scroll.js]
+;[browser_webconsole_bug_597756_reopen_closed_tab.js]
+;[browser_webconsole_bug_599725_response_headers.js]
+;[browser_webconsole_bug_600183_charset.js]
+;[browser_webconsole_bug_601177_log_levels.js]
+;[browser_webconsole_bug_601352_scroll.js]
+;[browser_webconsole_bug_601667_filter_buttons.js]
+;[browser_webconsole_bug_602572_log_bodies_checkbox.js]
+;[browser_webconsole_bug_603750_websocket.js]
+;[browser_webconsole_bug_611795.js]
+;[browser_webconsole_bug_613013_console_api_iframe.js]
+;[browser_webconsole_bug_613280_jsterm_copy.js]
+;[browser_webconsole_bug_613642_maintain_scroll.js]
+;[browser_webconsole_bug_613642_prune_scroll.js]
+;[browser_webconsole_bug_614793_jsterm_scroll.js]
+;[browser_webconsole_bug_618078_network_exceptions.js]
+;[browser_webconsole_bug_618311_close_panels.js]
+;[browser_webconsole_bug_621644_jsterm_dollar.js]
+;[browser_webconsole_bug_622303_persistent_filters.js]
+;[browser_webconsole_bug_623749_ctrl_a_select_all_winnt.js]
+;run-if = os == "win"
+;[browser_webconsole_bug_630733_response_redirect_headers.js]
+;[browser_webconsole_bug_632275_getters_document_width.js]
+;[browser_webconsole_bug_632347_iterators_generators.js]
+;[browser_webconsole_bug_632817.js]
+;[browser_webconsole_bug_642108_pruneTest.js]
+;[browser_webconsole_autocomplete_and_selfxss.js]
+;[browser_webconsole_bug_644419_log_limits.js]
+;[browser_webconsole_bug_646025_console_file_location.js]
+;[browser_webconsole_bug_651501_document_body_autocomplete.js]
+;[browser_webconsole_bug_653531_highlighter_console_helper.js]
+;[browser_webconsole_bug_658368_time_methods.js]
 [browser_webconsole_bug_659907_console_dir.js]
-[browser_webconsole_bug_660806_history_nav.js]
-[browser_webconsole_bug_664131_console_group.js]
-[browser_webconsole_bug_686937_autocomplete_JSTerm_helpers.js]
-[browser_webconsole_bug_704295.js]
-[browser_webconsole_bug_734061_No_input_change_and_Tab_key_pressed.js]
-[browser_webconsole_bug_737873_mixedcontent.js]
-[browser_webconsole_bug_762593_insecure_passwords_about_blank_web_console_warning.js]
-skip-if = buildapp == 'mulet'
-[browser_webconsole_bug_762593_insecure_passwords_web_console_warning.js]
-skip-if = buildapp == 'mulet'
-[browser_webconsole_bug_764572_output_open_url.js]
-[browser_webconsole_bug_766001_JS_Console_in_Debugger.js]
-skip-if = buildapp == 'mulet'
-[browser_webconsole_bug_770099_violation.js]
-[browser_webconsole_bug_782653_CSS_links_in_Style_Editor.js]
-skip-if = buildapp == 'mulet'
-[browser_webconsole_bug_804845_ctrl_key_nav.js]
-run-if = os == "mac"
-[browser_webconsole_bug_817834_add_edited_input_to_history.js]
-[browser_webconsole_bug_837351_securityerrors.js]
-skip-if = buildapp == 'mulet'
-[browser_webconsole_bug_846918_hsts_invalid-headers.js]
-skip-if = buildapp == 'mulet'
-[browser_webconsole_bug_915141_toggle_response_logging_with_keyboard.js]
+;[browser_webconsole_bug_660806_history_nav.js]
+;[browser_webconsole_bug_664131_console_group.js]
+;[browser_webconsole_bug_686937_autocomplete_JSTerm_helpers.js]
+;[browser_webconsole_bug_704295.js]
+;[browser_webconsole_bug_734061_No_input_change_and_Tab_key_pressed.js]
+;[browser_webconsole_bug_737873_mixedcontent.js]
+;[browser_webconsole_bug_762593_insecure_passwords_about_blank_web_console_warning.js]
+;skip-if = buildapp == 'mulet'
+;[browser_webconsole_bug_762593_insecure_passwords_web_console_warning.js]
+;skip-if = buildapp == 'mulet'
+;[browser_webconsole_bug_764572_output_open_url.js]
+;[browser_webconsole_bug_766001_JS_Console_in_Debugger.js]
+;skip-if = buildapp == 'mulet'
+;[browser_webconsole_bug_770099_violation.js]
+;[browser_webconsole_bug_782653_CSS_links_in_Style_Editor.js]
+;skip-if = buildapp == 'mulet'
+;[browser_webconsole_bug_804845_ctrl_key_nav.js]
+;run-if = os == "mac"
+;[browser_webconsole_bug_817834_add_edited_input_to_history.js]
+;[browser_webconsole_bug_837351_securityerrors.js]
+;skip-if = buildapp == 'mulet'
+;[browser_webconsole_bug_846918_hsts_invalid-headers.js]
+;skip-if = buildapp == 'mulet'
+;[browser_webconsole_bug_915141_toggle_response_logging_with_keyboard.js]
 [browser_webconsole_bug_1006027_message_timestamps_incorrect.js]
-[browser_webconsole_bug_1010953_cspro.js]
-[browser_webconsole_cached_autocomplete.js]
+;[browser_webconsole_bug_1010953_cspro.js]
+;[browser_webconsole_cached_autocomplete.js]
 [browser_webconsole_change_font_size.js]
 [browser_webconsole_chrome.js]
 [browser_webconsole_clickable_urls.js]
-[browser_webconsole_closure_inspection.js]
+;[browser_webconsole_closure_inspection.js]
 [browser_webconsole_completion.js]
-[browser_webconsole_console_extras.js]
+;[browser_webconsole_console_extras.js]
 [browser_webconsole_console_logging_api.js]
-[browser_webconsole_count.js]
+;[browser_webconsole_count.js]
 [browser_webconsole_dont_navigate_on_doubleclick.js]
 [browser_webconsole_execution_scope.js]
 [browser_webconsole_for_of.js]
 [browser_webconsole_history.js]
 [browser_webconsole_input_field_focus_on_panel_select.js]
 [browser_webconsole_inspect-parsed-documents.js]
 [browser_webconsole_js_input_expansion.js]
-[browser_webconsole_jsterm.js]
+;[browser_webconsole_jsterm.js]
 [browser_webconsole_live_filtering_of_message_types.js]
 [browser_webconsole_live_filtering_on_search_strings.js]
 [browser_webconsole_message_node_id.js]
-[browser_webconsole_netlogging.js]
-[browser_webconsole_network_panel.js]
-[browser_webconsole_notifications.js]
+;[browser_webconsole_netlogging.js]
+;[browser_webconsole_network_panel.js]
+;[browser_webconsole_notifications.js]
 [browser_webconsole_open-links-without-callback.js]
 [browser_webconsole_output_copy_newlines.js]
 [browser_webconsole_output_order.js]
-[browser_webconsole_property_provider.js]
-[browser_webconsole_scratchpad_panel_link.js]
-[browser_webconsole_split.js]
+;[browser_webconsole_property_provider.js]
+;[browser_webconsole_scratchpad_panel_link.js]
+;[browser_webconsole_split.js]
 [browser_webconsole_split_escape_key.js]
 [browser_webconsole_split_focus.js]
 [browser_webconsole_split_persist.js]
-[browser_webconsole_view_source.js]
-[browser_webconsole_reflow.js]
+;[browser_webconsole_view_source.js]
+;[browser_webconsole_reflow.js]
 [browser_webconsole_log_file_filter.js]
 [browser_webconsole_expandable_timestamps.js]
-[browser_webconsole_autocomplete_in_debugger_stackframe.js]
-[browser_webconsole_autocomplete_popup_close_on_tab_switch.js]
+;[browser_webconsole_autocomplete_in_debugger_stackframe.js] -> tried https://pastebin.mozilla.org/6061236 but got stuck with debugger stack frame errors
+;[browser_webconsole_autocomplete_popup_close_on_tab_switch.js] -> is successful when running alone, but fails with mach mochitest-devtools --e10s browser/devtools/webconsole/test/ --end-at=browser_webconsole_cd_iframe.js
 [browser_webconsole_autocomplete-properties-with-non-alphanumeric-names.js]
 [browser_console_hide_jsterm_when_devtools_chrome_enabled_false.js]
-[browser_webconsole_output_01.js]
+;[browser_webconsole_output_01.js]
 [browser_webconsole_output_02.js]
 [browser_webconsole_output_03.js]
 [browser_webconsole_output_04.js]
 [browser_webconsole_output_05.js]
 [browser_webconsole_output_06.js]
 [browser_webconsole_output_dom_elements_01.js]
-[browser_webconsole_output_dom_elements_02.js]
+;[browser_webconsole_output_dom_elements_02.js]
 [browser_webconsole_output_dom_elements_03.js]
 [browser_webconsole_output_dom_elements_04.js]
 [browser_webconsole_output_events.js]
 [browser_console_variables_view_highlighter.js]
 [browser_webconsole_start_netmon_first.js]
 [browser_webconsole_console_trace_duplicates.js]
 [browser_webconsole_cd_iframe.js]
 [browser_webconsole_autocomplete_crossdomain_iframe.js]
diff --git a/browser/devtools/webconsole/test/browser_bug664688_sandbox_update_after_navigation.js b/browser/devtools/webconsole/test/browser_bug664688_sandbox_update_after_navigation.js
--- a/browser/devtools/webconsole/test/browser_bug664688_sandbox_update_after_navigation.js
+++ b/browser/devtools/webconsole/test/browser_bug664688_sandbox_update_after_navigation.js
@@ -2,112 +2,90 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Tests if the JSTerm sandbox is updated when the user navigates from one
 // domain to another, in order to avoid permission denied errors with a sandbox
 // created for a different origin.
 
-function test()
-{
+"use strict";
+
+let test = asyncTest(function* () {
   const TEST_URI1 = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
   const TEST_URI2 = "http://example.org/browser/browser/devtools/webconsole/test/test-console.html";
 
-  let hud;
-  let msgForLocation1;
+  yield loadTab(TEST_URI1);
+  let hud = yield openConsole();
 
-  waitForExplicitFinish();
+  hud.jsterm.clearOutput();
+  hud.jsterm.execute("window.location.href");
 
-  gBrowser.selectedTab = gBrowser.addTab(TEST_URI1);
-  gBrowser.selectedBrowser.addEventListener("load", function onLoad() {
-    gBrowser.selectedBrowser.removeEventListener("load", onLoad, true);
-    openConsole(gBrowser.selectedTab, pageLoad1);
-  }, true);
+  info("wait for window.location.href");
 
-  function pageLoad1(aHud)
-  {
-    hud = aHud;
+  let msgForLocation1 = {
+    webconsole: hud,
+    messages: [
+      {
+        name: "window.location.href jsterm input",
+        text: "window.location.href",
+        category: CATEGORY_INPUT,
+      },
+      {
+        name: "window.location.href result is displayed",
+        text: TEST_URI1,
+        category: CATEGORY_OUTPUT,
+      },
+    ],
+  };
 
-    hud.jsterm.clearOutput();
-    hud.jsterm.execute("window.location.href");
+  yield waitForMessages(msgForLocation1);
 
-    info("wait for window.location.href");
+  // load second url
+  content.location = TEST_URI2;
+  yield loadBrowser(gBrowser.selectedBrowser);
 
-    msgForLocation1 = {
-      webconsole: hud,
-      messages: [
-        {
-          name: "window.location.href jsterm input",
-          text: "window.location.href",
-          category: CATEGORY_INPUT,
-        },
-        {
-          name: "window.location.href result is displayed",
-          text: TEST_URI1,
-          category: CATEGORY_OUTPUT,
-        },
-      ]
-    };
+  is(hud.outputNode.textContent.indexOf("Permission denied"), -1,
+     "no permission denied errors");
 
-    waitForMessages(msgForLocation1).then(() => {
-      gBrowser.selectedBrowser.addEventListener("load", onPageLoad2, true);
-      content.location = TEST_URI2;
-    });
-  }
+  hud.jsterm.clearOutput();
+  hud.jsterm.execute("window.location.href");
 
-  function onPageLoad2() {
-    gBrowser.selectedBrowser.removeEventListener("load", onPageLoad2, true);
+  info("wait for window.location.href after page navigation");
 
-    is(hud.outputNode.textContent.indexOf("Permission denied"), -1,
-       "no permission denied errors");
+  yield waitForMessages({
+    webconsole: hud,
+    messages: [
+      {
+        name: "window.location.href jsterm input",
+        text: "window.location.href",
+        category: CATEGORY_INPUT,
+      },
+      {
+        name: "window.location.href result is displayed",
+        text: TEST_URI2,
+        category: CATEGORY_OUTPUT,
+      },
+    ],
+  });
 
-    hud.jsterm.clearOutput();
-    hud.jsterm.execute("window.location.href");
+  is(hud.outputNode.textContent.indexOf("Permission denied"), -1,
+     "no permission denied errors");
 
-    info("wait for window.location.href after page navigation");
+  gBrowser.goBack();
 
-    waitForMessages({
-      webconsole: hud,
-      messages: [
-        {
-          name: "window.location.href jsterm input",
-          text: "window.location.href",
-          category: CATEGORY_INPUT,
-        },
-        {
-          name: "window.location.href result is displayed",
-          text: TEST_URI2,
-          category: CATEGORY_OUTPUT,
-        },
-      ]
-    }).then(() => {
-      is(hud.outputNode.textContent.indexOf("Permission denied"), -1,
-         "no permission denied errors");
-
-      gBrowser.goBack();
-      waitForSuccess(waitForBack);
-    });
-  }
-
-  let waitForBack = {
+  yield waitForSuccess({
     name: "go back",
-    validatorFn: function()
-    {
+    validator: function() {
       return content.location.href == TEST_URI1;
     },
-    successFn: function()
-    {
-      hud.jsterm.clearOutput();
-      executeSoon(() => {
-        hud.jsterm.execute("window.location.href");
-      });
+  });
 
-      info("wait for window.location.href after goBack()");
-      waitForMessages(msgForLocation1).then(() => executeSoon(() => {
-        is(hud.outputNode.textContent.indexOf("Permission denied"), -1,
-           "no permission denied errors");
-        finishTest();
-      }));
-    },
-    failureFn: finishTest,
-  };
-}
+  hud.jsterm.clearOutput();
+  executeSoon(() => {
+    hud.jsterm.execute("window.location.href");
+  });
+
+  info("wait for window.location.href after goBack()");
+  yield waitForMessages(msgForLocation1);
+  is(hud.outputNode.textContent.indexOf("Permission denied"), -1,
+     "no permission denied errors");
+});
diff --git a/browser/devtools/webconsole/test/browser_bug_638949_copy_link_location.js b/browser/devtools/webconsole/test/browser_bug_638949_copy_link_location.js
--- a/browser/devtools/webconsole/test/browser_bug_638949_copy_link_location.js
+++ b/browser/devtools/webconsole/test/browser_bug_638949_copy_link_location.js
@@ -1,118 +1,105 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/" +
-  "test/test-console.html?_date=" + Date.now();
-const COMMAND_NAME = "consoleCmd_copyURL";
-const CONTEXT_MENU_ID = "#menu_copyURL";
+// Test for the "Copy link location" context menu item shown when you right
+// click network requests in the output.
 
-let HUD = null;
-let output = null;
-let menu = null;
+"use strict";
 
-function test() {
-  let originalNetPref = Services.prefs.getBoolPref("devtools.webconsole.filter.networkinfo");
+let test = asyncTest(function* () {
+  const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/" +
+    "test/test-console.html?_date=" + Date.now();
+  const COMMAND_NAME = "consoleCmd_copyURL";
+  const CONTEXT_MENU_ID = "#menu_copyURL";
+
   registerCleanupFunction(() => {
-    Services.prefs.setBoolPref("devtools.webconsole.filter.networkinfo", originalNetPref);
-    HUD = output = menu = null;
+    Services.prefs.clearUserPref("devtools.webconsole.filter.networkinfo");
   });
 
   Services.prefs.setBoolPref("devtools.webconsole.filter.networkinfo", true);
 
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
+  let output = hud.outputNode;
+  let menu = hud.iframeWindow.document.getElementById("output-contextmenu");
 
-    openConsole(null, function (aHud) {
-      HUD = aHud;
-      output = aHud.outputNode;
-      menu = HUD.iframeWindow.document.getElementById("output-contextmenu");
-
-      executeSoon(testWithoutNetActivity);
-    });
-  }, true);
-}
-
-// Return whether "Copy Link Location" command is enabled or not.
-function isEnabled() {
-  let controller = top.document.commandDispatcher
-                   .getControllerForCommand(COMMAND_NAME);
-  return controller && controller.isCommandEnabled(COMMAND_NAME);
-}
-
-function testWithoutNetActivity() {
-  HUD.jsterm.clearOutput();
+  hud.jsterm.clearOutput();
   content.console.log("bug 638949");
 
   // Test that the "Copy Link Location" command is disabled for non-network
   // messages.
-  waitForMessages({
-    webconsole: HUD,
+  let [result] = yield waitForMessages({
+    webconsole: hud,
     messages: [{
       text: "bug 638949",
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG,
     }],
-  }).then(onConsoleMessage);
-}
+  });
 
-function onConsoleMessage(aResults) {
   output.focus();
-  let message = [...aResults[0].matched][0];
+  let message = [...result.matched][0];
 
   goUpdateCommand(COMMAND_NAME);
-  ok(!isEnabled(), COMMAND_NAME + "is disabled");
+  ok(!isEnabled(), COMMAND_NAME + " is disabled");
 
   // Test that the "Copy Link Location" menu item is hidden for non-network
   // messages.
   message.scrollIntoView();
-  waitForContextMenu(menu, message, () => {
+
+  yield waitForContextMenu(menu, message, () => {
     let isHidden = menu.querySelector(CONTEXT_MENU_ID).hidden;
     ok(isHidden, CONTEXT_MENU_ID + " is hidden");
-  }, testWithNetActivity);
-}
+  });
 
-function testWithNetActivity() {
-  HUD.jsterm.clearOutput();
+  hud.jsterm.clearOutput();
   content.location.reload(); // Reloading will produce network logging
 
   // Test that the "Copy Link Location" command is enabled and works
   // as expected for any network-related message.
   // This command should copy only the URL.
-  waitForMessages({
-    webconsole: HUD,
+  [result] = yield waitForMessages({
+    webconsole: hud,
     messages: [{
       text: "test-console.html",
       category: CATEGORY_NETWORK,
       severity: SEVERITY_LOG,
     }],
-  }).then(onNetworkMessage);
-}
+  });
 
-function onNetworkMessage(aResults) {
   output.focus();
-  let message = [...aResults[0].matched][0];
-  HUD.ui.output.selectMessage(message);
+  message = [...result.matched][0];
+  hud.ui.output.selectMessage(message);
 
   goUpdateCommand(COMMAND_NAME);
   ok(isEnabled(), COMMAND_NAME + " is enabled");
 
   info("expected clipboard value: " + message.url);
 
+  let deferred = promise.defer();
+
   waitForClipboard((aData) => { return aData.trim() == message.url; },
-    () => { goDoCommand(COMMAND_NAME) },
-    testMenuWithNetActivity, testMenuWithNetActivity);
+    () => { goDoCommand(COMMAND_NAME); },
+    () => { deferred.resolve(null); },
+    () => { deferred.reject(null); });
 
-  function testMenuWithNetActivity() {
-    // Test that the "Copy Link Location" menu item is visible for network-related
-    // messages.
-    message.scrollIntoView();
-    waitForContextMenu(menu, message, () => {
-      let isVisible = !menu.querySelector(CONTEXT_MENU_ID).hidden;
-      ok(isVisible, CONTEXT_MENU_ID + " is visible");
-    }, finishTest);
+  yield deferred.promise;
+
+  // Test that the "Copy Link Location" menu item is visible for network-related
+  // messages.
+  message.scrollIntoView();
+
+  yield waitForContextMenu(menu, message, () => {
+    let isVisible = !menu.querySelector(CONTEXT_MENU_ID).hidden;
+    ok(isVisible, CONTEXT_MENU_ID + " is visible");
+  });
+
+  // Return whether "Copy Link Location" command is enabled or not.
+  function isEnabled() {
+    let controller = top.document.commandDispatcher
+                     .getControllerForCommand(COMMAND_NAME);
+    return controller && controller.isCommandEnabled(COMMAND_NAME);
   }
-}
-
+});
diff --git a/browser/devtools/webconsole/test/browser_bug_862916_console_dir_and_filter_off.js b/browser/devtools/webconsole/test/browser_bug_862916_console_dir_and_filter_off.js
--- a/browser/devtools/webconsole/test/browser_bug_862916_console_dir_and_filter_off.js
+++ b/browser/devtools/webconsole/test/browser_bug_862916_console_dir_and_filter_off.js
@@ -1,34 +1,31 @@
 /*
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // Check that the output for console.dir() works even if Logging filter is off.
 
+"use strict";
+
 const TEST_URI = "data:text/html;charset=utf8,<p>test for bug 862916";
 
-function test()
-{
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
 
-function consoleOpened(hud)
-{
   ok(hud, "web console opened");
 
   hud.setFilterState("log", false);
   registerCleanupFunction(() => hud.setFilterState("log", true));
 
-  content.wrappedJSObject.fooBarz = "bug862916";
-  hud.jsterm.execute("console.dir(window)");
-  hud.jsterm.once("variablesview-fetched", (aEvent, aVar) => {
-    ok(aVar, "variables view object");
-    findVariableViewProperties(aVar, [
-      { name: "fooBarz", value: "bug862916" },
-    ], { webconsole: hud }).then(finishTest);
-  });
-}
+  hud.jsterm.execute("window.fooBarz = 'bug862916'; " +
+                     "console.dir(window)");
+
+  let varView = yield hud.jsterm.once("variablesview-fetched");
+  ok(varView, "variables view object");
+
+  yield findVariableViewProperties(varView, [
+    { name: "fooBarz", value: "bug862916" },
+  ], { webconsole: hud });
+});
+
diff --git a/browser/devtools/webconsole/test/browser_bug_865288_repeat_different_objects.js b/browser/devtools/webconsole/test/browser_bug_865288_repeat_different_objects.js
--- a/browser/devtools/webconsole/test/browser_bug_865288_repeat_different_objects.js
+++ b/browser/devtools/webconsole/test/browser_bug_865288_repeat_different_objects.js
@@ -1,81 +1,63 @@
 /*
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // Test that makes sure messages are not considered repeated when console.log()
 // is invoked with different objects, see bug 865288.
 
+"use strict";
+
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-repeated-messages.html";
 
-let hud = null;
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
-
-function consoleOpened(aHud) {
-  hud = aHud;
-
-  // Check that css warnings are not coalesced if they come from different lines.
   info("waiting for 3 console.log objects");
 
   hud.jsterm.clearOutput(true);
-  content.wrappedJSObject.testConsoleObjects();
+  hud.jsterm.execute("window.testConsoleObjects()");
 
-  waitForMessages({
+  let [result] = yield waitForMessages({
     webconsole: hud,
     messages: [{
       name: "3 console.log messages",
       text: "abba",
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG,
       count: 3,
       repeats: 1,
       objects: true,
     }],
-  }).then(checkMessages);
-}
+  });
 
-function checkMessages([result])
-{
   let msgs = [...result.matched];
   is(msgs.length, 3, "3 message elements");
-  let m = -1;
 
-  function nextMessage()
-  {
-    let msg = msgs[++m];
-    if (msg) {
-      ok(msg, "message element #" + m);
+  for (let i = 0; i < msgs.length; i++) {
+    info("test message element #" + i);
 
-      let clickable = msg.querySelector(".message-body a");
-      ok(clickable, "clickable object #" + m);
+    let msg = msgs[i];
+    let clickable = msg.querySelector(".message-body a");
+    ok(clickable, "clickable object #" + i);
 
-      msg.scrollIntoView(false);
-      clickObject(clickable);
-    }
-    else {
-      finishTest();
-    }
+    msg.scrollIntoView(false);
+    yield clickObject(clickable, i);
   }
 
-  nextMessage();
+  function* clickObject(obj, i)
+  {
+    executeSoon(() => {
+      EventUtils.synthesizeMouse(obj, 2, 2, {}, hud.iframeWindow);
+    });
 
-  function clickObject(aObject)
-  {
-    hud.jsterm.once("variablesview-fetched", onObjectFetch);
-    EventUtils.synthesizeMouse(aObject, 2, 2, {}, hud.iframeWindow);
+    let varView = yield hud.jsterm.once("variablesview-fetched");
+    ok(varView, "variables view fetched #" + i);
+
+    yield findVariableViewProperties(varView, [
+      { name: "id", value: "abba" + i },
+    ], { webconsole: hud });
   }
+});
 
-  function onObjectFetch(aEvent, aVar)
-  {
-    findVariableViewProperties(aVar, [
-      { name: "id", value: "abba" + m },
-    ], { webconsole: hud }).then(nextMessage);
-  }
-}
diff --git a/browser/devtools/webconsole/test/browser_bug_865871_variables_view_close_on_esc_key.js b/browser/devtools/webconsole/test/browser_bug_865871_variables_view_close_on_esc_key.js
--- a/browser/devtools/webconsole/test/browser_bug_865871_variables_view_close_on_esc_key.js
+++ b/browser/devtools/webconsole/test/browser_bug_865871_variables_view_close_on_esc_key.js
@@ -1,16 +1,18 @@
 /*
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // Check that the variables view sidebar can be closed by pressing Escape in the
 // web console.
 
+"use strict";
+
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-eval-in-stackframe.html";
 
 function test()
 {
   let hud;
 
   Task.spawn(runner).then(finishTest);
 
@@ -39,19 +41,16 @@ function test()
 
     let [result] = yield findVariableViewProperties(vviewVar, [
       { name: "testProp", value: "testValue" },
     ], { webconsole: hud });
 
     let prop = result.matchedProp;
     ok(prop, "matched the |testProp| property in the variables view");
 
-    is(content.wrappedJSObject.fooObj.testProp, result.value,
-       "|fooObj.testProp| value is correct");
-
     vview.window.focus();
 
     executeSoon(() => {
       EventUtils.synthesizeKey("VK_ESCAPE", {});
     });
     yield jsterm.once("sidebar-closed");
 
     jsterm.clearOutput();
diff --git a/browser/devtools/webconsole/test/browser_bug_869003_inspect_cross_domain_object.js b/browser/devtools/webconsole/test/browser_bug_869003_inspect_cross_domain_object.js
--- a/browser/devtools/webconsole/test/browser_bug_869003_inspect_cross_domain_object.js
+++ b/browser/devtools/webconsole/test/browser_bug_869003_inspect_cross_domain_object.js
@@ -1,99 +1,76 @@
 /*
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // Check that users can inspect objects logged from cross-domain iframes -
 // bug 869003.
 
+"use strict";
+
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-bug-869003-top-window.html";
 
-let gWebConsole, gJSTerm, gVariablesView;
-
-function test()
-{
+let test = asyncTest(function* () {
   // This test is slightly more involved: it opens the web console, then the
   // variables view for a given object, it updates a property in the view and
   // checks the result. We can get a timeout with debug builds on slower machines.
   requestLongerTimeout(2);
 
-  addTab("data:text/html;charset=utf8,<p>hello");
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
+  yield loadTab("data:text/html;charset=utf8,<p>hello");
+  let hud = yield openConsole();
 
-function consoleOpened(hud)
-{
-  gWebConsole = hud;
-  gJSTerm = hud.jsterm;
   content.location = TEST_URI;
 
-  waitForMessages({
+  let [result] = yield waitForMessages({
     webconsole: hud,
     messages: [{
       name: "console.log message",
       text: "foobar",
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG,
       objects: true,
     }],
-  }).then(onConsoleMessage);
-}
+  });
 
-function onConsoleMessage(aResults)
-{
-  let msg = [...aResults[0].matched][0];
+  let msg = [...result.matched][0];
   ok(msg, "message element");
 
   let body = msg.querySelector(".message-body");
   ok(body, "message body");
 
-  let clickable = aResults[0].clickableElements[0];
+  let clickable = result.clickableElements[0];
   ok(clickable, "clickable object found");
   ok(body.textContent.contains('{ hello: "world!",'), "message text check");
 
-  gJSTerm.once("variablesview-fetched", onObjFetch);
+  executeSoon(() => {
+    EventUtils.synthesizeMouse(clickable, 2, 2, {}, hud.iframeWindow)
+  });
 
-  EventUtils.synthesizeMouse(clickable, 2, 2, {}, gWebConsole.iframeWindow)
-}
+  let aVar = yield hud.jsterm.once("variablesview-fetched");
+  ok(aVar, "variables view fetched");
+  ok(aVar._variablesView, "variables view object");
 
-function onObjFetch(aEvent, aVar)
-{
-  gVariablesView = aVar._variablesView;
-  ok(gVariablesView, "variables view object");
-
-  findVariableViewProperties(aVar, [
+  [result] = yield findVariableViewProperties(aVar, [
     { name: "hello", value: "world!" },
     { name: "bug", value: 869003 },
-  ], { webconsole: gWebConsole }).then(onPropFound);
-}
+  ], { webconsole: hud });
 
-function onPropFound(aResults)
-{
-  let prop = aResults[0].matchedProp;
+  let prop = result.matchedProp;
   ok(prop, "matched the |hello| property in the variables view");
 
   // Check that property value updates work.
-  updateVariablesViewProperty({
+  aVar = yield updateVariablesViewProperty({
     property: prop,
     field: "value",
     string: "'omgtest'",
-    webconsole: gWebConsole,
-    callback: onFetchAfterUpdate,
+    webconsole: hud,
   });
-}
 
-function onFetchAfterUpdate(aEvent, aVar)
-{
   info("onFetchAfterUpdate");
 
-  findVariableViewProperties(aVar, [
+  yield findVariableViewProperties(aVar, [
     { name: "hello", value: "omgtest" },
     { name: "bug", value: 869003 },
-  ], { webconsole: gWebConsole }).then(() => {
-    gWebConsole = gJSTerm = gVariablesView = null;
-    finishTest();
-  });
-}
+  ], { webconsole: hud });
+});
+
diff --git a/browser/devtools/webconsole/test/browser_bug_871156_ctrlw_close_tab.js b/browser/devtools/webconsole/test/browser_bug_871156_ctrlw_close_tab.js
--- a/browser/devtools/webconsole/test/browser_bug_871156_ctrlw_close_tab.js
+++ b/browser/devtools/webconsole/test/browser_bug_871156_ctrlw_close_tab.js
@@ -1,83 +1,79 @@
 /*
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // Check that Ctrl-W closes the Browser Console and that Ctrl-W closes the
 // current tab when using the Web Console - bug 871156.
 
-function test()
-{
+"use strict";
+
+let test = asyncTest(function* () {
   const TEST_URI = "data:text/html;charset=utf8,<title>bug871156</title>\n" +
                    "<p>hello world";
   let firstTab = gBrowser.selectedTab;
+
   Services.prefs.setBoolPref("browser.tabs.animate", false);
+  registerCleanupFunction(() => {
+    Services.prefs.clearUserPref("browser.tabs.animate");
+  });
 
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
+  yield loadTab(TEST_URI);
 
-  function consoleOpened(hud)
-  {
-    ok(hud, "Web Console opened");
+  let hud = yield openConsole();
+  ok(hud, "Web Console opened");
 
-    let tabClosed = promise.defer();
-    let toolboxDestroyed = promise.defer();
-    let tabSelected = promise.defer();
+  let tabClosed = promise.defer();
+  let toolboxDestroyed = promise.defer();
+  let tabSelected = promise.defer();
 
-    let pageWindow = firstTab.linkedBrowser.contentWindow;
-    let toolbox = gDevTools.getToolbox(hud.target);
+  let target = TargetFactory.forTab(gBrowser.selectedTab);
+  let toolbox = gDevTools.getToolbox(target);
 
-    gBrowser.tabContainer.addEventListener("TabClose", function onTabClose() {
-      gBrowser.tabContainer.removeEventListener("TabClose", onTabClose);
-      info("tab closed");
-      tabClosed.resolve(null);
-    });
+  gBrowser.tabContainer.addEventListener("TabClose", function onTabClose() {
+    gBrowser.tabContainer.removeEventListener("TabClose", onTabClose);
+    info("tab closed");
+    tabClosed.resolve(null);
+  });
 
-    gBrowser.tabContainer.addEventListener("TabSelect", function onTabSelect() {
-      gBrowser.tabContainer.removeEventListener("TabSelect", onTabSelect);
-      if (gBrowser.selectedTab == firstTab) {
-        info("tab selected");
-        tabSelected.resolve(null);
-      }
-    });
+  gBrowser.tabContainer.addEventListener("TabSelect", function onTabSelect() {
+    gBrowser.tabContainer.removeEventListener("TabSelect", onTabSelect);
+    if (gBrowser.selectedTab == firstTab) {
+      info("tab selected");
+      tabSelected.resolve(null);
+    }
+  });
 
-    toolbox.once("destroyed", () => {
-      info("toolbox destroyed");
-      toolboxDestroyed.resolve(null);
-    });
+  toolbox.once("destroyed", () => {
+    info("toolbox destroyed");
+    toolboxDestroyed.resolve(null);
+  });
 
-    promise.all([tabClosed.promise, toolboxDestroyed.promise, tabSelected.promise ]).then(() => {
-      info("promise.all resolved");
-      waitForFocus(testBrowserConsole, pageWindow, true);
-    });
+  // Get out of the web console initialization.
+  executeSoon(() => {
+    EventUtils.synthesizeKey("w", { accelKey: true });
+  });
 
-    // Get out of the web console initialization.
-    executeSoon(() => {
-      EventUtils.synthesizeKey("w", { accelKey: true });
-    });
-  }
 
-  function testBrowserConsole()
-  {
-    info("test the Browser Console");
+  yield promise.all([tabClosed.promise, toolboxDestroyed.promise,
+                     tabSelected.promise]);
+  info("promise.all resolved. start testing the Browser Console");
 
-    HUDService.toggleBrowserConsole().then((hud) => {
-      ok(hud, "Browser Console opened");
+  hud = yield HUDService.toggleBrowserConsole();
+  ok(hud, "Browser Console opened");
 
-      Services.obs.addObserver(function onDestroy() {
-        Services.obs.removeObserver(onDestroy, "web-console-destroyed");
-        ok(true, "the Browser Console closed");
+  let deferred = promise.defer();
 
-        Services.prefs.clearUserPref("browser.tabs.animate");
-        waitForFocus(finish, content, true);
-      }, "web-console-destroyed", false);
+  Services.obs.addObserver(function onDestroy() {
+    Services.obs.removeObserver(onDestroy, "web-console-destroyed");
+    ok(true, "the Browser Console closed");
 
-      waitForFocus(() => {
-        EventUtils.synthesizeKey("w", { accelKey: true }, hud.iframeWindow);
-      }, hud.iframeWindow);
-    });
-  }
-}
+    deferred.resolve(null);
+  }, "web-console-destroyed", false);
+
+  waitForFocus(() => {
+    EventUtils.synthesizeKey("w", { accelKey: true }, hud.iframeWindow);
+  }, hud.iframeWindow);
+
+  yield deferred.promise;
+});
diff --git a/browser/devtools/webconsole/test/browser_console_addonsdk_loader_exception.js b/browser/devtools/webconsole/test/browser_console_addonsdk_loader_exception.js
--- a/browser/devtools/webconsole/test/browser_console_addonsdk_loader_exception.js
+++ b/browser/devtools/webconsole/test/browser_console_addonsdk_loader_exception.js
@@ -2,16 +2,18 @@
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // Check that exceptions from scripts loaded with the addon-sdk loader are
 // opened correctly in View Source from the Browser Console.
 // See bug 866950.
 
+"use strict";
+
 const TEST_URI = "data:text/html;charset=utf8,<p>hello world from bug 866950";
 
 function test()
 {
   requestLongerTimeout(2);
 
   let webconsole, browserconsole;
 
@@ -40,19 +42,20 @@ function test()
       executeSoon(fixToolbox);
       expectUncaughtException();
       toolbox.getToolPanels();
     });
 
     let [result] = yield waitForMessages({
       webconsole: browserconsole,
       messages: [{
-        text: "TypeError: can't convert null to object",
+        text: "can't convert null to object",
         category: CATEGORY_JS,
         severity: SEVERITY_ERROR,
+        source: { url: /\btoolbox\.js\b/ }
       }],
     });
 
     fixToolbox();
 
     let msg = [...result.matched][0];
     ok(msg, "message element found");
     let locationNode = msg.querySelector(".message-location");
diff --git a/browser/devtools/webconsole/test/browser_console_clear_on_reload.js b/browser/devtools/webconsole/test/browser_console_clear_on_reload.js
--- a/browser/devtools/webconsole/test/browser_console_clear_on_reload.js
+++ b/browser/devtools/webconsole/test/browser_console_clear_on_reload.js
@@ -1,73 +1,54 @@
 /*
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // Check that clear output on page reload works - bug 705921.
 
-function test()
-{
+"use strict";
+
+let test = asyncTest(function*() {
   const PREF = "devtools.webconsole.persistlog";
   const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
-  let hud = null;
 
   Services.prefs.setBoolPref(PREF, false);
   registerCleanupFunction(() => Services.prefs.clearUserPref(PREF));
 
-  addTab(TEST_URI);
+  yield loadTab(TEST_URI);
 
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
+  let hud = yield openConsole();
+  ok(hud, "Web Console opened");
 
-  function consoleOpened(aHud)
-  {
-    hud = aHud;
-    ok(hud, "Web Console opened");
+  hud.jsterm.clearOutput();
+  hud.jsterm.execute("console.log('foobarz1')");
 
-    hud.jsterm.clearOutput();
-    content.console.log("foobarz1");
-    waitForMessages({
-      webconsole: hud,
-      messages: [{
-        text: "foobarz1",
-        category: CATEGORY_WEBDEV,
-        severity: SEVERITY_LOG,
-      }],
-    }).then(onConsoleMessage);
-  }
+  yield waitForMessages({
+    webconsole: hud,
+    messages: [{
+      text: "foobarz1",
+      category: CATEGORY_WEBDEV,
+      severity: SEVERITY_LOG,
+    }],
+  });
 
-  function onConsoleMessage()
-  {
-    browser.addEventListener("load", onReload, true);
-    content.location.reload();
-  }
+  BrowserReload();
+  yield loadBrowser(gBrowser.selectedBrowser);
 
-  function onReload()
-  {
-    browser.removeEventListener("load", onReload, true);
+  hud.jsterm.execute("console.log('foobarz2')");
 
-    content.console.log("foobarz2");
+  yield waitForMessages({
+    webconsole: hud,
+    messages: [{
+      text: "test-console.html",
+      category: CATEGORY_NETWORK,
+    },
+    {
+      text: "foobarz2",
+      category: CATEGORY_WEBDEV,
+      severity: SEVERITY_LOG,
+    }],
+  });
 
-    waitForMessages({
-      webconsole: hud,
-      messages: [{
-        text: "test-console.html",
-        category: CATEGORY_NETWORK,
-      },
-      {
-        text: "foobarz2",
-        category: CATEGORY_WEBDEV,
-        severity: SEVERITY_LOG,
-      }],
-    }).then(onConsoleMessageAfterReload);
-  }
-
-  function onConsoleMessageAfterReload()
-  {
-    is(hud.outputNode.textContent.indexOf("foobarz1"), -1,
-       "foobarz1 has been removed from output");
-    finishTest();
-  }
-}
+  is(hud.outputNode.textContent.indexOf("foobarz1"), -1,
+     "foobarz1 has been removed from output");
+});
diff --git a/browser/devtools/webconsole/test/browser_console_click_focus.js b/browser/devtools/webconsole/test/browser_console_click_focus.js
--- a/browser/devtools/webconsole/test/browser_console_click_focus.js
+++ b/browser/devtools/webconsole/test/browser_console_click_focus.js
@@ -1,60 +1,55 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Tests that the input field is focused when the console is opened.
 
+"use strict";
+
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("DOMContentLoaded", testInputFocus, false);
-}
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
 
-function testInputFocus() {
-  browser.removeEventListener("DOMContentLoaded", testInputFocus, false);
+  let [result] = yield waitForMessages({
+    webconsole: hud,
+    messages: [{
+      text: "Dolske Digs Bacon",
+      category: CATEGORY_WEBDEV,
+      severity: SEVERITY_LOG,
+    }],
+  });
 
-  openConsole().then((hud) => {
-    waitForMessages({
-      webconsole: hud,
-      messages: [{
-        text: "Dolske Digs Bacon",
-        category: CATEGORY_WEBDEV,
-        severity: SEVERITY_LOG,
-      }],
-    }).then(([result]) => {
-      let msg = [...result.matched][0];
-      let outputItem = msg.querySelector(".message-body");
-      ok(outputItem, "found a logged message");
-      let inputNode = hud.jsterm.inputNode;
-      ok(inputNode.getAttribute("focused"), "input node is focused, first");
+  let msg = [...result.matched][0];
+  let outputItem = msg.querySelector(".message-body");
+  ok(outputItem, "found a logged message");
 
-      let lostFocus = () => {
-        inputNode.removeEventListener("blur", lostFocus);
-        info("input node lost focus");
-      }
+  let inputNode = hud.jsterm.inputNode;
+  ok(inputNode.getAttribute("focused"), "input node is focused, first");
 
-      inputNode.addEventListener("blur", lostFocus);
+  let lostFocus = () => {
+    inputNode.removeEventListener("blur", lostFocus);
+    info("input node lost focus");
+  }
 
-      browser.ownerDocument.getElementById("urlbar").click();
+  inputNode.addEventListener("blur", lostFocus);
 
-      ok(!inputNode.getAttribute("focused"), "input node is not focused");
+  document.getElementById("urlbar").click();
 
-      EventUtils.sendMouseEvent({type: "click"}, hud.outputNode);
+  ok(!inputNode.getAttribute("focused"), "input node is not focused");
 
-      ok(inputNode.getAttribute("focused"), "input node is focused, second time")
+  EventUtils.sendMouseEvent({type: "click"}, hud.outputNode);
 
-      // test click-drags are not focusing the input element.
-      EventUtils.sendMouseEvent({type: "mousedown", clientX: 3, clientY: 4},
-        outputItem);
-      EventUtils.sendMouseEvent({type: "click", clientX: 15, clientY: 5},
-        outputItem);
+  ok(inputNode.getAttribute("focused"), "input node is focused, second time")
 
-      executeSoon(() => {
-        todo(!inputNode.getAttribute("focused"), "input node is not focused after drag");
-        finishTest();
-      });
-    });
-  });
-}
+  // test click-drags are not focusing the input element.
+  EventUtils.sendMouseEvent({type: "mousedown", clientX: 3, clientY: 4},
+    outputItem);
+  EventUtils.sendMouseEvent({type: "click", clientX: 15, clientY: 5},
+    outputItem);
+
+  todo(!inputNode.getAttribute("focused"), "input node is not focused after drag");
+});
+
diff --git a/browser/devtools/webconsole/test/browser_console_consolejsm_output.js b/browser/devtools/webconsole/test/browser_console_consolejsm_output.js
--- a/browser/devtools/webconsole/test/browser_console_consolejsm_output.js
+++ b/browser/devtools/webconsole/test/browser_console_consolejsm_output.js
@@ -1,135 +1,137 @@
 /*
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // Test that Console.jsm outputs messages to the Browser Console, bug 851231.
 
-function test()
-{
+"use strict";
+
+let test = asyncTest(function*() {
   let storage = Cc["@mozilla.org/consoleAPI-storage;1"].getService(Ci.nsIConsoleAPIStorage);
   storage.clearEvents();
 
   let console = Cu.import("resource://gre/modules/devtools/Console.jsm", {}).console;
   console.log("bug861338-log-cached");
 
-  HUDService.toggleBrowserConsole().then(consoleOpened);
-  let hud = null;
+  let hud = yield HUDService.toggleBrowserConsole();
 
-  function consoleOpened(aHud)
-  {
-    hud = aHud;
-    waitForMessages({
-      webconsole: hud,
-      messages: [{
-        name: "cached console.log message",
-        text: "bug861338-log-cached",
+  yield waitForMessages({
+    webconsole: hud,
+    messages: [{
+      name: "cached console.log message",
+      text: "bug861338-log-cached",
+      category: CATEGORY_WEBDEV,
+      severity: SEVERITY_LOG,
+    }],
+  });
+
+  hud.jsterm.clearOutput(true);
+
+  function testTrace() {
+    console.trace();
+  }
+
+  console.time("foobarTimer");
+  let foobar = { bug851231prop: "bug851231value" };
+
+  console.log("bug851231-log");
+  console.info("bug851231-info");
+  console.warn("bug851231-warn");
+  console.error("bug851231-error", foobar);
+  console.debug("bug851231-debug");
+  console.dir(document);
+  testTrace();
+  console.timeEnd("foobarTimer");
+
+  info("wait for the Console.jsm messages");
+
+  let results = yield waitForMessages({
+    webconsole: hud,
+    messages: [
+      {
+        name: "console.log output",
+        text: "bug851231-log",
         category: CATEGORY_WEBDEV,
         severity: SEVERITY_LOG,
-      }],
-    }).then(onCachedMessage);
-  }
+      },
+      {
+        name: "console.info output",
+        text: "bug851231-info",
+        category: CATEGORY_WEBDEV,
+        severity: SEVERITY_INFO,
+      },
+      {
+        name: "console.warn output",
+        text: "bug851231-warn",
+        category: CATEGORY_WEBDEV,
+        severity: SEVERITY_WARNING,
+      },
+      {
+        name: "console.error output",
+        text: /\bbug851231-error\b.+\{\s*bug851231prop:\s"bug851231value"\s*\}/,
+        category: CATEGORY_WEBDEV,
+        severity: SEVERITY_ERROR,
+        objects: true,
+      },
+      {
+        name: "console.debug output",
+        text: "bug851231-debug",
+        category: CATEGORY_WEBDEV,
+        severity: SEVERITY_LOG,
+      },
+      {
+        name: "console.trace output",
+        consoleTrace: {
+          file: "browser_console_consolejsm_output.js",
+          fn: "testTrace",
+        },
+      },
+      {
+        name: "console.dir output",
+        consoleDir: /XULDocument\s+.+\s+chrome:\/\/.+\/browser\.xul/,
+      },
+      {
+        name: "console.time output",
+        consoleTime: "foobarTimer",
+      },
+      {
+        name: "console.timeEnd output",
+        consoleTimeEnd: "foobarTimer",
+      },
+    ],
+  });
 
-  function onCachedMessage()
-  {
-    hud.jsterm.clearOutput(true);
+  let consoleErrorMsg = results[3];
+  ok(consoleErrorMsg, "console.error message element found");
+  let clickable = consoleErrorMsg.clickableElements[0];
+  ok(clickable, "clickable object found for console.error");
 
-    console.time("foobarTimer");
-    let foobar = { bug851231prop: "bug851231value" };
+  let deferred = promise.defer();
 
-    console.log("bug851231-log");
-    console.info("bug851231-info");
-    console.warn("bug851231-warn");
-    console.error("bug851231-error", foobar);
-    console.debug("bug851231-debug");
-    console.trace();
-    console.dir(document);
-    console.timeEnd("foobarTimer");
+  let onFetch = (aEvent, aVar) => {
+    // Skip the notification from console.dir variablesview-fetched.
+    if (aVar._variablesView != hud.jsterm._variablesView) {
+      return;
+    }
+    hud.jsterm.off("variablesview-fetched", onFetch);
 
-    info("wait for the Console.jsm messages");
+    deferred.resolve(aVar);
+  };
 
-    waitForMessages({
-      webconsole: hud,
-      messages: [
-        {
-          name: "console.log output",
-          text: "bug851231-log",
-          category: CATEGORY_WEBDEV,
-          severity: SEVERITY_LOG,
-        },
-        {
-          name: "console.info output",
-          text: "bug851231-info",
-          category: CATEGORY_WEBDEV,
-          severity: SEVERITY_INFO,
-        },
-        {
-          name: "console.warn output",
-          text: "bug851231-warn",
-          category: CATEGORY_WEBDEV,
-          severity: SEVERITY_WARNING,
-        },
-        {
-          name: "console.error output",
-          text: /\bbug851231-error\b.+\{\s*bug851231prop:\s"bug851231value"\s*\}/,
-          category: CATEGORY_WEBDEV,
-          severity: SEVERITY_ERROR,
-          objects: true,
-        },
-        {
-          name: "console.debug output",
-          text: "bug851231-debug",
-          category: CATEGORY_WEBDEV,
-          severity: SEVERITY_LOG,
-        },
-        {
-          name: "console.trace output",
-          consoleTrace: {
-            file: "browser_console_consolejsm_output.js",
-            fn: "onCachedMessage",
-          },
-        },
-        {
-          name: "console.dir output",
-          consoleDir: /XULDocument\s+.+\s+chrome:\/\/.+\/browser\.xul/,
-        },
-        {
-          name: "console.time output",
-          consoleTime: "foobarTimer",
-        },
-        {
-          name: "console.timeEnd output",
-          consoleTimeEnd: "foobarTimer",
-        },
-      ],
-    }).then((aResults) => {
-      let consoleErrorMsg = aResults[3];
-      ok(consoleErrorMsg, "console.error message element found");
-      let clickable = consoleErrorMsg.clickableElements[0];
-      ok(clickable, "clickable object found for console.error");
+  hud.jsterm.on("variablesview-fetched", onFetch);
 
-      let onFetch = (aEvent, aVar) => {
-        // Skip the notification from console.dir variablesview-fetched.
-        if (aVar._variablesView != hud.jsterm._variablesView) {
-          return;
-        }
-        hud.jsterm.off("variablesview-fetched", onFetch);
+  clickable.scrollIntoView(false);
 
-        ok(aVar, "object inspector opened on click");
+  info("wait for variablesview-fetched");
+  executeSoon(() =>
+    EventUtils.synthesizeMouse(clickable, 2, 2, {}, hud.iframeWindow));
 
-        findVariableViewProperties(aVar, [{
-          name: "bug851231prop",
-          value: "bug851231value",
-        }], { webconsole: hud }).then(finishTest);
-      };
+  let varView = yield deferred.promise;
+  ok(varView, "object inspector opened on click");
 
-      hud.jsterm.on("variablesview-fetched", onFetch);
-
-      clickable.scrollIntoView(false);
-
-      info("wait for variablesview-fetched");
-      executeSoon(() =>
-        EventUtils.synthesizeMouse(clickable, 2, 2, {}, hud.iframeWindow));
-    });
-  }
-}
+  yield findVariableViewProperties(varView, [{
+    name: "bug851231prop",
+    value: "bug851231value",
+  }], { webconsole: hud });
+});
diff --git a/browser/devtools/webconsole/test/browser_console_dead_objects.js b/browser/devtools/webconsole/test/browser_console_dead_objects.js
--- a/browser/devtools/webconsole/test/browser_console_dead_objects.js
+++ b/browser/devtools/webconsole/test/browser_console_dead_objects.js
@@ -7,16 +7,18 @@
 // This test does:
 // - opens a new tab,
 // - opens the Browser Console,
 // - stores a reference to the content document of the tab on the chrome window object,
 // - closes the tab,
 // - tries to use the object that was pointing to the now-defunct content
 // document. This is the dead object.
 
+"use strict";
+
 const TEST_URI = "data:text/html;charset=utf8,<p>dead objects!";
 
 function test()
 {
   let hud = null;
 
   registerCleanupFunction(() => {
     Services.prefs.clearUserPref("devtools.chrome.enabled");
@@ -32,21 +34,17 @@ function test()
 
     hud = yield HUDService.toggleBrowserConsole();
     ok(hud, "browser console opened");
 
     hud.jsterm.clearOutput();
 
     // Add the reference to the content document.
 
-    yield execute("Cu = Components.utils;" +
-                  "Cu.import('resource://gre/modules/Services.jsm');" +
-                  "chromeWindow = Services.wm.getMostRecentWindow('navigator:browser');" +
-                  "foobarzTezt = chromeWindow.content.document;" +
-                  "delete chromeWindow");
+    yield execute("foobarzTezt = content.document.documentElement");
 
     gBrowser.removeCurrentTab();
 
     let msg = yield execute("foobarzTezt");
 
     isnot(hud.outputNode.textContent.indexOf("[object DeadObject]"), -1,
           "dead object found");
 
@@ -56,16 +54,18 @@ function test()
       EventUtils.synthesizeKey(c, {}, hud.iframeWindow);
     }
 
     yield execute();
 
     isnot(hud.outputNode.textContent.indexOf("can't access dead object"), -1,
           "'cannot access dead object' message found");
 
+    yield promise.defer().promise;
+
     // Click the second execute output.
     let clickable = msg.querySelector("a");
     ok(clickable, "clickable object found");
     isnot(clickable.textContent.indexOf("[object DeadObject]"), -1,
           "message text check");
 
     msg.scrollIntoView();
 
diff --git a/browser/devtools/webconsole/test/browser_console_filters.js b/browser/devtools/webconsole/test/browser_console_filters.js
--- a/browser/devtools/webconsole/test/browser_console_filters.js
+++ b/browser/devtools/webconsole/test/browser_console_filters.js
@@ -1,32 +1,27 @@
 /*
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // Check that the Browser Console does not use the same filter prefs as the Web
 // Console. See bug 878186.
 
+"use strict";
+
 const TEST_URI = "data:text/html;charset=utf8,<p>browser console filters";
 const WEB_CONSOLE_PREFIX = "devtools.webconsole.filter.";
 const BROWSER_CONSOLE_PREFIX = "devtools.browserconsole.filter.";
 
-function test()
-{
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    info("open the web console");
-    openConsole(null, consoleOpened);
-  }, true);
-}
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
 
-function consoleOpened(hud)
-{
+  info("open the web console");
+  let hud = yield openConsole();
   ok(hud, "web console opened");
 
   is(Services.prefs.getBoolPref(BROWSER_CONSOLE_PREFIX + "exception"), true,
      "'exception' filter is enabled (browser console)");
   is(Services.prefs.getBoolPref(WEB_CONSOLE_PREFIX + "exception"), true,
      "'exception' filter is enabled (web console)");
 
   info("toggle 'exception' filter");
@@ -34,38 +29,32 @@ function consoleOpened(hud)
 
   is(Services.prefs.getBoolPref(BROWSER_CONSOLE_PREFIX + "exception"), true,
      "'exception' filter is enabled (browser console)");
   is(Services.prefs.getBoolPref(WEB_CONSOLE_PREFIX + "exception"), false,
      "'exception' filter is disabled (web console)");
 
   hud.setFilterState("exception", true);
 
-  executeSoon(() => closeConsole(null, onWebConsoleClose));
-}
+  // We need to let the console opening event loop to finish.
+  let deferred = promise.defer();
+  executeSoon(() => closeConsole().then(() => deferred.resolve(null)));
+  yield deferred.promise;
 
-function onWebConsoleClose()
-{
   info("web console closed");
-  HUDService.toggleBrowserConsole().then(onBrowserConsoleOpen);
-}
-
-function onBrowserConsoleOpen(hud)
-{
+  hud = yield HUDService.toggleBrowserConsole();
   ok(hud, "browser console opened");
 
   is(Services.prefs.getBoolPref(BROWSER_CONSOLE_PREFIX + "exception"), true,
      "'exception' filter is enabled (browser console)");
   is(Services.prefs.getBoolPref(WEB_CONSOLE_PREFIX + "exception"), true,
      "'exception' filter is enabled (web console)");
 
   info("toggle 'exception' filter");
   hud.setFilterState("exception", false);
 
   is(Services.prefs.getBoolPref(BROWSER_CONSOLE_PREFIX + "exception"), false,
      "'exception' filter is disabled (browser console)");
   is(Services.prefs.getBoolPref(WEB_CONSOLE_PREFIX + "exception"), true,
      "'exception' filter is enabled (web console)");
 
   hud.setFilterState("exception", true);
-
-  executeSoon(finishTest);
-}
+});
diff --git a/browser/devtools/webconsole/test/browser_console_keyboard_accessibility.js b/browser/devtools/webconsole/test/browser_console_keyboard_accessibility.js
--- a/browser/devtools/webconsole/test/browser_console_keyboard_accessibility.js
+++ b/browser/devtools/webconsole/test/browser_console_keyboard_accessibility.js
@@ -1,90 +1,79 @@
 /*
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // Check that basic keyboard shortcuts work in the web console.
 
-function test()
-{
+"use strict";
+
+let test = asyncTest(function*() {
   const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
-  let hud = null;
 
-  addTab(TEST_URI);
+  yield loadTab(TEST_URI);
 
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
+  let hud = yield openConsole();
+  ok(hud, "Web Console opened");
 
-  function consoleOpened(aHud)
-  {
-    hud = aHud;
-    ok(hud, "Web Console opened");
+  info("dump some spew into the console for scrolling");
+  hud.jsterm.execute("(function() { for (var i = 0; i < 100; i++) { " +
+                     "console.log('foobarz' + i);" +
+                     "}})();");
 
-    info("dump some spew into the console for scrolling");
-    for (let i = 0; i < 100; i++)
-      content.console.log("foobarz" + i);
-    waitForMessages({
-      webconsole: hud,
-      messages: [{
-        text: "foobarz99",
-        category: CATEGORY_WEBDEV,
-        severity: SEVERITY_LOG,
-      }],
-    }).then(onConsoleMessage);
+  yield waitForMessages({
+    webconsole: hud,
+    messages: [{
+      text: "foobarz99",
+      category: CATEGORY_WEBDEV,
+      severity: SEVERITY_LOG,
+    }],
+  });
+
+  let currentPosition = hud.outputNode.parentNode.scrollTop;
+  let bottom = currentPosition;
+
+  EventUtils.synthesizeKey("VK_PAGE_UP", {});
+  isnot(hud.outputNode.parentNode.scrollTop, currentPosition, "scroll position changed after page up");
+
+  currentPosition = hud.outputNode.parentNode.scrollTop;
+  EventUtils.synthesizeKey("VK_PAGE_DOWN", {});
+  ok(hud.outputNode.parentNode.scrollTop > currentPosition, "scroll position now at bottom");
+
+  EventUtils.synthesizeKey("VK_HOME", {});
+  is(hud.outputNode.parentNode.scrollTop, 0, "scroll position now at top");
+
+  EventUtils.synthesizeKey("VK_END", {});
+
+  let scrollTop = hud.outputNode.parentNode.scrollTop;
+  ok(scrollTop > 0 && Math.abs(scrollTop - bottom) <= 5,
+     "scroll position now at bottom");
+
+  info("try ctrl-l to clear output");
+  executeSoon(() => { EventUtils.synthesizeKey("l", { ctrlKey: true }); });
+  yield hud.jsterm.once("messages-cleared");
+
+  is(hud.outputNode.textContent.indexOf("foobarz1"), -1, "output cleared");
+  is(hud.jsterm.inputNode.getAttribute("focused"), "true",
+     "jsterm input is focused");
+
+  info("try ctrl-f to focus filter");
+  EventUtils.synthesizeKey("F", { accelKey: true });
+  ok(!hud.jsterm.inputNode.getAttribute("focused"),
+     "jsterm input is not focused");
+  is(hud.ui.filterBox.getAttribute("focused"), "true",
+     "filter input is focused");
+
+  if (Services.appinfo.OS == "Darwin") {
+    ok(hud.ui.getFilterState("network"), "network category is enabled");
+    EventUtils.synthesizeKey("t", { ctrlKey: true });
+    ok(!hud.ui.getFilterState("network"), "accesskey for Network works");
+    EventUtils.synthesizeKey("t", { ctrlKey: true });
+    ok(hud.ui.getFilterState("network"), "accesskey for Network works (again)");
   }
-
-  function onConsoleMessage()
-  {
-    let currentPosition = hud.outputNode.parentNode.scrollTop;
-    let bottom = currentPosition;
-
-    EventUtils.synthesizeKey("VK_PAGE_UP", {});
-    isnot(hud.outputNode.parentNode.scrollTop, currentPosition, "scroll position changed after page up");
-
-    currentPosition = hud.outputNode.parentNode.scrollTop;
-    EventUtils.synthesizeKey("VK_PAGE_DOWN", {});
-    ok(hud.outputNode.parentNode.scrollTop > currentPosition, "scroll position now at bottom");
-
-    EventUtils.synthesizeKey("VK_HOME", {});
-    is(hud.outputNode.parentNode.scrollTop, 0, "scroll position now at top");
-
-    EventUtils.synthesizeKey("VK_END", {});
-    is(hud.outputNode.parentNode.scrollTop, bottom, "scroll position now at bottom");
-
-    hud.jsterm.once("messages-cleared", onClear);
-    info("try ctrl-l to clear output");
-    EventUtils.synthesizeKey("l", { ctrlKey: true });
+  else {
+    EventUtils.synthesizeKey("N", { altKey: true });
+    let net = hud.ui.document.querySelector("toolbarbutton[category=net]");
+    is(hud.ui.document.activeElement, net,
+       "accesskey for Network category focuses the Net button");
   }
-
-  function onClear()
-  {
-    is(hud.outputNode.textContent.indexOf("foobarz1"), -1, "output cleared");
-    is(hud.jsterm.inputNode.getAttribute("focused"), "true",
-       "jsterm input is focused");
-
-    info("try ctrl-f to focus filter");
-    EventUtils.synthesizeKey("F", { accelKey: true });
-    ok(!hud.jsterm.inputNode.getAttribute("focused"),
-       "jsterm input is not focused");
-    is(hud.ui.filterBox.getAttribute("focused"), "true",
-       "filter input is focused");
-
-    if (Services.appinfo.OS == "Darwin") {
-      ok(hud.ui.getFilterState("network"), "network category is enabled");
-      EventUtils.synthesizeKey("t", { ctrlKey: true });
-      ok(!hud.ui.getFilterState("network"), "accesskey for Network works");
-      EventUtils.synthesizeKey("t", { ctrlKey: true });
-      ok(hud.ui.getFilterState("network"), "accesskey for Network works (again)");
-    }
-    else {
-      EventUtils.synthesizeKey("N", { altKey: true });
-      let net = hud.ui.document.querySelector("toolbarbutton[category=net]");
-      is(hud.ui.document.activeElement, net,
-         "accesskey for Network category focuses the Net button");
-    }
-
-    finishTest();
-  }
-}
+});
diff --git a/browser/devtools/webconsole/test/browser_console_log_inspectable_object.js b/browser/devtools/webconsole/test/browser_console_log_inspectable_object.js
--- a/browser/devtools/webconsole/test/browser_console_log_inspectable_object.js
+++ b/browser/devtools/webconsole/test/browser_console_log_inspectable_object.js
@@ -1,58 +1,50 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 // Test that objects given to console.log() are inspectable.
 
-function test()
-{
-  waitForExplicitFinish();
+"use strict";
 
-  addTab("data:text/html;charset=utf8,test for bug 676722 - inspectable objects for window.console");
+let test = asyncTest(function*() {
+  yield loadTab("data:text/html;charset=utf8,test for bug 676722 - inspectable objects for window.console");
 
-  gBrowser.selectedBrowser.addEventListener("load", function onLoad() {
-    gBrowser.selectedBrowser.removeEventListener("load", onLoad, true);
-    openConsole(null, performTest);
-  }, true);
-}
-
-function performTest(hud)
-{
+  let hud = yield openConsole();
   hud.jsterm.clearOutput(true);
 
   hud.jsterm.execute("myObj = {abba: 'omgBug676722'}");
   hud.jsterm.execute("console.log('fooBug676722', myObj)");
 
-  waitForMessages({
+  let [result] = yield waitForMessages({
     webconsole: hud,
     messages: [{
       text: "fooBug676722",
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG,
       objects: true,
     }],
-  }).then(([result]) => {
-    let msg = [...result.matched][0];
-    ok(msg, "message element");
-    let body = msg.querySelector(".message-body");
-    ok(body, "message body");
-    let clickable = result.clickableElements[0];
-    ok(clickable, "the console.log() object anchor was found");
-    ok(body.textContent.contains('{ abba: "omgBug676722" }'),
-       "clickable node content is correct");
+  });
 
-    hud.jsterm.once("variablesview-fetched",
-      (aEvent, aVar) => {
-        ok(aVar, "object inspector opened on click");
+  let msg = [...result.matched][0];
+  ok(msg, "message element");
 
-        findVariableViewProperties(aVar, [{
-          name: "abba",
-          value: "omgBug676722",
-        }], { webconsole: hud }).then(finishTest);
-      });
+  let body = msg.querySelector(".message-body");
+  ok(body, "message body");
 
-    executeSoon(function() {
-      EventUtils.synthesizeMouse(clickable, 2, 2, {}, hud.iframeWindow);
-    });
+  let clickable = result.clickableElements[0];
+  ok(clickable, "the console.log() object anchor was found");
+  ok(body.textContent.contains('{ abba: "omgBug676722" }'),
+     "clickable node content is correct");
+
+  executeSoon(() => {
+    EventUtils.synthesizeMouse(clickable, 2, 2, {}, hud.iframeWindow);
   });
-}
+
+  let varView = yield hud.jsterm.once("variablesview-fetched");
+  ok(varView, "object inspector opened on click");
+
+  yield findVariableViewProperties(varView, [{
+    name: "abba",
+    value: "omgBug676722",
+  }], { webconsole: hud });
+});
diff --git a/browser/devtools/webconsole/test/browser_console_native_getters.js b/browser/devtools/webconsole/test/browser_console_native_getters.js
--- a/browser/devtools/webconsole/test/browser_console_native_getters.js
+++ b/browser/devtools/webconsole/test/browser_console_native_getters.js
@@ -1,121 +1,99 @@
 /*
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // Check that native getters and setters for DOM elements work as expected in
 // variables view - bug 870220.
 
+"use strict";
+
 const TEST_URI = "data:text/html;charset=utf8,<title>bug870220</title>\n" +
                  "<p>hello world\n<p>native getters!";
 
-let gWebConsole, gJSTerm, gVariablesView;
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
+  let jsterm = hud.jsterm;
 
-function test()
-{
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
+  jsterm.execute("document");
 
-function consoleOpened(hud)
-{
-  gWebConsole = hud;
-  gJSTerm = hud.jsterm;
-
-  gJSTerm.execute("document");
-
-  waitForMessages({
+  let [result] = yield waitForMessages({
     webconsole: hud,
     messages: [{
       text: "HTMLDocument \u2192 data:text/html;charset=utf8",
       category: CATEGORY_OUTPUT,
       objects: true,
     }],
-  }).then(onEvalResult);
-}
+  });
 
-function onEvalResult(aResults)
-{
-  let clickable = aResults[0].clickableElements[0];
+  let clickable = result.clickableElements[0];
   ok(clickable, "clickable object found");
 
-  gJSTerm.once("variablesview-fetched", onDocumentFetch);
-  EventUtils.synthesizeMouse(clickable, 2, 2, {}, gWebConsole.iframeWindow)
-}
+  executeSoon(() => {
+    EventUtils.synthesizeMouse(clickable, 2, 2, {}, hud.iframeWindow);
+  });
 
-function onDocumentFetch(aEvent, aVar)
-{
-  gVariablesView = aVar._variablesView;
-  ok(gVariablesView, "variables view object");
+  let fetchedVar = yield jsterm.once("variablesview-fetched");
 
-  findVariableViewProperties(aVar, [
+  let variablesView = fetchedVar._variablesView;
+  ok(variablesView, "variables view object");
+
+  let results = yield findVariableViewProperties(fetchedVar, [
     { name: "title", value: "bug870220" },
     { name: "bgColor" },
-  ], { webconsole: gWebConsole }).then(onDocumentPropsFound);
-}
+  ], { webconsole: hud });
 
-function onDocumentPropsFound(aResults)
-{
-  let prop = aResults[1].matchedProp;
+  let prop = results[1].matchedProp;
   ok(prop, "matched the |bgColor| property in the variables view");
 
   // Check that property value updates work.
-  updateVariablesViewProperty({
+  let updatedVar = yield updateVariablesViewProperty({
     property: prop,
     field: "value",
     string: "'red'",
-    webconsole: gWebConsole,
-    callback: onFetchAfterBackgroundUpdate,
+    webconsole: hud,
   });
-}
 
-function onFetchAfterBackgroundUpdate(aEvent, aVar)
-{
-  info("onFetchAfterBackgroundUpdate");
+  info("on fetch after background update");
 
-  is(content.document.bgColor, "red", "document background color changed");
+  jsterm.clearOutput(true);
+  jsterm.execute("document.bgColor");
 
-  findVariableViewProperties(aVar, [
+  [result] = yield waitForMessages({
+    webconsole: hud,
+    messages: [{
+      text: "red",
+      category: CATEGORY_OUTPUT,
+    }],
+  });
+
+  yield findVariableViewProperties(updatedVar, [
     { name: "bgColor", value: "red" },
-  ], { webconsole: gWebConsole }).then(testParagraphs);
-}
+  ], { webconsole: hud });
 
-function testParagraphs()
-{
-  gJSTerm.execute("$$('p')");
+  jsterm.execute("$$('p')");
 
-  waitForMessages({
-    webconsole: gWebConsole,
+  [result] = yield waitForMessages({
+    webconsole: hud,
     messages: [{
       text: "NodeList [",
       category: CATEGORY_OUTPUT,
       objects: true,
     }],
-  }).then(onEvalNodeList);
-}
+  });
 
-function onEvalNodeList(aResults)
-{
-  let clickable = aResults[0].clickableElements[0];
+  clickable = result.clickableElements[0];
   ok(clickable, "clickable object found");
 
-  gJSTerm.once("variablesview-fetched", onNodeListFetch);
-  EventUtils.synthesizeMouse(clickable, 2, 2, {}, gWebConsole.iframeWindow)
-}
+  executeSoon(() => {
+    EventUtils.synthesizeMouse(clickable, 2, 2, {}, hud.iframeWindow);
+  });
 
-function onNodeListFetch(aEvent, aVar)
-{
-  gVariablesView = aVar._variablesView;
-  ok(gVariablesView, "variables view object");
+  fetchedVar = yield jsterm.once("variablesview-fetched");
 
-  findVariableViewProperties(aVar, [
+  yield findVariableViewProperties(fetchedVar, [
     { name: "0.textContent", value: /hello world/ },
     { name: "1.textContent", value: /native getters/ },
-  ], { webconsole: gWebConsole }).then(() => {
-    gWebConsole = gJSTerm = gVariablesView = null;
-    finishTest();
-  });
-}
+  ], { webconsole: hud });
+});
diff --git a/browser/devtools/webconsole/test/browser_console_variables_view_highlighter.js b/browser/devtools/webconsole/test/browser_console_variables_view_highlighter.js
--- a/browser/devtools/webconsole/test/browser_console_variables_view_highlighter.js
+++ b/browser/devtools/webconsole/test/browser_console_variables_view_highlighter.js
@@ -7,21 +7,21 @@
 // selecting DOM nodes
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-bug-952277-highlight-nodes-in-vview.html";
 
 let gWebConsole, gJSTerm, gVariablesView, gToolbox;
 
 function test()
 {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
+  loadTab(TEST_URI).then(() => {
+    openConsole().then(hud => {
+      consoleOpened(hud);
+    })
+  });
 }
 
 function consoleOpened(hud)
 {
   gWebConsole = hud;
   gJSTerm = hud.jsterm;
   gToolbox = gDevTools.getToolbox(hud.target);
   gJSTerm.execute("document.querySelectorAll('p')", onQSAexecuted);
diff --git a/browser/devtools/webconsole/test/browser_webconsole_autocomplete-properties-with-non-alphanumeric-names.js b/browser/devtools/webconsole/test/browser_webconsole_autocomplete-properties-with-non-alphanumeric-names.js
--- a/browser/devtools/webconsole/test/browser_webconsole_autocomplete-properties-with-non-alphanumeric-names.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_autocomplete-properties-with-non-alphanumeric-names.js
@@ -4,39 +4,37 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 "use strict";
 
 // Test that properties starting with underscores or dollars can be
 // autocompleted (bug 967468).
 
-function test() {
+
+let test = asyncTest(function*() {
   const TEST_URI = "data:text/html;charset=utf8,test autocompletion with $ or _";
-  Task.spawn(runner).then(finishTest);
+  yield loadTab(TEST_URI);
 
-  function* runner() {
-    function autocomplete(term) {
-      let deferred = promise.defer();
+  function autocomplete(term) {
+    let deferred = promise.defer();
 
-      jsterm.setInputValue(term);
-      jsterm.complete(jsterm.COMPLETE_HINT_ONLY, deferred.resolve);
+    jsterm.setInputValue(term);
+    jsterm.complete(jsterm.COMPLETE_HINT_ONLY, deferred.resolve);
 
-      yield deferred.promise;
+    yield deferred.promise;
 
-      ok(popup.itemCount > 0, "There's suggestions for '" + term + "'");
-    }
+    ok(popup.itemCount > 0, "There's suggestions for '" + term + "'");
+  }
 
-    yield addTab(TEST_URI);
-    let { jsterm } = yield openConsole(tab);
-    let popup = jsterm.autocompletePopup;
+  let { jsterm } = yield openConsole();
+  let popup = jsterm.autocompletePopup;
 
-    jsterm.execute("let testObject = {$$aaab: '', $$aaac: ''}");
+  jsterm.execute("let testObject = {$$aaab: '', $$aaac: ''}");
 
-    // Should work with bug 967468.
-    yield autocomplete("Object.__d");
-    yield autocomplete("testObject.$$a");
+  // Should work with bug 967468.
+  yield autocomplete("Object.__d");
+  yield autocomplete("testObject.$$a");
 
-    // Here's when things go wrong in bug 967468.
-    yield autocomplete("Object.__de");
-    yield autocomplete("testObject.$$aa");
-  }
-}
+  // Here's when things go wrong in bug 967468.
+  yield autocomplete("Object.__de");
+  yield autocomplete("testObject.$$aa");
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_autocomplete_popup_close_on_tab_switch.js b/browser/devtools/webconsole/test/browser_webconsole_autocomplete_popup_close_on_tab_switch.js
--- a/browser/devtools/webconsole/test/browser_webconsole_autocomplete_popup_close_on_tab_switch.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_autocomplete_popup_close_on_tab_switch.js
@@ -2,41 +2,34 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Test that the autocomplete popup closes on switching tabs. See bug 900448.
 
 const TEST_URI = "data:text/html;charset=utf-8,<p>bug 900448 - autocomplete popup closes on tab switch";
 
-let popup = null;
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
+  let popup = hud.jsterm.autocompletePopup;
+  let popupShown = onPopupShown(popup._panel);
 
-registerCleanupFunction(function() {
-  popup = null;
+  hud.jsterm.setInputValue("sc");
+  EventUtils.synthesizeKey("r", {});
+
+  yield popupShown;
+
+  ok(!popup.isOpen, "Popup closes on tab switch");
 });
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
+function onPopupShown(panel) {
+  let finished = promise.defer();
 
-function consoleOpened(HUD) {
-  popup = HUD.jsterm.autocompletePopup;
-
-  popup._panel.addEventListener("popupshown", function popupOpened() {
-    popup._panel.removeEventListener("popupshown", popupOpened, false);
-    addTab("data:text/html;charset=utf-8,<p>testing autocomplete closes");
-    gBrowser.selectedBrowser.addEventListener("load", tab2Loaded, true);
+  panel.addEventListener("popupshown", function popupOpened() {
+    panel.removeEventListener("popupshown", popupOpened, false);
+    loadTab("data:text/html;charset=utf-8,<p>testing autocomplete closes").then(() => {
+      finished.resolve();
+    });
   }, false);
 
-  HUD.jsterm.setInputValue("sc");
-  EventUtils.synthesizeKey("r", {});
+  return finished.promise;
 }
-
-function tab2Loaded() {
-  gBrowser.selectedBrowser.removeEventListener("load", tab2Loaded, true);
-  ok(!popup.isOpen, "Popup closes on tab switch");
-  gBrowser.removeCurrentTab();
-  finishTest();
-}
diff --git a/browser/devtools/webconsole/test/browser_webconsole_basic_net_logging.js b/browser/devtools/webconsole/test/browser_webconsole_basic_net_logging.js
--- a/browser/devtools/webconsole/test/browser_webconsole_basic_net_logging.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_basic_net_logging.js
@@ -1,44 +1,42 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Tests that the page's resources are displayed in the console as they're
 // loaded
 
+"use strict";
+
 const TEST_NETWORK_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-network.html" + "?_date=" + Date.now();
 
-function test() {
-  addTab("data:text/html;charset=utf-8,Web Console basic network logging test");
-  browser.addEventListener("load", onLoad, true);
+let test = asyncTest(function* () {
+  yield loadTab("data:text/html;charset=utf-8,Web Console basic network logging test");
+  let hud = yield openConsole();
 
-  function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, function(hud) {
-      content.location = TEST_NETWORK_URI;
-      waitForMessages({
-        webconsole: hud,
-        messages: [{
-          text: "running network console",
-          category: CATEGORY_WEBDEV,
-          severity: SEVERITY_LOG,
-        },
-        {
-          text: "test-network.html",
-          category: CATEGORY_NETWORK,
-          severity: SEVERITY_LOG,
-        },
-        {
-          text: "testscript.js",
-          category: CATEGORY_NETWORK,
-          severity: SEVERITY_LOG,
-        },
-        {
-          text: "test-image.png",
-          category: CATEGORY_NETWORK,
-          severity: SEVERITY_LOG,
-        }],
-      }).then(finishTest);
-    });
-  }
-}
+  content.location = TEST_NETWORK_URI;
+
+  yield waitForMessages({
+    webconsole: hud,
+    messages: [{
+      text: "running network console",
+      category: CATEGORY_WEBDEV,
+      severity: SEVERITY_LOG,
+    },
+    {
+      text: "test-network.html",
+      category: CATEGORY_NETWORK,
+      severity: SEVERITY_LOG,
+    },
+    {
+      text: "testscript.js",
+      category: CATEGORY_NETWORK,
+      severity: SEVERITY_LOG,
+    },
+    {
+      text: "test-image.png",
+      category: CATEGORY_NETWORK,
+      severity: SEVERITY_LOG,
+    }],
+  });
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_1006027_message_timestamps_incorrect.js b/browser/devtools/webconsole/test/browser_webconsole_bug_1006027_message_timestamps_incorrect.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_1006027_message_timestamps_incorrect.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_1006027_message_timestamps_incorrect.js
@@ -1,12 +1,14 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+"use strict";
+
 function test() {
   Task.spawn(runner).then(finishTest);
 
   function* runner() {
     const {tab} = yield loadTab("data:text/html;charset=utf8,<title>Test for Bug 1006027");
 
     const target = TargetFactory.forTab(tab);
     const hud = yield openConsole(tab);
@@ -32,9 +34,8 @@ function test() {
          return Date.parse('T'+String.trim(value.textContent));
       });
 
     let minTimestamp = Math.min.apply(null, aTimestampMilliseconds);
     let maxTimestamp = Math.max.apply(null, aTimestampMilliseconds);
     ok(Math.abs(maxTimestamp - minTimestamp) < 1000, "console.log message timestamp spread < 1000ms confirmed");
   }
 }
-
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_579412_input_focus.js b/browser/devtools/webconsole/test/browser_webconsole_bug_579412_input_focus.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_579412_input_focus.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_579412_input_focus.js
@@ -1,25 +1,19 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Tests that the input field is focused when the console is opened.
 
+"use strict";
+
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("DOMContentLoaded", testInputFocus, false);
-}
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
+  hud.jsterm.clearOutput();
 
-function testInputFocus() {
-  browser.removeEventListener("DOMContentLoaded", testInputFocus, false);
-
-  openConsole(null, function(hud) {
-    let inputNode = hud.jsterm.inputNode;
-    ok(inputNode.getAttribute("focused"), "input node is focused");
-
-    finishTest();
-  });
-}
-
+  let inputNode = hud.jsterm.inputNode;
+  ok(inputNode.getAttribute("focused"), "input node is focused");
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_580454_timestamp_l10n.js b/browser/devtools/webconsole/test/browser_webconsole_bug_580454_timestamp_l10n.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_580454_timestamp_l10n.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_580454_timestamp_l10n.js
@@ -5,32 +5,26 @@
  *
  * Contributor(s):
  *  Patrick Walton <pcwalton@mozilla.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
 // Tests that appropriately-localized timestamps are printed.
 
+"use strict";
+
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("DOMContentLoaded", testTimestamp, false);
-
-  function testTimestamp()
-  {
-    browser.removeEventListener("DOMContentLoaded", testTimestamp, false);
-    const TEST_TIMESTAMP = 12345678;
-    let date = new Date(TEST_TIMESTAMP);
-    let localizedString = WCU_l10n.timestampString(TEST_TIMESTAMP);
-    isnot(localizedString.indexOf(date.getHours()), -1, "the localized " +
-          "timestamp contains the hours");
-    isnot(localizedString.indexOf(date.getMinutes()), -1, "the localized " +
-          "timestamp contains the minutes");
-    isnot(localizedString.indexOf(date.getSeconds()), -1, "the localized " +
-          "timestamp contains the seconds");
-    isnot(localizedString.indexOf(date.getMilliseconds()), -1, "the localized " +
-          "timestamp contains the milliseconds");
-    finishTest();
-  }
-}
-
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
+  const TEST_TIMESTAMP = 12345678;
+  let date = new Date(TEST_TIMESTAMP);
+  let localizedString = WCU_l10n.timestampString(TEST_TIMESTAMP);
+  isnot(localizedString.indexOf(date.getHours()), -1, "the localized " +
+        "timestamp contains the hours");
+  isnot(localizedString.indexOf(date.getMinutes()), -1, "the localized " +
+        "timestamp contains the minutes");
+  isnot(localizedString.indexOf(date.getSeconds()), -1, "the localized " +
+        "timestamp contains the seconds");
+  isnot(localizedString.indexOf(date.getMilliseconds()), -1, "the localized " +
+        "timestamp contains the milliseconds");
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_585956_console_trace.js b/browser/devtools/webconsole/test/browser_webconsole_bug_585956_console_trace.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_585956_console_trace.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_585956_console_trace.js
@@ -1,13 +1,15 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+"use strict";
+
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-bug-585956-console-trace.html";
 
 function test() {
   Task.spawn(runner).then(finishTest);
 
   function* runner() {
     let {tab} = yield loadTab("data:text/html;charset=utf8,<p>hello");
     let hud = yield openConsole(tab);
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js b/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js
@@ -1,36 +1,45 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 const TEST_URI = "data:text/html;charset=utf-8,<p>bug 585991 - autocomplete popup keyboard usage test";
 let HUD, popup, jsterm, inputNode, completeNode;
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
+
+  yield consoleOpened(hud);
+  yield popupHideAfterTab();
+  yield testReturnKey();
+  yield dontShowArrayNumbers();
+  yield testReturnWithNoSelection();
+  yield popupHideAfterReturnWithNoSelection();
+  yield testCompletionInText();
+  yield popupHideAfterCompletionInText();
+});
 
 function consoleOpened(aHud) {
+  let deferred = promise.defer();
   HUD = aHud;
   info("web console opened");
 
   jsterm = HUD.jsterm;
 
   jsterm.execute("window.foobarBug585991={" +
     "'item0': 'value0'," +
     "'item1': 'value1'," +
     "'item2': 'value2'," +
     "'item3': 'value3'" +
   "}");
+  jsterm.execute("window.testBug873250a = 'hello world';"
+    + "window.testBug873250b = 'hello world 2';");
   popup = jsterm.autocompletePopup;
   completeNode = jsterm.completeNode;
   inputNode = jsterm.inputNode;
 
   ok(!popup.isOpen, "popup is not open");
 
   popup._panel.addEventListener("popupshown", function onShown() {
     popup._panel.removeEventListener("popupshown", onShown, false);
@@ -105,30 +114,35 @@ function consoleOpened(aHud) {
 
     EventUtils.synthesizeKey("VK_END", {});
     is(popup.selectedIndex, 17, "index is last after End");
 
     EventUtils.synthesizeKey("VK_HOME", {});
     is(popup.selectedIndex, 0, "index is first after Home");
 
     info("press Tab and wait for popup to hide");
-    popup._panel.addEventListener("popuphidden", popupHideAfterTab, false);
+    popup._panel.addEventListener("popuphidden", function popupHidden() {
+      popup._panel.removeEventListener("popuphidden", popupHidden, false);
+      deferred.resolve();
+    }, false);
     EventUtils.synthesizeKey("VK_TAB", {});
   }, false);
 
   info("wait for completion: window.foobarBug585991.");
   jsterm.setInputValue("window.foobarBug585991");
   EventUtils.synthesizeKey(".", {});
+
+  return deferred.promise;
 }
 
 function popupHideAfterTab()
 {
+  let deferred = promise.defer();
+
   // At this point the completion suggestion should be accepted.
-  popup._panel.removeEventListener("popuphidden", popupHideAfterTab, false);
-
   ok(!popup.isOpen, "popup is not open");
 
   is(inputNode.value, "window.foobarBug585991.watch",
      "completion was successful after VK_TAB");
 
   ok(!completeNode.value, "completeNode is empty");
 
   popup._panel.addEventListener("popupshown", function onShown() {
@@ -153,34 +167,38 @@ function popupHideAfterTab()
 
       ok(!popup.isOpen, "popup is not open after VK_ESCAPE");
 
       is(inputNode.value, "window.foobarBug585991.",
          "completion was cancelled");
 
       ok(!completeNode.value, "completeNode is empty");
 
-      executeSoon(testReturnKey);
+      deferred.resolve();
     }, false);
 
     info("press Escape to close the popup");
     executeSoon(function() {
       EventUtils.synthesizeKey("VK_ESCAPE", {});
     });
   }, false);
 
   info("wait for completion: window.foobarBug585991.");
   executeSoon(function() {
     jsterm.setInputValue("window.foobarBug585991");
     EventUtils.synthesizeKey(".", {});
   });
+
+  return deferred.promise;
 }
 
 function testReturnKey()
 {
+  let deferred = promise.defer();
+
   popup._panel.addEventListener("popupshown", function onShown() {
     popup._panel.removeEventListener("popupshown", onShown, false);
 
     ok(popup.isOpen, "popup is open");
 
     is(popup.itemCount, 18, "popup.itemCount is correct");
 
     is(popup.selectedIndex, 17, "First index from bottom is selected");
@@ -205,143 +223,152 @@ function testReturnKey()
 
       ok(!popup.isOpen, "popup is not open after VK_RETURN");
 
       is(inputNode.value, "window.foobarBug585991.valueOf",
          "completion was successful after VK_RETURN");
 
       ok(!completeNode.value, "completeNode is empty");
 
-      dontShowArrayNumbers();
+      deferred.resolve();
     }, false);
 
     info("press Return to accept suggestion. wait for popup to hide");
 
     executeSoon(() => EventUtils.synthesizeKey("VK_RETURN", {}));
   }, false);
 
   info("wait for completion suggestions: window.foobarBug585991.");
 
   executeSoon(function() {
     jsterm.setInputValue("window.foobarBug58599");
     EventUtils.synthesizeKey("1", {});
     EventUtils.synthesizeKey(".", {});
   });
+
+  return deferred.promise;
 }
 
 function dontShowArrayNumbers()
 {
+  let deferred = promise.defer();
+
   info("dontShowArrayNumbers");
   content.wrappedJSObject.foobarBug585991 = ["Sherlock Holmes"];
 
   let jsterm = HUD.jsterm;
   let popup = jsterm.autocompletePopup;
   let completeNode = jsterm.completeNode;
 
   popup._panel.addEventListener("popupshown", function onShown() {
     popup._panel.removeEventListener("popupshown", onShown, false);
 
     let sameItems = popup.getItems().map(function(e) {return e.label;});
     ok(!sameItems.some(function(prop, index) { prop === "0"; }),
        "Completing on an array doesn't show numbers.");
 
-    popup._panel.addEventListener("popuphidden", testReturnWithNoSelection, false);
+    popup._panel.addEventListener("popuphidden", function popupHidden() {
+      popup._panel.removeEventListener("popuphidden", popupHidden, false);
+      deferred.resolve();
+    }, false);
 
     info("wait for popup to hide");
     executeSoon(() => EventUtils.synthesizeKey("VK_ESCAPE", {}));
   }, false);
 
   info("wait for popup to show");
   executeSoon(() => {
     jsterm.setInputValue("window.foobarBug585991");
     EventUtils.synthesizeKey(".", {});
   });
+
+  return deferred.promise;
 }
 
 function testReturnWithNoSelection()
 {
-  popup._panel.removeEventListener("popuphidden", testReturnWithNoSelection, false);
+  let deferred = promise.defer();
 
   info("test pressing return with open popup, but no selection, see bug 873250");
-  content.wrappedJSObject.testBug873250a = "hello world";
-  content.wrappedJSObject.testBug873250b = "hello world 2";
 
   popup._panel.addEventListener("popupshown", function onShown() {
     popup._panel.removeEventListener("popupshown", onShown);
 
     ok(popup.isOpen, "popup is open");
     is(popup.itemCount, 2, "popup.itemCount is correct");
     isnot(popup.selectedIndex, -1, "popup.selectedIndex is correct");
 
     info("press Return and wait for popup to hide");
-    popup._panel.addEventListener("popuphidden", popupHideAfterReturnWithNoSelection);
+    popup._panel.addEventListener("popuphidden", function popupHidden() {
+      popup._panel.removeEventListener("popuphidden", popupHidden);
+      deferred.resolve();
+    });
     executeSoon(() => EventUtils.synthesizeKey("VK_RETURN", {}));
   });
 
   executeSoon(() => {
     info("wait for popup to show");
     jsterm.setInputValue("window.testBu");
     EventUtils.synthesizeKey("g", {});
   });
+
+  return deferred.promise;
 }
 
 function popupHideAfterReturnWithNoSelection()
 {
-  popup._panel.removeEventListener("popuphidden", popupHideAfterReturnWithNoSelection);
-
   ok(!popup.isOpen, "popup is not open after VK_RETURN");
 
   is(inputNode.value, "", "inputNode is empty after VK_RETURN");
   is(completeNode.value, "", "completeNode is empty");
   is(jsterm.history[jsterm.history.length-1], "window.testBug",
      "jsterm history is correct");
 
-  executeSoon(testCompletionInText);
+  return promise.resolve();
 }
 
 function testCompletionInText()
 {
   info("test that completion works inside text, see bug 812618");
 
+  let deferred = promise.defer();
+
   popup._panel.addEventListener("popupshown", function onShown() {
     popup._panel.removeEventListener("popupshown", onShown);
 
     ok(popup.isOpen, "popup is open");
     is(popup.itemCount, 2, "popup.itemCount is correct");
 
     EventUtils.synthesizeKey("VK_DOWN", {});
     is(popup.selectedIndex, 0, "popup.selectedIndex is correct");
     ok(!completeNode.value, "completeNode.value is empty");
 
     let items = popup.getItems().reverse().map(e => e.label);
     let sameItems = items.every((prop, index) =>
       ["testBug873250a", "testBug873250b"][index] === prop);
     ok(sameItems, "getItems returns the items we expect");
 
     info("press Tab and wait for popup to hide");
-    popup._panel.addEventListener("popuphidden", popupHideAfterCompletionInText);
+    popup._panel.addEventListener("popuphidden", function popupHidden() {
+      popup._panel.removeEventListener("popuphidden", popupHidden);
+      deferred.resolve();
+    });
     EventUtils.synthesizeKey("VK_TAB", {});
   });
 
   jsterm.setInputValue("dump(window.testBu)");
   inputNode.selectionStart = inputNode.selectionEnd = 18;
   EventUtils.synthesizeKey("g", {});
+  return deferred.promise;
 }
 
 function popupHideAfterCompletionInText()
 {
   // At this point the completion suggestion should be accepted.
-  popup._panel.removeEventListener("popuphidden", popupHideAfterCompletionInText);
-
   ok(!popup.isOpen, "popup is not open");
   is(inputNode.value, "dump(window.testBug873250b)",
      "completion was successful after VK_TAB");
   is(inputNode.selectionStart, 26, "cursor location is correct");
   is(inputNode.selectionStart, inputNode.selectionEnd, "cursor location (confirmed)");
   ok(!completeNode.value, "completeNode is empty");
 
-  finishUp();
+  return promise.resolve();
 }
-
-function finishUp() {
-  HUD = popup = jsterm = inputNode = completeNode = null;
-  finishTest();
-}
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_popup.js b/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_popup.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_popup.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_popup.js
@@ -1,24 +1,27 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 const TEST_URI = "data:text/html;charset=utf-8,<p>bug 585991 - autocomplete popup test";
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
+"use strict";
+
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
+
+  yield consoleOpened(hud);
+});
 
 function consoleOpened(HUD) {
+  let deferred = promise.defer();
+
   let items = [
     {label: "item0", value: "value0"},
     {label: "item1", value: "value1"},
     {label: "item2", value: "value2"},
   ];
 
   let popup = HUD.jsterm.autocompletePopup;
 
@@ -82,14 +85,16 @@ function consoleOpened(HUD) {
     is(popup.selectedIndex, 2, "index2 is selected");
     is(popup.selectedItem, items[3], "item3 is still selected");
     is(popup.itemCount, items.length - 1, "item2 removed");
 
     popup.clearItems();
     is(popup.itemCount, 0, "items cleared");
 
     popup.hidePopup();
-    finishTest();
+    deferred.resolve();
   }, false);
 
   popup.openPopup();
+
+  return deferred.promise;
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_586388_select_all.js b/browser/devtools/webconsole/test/browser_webconsole_bug_586388_select_all.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_586388_select_all.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_586388_select_all.js
@@ -5,88 +5,87 @@
  *
  * Contributor(s):
  *  Patrick Walton <pcwalton@mozilla.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
 const TEST_URI = "http://example.com/";
 
-function test() {
-  let hud;
+"use strict";
 
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, testSelectionWhenMovingBetweenBoxes);
-  }, true);
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
 
-  function testSelectionWhenMovingBetweenBoxes(aHud) {
-    hud = aHud;
-    let jsterm = hud.jsterm;
+  let hud = yield openConsole();
+  yield testSelectionWhenMovingBetweenBoxes(hud);
+  performTestsAfterOutput(hud);
+})
 
-    // Fill the console with some output.
-    jsterm.clearOutput();
-    jsterm.execute("1 + 2");
-    jsterm.execute("3 + 4");
-    jsterm.execute("5 + 6");
+function testSelectionWhenMovingBetweenBoxes(aHud) {
+  let hud = aHud;
+  let jsterm = hud.jsterm;
 
-    waitForMessages({
-      webconsole: hud,
-      messages: [{
-        text: "3",
-        category: CATEGORY_OUTPUT,
-      },
-      {
-        text: "7",
-        category: CATEGORY_OUTPUT,
-      },
-      {
-        text: "11",
-        category: CATEGORY_OUTPUT,
-      }],
-    }).then(performTestsAfterOutput);
-  }
+  // Fill the console with some output.
+  jsterm.clearOutput();
+  jsterm.execute("1 + 2");
+  jsterm.execute("3 + 4");
+  jsterm.execute("5 + 6");
 
-  function performTestsAfterOutput() {
-    let outputNode = hud.outputNode;
+  return waitForMessages({
+    webconsole: hud,
+    messages: [{
+      text: "3",
+      category: CATEGORY_OUTPUT,
+    },
+    {
+      text: "7",
+      category: CATEGORY_OUTPUT,
+    },
+    {
+      text: "11",
+      category: CATEGORY_OUTPUT,
+    }],
+  });
+}
 
-    ok(outputNode.childNodes.length >= 3, "the output node has children after " +
-       "executing some JavaScript");
+function performTestsAfterOutput(aHud) {
+  let hud = aHud;
+  let outputNode = hud.outputNode;
 
-    // Test that the global Firefox "Select All" functionality (e.g. Edit >
-    // Select All) works properly in the Web Console.
-    let commandController = hud.ui._commandController;
-    ok(commandController != null, "the window has a command controller object");
+  ok(outputNode.childNodes.length >= 3, "the output node has children after " +
+     "executing some JavaScript");
 
-    commandController.selectAll();
+  // Test that the global Firefox "Select All" functionality (e.g. Edit >
+  // Select All) works properly in the Web Console.
+  let commandController = hud.ui._commandController;
+  ok(commandController != null, "the window has a command controller object");
 
-    let selectedCount = hud.ui.output.getSelectedMessages().length;
-    is(selectedCount, outputNode.childNodes.length,
-       "all console messages are selected after performing a regular browser " +
-       "select-all operation");
+  commandController.selectAll();
 
-    hud.iframeWindow.getSelection().removeAllRanges();
+  let selectedCount = hud.ui.output.getSelectedMessages().length;
+  is(selectedCount, outputNode.childNodes.length,
+     "all console messages are selected after performing a regular browser " +
+     "select-all operation");
 
-    // Test the context menu "Select All" (which has a different code path) works
-    // properly as well.
-    let contextMenuId = outputNode.parentNode.getAttribute("context");
-    let contextMenu = hud.ui.document.getElementById(contextMenuId);
-    ok(contextMenu != null, "the output node has a context menu");
+  hud.iframeWindow.getSelection().removeAllRanges();
 
-    let selectAllItem = contextMenu.querySelector("*[command='cmd_selectAll']");
-    ok(selectAllItem != null,
-       "the context menu on the output node has a \"Select All\" item");
+  // Test the context menu "Select All" (which has a different code path) works
+  // properly as well.
+  let contextMenuId = outputNode.parentNode.getAttribute("context");
+  let contextMenu = hud.ui.document.getElementById(contextMenuId);
+  ok(contextMenu != null, "the output node has a context menu");
 
-    outputNode.focus();
+  let selectAllItem = contextMenu.querySelector("*[command='cmd_selectAll']");
+  ok(selectAllItem != null,
+     "the context menu on the output node has a \"Select All\" item");
 
-    selectAllItem.doCommand();
+  outputNode.focus();
 
-    let selectedCount = hud.ui.output.getSelectedMessages().length;
-    is(selectedCount, outputNode.childNodes.length,
-       "all console messages are selected after performing a select-all " +
-       "operation from the context menu");
+  selectAllItem.doCommand();
 
-    hud.iframeWindow.getSelection().removeAllRanges();
+  let selectedCount = hud.ui.output.getSelectedMessages().length;
+  is(selectedCount, outputNode.childNodes.length,
+     "all console messages are selected after performing a select-all " +
+     "operation from the context menu");
 
-    finishTest();
-  }
+  hud.iframeWindow.getSelection().removeAllRanges();
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_587617_output_copy.js b/browser/devtools/webconsole/test/browser_webconsole_bug_587617_output_copy.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_587617_output_copy.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_587617_output_copy.js
@@ -7,27 +7,31 @@
  *  Patrick Walton <pcwalton@mozilla.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
 let HUD, outputNode;
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
+"use strict";
+
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+
+  let hud = yield openConsole();
+  yield consoleOpened(hud);
+  yield testContextMenuCopy();
+});
 
 function consoleOpened(aHud) {
   HUD = aHud;
 
+  let deferred = promise.defer();
+
   // See bugs 574036, 586386 and 587617.
   outputNode = HUD.outputNode;
 
   HUD.jsterm.clearOutput();
 
   let controller = top.document.commandDispatcher.
                    getControllerForCommand("cmd_copy");
   is(controller.isCommandEnabled("cmd_copy"), false, "cmd_copy is disabled");
@@ -52,32 +56,37 @@ function consoleOpened(aHud) {
     is(controller.isCommandEnabled("cmd_copy"), true, "cmd_copy is enabled");
 
     let selection = HUD.iframeWindow.getSelection() + "";
     isnot(selection.indexOf("bug587617"), -1,
           "selection text includes 'bug587617'");
 
     waitForClipboard((str) => { return selection.trim() == str.trim(); },
       () => { goDoCommand("cmd_copy") },
-      testContextMenuCopy, testContextMenuCopy);
+      deferred.resolve, deferred.resolve);
   });
+  return deferred.promise;
 }
 
 // Test that the context menu "Copy" (which has a different code path) works
 // properly as well.
 function testContextMenuCopy() {
+  let deferred = promise.defer();
+
   let contextMenuId = outputNode.parentNode.getAttribute("context");
   let contextMenu = HUD.ui.document.getElementById(contextMenuId);
   ok(contextMenu, "the output node has a context menu");
 
   let copyItem = contextMenu.querySelector("*[command='cmd_copy']");
   ok(copyItem, "the context menu on the output node has a \"Copy\" item");
 
   let selection = HUD.iframeWindow.getSelection() + "";
 
   copyItem.doCommand();
 
   waitForClipboard((str) => { return selection.trim() == str.trim(); },
     () => { goDoCommand("cmd_copy") },
-    finishTest, finishTest);
+    deferred.resolve, deferred.resolve);
   HUD = outputNode = null;
+
+  return deferred.promise;
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_588342_document_focus.js b/browser/devtools/webconsole/test/browser_webconsole_bug_588342_document_focus.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_588342_document_focus.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_588342_document_focus.js
@@ -4,36 +4,34 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  *
  * Contributor(s):
  *  Mihai ucan <mihai.sucan@gmail.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
 const TEST_URI = "data:text/html;charset=utf-8,Web Console test for bug 588342";
-let fm;
 
-function test() {
-  fm = Cc["@mozilla.org/focus-manager;1"].getService(Ci.nsIFocusManager);
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
+let fm = Cc["@mozilla.org/focus-manager;1"].getService(Ci.nsIFocusManager);
+
+"use strict";
+
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+
+  let hud = yield openConsole();
+  yield consoleOpened(hud);
+
+  is(fm.focusedWindow, window,
+     "content document has focus");
+});
 
 function consoleOpened(hud) {
+  let deferred = promise.defer();
   waitForFocus(function() {
     is(hud.jsterm.inputNode.getAttribute("focused"), "true",
        "jsterm input is focused on web console open");
     isnot(fm.focusedWindow, content, "content document has no focus");
-    closeConsole(null, consoleClosed);
+    closeConsole(null).then(deferred.resolve);
   }, hud.iframeWindow);
+
+  return deferred.promise;
 }
-
-function consoleClosed() {
-  is(fm.focusedWindow, browser.contentWindow,
-     "content document has focus");
-
-  fm = null;
-  finishTest();
-}
-
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_588730_text_node_insertion.js b/browser/devtools/webconsole/test/browser_webconsole_bug_588730_text_node_insertion.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_588730_text_node_insertion.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_588730_text_node_insertion.js
@@ -2,27 +2,30 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Tests that adding text to one of the output labels doesn't cause errors.
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, testTextNodeInsertion);
-  }, true);
-}
+"use strict";
+
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+
+  let hud = yield openConsole();
+
+  yield testTextNodeInsertion(hud);
+});
 
 // Test for bug 588730: Adding a text node to an existing label element causes
 // warnings
 function testTextNodeInsertion(hud) {
+  let deferred = promise.defer();
   let outputNode = hud.outputNode;
 
   let label = document.createElementNS(
     "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul", "label");
   outputNode.appendChild(label);
 
   let error = false;
   let listener = {
@@ -38,12 +41,13 @@ function testTextNodeInsertion(hud) {
 
   // This shouldn't fail.
   label.appendChild(document.createTextNode("foo"));
 
   executeSoon(function() {
     Services.console.unregisterListener(listener);
     ok(!error, "no error when adding text nodes as children of labels");
 
-    finishTest();
+    return deferred.resolve();
   });
+  return deferred.promise;
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_588967_input_expansion.js b/browser/devtools/webconsole/test/browser_webconsole_bug_588967_input_expansion.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_588967_input_expansion.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_588967_input_expansion.js
@@ -1,22 +1,25 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, testInputExpansion);
-  }, true);
-}
+"use strict";
+
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+
+  let hud = yield openConsole();
+
+  testInputExpansion(hud);
+});
+
 
 function testInputExpansion(hud) {
   let input = hud.jsterm.inputNode;
 
   input.focus();
 
   is(input.getAttribute("multiline"), "true", "multiline is enabled");
 
@@ -33,12 +36,10 @@ function testInputExpansion(hud) {
   ok(input.clientHeight > ordinaryHeight, "the input expanded");
 
   // Test if the inputNode shrinks again.
   input.value = "";
   EventUtils.synthesizeKey("d", {});
   is(input.clientHeight, ordinaryHeight, "the input's height is normal again");
 
   input = length = null;
-
-  finishTest();
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_589162_css_filter.js b/browser/devtools/webconsole/test/browser_webconsole_bug_589162_css_filter.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_589162_css_filter.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_589162_css_filter.js
@@ -4,16 +4,18 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  *
  * Contributor(s):
  *  Mihai ucan <mihai.sucan@gmail.com>
  *  Patrick Walton <pcwalton@mozilla.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
+"use strict"
+
 const TEST_URI = "data:text/html;charset=utf-8,<div style='font-size:3em;" +
   "foobarCssParser:baz'>test CSS parser filter</div>";
 
 /**
  * Unit test for bug 589162:
  * CSS filtering on the console does not work
  */
 function test() {
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_592442_closing_brackets.js b/browser/devtools/webconsole/test/browser_webconsole_bug_592442_closing_brackets.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_592442_closing_brackets.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_592442_closing_brackets.js
@@ -8,34 +8,30 @@
  *  Patrick Walton <pcwalton@mozilla.com>
  *  Mihai ucan <mihai.sucan@gmail.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
 // Tests that, when the user types an extraneous closing bracket, no error
 // appears.
 
-function test() {
-  addTab("data:text/html;charset=utf-8,test for bug 592442");
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, testExtraneousClosingBrackets);
-  }, true);
-}
+"use strict";
 
-function testExtraneousClosingBrackets(hud) {
+const TEST_URI = "data:text/html;charset=utf-8,test for bug 592442";
+
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
+  hud.jsterm.clearOutput();
   let jsterm = hud.jsterm;
 
   jsterm.setInputValue("document.getElementById)");
 
   let error = false;
   try {
     jsterm.complete(jsterm.COMPLETE_HINT_ONLY);
   }
   catch (ex) {
     error = true;
   }
 
   ok(!error, "no error was thrown when an extraneous bracket was inserted");
-
-  finishTest();
-}
-
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_594477_clickable_output.js b/browser/devtools/webconsole/test/browser_webconsole_bug_594477_clickable_output.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_594477_clickable_output.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_594477_clickable_output.js
@@ -5,77 +5,91 @@
  *
  * Contributor(s):
  *  Mihai ucan <mihai.sucan@gmail.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 let HUD;
+let outputItem;
+let outputNode;
 
-let outputItem;
+"use strict";
 
-function consoleOpened(aHud) {
-  HUD = aHud;
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
 
+  HUD = yield openConsole();
   outputNode = HUD.outputNode;
 
-  browser.addEventListener("load", tabLoad2, true);
+  // reload the tab
+  BrowserReload();
+  yield loadBrowser(gBrowser.selectedBrowser);
 
-  // Reload so we get some output in the console.
-  browser.contentWindow.location.reload();
-}
+  let event = yield clickEvents();
+  yield testClickAgain(event);
+  yield networkPanelHidden();
+});
 
-function tabLoad2(aEvent) {
-  browser.removeEventListener(aEvent.type, tabLoad2, true);
+function clickEvents() {
+  let deferred = promise.defer();
 
   waitForMessages({
     webconsole: HUD,
     messages: [{
       text: "test-console.html",
       category: CATEGORY_NETWORK,
       severity: SEVERITY_LOG,
     }],
   }).then(([result]) => {
     let msg = [...result.matched][0];
     outputItem = msg.querySelector(".message-body .url");
     ok(outputItem, "found a network message");
-    document.addEventListener("popupshown", networkPanelShown, false);
+    document.addEventListener("popupshown", function onPanelShown(event) {
+      document.removeEventListener("popupshown", onPanelShown, false);
+      deferred.resolve(event);
+    }, false);
 
     // Send the mousedown and click events such that the network panel opens.
     EventUtils.sendMouseEvent({type: "mousedown"}, outputItem);
     EventUtils.sendMouseEvent({type: "click"}, outputItem);
   });
+
+  return deferred.promise;
 }
 
-function networkPanelShown(aEvent) {
-  document.removeEventListener(aEvent.type, networkPanelShown, false);
+function testClickAgain(event) {
+  info("testClickAgain");
 
-  info("networkPanelShown");
+  let deferred = promise.defer();
 
   document.addEventListener("popupshown", networkPanelShowFailure, false);
 
   // The network panel should not open for the second time.
   EventUtils.sendMouseEvent({type: "mousedown"}, outputItem);
   EventUtils.sendMouseEvent({type: "click"}, outputItem);
 
   executeSoon(function() {
-    aEvent.target.addEventListener("popuphidden", networkPanelHidden, false);
-    aEvent.target.hidePopup();
+    document.addEventListener("popuphidden", function onHidden() {
+      document.removeEventListener("popuphidden", onHidden, false);
+      deferred.resolve();
+    }, false);
+    event.target.hidePopup();
   });
+
+  return deferred.promise;
 }
 
-function networkPanelShowFailure(aEvent) {
-  document.removeEventListener(aEvent.type, networkPanelShowFailure, false);
-
+function networkPanelShowFailure() {
   ok(false, "the network panel should not show");
 }
 
-function networkPanelHidden(aEvent) {
-  this.removeEventListener(aEvent.type, networkPanelHidden, false);
+function networkPanelHidden() {
+  let deferred = promise.defer();
 
   info("networkPanelHidden");
 
   // The network panel should not show because this is a mouse event that starts
   // in a position and ends in another.
   EventUtils.sendMouseEvent({type: "mousedown", clientX: 3, clientY: 4},
     outputItem);
   EventUtils.sendMouseEvent({type: "click", clientX: 5, clientY: 6},
@@ -96,36 +110,20 @@ function networkPanelHidden(aEvent) {
   executeSoon(function() {
     document.removeEventListener("popupshown", networkPanelShowFailure, false);
 
     // Done with the network output. Now test the jsterm output and the property
     // panel.
     HUD.jsterm.execute("document", (msg) => {
       info("jsterm execute 'document' callback");
 
-      HUD.jsterm.once("variablesview-open", onVariablesViewOpen);
+      HUD.jsterm.once("variablesview-open", deferred.resolve);
       let outputItem = msg.querySelector(".message-body a");
       ok(outputItem, "jsterm output message found");
 
       // Send the mousedown and click events such that the property panel opens.
       EventUtils.sendMouseEvent({type: "mousedown"}, outputItem);
       EventUtils.sendMouseEvent({type: "click"}, outputItem);
     });
   });
+
+  return deferred.promise;
 }
-
-function onVariablesViewOpen() {
-  info("onVariablesViewOpen");
-
-  executeSoon(function() {
-    HUD = outputItem = null;
-    executeSoon(finishTest);
-  });
-}
-
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
-
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_594497_history_arrow_keys.js b/browser/devtools/webconsole/test/browser_webconsole_bug_594497_history_arrow_keys.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_594497_history_arrow_keys.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_594497_history_arrow_keys.js
@@ -5,37 +5,43 @@
  *
  * Contributor(s):
  *  Mihai ucan <mihai.sucan@gmail.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
 let inputNode, values;
 
-function tabLoad(aEvent) {
-  browser.removeEventListener(aEvent.type, tabLoad, true);
+let TEST_URI = "data:text/html;charset=utf-8,Web Console test for bug 594497 and bug 619598";
+"use strict";
 
-  openConsole(null, function(HUD) {
-    inputNode = HUD.jsterm.inputNode;
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
 
-    inputNode.focus();
+  let hud = yield openConsole();
 
-    ok(!inputNode.value, "inputNode.value is empty");
+  setup(hud);
+  performTests();
+});
 
-    values = ["document", "window", "document.body"];
-    values.push(values.join(";\n"), "document.location");
+function setup(HUD) {
+  inputNode = HUD.jsterm.inputNode;
 
-    // Execute each of the values;
-    for (let i = 0; i < values.length; i++) {
-      HUD.jsterm.setInputValue(values[i]);
-      HUD.jsterm.execute();
-    }
+  inputNode.focus();
 
-    performTests();
-  });
+  ok(!inputNode.value, "inputNode.value is empty");
+
+  values = ["document", "window", "document.body"];
+  values.push(values.join(";\n"), "document.location");
+
+  // Execute each of the values;
+  for (let i = 0; i < values.length; i++) {
+    HUD.jsterm.setInputValue(values[i]);
+    HUD.jsterm.execute();
+  }
 }
 
 function performTests() {
   EventUtils.synthesizeKey("VK_UP", {});
 
   is(inputNode.value, values[4],
      "VK_UP: inputNode.value #4 is correct");
 
@@ -140,18 +146,9 @@ function performTests() {
 
   is(inputNode.value, values[4],
      "VK_DOWN: inputNode.value #4 is correct");
 
   EventUtils.synthesizeKey("VK_DOWN", {});
 
   ok(!inputNode.value,
      "VK_DOWN: inputNode.value is empty");
-
-  inputNode = values = null;
-  executeSoon(finishTest);
 }
-
-function test() {
-  addTab("data:text/html;charset=utf-8,Web Console test for bug 594497 and bug 619598");
-  browser.addEventListener("load", tabLoad, true);
-}
-
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_659907_console_dir.js b/browser/devtools/webconsole/test/browser_webconsole_bug_659907_console_dir.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_659907_console_dir.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_659907_console_dir.js
@@ -1,29 +1,28 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /*
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // Tests that console.dir works as intended.
 
-function test() {
-  addTab("data:text/html;charset=utf-8,Web Console test for bug 659907: Expand console " +
-         "object with a dir method");
-  browser.addEventListener("load", function onLoad(aEvent) {
-    browser.removeEventListener(aEvent.type, onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
+"use strict";
 
-function consoleOpened(hud) {
+const TEST_URI = "data:text/html;charset=utf-8,Web Console test for bug 659907: " +
+  "Expand console object with a dir method"
+
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
+  hud.jsterm.clearOutput();
+
   hud.jsterm.execute("console.dir(document)");
-  hud.jsterm.once("variablesview-fetched", testConsoleDir.bind(null, hud));
-}
 
-function testConsoleDir(hud, ev, view) {
-  findVariableViewProperties(view, [
+  let varView = yield hud.jsterm.once("variablesview-fetched");
+
+  yield findVariableViewProperties(varView, [
     { name: "__proto__.__proto__.querySelectorAll", value: "querySelectorAll()" },
     { name: "location", value: /Location \u2192 data:Web/ },
     { name: "__proto__.write", value: "write()" },
-  ], { webconsole: hud }).then(finishTest);
-}
+  ], { webconsole: hud });
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_change_font_size.js b/browser/devtools/webconsole/test/browser_webconsole_change_font_size.js
--- a/browser/devtools/webconsole/test/browser_webconsole_change_font_size.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_change_font_size.js
@@ -3,28 +3,25 @@
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  *
  * Contributor(s):
  *  Jennifer Fong <jfong@mozilla.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
+"use strict";
+
 const TEST_URI = "http://example.com/";
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    Services.prefs.setIntPref("devtools.webconsole.fontSize", 10);
-    HUDService.toggleBrowserConsole().then(testFontSizeChange);
-  }, true);
-}
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
+  Services.prefs.setIntPref("devtools.webconsole.fontSize", 10);
+  let hud = yield HUDService.toggleBrowserConsole();
 
-function testFontSizeChange(hud) {
   let inputNode = hud.jsterm.inputNode;
   let outputNode = hud.jsterm.outputNode;
   outputNode.focus();
 
   EventUtils.synthesizeKey("-", { accelKey: true }, hud.iframeWindow);
   is(inputNode.style.fontSize, "10px", "input font stays at same size with ctrl+-");
   is(outputNode.style.fontSize, inputNode.style.fontSize, "output font stays at same size with ctrl+-");
 
@@ -34,11 +31,9 @@ function testFontSizeChange(hud) {
 
   EventUtils.synthesizeKey("-", { accelKey: true }, hud.iframeWindow);
   is(inputNode.style.fontSize, "10px", "font decreased with ctrl+-");
   is(outputNode.style.fontSize, inputNode.style.fontSize, "output font stays at same size with ctrl+-");
 
   EventUtils.synthesizeKey("0", { accelKey: true }, hud.iframeWindow);
   is(inputNode.style.fontSize, "", "font reset with ctrl+0");
   is(outputNode.style.fontSize, inputNode.style.fontSize, "output font stays at same size with ctrl+0");
-
-  finishTest();
-}
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_chrome.js b/browser/devtools/webconsole/test/browser_webconsole_chrome.js
--- a/browser/devtools/webconsole/test/browser_webconsole_chrome.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_chrome.js
@@ -1,15 +1,17 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Tests that code completion works properly in chrome tabs, like about:credits.
 
+"use strict";
+
 function test() {
   Task.spawn(function*() {
     const {tab} = yield loadTab("about:config");
     ok(tab, "tab loaded");
 
     const hud = yield openConsole(tab);
     ok(hud, "we have a console");
     ok(hud.iframeWindow, "we have the console UI window");
diff --git a/browser/devtools/webconsole/test/browser_webconsole_clickable_urls.js b/browser/devtools/webconsole/test/browser_webconsole_clickable_urls.js
--- a/browser/devtools/webconsole/test/browser_webconsole_clickable_urls.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_clickable_urls.js
@@ -1,16 +1,18 @@
 /*
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // When strings containing URLs are entered into the webconsole,
 // check its output and ensure that the output can be clicked to open those URLs.
 
+"use strict";
+
 const TEST_URI = "data:text/html;charset=utf8,Bug 1005909 - Clickable URLS";
 
 let inputTests = [
 
   // 0: URL opens page when clicked.
   {
     input: "'http://example.com'",
     output: "http://example.com",
diff --git a/browser/devtools/webconsole/test/browser_webconsole_completion.js b/browser/devtools/webconsole/test/browser_webconsole_completion.js
--- a/browser/devtools/webconsole/test/browser_webconsole_completion.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_completion.js
@@ -2,119 +2,98 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Tests that code completion works properly.
 
 const TEST_URI = "data:text/html;charset=utf8,<p>test code completion";
 
-let testDriver;
+let jsterm;
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, function(hud) {
-      testDriver = testCompletion(hud);
-      testDriver.next();
-    });
-  }, true);
-}
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
 
-function testNext() {
-  executeSoon(function() {
-    testDriver.next();
-  });
-}
+  let hud = yield openConsole();
 
-function testCompletion(hud) {
-  let jsterm = hud.jsterm;
+  jsterm = hud.jsterm;
   let input = jsterm.inputNode;
 
   // Test typing 'docu'.
   input.value = "docu";
   input.setSelectionRange(4, 4);
-  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
-  yield undefined;
+  yield complete(jsterm.COMPLETE_HINT_ONLY);
 
   is(input.value, "docu", "'docu' completion (input.value)");
   is(jsterm.completeNode.value, "    ment", "'docu' completion (completeNode)");
 
   // Test typing 'docu' and press tab.
   input.value = "docu";
   input.setSelectionRange(4, 4);
-  jsterm.complete(jsterm.COMPLETE_FORWARD, testNext);
-  yield undefined;
+  yield complete(jsterm.COMPLETE_FORWARD);
 
   is(input.value, "document", "'docu' tab completion");
   is(input.selectionStart, 8, "start selection is alright");
   is(input.selectionEnd, 8, "end selection is alright");
   is(jsterm.completeNode.value.replace(/ /g, ""), "", "'docu' completed");
 
   // Test typing 'window.Ob' and press tab.  Just 'window.O' is
   // ambiguous: could be window.Object, window.Option, etc.
   input.value = "window.Ob";
   input.setSelectionRange(9, 9);
-  jsterm.complete(jsterm.COMPLETE_FORWARD, testNext);
-  yield undefined;
+  yield complete(jsterm.COMPLETE_FORWARD);
 
   is(input.value, "window.Object", "'window.Ob' tab completion");
 
   // Test typing 'document.getElem'.
   input.value = "document.getElem";
   input.setSelectionRange(16, 16);
-  jsterm.complete(jsterm.COMPLETE_FORWARD, testNext);
-  yield undefined;
+  yield complete(jsterm.COMPLETE_FORWARD);
 
   is(input.value, "document.getElem", "'document.getElem' completion");
   is(jsterm.completeNode.value, "                entsByTagNameNS", "'document.getElem' completion");
 
   // Test pressing tab another time.
-  jsterm.complete(jsterm.COMPLETE_FORWARD, testNext);
-  yield undefined;
+  yield jsterm.complete(jsterm.COMPLETE_FORWARD);
 
   is(input.value, "document.getElem", "'document.getElem' completion");
   is(jsterm.completeNode.value, "                entsByTagName", "'document.getElem' another tab completion");
 
   // Test pressing shift_tab.
-  jsterm.complete(jsterm.COMPLETE_BACKWARD, testNext);
-  yield undefined;
+  complete(jsterm.COMPLETE_BACKWARD);
 
   is(input.value, "document.getElem", "'document.getElem' untab completion");
   is(jsterm.completeNode.value, "                entsByTagNameNS", "'document.getElem' completion");
 
   jsterm.clearOutput();
 
   input.value = "docu";
-  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
-  yield undefined;
+  yield complete(jsterm.COMPLETE_HINT_ONLY);
 
   is(jsterm.completeNode.value, "    ment", "'docu' completion");
   jsterm.execute();
   is(jsterm.completeNode.value, "", "clear completion on execute()");
 
   // Test multi-line completion works
   input.value =                 "console.log('one');\nconsol";
-  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
-  yield undefined;
+  yield complete(jsterm.COMPLETE_HINT_ONLY);
 
   is(jsterm.completeNode.value, "                   \n      e", "multi-line completion");
 
   // Test non-object autocompletion.
   input.value = "Object.name.sl";
-  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
-  yield undefined;
+  yield complete(jsterm.COMPLETE_HINT_ONLY);
 
   is(jsterm.completeNode.value, "              ice", "non-object completion");
 
   // Test string literal autocompletion.
   input.value = "'Asimov'.sl";
-  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
-  yield undefined;
+  yield complete(jsterm.COMPLETE_HINT_ONLY);
 
   is(jsterm.completeNode.value, "           ice", "string literal completion");
+});
 
-  testDriver = jsterm = input = null;
-  executeSoon(finishTest);
-  yield undefined;
+
+function complete(type) {
+  let updated = jsterm.once("autocomplete-updated");
+  jsterm.complete(type);
+  return updated;
 }
-
diff --git a/browser/devtools/webconsole/test/browser_webconsole_console_logging_api.js b/browser/devtools/webconsole/test/browser_webconsole_console_logging_api.js
--- a/browser/devtools/webconsole/test/browser_webconsole_console_logging_api.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_console_logging_api.js
@@ -1,109 +1,101 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Tests that the basic console.log()-style APIs and filtering work.
 
+"use strict";
+
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
-let hud, outputNode;
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
+  hud.jsterm.clearOutput();
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    Task.spawn(runner);
-  }, true);
+  let outputNode = hud.outputNode;
 
-  function* runner() {
-    hud = yield openConsole();
-    outputNode = hud.outputNode;
+  let methods = ["log", "info", "warn", "error", "exception", "debug"];
+  for (let method of methods) {
+    yield testMethod(method, hud, outputNode);
+  }
+});
 
-    let methods = ["log", "info", "warn", "error", "exception", "debug"];
-    for (let method of methods) {
-      yield testMethod(method);
-    }
-
-    executeSoon(finishTest);
-  }
-}
-
-function* testMethod(aMethod) {
+function* testMethod(aMethod, aHud, aOutputNode) {
   let console = content.console;
 
-  hud.jsterm.clearOutput();
+  aHud.jsterm.clearOutput();
 
   console[aMethod]("foo-bar-baz");
   console[aMethod]("baar-baz");
 
   yield waitForMessages({
-    webconsole: hud,
+    webconsole: aHud,
     messages: [{
       text: "foo-bar-baz",
     }, {
       text: "baar-baz",
     }],
   });
 
-  setStringFilter("foo");
+  setStringFilter("foo", aHud);
 
-  is(outputNode.querySelectorAll(".filtered-by-string").length, 1,
+  is(aOutputNode.querySelectorAll(".filtered-by-string").length, 1,
      "1 hidden " + aMethod + " node via string filtering")
 
-  hud.jsterm.clearOutput();
+  aHud.jsterm.clearOutput();
 
   // now toggle the current method off - make sure no visible message
   // TODO: move all filtering tests into a separate test file: see bug 608135
 
   console[aMethod]("foo-bar-baz");
   yield waitForMessages({
-    webconsole: hud,
+    webconsole: aHud,
     messages: [{
       text: "foo-bar-baz",
     }],
   });
 
-  setStringFilter("");
+  setStringFilter("", aHud);
   let filter;
   switch(aMethod) {
     case "debug":
       filter = "log";
       break;
     case "exception":
       filter = "error";
       break;
     default:
       filter = aMethod;
       break;
   }
 
-  hud.setFilterState(filter, false);
+  aHud.setFilterState(filter, false);
 
-  is(outputNode.querySelectorAll(".filtered-by-type").length, 1,
+  is(aOutputNode.querySelectorAll(".filtered-by-type").length, 1,
      "1 message hidden for " + aMethod + " (logging turned off)")
 
-  hud.setFilterState(filter, true);
+  aHud.setFilterState(filter, true);
 
-  is(outputNode.querySelectorAll(".message:not(.filtered-by-type)").length, 1,
+  is(aOutputNode.querySelectorAll(".message:not(.filtered-by-type)").length, 1,
      "1 message shown for " + aMethod + " (logging turned on)")
 
-  hud.jsterm.clearOutput();
+  aHud.jsterm.clearOutput();
 
   // test for multiple arguments.
   console[aMethod]("foo", "bar");
 
   yield waitForMessages({
-    webconsole: hud,
+    webconsole: aHud,
     messages: [{
       text: '"foo" "bar"',
       category: CATEGORY_WEBDEV,
     }],
   })
 }
 
-function setStringFilter(aValue) {
-  hud.ui.filterBox.value = aValue;
-  hud.ui.adjustVisibilityOnSearchStringChange();
+function setStringFilter(aValue, aHud) {
+  aHud.ui.filterBox.value = aValue;
+  aHud.ui.adjustVisibilityOnSearchStringChange();
 }
-
diff --git a/browser/devtools/webconsole/test/browser_webconsole_dont_navigate_on_doubleclick.js b/browser/devtools/webconsole/test/browser_webconsole_dont_navigate_on_doubleclick.js
--- a/browser/devtools/webconsole/test/browser_webconsole_dont_navigate_on_doubleclick.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_dont_navigate_on_doubleclick.js
@@ -1,15 +1,17 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 // Tests that if a link in console is double clicked, the console frame doesn't
 // navigate to that destination (bug 975707).
 
+"use strict";
+
 function test() {
   let originalNetPref = Services.prefs.getBoolPref("devtools.webconsole.filter.networkinfo");
   registerCleanupFunction(() => {
     Services.prefs.setBoolPref("devtools.webconsole.filter.networkinfo", originalNetPref);
   });
   Services.prefs.setBoolPref("devtools.webconsole.filter.networkinfo", true);
   Task.spawn(runner).then(finishTest);
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_execution_scope.js b/browser/devtools/webconsole/test/browser_webconsole_execution_scope.js
--- a/browser/devtools/webconsole/test/browser_webconsole_execution_scope.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_execution_scope.js
@@ -1,41 +1,34 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Tests that commands run by the user are executed in content space.
 
+"use strict";
+
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, testExecutionScope);
-  }, true);
-}
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
+  hud.jsterm.clearOutput();
+  hud.jsterm.execute("window.location.href;");
 
-function testExecutionScope(hud) {
-  let jsterm = hud.jsterm;
-
-  jsterm.clearOutput();
-  jsterm.execute("window.location.href;");
-  waitForMessages({
+  let [input, output] = yield waitForMessages({
     webconsole: hud,
     messages: [{
       text: "window.location.href;",
       category: CATEGORY_INPUT,
     },
     {
       text: TEST_URI,
       category: CATEGORY_OUTPUT,
     }],
-  }).then(([input, output]) => {
-    let inputNode = [...input.matched][0];
-    let outputNode = [...output.matched][0];
-    is(inputNode.getAttribute("category"), "input", "input node category is correct");
-    is(outputNode.getAttribute("category"), "output", "output node category is correct");
-    finishTest();
   });
-}
 
+  let inputNode = [...input.matched][0];
+  let outputNode = [...output.matched][0];
+  is(inputNode.getAttribute("category"), "input", "input node category is correct");
+  is(outputNode.getAttribute("category"), "output", "output node category is correct");
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_expandable_timestamps.js b/browser/devtools/webconsole/test/browser_webconsole_expandable_timestamps.js
--- a/browser/devtools/webconsole/test/browser_webconsole_expandable_timestamps.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_expandable_timestamps.js
@@ -1,57 +1,55 @@
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 // Test for the message timestamps option: check if the preference toggles the
 // display of messages in the console output. See bug 722267.
 
-function test()
+let TEST_URI = "data:text/html;charset=utf-8,Web Console test for bug 722267 - " +
+               "preference for toggling timestamps in messages";
+let PREF_MESSAGE_TIMESTAMP = "devtools.webconsole.timestampMessages";
+let hud;
+
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+
+  hud = yield openConsole();
+  let panel = yield consoleOpened();
+
+  yield onOptionsPanelSelected(panel);
+  onPrefChanged();
+
+  Services.prefs.clearUserPref(PREF_MESSAGE_TIMESTAMP);
+});
+
+function consoleOpened()
 {
-  const PREF_MESSAGE_TIMESTAMP = "devtools.webconsole.timestampMessages";
-  let hud;
+  info("console opened");
+  let prefValue = Services.prefs.getBoolPref(PREF_MESSAGE_TIMESTAMP);
+  ok(!prefValue, "messages have no timestamp by default (pref check)");
+  ok(hud.outputNode.classList.contains("hideTimestamps"),
+     "messages have no timestamp (class name check)");
 
-  registerCleanupFunction(() => {
-    Services.prefs.clearUserPref(PREF_MESSAGE_TIMESTAMP);
-  });
+  let toolbox = gDevTools.getToolbox(hud.target);
+  return toolbox.selectTool("options");
+}
 
-  addTab("data:text/html;charset=utf-8,Web Console test for bug 722267 - " +
-         "preference for toggling timestamps in messages");
+function onOptionsPanelSelected(panel)
+{
+  info("options panel opened");
 
-  browser.addEventListener("load", function tabLoad() {
-    browser.removeEventListener("load", tabLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
+  let prefChanged = gDevTools.once("pref-changed", onPrefChanged);
 
-  function consoleOpened(aHud)
-  {
-    hud = aHud;
+  let checkbox = panel.panelDoc.getElementById("webconsole-timestamp-messages");
+  checkbox.click();
 
-    info("console opened");
-    let prefValue = Services.prefs.getBoolPref(PREF_MESSAGE_TIMESTAMP);
-    ok(!prefValue, "messages have no timestamp by default (pref check)");
-    ok(hud.outputNode.classList.contains("hideTimestamps"),
-       "messages have no timestamp (class name check)");
+  return prefChanged;
+}
 
-    let toolbox = gDevTools.getToolbox(hud.target);
-    toolbox.selectTool("options").then(onOptionsPanelSelected);
-  }
-
-  function onOptionsPanelSelected(panel)
-  {
-    info("options panel opened");
-
-    gDevTools.once("pref-changed", onPrefChanged);
-
-    let checkbox = panel.panelDoc.getElementById("webconsole-timestamp-messages");
-    checkbox.click();
-  }
-
-  function onPrefChanged()
-  {
-    info("pref changed");
-    let prefValue = Services.prefs.getBoolPref(PREF_MESSAGE_TIMESTAMP);
-    ok(prefValue, "messages have timestamps (pref check)");
-    ok(!hud.outputNode.classList.contains("hideTimestamps"),
-       "messages have timestamps (class name check)");
-    finishTest();
-  }
+function onPrefChanged()
+{
+  info("pref changed");
+  let prefValue = Services.prefs.getBoolPref(PREF_MESSAGE_TIMESTAMP);
+  ok(prefValue, "messages have timestamps (pref check)");
+  ok(!hud.outputNode.classList.contains("hideTimestamps"),
+     "messages have timestamps (class name check)");
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_for_of.js b/browser/devtools/webconsole/test/browser_webconsole_for_of.js
--- a/browser/devtools/webconsole/test/browser_webconsole_for_of.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_for_of.js
@@ -1,24 +1,27 @@
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 // A for-of loop in Web Console code can loop over a content NodeList.
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-for-of.html";
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, testForOf);
-  }, true);
-}
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+
+  let hud = yield openConsole();
+  yield testForOf(hud);
+});
 
 function testForOf(hud) {
+  let deferred = promise.defer();
+
   var jsterm = hud.jsterm;
   jsterm.execute("{ [x.tagName for (x of document.body.childNodes) if (x.nodeType === 1)].join(' '); }",
     (node) => {
       ok(/H1 DIV H2 P/.test(node.textContent),
         "for-of loop should find all top-level nodes");
-      finishTest();
+      deferred.resolve();
     });
+
+  return deferred.promise;
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_history.js b/browser/devtools/webconsole/test/browser_webconsole_history.js
--- a/browser/devtools/webconsole/test/browser_webconsole_history.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_history.js
@@ -1,30 +1,28 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Tests the console history feature accessed via the up and down arrow keys.
 
+"use strict";
+
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
 // Constants used for defining the direction of JSTerm input history navigation.
 const HISTORY_BACK = -1;
 const HISTORY_FORWARD = 1;
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, testHistory);
-  }, true);
-}
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
+  hud.jsterm.clearOutput();
 
-function testHistory(hud) {
   let jsterm = hud.jsterm;
   let input = jsterm.inputNode;
 
   let executeList = ["document", "window", "window.location"];
 
   for each (var item in executeList) {
     input.value = item;
     jsterm.execute();
@@ -55,12 +53,9 @@ function testHistory(hud) {
   jsterm.historyPeruse(HISTORY_FORWARD);
   jsterm.historyPeruse(HISTORY_FORWARD);
 
   is (input.value, "", "check input is still empty");
 
   let idxLast = executeList.length - 1;
   jsterm.historyPeruse(HISTORY_BACK);
   is (input.value, executeList[idxLast], "check history next idx:" + idxLast);
-
-  executeSoon(finishTest);
-}
-
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_input_field_focus_on_panel_select.js b/browser/devtools/webconsole/test/browser_webconsole_input_field_focus_on_panel_select.js
--- a/browser/devtools/webconsole/test/browser_webconsole_input_field_focus_on_panel_select.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_input_field_focus_on_panel_select.js
@@ -1,46 +1,33 @@
 /* Any copyright is dedicated to the Public Domain
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // Test that the JS input field is focused when the user switches back to the
 // web console from other tools, see bug 891581.
 
+"use strict";
+
 const TEST_URI = "data:text/html;charset=utf8,<p>hello";
 
-function test()
-{
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
+  hud.jsterm.clearOutput();
 
-function consoleOpened(hud)
-{
   is(hud.jsterm.inputNode.hasAttribute("focused"), true,
      "inputNode should be focused");
 
   hud.ui.filterBox.focus();
 
   is(hud.ui.filterBox.hasAttribute("focused"), true,
      "filterBox should be focused");
 
   is(hud.jsterm.inputNode.hasAttribute("focused"), false,
      "inputNode shouldn't be focused");
 
-  openDebugger().then(debuggerOpened);
-}
+  yield openDebugger();
+  hud = yield openConsole();
 
-function debuggerOpened()
-{
-  openConsole(null, consoleReopened);
-}
-
-function consoleReopened(hud)
-{
   is(hud.jsterm.inputNode.hasAttribute("focused"), true,
      "inputNode should be focused");
-
-  finishTest();
-}
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_inspect-parsed-documents.js b/browser/devtools/webconsole/test/browser_webconsole_inspect-parsed-documents.js
--- a/browser/devtools/webconsole/test/browser_webconsole_inspect-parsed-documents.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_inspect-parsed-documents.js
@@ -1,16 +1,17 @@
 /* vim: set ft=javascript ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
    http://creativecommons.org/publicdomain/zero/1.0/ */
-"use strict";
 
 // Test that dynamically created (HTML|XML|SVG)Documents can be inspected by
 // clicking on the object in console (bug 1035198).
 
+"use strict;"
+
 const TEST_CASES = [
   {
     input: '(new DOMParser()).parseFromString("<a />", "text/html")',
     output: "HTMLDocument",
     inspectable: true,
   },
   {
     input: '(new DOMParser()).parseFromString("<a />", "application/xml")',
@@ -21,13 +22,14 @@ const TEST_CASES = [
     input: '(new DOMParser()).parseFromString("<svg></svg>", "image/svg+xml")',
     output: "SVGDocument",
     inspectable: true,
   },
 ];
 
 const TEST_URI = "data:text/html;charset=utf8," +
   "browser_webconsole_inspect-parsed-documents.js";
+
 let test = asyncTest(function* () {
     let {tab} = yield loadTab(TEST_URI);
     let hud = yield openConsole(tab);
     yield checkOutputForInputs(hud, TEST_CASES);
 });
diff --git a/browser/devtools/webconsole/test/browser_webconsole_js_input_expansion.js b/browser/devtools/webconsole/test/browser_webconsole_js_input_expansion.js
--- a/browser/devtools/webconsole/test/browser_webconsole_js_input_expansion.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_js_input_expansion.js
@@ -1,28 +1,25 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Tests that the input box expands as the user types long lines.
 
+"use strict";
+
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, testJSInputExpansion);
-  }, true);
-}
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
+  hud.jsterm.clearOutput();
 
-function testJSInputExpansion(hud) {
-  let jsterm = hud.jsterm;
-  let input = jsterm.inputNode;
+  let input = hud.jsterm.inputNode;
   input.focus();
 
   is(input.getAttribute("multiline"), "true", "multiline is enabled");
   // Tests if the inputNode expands.
   input.value = "hello\nworld\n";
   let length = input.value.length;
   input.selectionEnd = length;
   input.selectionStart = length;
@@ -50,11 +47,9 @@ function testJSInputExpansion(hud) {
   // Test if the inputNode shrinks again.
   input.value = "";
   EventUtils.synthesizeKey("d", {});
   let height = getHeight();
   info("height: " + height);
   info("initialHeight: " + initialHeight);
   let finalHeightDifference = Math.abs(initialHeight - height);
   ok(finalHeightDifference <= 1, "height shrank to original size within 1px");
-
-  finishTest();
-}
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_live_filtering_of_message_types.js b/browser/devtools/webconsole/test/browser_webconsole_live_filtering_of_message_types.js
--- a/browser/devtools/webconsole/test/browser_webconsole_live_filtering_of_message_types.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_live_filtering_of_message_types.js
@@ -1,62 +1,51 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Tests that the message type filter checkboxes work.
 
+"use strict";
+
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
-let hud;
-
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
-
-function consoleOpened(aHud) {
-  hud = aHud;
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
   hud.jsterm.clearOutput();
 
   let console = content.console;
 
   for (let i = 0; i < 50; i++) {
     console.log("foobarz #" + i);
   }
 
-  waitForMessages({
+  yield waitForMessages({
     webconsole: hud,
     messages: [{
       text: "foobarz #49",
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG,
     }],
-  }).then(testLiveFilteringOfMessageTypes);
-}
+  });
 
-function testLiveFilteringOfMessageTypes() {
   is(hud.outputNode.children.length, 50, "number of messages");
 
   hud.setFilterState("log", false);
-  is(countMessageNodes(), 0, "the log nodes are hidden when the " +
+  is(countMessageNodes(hud), 0, "the log nodes are hidden when the " +
     "corresponding filter is switched off");
 
   hud.setFilterState("log", true);
-  is(countMessageNodes(), 50, "the log nodes reappear when the " +
+  is(countMessageNodes(hud), 50, "the log nodes reappear when the " +
     "corresponding filter is switched on");
+});
 
-  finishTest();
-}
-
-function countMessageNodes() {
+function countMessageNodes(hud) {
   let messageNodes = hud.outputNode.querySelectorAll(".message");
   let displayedMessageNodes = 0;
   let view = hud.iframeWindow;
   for (let i = 0; i < messageNodes.length; i++) {
     let computedStyle = view.getComputedStyle(messageNodes[i], null);
     if (computedStyle.display !== "none") {
       displayedMessageNodes++;
     }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_live_filtering_on_search_strings.js b/browser/devtools/webconsole/test/browser_webconsole_live_filtering_on_search_strings.js
--- a/browser/devtools/webconsole/test/browser_webconsole_live_filtering_on_search_strings.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_live_filtering_on_search_strings.js
@@ -1,106 +1,96 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Tests that the text filter box works.
 
+"use strict";
+
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
-let hud;
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
+  hud.jsterm.clearOutput();
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
-
-function consoleOpened(aHud) {
-  hud = aHud;
-  hud.jsterm.clearOutput();
   let console = content.console;
 
   for (let i = 0; i < 50; i++) {
     console.log("http://www.example.com/ " + i);
   }
 
-  waitForMessages({
+  yield waitForMessages({
     webconsole: hud,
     messages: [{
       text: "http://www.example.com/ 49",
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG,
     }],
-  }).then(testLiveFilteringOnSearchStrings);
-}
+  })
 
-function testLiveFilteringOnSearchStrings() {
   is(hud.outputNode.children.length, 50, "number of messages");
 
-  setStringFilter("http");
-  isnot(countMessageNodes(), 0, "the log nodes are not hidden when the " +
+  setStringFilter(hud, "http");
+  isnot(countMessageNodes(hud), 0, "the log nodes are not hidden when the " +
     "search string is set to \"http\"");
 
-  setStringFilter("hxxp");
-  is(countMessageNodes(), 0, "the log nodes are hidden when the search " +
+  setStringFilter(hud, "hxxp");
+  is(countMessageNodes(hud), 0, "the log nodes are hidden when the search " +
     "string is set to \"hxxp\"");
 
-  setStringFilter("ht tp");
-  isnot(countMessageNodes(), 0, "the log nodes are not hidden when the " +
+  setStringFilter(hud, "ht tp");
+  isnot(countMessageNodes(hud), 0, "the log nodes are not hidden when the " +
     "search string is set to \"ht tp\"");
 
-  setStringFilter(" zzzz   zzzz ");
-  is(countMessageNodes(), 0, "the log nodes are hidden when the search " +
+  setStringFilter(hud, " zzzz   zzzz ");
+  is(countMessageNodes(hud), 0, "the log nodes are hidden when the search " +
     "string is set to \" zzzz   zzzz \"");
 
-  setStringFilter("");
-  isnot(countMessageNodes(), 0, "the log nodes are not hidden when the " +
+  setStringFilter(hud, "");
+  isnot(countMessageNodes(hud), 0, "the log nodes are not hidden when the " +
     "search string is removed");
 
-  setStringFilter("\u9f2c");
-  is(countMessageNodes(), 0, "the log nodes are hidden when searching " +
+  setStringFilter(hud, "\u9f2c");
+  is(countMessageNodes(hud), 0, "the log nodes are hidden when searching " +
     "for weasels");
 
-  setStringFilter("\u0007");
-  is(countMessageNodes(), 0, "the log nodes are hidden when searching for " +
+  setStringFilter(hud, "\u0007");
+  is(countMessageNodes(hud), 0, "the log nodes are hidden when searching for " +
     "the bell character");
 
-  setStringFilter('"foo"');
-  is(countMessageNodes(), 0, "the log nodes are hidden when searching for " +
+  setStringFilter(hud, '"foo"');
+  is(countMessageNodes(hud), 0, "the log nodes are hidden when searching for " +
     'the string "foo"');
 
-  setStringFilter("'foo'");
-  is(countMessageNodes(), 0, "the log nodes are hidden when searching for " +
+  setStringFilter(hud, "'foo'");
+  is(countMessageNodes(hud), 0, "the log nodes are hidden when searching for " +
     "the string 'foo'");
 
-  setStringFilter("foo\"bar'baz\"boo'");
-  is(countMessageNodes(), 0, "the log nodes are hidden when searching for " +
+  setStringFilter(hud, "foo\"bar'baz\"boo'");
+  is(countMessageNodes(hud), 0, "the log nodes are hidden when searching for " +
     "the string \"foo\"bar'baz\"boo'\"");
+});
 
-  finishTest();
-}
-
-function countMessageNodes() {
+function countMessageNodes(hud) {
   let outputNode = hud.outputNode;
 
   let messageNodes = outputNode.querySelectorAll(".message");
   let displayedMessageNodes = 0;
   let view = hud.iframeWindow;
   for (let i = 0; i < messageNodes.length; i++) {
     let computedStyle = view.getComputedStyle(messageNodes[i], null);
     if (computedStyle.display !== "none") {
       displayedMessageNodes++;
     }
   }
 
   return displayedMessageNodes;
 }
 
-function setStringFilter(aValue)
+function setStringFilter(hud, aValue)
 {
   hud.ui.filterBox.value = aValue;
   hud.ui.adjustVisibilityOnSearchStringChange();
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_log_file_filter.js b/browser/devtools/webconsole/test/browser_webconsole_log_file_filter.js
--- a/browser/devtools/webconsole/test/browser_webconsole_log_file_filter.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_log_file_filter.js
@@ -4,36 +4,38 @@
 
 // Tests that the text filter box works to filter based on filenames
 // where the logs were generated.
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-bug_923281_console_log_filter.html";
 
 let hud;
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
+"use strict";
 
-function consoleOpened(aHud) {
-  hud = aHud;
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+
+  hud = yield openConsole();
+  yield consoleOpened();
+
+  testLiveFilteringOnSearchStrings();
+});
+
+function consoleOpened() {
   let console = content.console;
   console.log("sentinel log");
-  waitForMessages({
+  return waitForMessages({
     webconsole: hud,
     messages: [{
       text: "sentinel log",
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG
     }],
-  }).then(testLiveFilteringOnSearchStrings);
+  })
 }
 
 function testLiveFilteringOnSearchStrings() {
   is(hud.outputNode.children.length, 4, "number of messages");
 
   setStringFilter("random");
   is(countMessageNodes(), 1, "the log nodes not containing string " +
       "\"random\" are hidden");
@@ -46,18 +48,16 @@ function testLiveFilteringOnSearchString
   setStringFilter("test1");
   is(countMessageNodes(), 2, "show only log nodes containing string " +
       "\"test1\" or log nodes created from files with filename " +
       "containing \"test1\" as substring.");
 
   setStringFilter("");
   is(countMessageNodes(), 4, "show all log nodes on setting filter string " +
       "as \"\".");
-
-  finishTest();
 }
 
 function countMessageNodes() {
   let outputNode = hud.outputNode;
 
   let messageNodes = outputNode.querySelectorAll(".message");
   content.console.log(messageNodes.length);
   let displayedMessageNodes = 0;
diff --git a/browser/devtools/webconsole/test/browser_webconsole_message_node_id.js b/browser/devtools/webconsole/test/browser_webconsole_message_node_id.js
--- a/browser/devtools/webconsole/test/browser_webconsole_message_node_id.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_message_node_id.js
@@ -1,31 +1,27 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+"use strict";
+
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("DOMContentLoaded", onLoad, false);
-}
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
 
-function onLoad() {
-  browser.removeEventListener("DOMContentLoaded", onLoad, false);
-  openConsole(null, function(hud) {
-    content.console.log("a log message");
+  hud.jsterm.execute("console.log('a log message')");
 
-    waitForMessages({
+  let [result] = yield waitForMessages({
       webconsole: hud,
       messages: [{
         text: "a log message",
         category: CATEGORY_WEBDEV,
         severity: SEVERITY_LOG,
       }],
-    }).then(([result]) => {
-      let msg = [...result.matched][0];
-      ok(msg.getAttribute("id"), "log message has an ID");
-      finishTest();
-    });
   });
-}
+
+  let msg = [...result.matched][0];
+  ok(msg.getAttribute("id"), "log message has an ID");
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_open-links-without-callback.js b/browser/devtools/webconsole/test/browser_webconsole_open-links-without-callback.js
--- a/browser/devtools/webconsole/test/browser_webconsole_open-links-without-callback.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_open-links-without-callback.js
@@ -1,15 +1,17 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 // Tests that if a link without an onclick callback is clicked the link is
 // opened in a new tab and no exception occurs (bug 999236).
 
+"use strict";
+
 function test() {
   function* runner() {
     const TEST_EVAL_STRING = "document";
     const TEST_PAGE_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
     const {tab} = yield loadTab(TEST_PAGE_URI);
     const hud = yield openConsole(tab);
 
     hud.jsterm.execute(TEST_EVAL_STRING);
diff --git a/browser/devtools/webconsole/test/browser_webconsole_output_copy_newlines.js b/browser/devtools/webconsole/test/browser_webconsole_output_copy_newlines.js
--- a/browser/devtools/webconsole/test/browser_webconsole_output_copy_newlines.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_output_copy_newlines.js
@@ -1,77 +1,67 @@
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 // Test that multiple messages are copied into the clipboard and that they are
 // separated by new lines. See bug 916997.
 
-function test()
-{
+"use strict";
+
+let test = asyncTest(function*() {
   const TEST_URI = "data:text/html;charset=utf8,<p>hello world, bug 916997";
   let clipboardValue = "";
 
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
+  hud.jsterm.clearOutput();
 
-  function consoleOpened(hud)
-  {
-    hud.jsterm.clearOutput();
+  let controller = top.document.commandDispatcher.
+                   getControllerForCommand("cmd_copy");
+  is(controller.isCommandEnabled("cmd_copy"), false, "cmd_copy is disabled");
 
-    let controller = top.document.commandDispatcher.
-                     getControllerForCommand("cmd_copy");
-    is(controller.isCommandEnabled("cmd_copy"), false, "cmd_copy is disabled");
+  content.console.log("Hello world! bug916997a");
+  content.console.log("Hello world 2! bug916997b");
 
-    content.console.log("Hello world! bug916997a");
-    content.console.log("Hello world 2! bug916997b");
+  yield waitForMessages({
+    webconsole: hud,
+    messages: [{
+      text: "Hello world! bug916997a",
+      category: CATEGORY_WEBDEV,
+      severity: SEVERITY_LOG,
+    }, {
+      text: "Hello world 2! bug916997b",
+      category: CATEGORY_WEBDEV,
+      severity: SEVERITY_LOG,
+    }],
+  });
 
-    waitForMessages({
-      webconsole: hud,
-      messages: [{
-        text: "Hello world! bug916997a",
-        category: CATEGORY_WEBDEV,
-        severity: SEVERITY_LOG,
-      }, {
-        text: "Hello world 2! bug916997b",
-        category: CATEGORY_WEBDEV,
-        severity: SEVERITY_LOG,
-      }],
-    }).then(() => {
-      hud.ui.output.selectAllMessages();
-      hud.outputNode.focus();
+  hud.ui.output.selectAllMessages();
+  hud.outputNode.focus();
 
-      goUpdateCommand("cmd_copy");
-      controller = top.document.commandDispatcher.getControllerForCommand("cmd_copy");
-      is(controller.isCommandEnabled("cmd_copy"), true, "cmd_copy is enabled");
+  goUpdateCommand("cmd_copy");
+  controller = top.document.commandDispatcher.getControllerForCommand("cmd_copy");
+  is(controller.isCommandEnabled("cmd_copy"), true, "cmd_copy is enabled");
 
-      let selection = hud.iframeWindow.getSelection() + "";
-      info("selection '" + selection + "'");
-      waitForClipboard((str) => {
-          clipboardValue = str;
-          return str.indexOf("bug916997a") > -1 && str.indexOf("bug916997b") > -1;
-        },
-        () => { goDoCommand("cmd_copy"); },
-        checkClipboard.bind(null, hud),
-        () => {
-          info("last clipboard value: '" + clipboardValue + "'");
-          finishTest();
-        });
+  let selection = hud.iframeWindow.getSelection() + "";
+  info("selection '" + selection + "'");
+
+  waitForClipboard((str) => {
+      clipboardValue = str;
+      return str.indexOf("bug916997a") > -1 && str.indexOf("bug916997b") > -1;
+    },
+    () => { goDoCommand("cmd_copy"); },
+    () => {
+      info("clipboard value '" + clipboardValue + "'");
+      let lines = clipboardValue.trim().split("\n");
+      is(hud.outputNode.children.length, 2, "number of messages");
+      is(lines.length, hud.outputNode.children.length, "number of lines");
+      isnot(lines[0].indexOf("bug916997a"), -1,
+            "first message text includes 'bug916997a'");
+      isnot(lines[1].indexOf("bug916997b"), -1,
+            "second message text includes 'bug916997b'");
+      is(lines[0].indexOf("bug916997b"), -1,
+         "first message text does not include 'bug916997b'");
+    },
+    () => {
+      info("last clipboard value: '" + clipboardValue + "'");
     });
-  }
-
-  function checkClipboard(hud)
-  {
-    info("clipboard value '" + clipboardValue + "'");
-    let lines = clipboardValue.trim().split("\n");
-    is(hud.outputNode.children.length, 2, "number of messages");
-    is(lines.length, hud.outputNode.children.length, "number of lines");
-    isnot(lines[0].indexOf("bug916997a"), -1,
-          "first message text includes 'bug916997a'");
-    isnot(lines[1].indexOf("bug916997b"), -1,
-          "second message text includes 'bug916997b'");
-    is(lines[0].indexOf("bug916997b"), -1,
-       "first message text does not include 'bug916997b'");
-    finishTest();
-  }
-}
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_output_events.js b/browser/devtools/webconsole/test/browser_webconsole_output_events.js
--- a/browser/devtools/webconsole/test/browser_webconsole_output_events.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_output_events.js
@@ -2,59 +2,47 @@
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // Test the webconsole output for DOM events.
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console-output-events.html";
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    Task.spawn(runner);
-  }, true);
+"use strict";
 
-  function* runner()
-  {
-    let hud = yield openConsole();
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
 
-    hud.jsterm.clearOutput();
-    hud.jsterm.execute("testDOMEvents()");
+  hud.jsterm.clearOutput();
+  hud.jsterm.execute("testDOMEvents()");
 
-    yield waitForMessages({
-      webconsole: hud,
-      messages: [{
-        name: "testDOMEvents() output",
-        text: "undefined",
-        category: CATEGORY_OUTPUT,
-      }],
-    });
+  yield waitForMessages({
+    webconsole: hud,
+    messages: [{
+      name: "testDOMEvents() output",
+      text: "undefined",
+      category: CATEGORY_OUTPUT,
+    }],
+  });
 
-    EventUtils.synthesizeMouse(content.document.body, 2, 2, {type: "mousemove"}, content);
+  yield waitForMessages({
+    webconsole: hud,
+    messages: [{
+      name: "console.log() output for mousemove",
+      text: /"eventLogger" mousemove { target: .+, buttons: 0, clientX: \d+, clientY: \d+, layerX: \d+, layerY: \d+ }/,
+      category: CATEGORY_WEBDEV,
+      severity: SEVERITY_LOG,
+    }],
+  });
 
-    yield waitForMessages({
-      webconsole: hud,
-      messages: [{
-        name: "console.log() output for mousemove",
-        text: /"eventLogger" mousemove { target: .+, buttons: 1, clientX: \d+, clientY: \d+, layerX: \d+, layerY: \d+ }/,
-        category: CATEGORY_WEBDEV,
-        severity: SEVERITY_LOG,
-      }],
-    });
+  yield waitForMessages({
+    webconsole: hud,
+    messages: [{
+      name: "console.log() output for keypress",
+      text: /"eventLogger" keypress Shift { target: .+, key: .+, charCode: \d+, keyCode: \d+ }/,
+      category: CATEGORY_WEBDEV,
+      severity: SEVERITY_LOG,
+    }],
+  });
+})
 
-    content.focus();
-    EventUtils.synthesizeKey("a", {shiftKey: true}, content);
-
-    yield waitForMessages({
-      webconsole: hud,
-      messages: [{
-        name: "console.log() output for keypress",
-        text: /"eventLogger" keypress Shift { target: .+, key: .+, charCode: \d+, keyCode: \d+ }/,
-        category: CATEGORY_WEBDEV,
-        severity: SEVERITY_LOG,
-      }],
-    });
-
-    finishTest();
-  }
-}
diff --git a/browser/devtools/webconsole/test/browser_webconsole_output_order.js b/browser/devtools/webconsole/test/browser_webconsole_output_order.js
--- a/browser/devtools/webconsole/test/browser_webconsole_output_order.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_output_order.js
@@ -1,51 +1,47 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Tests that any output created from calls to the console API comes after the
 // echoed JavaScript.
 
+"use strict";
+
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, testOutputOrder);
-  }, true);
-}
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
 
-function testOutputOrder(hud) {
   let jsterm = hud.jsterm;
   let outputNode = jsterm.outputNode;
 
   jsterm.clearOutput();
   jsterm.execute("console.log('foo', 'bar');");
 
-  waitForMessages({
+  let [function_call, result, console_message] = yield waitForMessages({
     webconsole: hud,
     messages: [{
       text: "console.log('foo', 'bar');",
       category: CATEGORY_INPUT,
     },
     {
       text: "undefined",
       category: CATEGORY_OUTPUT,
     },
     {
       text: '"foo" "bar"',
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG,
     }],
-  }).then(([function_call, result, console_message]) => {
-    let fncall_node = [...function_call.matched][0];
-    let result_node = [...result.matched][0];
-    let console_message_node = [...console_message.matched][0];
-    is(fncall_node.nextElementSibling, result_node,
-       "console.log() is followed by undefined");
-    is(result_node.nextElementSibling, console_message_node,
-       "undefined is followed by 'foo' 'bar'");
-    finishTest();
   });
-}
+
+  let fncall_node = [...function_call.matched][0];
+  let result_node = [...result.matched][0];
+  let console_message_node = [...console_message.matched][0];
+  is(fncall_node.nextElementSibling, result_node,
+     "console.log() is followed by undefined");
+  is(result_node.nextElementSibling, console_message_node,
+     "undefined is followed by 'foo' 'bar'");
+});
diff --git a/browser/devtools/webconsole/test/head.js b/browser/devtools/webconsole/test/head.js
--- a/browser/devtools/webconsole/test/head.js
+++ b/browser/devtools/webconsole/test/head.js
@@ -10,16 +10,17 @@ let {console} = Cu.import("resource://gr
 let {Promise: promise} = Cu.import("resource://gre/modules/Promise.jsm", {});
 let {Task} = Cu.import("resource://gre/modules/Task.jsm", {});
 let {devtools} = Cu.import("resource://gre/modules/devtools/Loader.jsm", {});
 let {require, TargetFactory} = devtools;
 let {Utils: WebConsoleUtils} = require("devtools/toolkit/webconsole/utils");
 let {Messages} = require("devtools/webconsole/console-output");
 
 // promise._reportErrors = true; // please never leave me.
+//Services.prefs.setBoolPref("devtools.debugger.log", true);
 
 let gPendingOutputTest = 0;
 
 // The various categories of messages.
 const CATEGORY_NETWORK = 0;
 const CATEGORY_CSS = 1;
 const CATEGORY_JS = 2;
 const CATEGORY_WEBDEV = 3;
@@ -35,51 +36,24 @@ const SEVERITY_LOG = 3;
 
 // The indent of a console group in pixels.
 const GROUP_INDENT = 12;
 
 const WEBCONSOLE_STRINGS_URI = "chrome://browser/locale/devtools/webconsole.properties";
 let WCU_l10n = new WebConsoleUtils.l10n(WEBCONSOLE_STRINGS_URI);
 
 gDevTools.testing = true;
-SimpleTest.registerCleanupFunction(() => {
-  gDevTools.testing = false;
-});
 
 /**
  * Define an async test based on a generator function
  */
 function asyncTest(generator) {
-  return () => Task.spawn(generator).then(null, ok.bind(null, false)).then(finishTest);
-}
-
-function log(aMsg)
-{
-  dump("*** WebConsoleTest: " + aMsg + "\n");
-}
-
-function pprint(aObj)
-{
-  for (let prop in aObj) {
-    if (typeof aObj[prop] == "function") {
-      log("function " + prop);
-    }
-    else {
-      log(prop + ": " + aObj[prop]);
-    }
-  }
-}
-
-let tab, browser, hudId, hud, hudBox, filterBox, outputNode, cs;
-
-function addTab(aURL)
-{
-  gBrowser.selectedTab = gBrowser.addTab(aURL);
-  tab = gBrowser.selectedTab;
-  browser = gBrowser.getBrowserForTab(tab);
+  return () => {
+    Task.spawn(generator).then(finishTest);
+  };
 }
 
 function loadTab(url) {
   let deferred = promise.defer();
 
   let tab = gBrowser.selectedTab = gBrowser.addTab(url);
   let browser = gBrowser.getBrowserForTab(tab);
 
@@ -91,17 +65,17 @@ function loadTab(url) {
   return deferred.promise;
 }
 
 function loadBrowser(browser) {
   let deferred = promise.defer();
 
   browser.addEventListener("load", function onLoad() {
     browser.removeEventListener("load", onLoad, true);
-    deferred.resolve(null)
+    deferred.resolve(null);
   }, true);
 
   return deferred.promise;
 }
 
 function closeTab(tab) {
   let deferred = promise.defer();
 
@@ -200,95 +174,92 @@ function findLogEntry(aString)
  *        Optional tab element for which you want open the Web Console. The
  *        default tab is taken from the global variable |tab|.
  * @param function [aCallback]
  *        Optional function to invoke after the Web Console completes
  *        initialization (web-console-created).
  * @return object
  *         A promise that is resolved once the web console is open.
  */
-function openConsole(aTab, aCallback = function() { })
-{
-  let deferred = promise.defer();
-  let target = TargetFactory.forTab(aTab || tab);
-  gDevTools.showToolbox(target, "webconsole").then(function(toolbox) {
+let openConsole = function(aTab) {
+  let webconsoleOpened = promise.defer();
+  let target = TargetFactory.forTab(aTab || gBrowser.selectedTab);
+  gDevTools.showToolbox(target, "webconsole").then(toolbox => {
     let hud = toolbox.getCurrentPanel().hud;
     hud.jsterm._lazyVariablesView = false;
-    aCallback(hud);
-    deferred.resolve(hud);
+    webconsoleOpened.resolve(hud);
   });
-  return deferred.promise;
-}
+  return webconsoleOpened.promise;
+};
 
 /**
  * Close the Web Console for the given tab.
  *
  * @param nsIDOMElement [aTab]
  *        Optional tab element for which you want close the Web Console. The
  *        default tab is taken from the global variable |tab|.
  * @param function [aCallback]
  *        Optional function to invoke after the Web Console completes
  *        closing (web-console-destroyed).
  * @return object
  *         A promise that is resolved once the web console is closed.
  */
-function closeConsole(aTab, aCallback = function() { })
-{
-  let target = TargetFactory.forTab(aTab || tab);
+let closeConsole = Task.async(function* (aTab) {
+  let target = TargetFactory.forTab(aTab || gBrowser.selectedTab);
   let toolbox = gDevTools.getToolbox(target);
   if (toolbox) {
-    let panel = toolbox.getPanel("webconsole");
-    if (panel) {
-      let hudId = panel.hud.hudId;
-      return toolbox.destroy().then(aCallback.bind(null, hudId)).then(null, console.debug);
-    }
-    return toolbox.destroy().then(aCallback.bind(null));
+    yield toolbox.destroy();
   }
-
-  aCallback();
-  return promise.resolve(null);
-}
+});
 
 /**
  * Wait for a context menu popup to open.
  *
  * @param nsIDOMElement aPopup
  *        The XUL popup you expect to open.
  * @param nsIDOMElement aButton
  *        The button/element that receives the contextmenu event. This is
  *        expected to open the popup.
  * @param function aOnShown
  *        Function to invoke on popupshown event.
  * @param function aOnHidden
  *        Function to invoke on popuphidden event.
+ * @return object
+ *         A Promise object that is resolved after the popuphidden event
+ *         callback is invoked.
  */
 function waitForContextMenu(aPopup, aButton, aOnShown, aOnHidden)
 {
   function onPopupShown() {
     info("onPopupShown");
     aPopup.removeEventListener("popupshown", onPopupShown);
 
-    aOnShown();
+    aOnShown && aOnShown();
 
     // Use executeSoon() to get out of the popupshown event.
     aPopup.addEventListener("popuphidden", onPopupHidden);
     executeSoon(() => aPopup.hidePopup());
   }
   function onPopupHidden() {
     info("onPopupHidden");
     aPopup.removeEventListener("popuphidden", onPopupHidden);
-    aOnHidden();
+
+    aOnHidden && aOnHidden();
+
+    deferred.resolve(aPopup);
   }
 
+  let deferred = promise.defer();
   aPopup.addEventListener("popupshown", onPopupShown);
 
   info("wait for the context menu to open");
   let eventDetails = { type: "contextmenu", button: 2};
   EventUtils.synthesizeMouse(aButton, 2, 2, eventDetails,
                              aButton.ownerDocument.defaultView);
+  return deferred.promise;
 }
 
 /**
  * Dump the output of all open Web Consoles - used only for debugging purposes.
  */
 function dumpConsoles()
 {
   if (gPendingOutputTest) {
@@ -328,120 +299,109 @@ function dumpMessageElement(aMessage)
                 "class", aMessage.className,
                 "category", aMessage.category,
                 "severity", aMessage.severity,
                 "repeats", repeats,
                 "clipboardText", aMessage.clipboardText,
                 "text", text);
 }
 
-function finishTest()
-{
-  browser = hudId = hud = filterBox = outputNode = cs = hudBox = null;
-
+let finishTest = Task.async(function* () {
   dumpConsoles();
 
   let browserConsole = HUDService.getBrowserConsole();
   if (browserConsole) {
     if (browserConsole.jsterm) {
       browserConsole.jsterm.clearOutput(true);
     }
-    HUDService.toggleBrowserConsole().then(finishTest);
-    return;
+    yield HUDService.toggleBrowserConsole();
   }
 
-  let hud = HUDService.getHudByWindow(content);
-  if (!hud) {
-    finish();
-    return;
-  }
+  let target = TargetFactory.forTab(gBrowser.selectedTab);
+  yield gDevTools.closeToolbox(target);
 
-  if (hud.jsterm) {
-    hud.jsterm.clearOutput(true);
-  }
-
-  closeConsole(hud.target.tab, finish);
-
-  hud = null;
-}
+  finish();
+});
 
 function tearDown()
 {
+  gDevTools.testing = false;
+
   dumpConsoles();
 
   if (HUDService.getBrowserConsole()) {
     HUDService.toggleBrowserConsole();
   }
 
   let target = TargetFactory.forTab(gBrowser.selectedTab);
   gDevTools.closeToolbox(target);
+
   while (gBrowser.tabs.length > 1) {
     gBrowser.removeCurrentTab();
   }
-  WCU_l10n = tab = browser = hudId = hud = filterBox = outputNode = cs = null;
 }
 
 registerCleanupFunction(tearDown);
 
 waitForExplicitFinish();
 
 /**
  * Polls a given function waiting for it to become true.
  *
  * @param object aOptions
  *        Options object with the following properties:
- *        - validatorFn
+ *        - validator
  *        A validator function that returns a boolean. This is called every few
- *        milliseconds to check if the result is true. When it is true, succesFn
- *        is called and polling stops. If validatorFn never returns true, then
- *        polling timeouts after several tries and a failure is recorded.
- *        - successFn
- *        A function called when the validator function returns true.
- *        - failureFn
- *        A function called if the validator function timeouts - fails to return
- *        true in the given time.
+ *        milliseconds to check if the result is true. When it is true, the
+ *        promise is resolved and polling stops. If validator never returns
+ *        true, then polling timeouts after several tries and the promise is
+ *        rejected.
  *        - name
  *        Name of test. This is used to generate the success and failure
  *        messages.
  *        - timeout
  *        Timeout for validator function, in milliseconds. Default is 5000.
+ * @return object
+ *         A Promise object that is resolved based on the validator function.
  */
 function waitForSuccess(aOptions)
 {
+  let deferred = promise.defer();
   let start = Date.now();
   let timeout = aOptions.timeout || 5000;
+  let {validator} = aOptions;
 
-  function wait(validatorFn, successFn, failureFn)
+  function wait()
   {
     if ((Date.now() - start) > timeout) {
       // Log the failure.
       ok(false, "Timed out while waiting for: " + aOptions.name);
-      failureFn(aOptions);
+      deferred.reject(null);
       return;
     }
 
-    if (validatorFn(aOptions)) {
+    if (validator(aOptions)) {
       ok(true, aOptions.name);
-      successFn();
+      deferred.resolve(null);
     }
     else {
-      setTimeout(function() wait(validatorFn, successFn, failureFn), 100);
+      setTimeout(wait, 100);
     }
   }
 
-  wait(aOptions.validatorFn, aOptions.successFn, aOptions.failureFn);
+  setTimeout(wait, 100);
+
+  return deferred.promise;
 }
 
-function openInspector(aCallback, aTab = gBrowser.selectedTab)
-{
+let openInspector = Task.async(function* (aTab = gBrowser.selectedTab) {
   let target = TargetFactory.forTab(aTab);
-  gDevTools.showToolbox(target, "inspector").then(function(toolbox) {
-    aCallback(toolbox.getCurrentPanel());
-  });
-}
+  let toolbox = yield gDevTools.showToolbox(target, "inspector");
+  return toolbox.getCurrentPanel();
+});
 
 /**
  * Find variables or properties in a VariablesView instance.
  *
  * @param object aView
  *        The VariablesView instance.
  * @param array aRules
  *        The array of rules you want to match. Each rule is an object with:
@@ -775,54 +735,61 @@ function variablesViewExpandTo(aOptions)
  * @param object aOptions
  *        Options for the property update:
  *        - property: the property you want to change.
  *        - field: string that tells what you want to change:
  *          - use "name" to change the property name,
  *          - or "value" to change the property value.
  *        - string: the new string to write into the field.
  *        - webconsole: reference to the Web Console instance we work with.
- *        - callback: function to invoke after the property is updated.
+ * @return object
+ *         A Promise object that is resolved once the property is updated.
  */
-function updateVariablesViewProperty(aOptions)
-{
+let updateVariablesViewProperty = Task.async(function* (aOptions) {
   let view = aOptions.property._variablesView;
   view.window.focus();
   aOptions.property.focus();
 
   switch (aOptions.field) {
     case "name":
       EventUtils.synthesizeKey("VK_RETURN", { shiftKey: true }, view.window);
       break;
     case "value":
       EventUtils.synthesizeKey("VK_RETURN", {}, view.window);
       break;
     default:
       throw new Error("options.field is incorrect");
-      return;
   }
 
+  let deferred = promise.defer();
+
   executeSoon(() => {
     EventUtils.synthesizeKey("A", { accelKey: true }, view.window);
 
     for (let c of aOptions.string) {
-      EventUtils.synthesizeKey(c, {}, gVariablesView.window);
+      EventUtils.synthesizeKey(c, {}, view.window);
     }
 
     if (aOptions.webconsole) {
-      aOptions.webconsole.jsterm.once("variablesview-fetched", aOptions.callback);
+      aOptions.webconsole.jsterm.once("variablesview-fetched").then((varView) => {
+        deferred.resolve(varView);
+      });
     }
 
     EventUtils.synthesizeKey("VK_RETURN", {}, view.window);
 
     if (!aOptions.webconsole) {
-      executeSoon(aOptions.callback);
+      executeSoon(() => {
+        deferred.resolve(null);
+      });
     }
   });
-}
+
+  return deferred.promise;
+});
 
 /**
  * Open the JavaScript debugger.
  *
  * @param object aOptions
  *        Options for opening the debugger:
  *        - tab: the tab you want to open the debugger for.
  * @return object
diff --git a/browser/devtools/webconsole/test/test-console-output-events.html b/browser/devtools/webconsole/test/test-console-output-events.html
--- a/browser/devtools/webconsole/test/test-console-output-events.html
+++ b/browser/devtools/webconsole/test/test-console-output-events.html
@@ -5,19 +5,39 @@
   <title>Test the web console output for DOM events</title>
   <!--
   - Any copyright is dedicated to the Public Domain.
   - http://creativecommons.org/publicdomain/zero/1.0/
   -->
 </head>
 <body>
   <p>hello world!</p>
+
   <script type="text/javascript">
 function testDOMEvents() {
   function eventLogger(ev) {
     console.log("eventLogger", ev);
   }
   document.addEventListener("mousemove", eventLogger);
   document.addEventListener("keypress", eventLogger);
+
+  synthesizeKeyPress("a", {shiftKey: true});
+  synthesizeMouseMove();
 }
+
+function synthesizeKeyPress(key, options) {
+  var keyboardEvent = document.createEvent("KeyboardEvent");
+  keyboardEvent.initKeyEvent("keypress", true, true, window, false, false,
+                             options.shiftKey, false, key.charCodeAt(0), 0);
+  document.dispatchEvent(keyboardEvent);
+}
+
+function synthesizeMouseMove(element) {
+  var mouseEvent = document.createEvent("MouseEvent");
+  mouseEvent.initMouseEvent("mousemove", true, true, window, 0, 0, 0, 0, 0,
+                            false, false, false, false, 0, null);
+
+  document.dispatchEvent(mouseEvent);
+}
+
   </script>
 </body>
 </html>
