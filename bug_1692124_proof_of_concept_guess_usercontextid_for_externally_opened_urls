# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1660671120 25200
#      Tue Aug 16 10:32:00 2022 -0700
# Node ID aa01cd30d1595d972e0295e750975c531fe1e61c
# Parent  af764baf74a1dd0e0b863a8cf26c25266bdcbc14
Bug 1692124 - Proof of concept - guess userContextId for externally opened urls

This isn't intended to land, but it shows a demo of opening the right URL based on
the userContextId of currently opened tabs with the same host.

Differential Revision: https://phabricator.services.mozilla.com/D154812

diff --git a/browser/base/content/browser.js b/browser/base/content/browser.js
--- a/browser/base/content/browser.js
+++ b/browser/base/content/browser.js
@@ -6044,6 +6044,9 @@ nsBrowserAccess.prototype = {
   ) {
     var browsingContext = null;
     var isExternal = !!(aFlags & Ci.nsIBrowserDOMWindow.OPEN_EXTERNAL);
+    var openingUserContextId =
+      (isExternal && guessUserContextId(aURI)) ||
+      Ci.nsIScriptSecurityManager.DEFAULT_USER_CONTEXT_ID;
 
     if (aOpenWindowInfo && isExternal) {
       console.error(
@@ -6149,7 +6152,7 @@ nsBrowserAccess.prototype = {
         let forceNotRemote = aOpenWindowInfo && !aOpenWindowInfo.isRemote;
         let userContextId = aOpenWindowInfo
           ? aOpenWindowInfo.originAttributes.userContextId
-          : Ci.nsIScriptSecurityManager.DEFAULT_USER_CONTEXT_ID;
+          : openingUserContextId;
         let browser = this._openURIInNewTab(
           aURI,
           referrerInfo,
@@ -7014,6 +7017,51 @@ function handleLinkClick(event, href, li
   return true;
 }
 
+// Given a URI, guess which container to use to open it. This is used for external
+// openers as a quality of life improvement (e.g. to open a document into the container
+// where you are logged in to the service that hosts it).
+// For now this can only query open windows, until history is tagged with the container
+// id (https://bugzilla.mozilla.org/show_bug.cgi?id=1283320).
+function guessUserContextId(aURI) {
+  let tabs = [];
+  for (let win of BrowserWindowTracker.orderedWindows) {
+    for (let tab of win.gBrowser.visibleTabs) {
+      // Todo - just filter and count here rather than building up the data
+      // structure and looping again
+      tabs.push({
+        currentURI: tab.linkedBrowser.currentURI,
+        userContextId: tab.userContextId,
+      });
+    }
+  }
+  let matchingContainers = new Map();
+  for (let { currentURI, userContextId } of tabs) {
+    let currentURIHost = null;
+    try {
+      currentURIHost = currentURI.host;
+    } catch (e) {}
+    if (currentURIHost == aURI.host) {
+      if (!matchingContainers.has(userContextId)) {
+        matchingContainers.set(userContextId, 0);
+      }
+      matchingContainers.set(
+        userContextId,
+        matchingContainers.get(userContextId) + 1
+      );
+    }
+  }
+
+  let guessedUserContextId = null;
+  let maxCount = 0;
+  for (let [userContextId, count] of matchingContainers.entries()) {
+    if (count > maxCount) {
+      guessedUserContextId = userContextId;
+      maxCount = count;
+    }
+  }
+  return guessedUserContextId;
+}
+
 /**
  * Handles paste on middle mouse clicks.
  *
diff --git a/browser/components/contextualidentity/test/browser/browser.toml b/browser/components/contextualidentity/test/browser/browser.toml
--- a/browser/components/contextualidentity/test/browser/browser.toml
+++ b/browser/components/contextualidentity/test/browser/browser.toml
@@ -38,6 +38,8 @@ skip-if = ["true"] # Bug 1541885
 ["browser_imageCache.js"]
 skip-if = ["verify && debug && os == 'win'"]
 
+["browser_guessusercontext.js"]
+
 ["browser_middleClick.js"]
 skip-if = [
   "verify && debug && os == 'linux'",
diff --git a/browser/components/contextualidentity/test/browser/browser_guessusercontext.js b/browser/components/contextualidentity/test/browser/browser_guessusercontext.js
new file mode 100644
--- /dev/null
+++ b/browser/components/contextualidentity/test/browser/browser_guessusercontext.js
@@ -0,0 +1,102 @@
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// add_task(async function test_TODO() {
+//   ok(true, "TODO: implement the test");
+// });
+
+const USER_CONTEXT_PERSONAL = "personal";
+const USER_CONTEXT_WORK = "work";
+
+const HOST_MOCHI_URI =
+  "http://mochi.test:8888/browser/browser/components/contextualidentity/test/browser/blank.html";
+const HOST_EXAMPLE_URI =
+  "http://example.com/browser/browser/components/contextualidentity/test/browser/blank.html";
+
+// opens `uri' in a new tab with the provided userContextId and focuses it.
+// returns the newly opened tab
+function openTabInUserContext(uri, userContextId) {
+  // open the tab in the correct userContextId
+  let tab = BrowserTestUtils.addTab(gBrowser, uri, { userContextId });
+
+  // select tab and make sure its browser is focused
+  gBrowser.selectedTab = tab;
+  tab.ownerGlobal.focus();
+
+  return tab;
+}
+
+add_setup(async function () {
+  // make sure userContext is enabled.
+  await SpecialPowers.pushPrefEnv({
+    set: [
+      ["privacy.userContext.enabled", true],
+      ["dom.ipc.processCount", 1],
+    ],
+  });
+});
+
+add_task(async function test() {
+  openTabInUserContext(HOST_EXAMPLE_URI, USER_CONTEXT_PERSONAL);
+  openTabInUserContext(HOST_EXAMPLE_URI, USER_CONTEXT_WORK);
+  await new Promise(r=>r);
+
+  // // wait for tab load
+  // await BrowserTestUtils.browserLoaded(gBrowser.getBrowserForTab(tab));
+  // for (let userContextId of Object.keys(USER_CONTEXTS)) {
+  //   // load the page in 3 different contexts and set a cookie
+  //   // which should only be visible in that context
+  //   let cookie = USER_CONTEXTS[userContextId];
+
+  //   // open our tab in the given user context
+  //   let tab = openTabInUserContext(
+  //     HOST_EXAMPLE_URI + "?" + cookie,
+  //     userContextId
+  //   );
+
+  //   // wait for tab load
+  //   await BrowserTestUtils.browserLoaded(gBrowser.getBrowserForTab(tab));
+  // }
+
+  // {
+  //   // Set a cookie in a different context so we can detect if that affects
+  //   // cross-context properly. If we don't do that, we get an UNEXPECTED-PASS
+  //   // for the localStorage case for the last tab we set.
+  //   let tab = openTabInUserContext(BASE_URI + "?foo", 9999);
+  //   await BrowserTestUtils.browserLoaded(gBrowser.getBrowserForTab(tab));
+  //   gBrowser.removeTab(tab);
+  // }
+
+  // for (let userContextId of Object.keys(USER_CONTEXTS)) {
+  //   // Load the page without setting the cookie this time
+  //   let expectedContext = USER_CONTEXTS[userContextId];
+
+  //   let tab = openTabInUserContext(BASE_URI, userContextId);
+
+  //   // wait for load
+  //   let browser = gBrowser.getBrowserForTab(tab);
+  //   await BrowserTestUtils.browserLoaded(browser);
+
+  //   // get the title
+  //   let title = browser.contentTitle.trim().split("|");
+
+  //   // check each item in the title and validate it meets expectatations
+  //   for (let part of title) {
+  //     let [storageMethodName, value] = part.split("=");
+  //     is(
+  //       value,
+  //       expectedContext,
+  //       "the title reflects the expected contextual identity of " +
+  //         expectedContext +
+  //         " for method " +
+  //         storageMethodName +
+  //         ": " +
+  //         value
+  //     );
+  //   }
+
+  //   gBrowser.removeTab(tab);
+  // }
+});
