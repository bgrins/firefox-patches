# HG changeset patch
# User Patrick Brosset <pbrosset@mozilla.com>
# Date 1426001337 -3600
#      Tue Mar 10 16:28:57 2015 +0100
# Node ID 109af3779a362e592e20478c40669345202c0e9b
# Parent  95407a27036794d0cd9e83011f3b2dffc007da21
Bug 1139186 - 1 - Refactor to the native anon nodes manipulation in highlighters; r=bgrins

diff --git a/browser/devtools/commandline/test/browser.ini b/browser/devtools/commandline/test/browser.ini
--- a/browser/devtools/commandline/test/browser.ini
+++ b/browser/devtools/commandline/test/browser.ini
@@ -49,16 +49,17 @@ support-files =
  browser_cmd_csscoverage_page3.html
  browser_cmd_csscoverage_sheetA.css
  browser_cmd_csscoverage_sheetB.css
  browser_cmd_csscoverage_sheetC.css
  browser_cmd_csscoverage_sheetD.css
 [browser_cmd_folder.js]
 [browser_cmd_highlight_01.js]
 [browser_cmd_highlight_02.js]
+[browser_cmd_highlight_03.js]
 [browser_cmd_inject.js]
 support-files =
  browser_cmd_inject.html
 [browser_cmd_csscoverage_util.js]
 [browser_cmd_jsb.js]
 support-files =
   browser_cmd_jsb_script.jsi
 [browser_cmd_media.js]
diff --git a/browser/devtools/commandline/test/browser_cmd_highlight_01.js b/browser/devtools/commandline/test/browser_cmd_highlight_01.js
--- a/browser/devtools/commandline/test/browser_cmd_highlight_01.js
+++ b/browser/devtools/commandline/test/browser_cmd_highlight_01.js
@@ -5,17 +5,19 @@
 
 // Tests the various highlight command parameters and options
 
 // Creating a test page with many elements to test the --showall option
 let TEST_PAGE = "data:text/html;charset=utf-8,<body><ul>";
 for (let i = 0; i < 200; i ++) {
   TEST_PAGE += "<li class='item'>" + i + "</li>";
 }
-TEST_PAGE += "</ul></body>";
+TEST_PAGE += "</ul>";
+TEST_PAGE += "<div style='position:absolute;top:0;right:0;width:100px;height:100px;'></div>";
+TEST_PAGE += "</body>";
 
 function test() {
   return Task.spawn(spawnTest).then(finish, helpers.handleError);
 }
 
 function* spawnTest() {
   let options = yield helpers.openTab(TEST_PAGE);
   yield helpers.openToolbar(options);
@@ -202,17 +204,17 @@ function* spawnTest() {
       }
     },
     {
       setup: 'highlight body --hideguides --showinfobar --showall --region ' +
         'content --fill red --keep',
       check: {
         input:  'highlight body --hideguides --showinfobar --showall --region ' +
           'content --fill red --keep',
-        hints: '',
+        hints:                      ' [options]',
         markup: 'VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV' +
           'VVVVVVVVVVVVVVVVVVVVVVVVV',
         status: 'VALID'
       },
       exec: {
         output: '1 node highlighted'
       }
     },
@@ -237,16 +239,43 @@ function* spawnTest() {
         markup: 'VVVVVVVVVVVVVVVVVVVVVVVVV',
         status: 'VALID'
       },
       exec: {
         output: '200 nodes highlighted'
       }
     },
     {
+      setup: 'highlight div --geometry',
+      check: {
+        input:  'highlight div --geometry',
+        hints:                           ' [options]',
+        markup: 'VVVVVVVVVVVVVVVVVVVVVVVV',
+        status: 'VALID'
+      },
+      exec: {
+        output: '1 node highlighted'
+      }
+    },
+    {
+      setup: 'highlight body --hideguides --showinfobar --showall --region ' +
+        'content --fill red --keep --geometry',
+      check: {
+        input:  'highlight body --hideguides --showinfobar --showall --region ' +
+          'content --fill red --keep --geometry',
+        hints: '',
+        markup: 'VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV' +
+          'VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV',
+        status: 'VALID'
+      },
+      exec: {
+        output: '1 node highlighted'
+      }
+    },
+    {
       setup: 'unhighlight',
       check: {
         input:  'unhighlight',
         hints:  '',
         markup: 'VVVVVVVVVVV',
         status: 'VALID'
       }
     }
diff --git a/browser/devtools/commandline/test/browser_cmd_highlight_03.js b/browser/devtools/commandline/test/browser_cmd_highlight_03.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/commandline/test/browser_cmd_highlight_03.js
@@ -0,0 +1,45 @@
+/* Any copyright is dedicated to the Public Domain.
+ * http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Tests that the highlight command with the --geometry option creates a
+// GeometryEditorHighlighter highlighter.
+
+const TEST_PAGE = "data:text/html;charset=utf-8," +
+                  "<div style='background:red;position:absolute;top:50px;left:50px;width:50px;height:50px;'></div>";
+
+function test() {
+  return Task.spawn(function*() {
+    let options = yield helpers.openTab(TEST_PAGE);
+    yield helpers.openToolbar(options);
+
+    info("highlight the geometry of the DIV node");
+    yield runCommand("highlight div --geometry", options);
+
+    let highlighters = getHighlighters();
+    is(highlighters.length, 1, "The highlighter element exists for div");
+    ok(highlighters[0].ID_CLASS_PREFIX.indexOf("geometry") !== -1,
+      "The right highlighter type was used");
+
+    info("highlight the DIV node again without the geometry argument");
+    yield runCommand("highlight div", options);
+
+    highlighters = getHighlighters();
+    ok(highlighters[0].ID_CLASS_PREFIX.indexOf("box-model") !== -1,
+      "The right highlighter type was used");
+
+    yield helpers.closeToolbar(options);
+    yield helpers.closeTab(options);
+  }).then(finish, helpers.handleError);
+}
+
+function getHighlighters() {
+  // Note that this only works as long as gcli tests aren't run with e10s on.
+  // To make this e10s ready, execute this in a content frame script instead.
+  return require("gcli/commands/highlight").highlighters;
+}
+
+function* runCommand(cmd, options) {
+  yield helpers.audit(options, [{ setup: cmd, exec: {} }]);
+}
diff --git a/browser/devtools/inspector/test/browser.ini b/browser/devtools/inspector/test/browser.ini
--- a/browser/devtools/inspector/test/browser.ini
+++ b/browser/devtools/inspector/test/browser.ini
@@ -43,16 +43,19 @@ skip-if = e10s # GCLI isn't e10s compati
 [browser_inspector_highlighter-comments.js]
 [browser_inspector_highlighter-csstransform_01.js]
 [browser_inspector_highlighter-csstransform_02.js]
 [browser_inspector_highlighter-geometry_01.js]
 [browser_inspector_highlighter-geometry_02.js]
 [browser_inspector_highlighter-geometry_03.js]
 [browser_inspector_highlighter-geometry_04.js]
 [browser_inspector_highlighter-geometry_05.js]
+[browser_inspector_highlighter-geometry_06.js]
+[browser_inspector_highlighter-geometry_07.js]
+[browser_inspector_highlighter-geometry_08.js]
 [browser_inspector_highlighter-hover_01.js]
 [browser_inspector_highlighter-hover_02.js]
 [browser_inspector_highlighter-hover_03.js]
 [browser_inspector_highlighter-iframes.js]
 [browser_inspector_highlighter-keybinding_01.js]
 [browser_inspector_highlighter-keybinding_02.js]
 [browser_inspector_highlighter-keybinding_03.js]
 [browser_inspector_highlighter-options.js]
diff --git a/browser/devtools/inspector/test/browser_inspector_highlighter-geometry_06.js b/browser/devtools/inspector/test/browser_inspector_highlighter-geometry_06.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/inspector/test/browser_inspector_highlighter-geometry_06.js
@@ -0,0 +1,107 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+// Test that elements positioned with at least one of top, right, bottom, left
+// can be moved in content by drag/dropping with the GeometryEditorHighlighter.
+
+const TEST_URL = TEST_URL_ROOT + "doc_inspector_highlighter-geometry_01.html";
+const ID = "geometry-editor-";
+
+const TEST_DATA = [{
+  desc: "Moving a top/left absolute positioned element along x and y",
+  selector: "#absolute-container",
+  arrowsBefore: {
+   "top": {x1: 651, y1: 0, x2: 651, y2: 50},
+   "left": {x1: 0, y1: 251, x2: 400, y2: 251}
+  },
+  dragFrom: {x:410, y:60},
+  dragTo: {x:510, y:110},
+  arrowsAfter: {
+   "top": {x1: 751, y1: 0, x2: 751, y2: 100},
+   "left": {x1: 0, y1: 301, x2: 500, y2: 301}
+  }
+}, {
+  desc: "Moving a top/bottom absolute positioned element should only move along y",
+  selector: ".absolute-top-bottom",
+  arrowsBefore: {
+   "top": {x1: 546, y1: 101, x2: 546, y2: 321},
+   "bottom": {x1: 546, y1: 501, x2: 546, y2: 471}
+  },
+  dragFrom: {x:510, y:330},
+  dragTo: {x:600, y:360},
+  arrowsAfter: {
+   "top": {x1: 546, y1: 101, x2: 546, y2: 351},
+   "bottom": {x1: 546, y1: 501, x2: 546, y2: 501}
+  }
+}, {
+  desc: "Moving a right absolute positioned element should only move along x",
+  selector: ".absolute-right",
+  arrowsBefore: {
+   "right": {x1: 1001, y1: 188, x2: 951, y2: 188}
+  },
+  dragFrom: {x:930, y:230},
+  dragTo: {x:530, y:500},
+  arrowsAfter: {
+   "right": {x1: 1001, y1: 188, x2: 551, y2: 188}
+  }
+}];
+
+add_task(function*() {
+  let {inspector, toolbox} = yield openInspectorForURL(TEST_URL);
+  let front = inspector.inspector;
+  let highlighter = yield front.getHighlighterByType("GeometryEditorHighlighter");
+
+  for (let data of TEST_DATA) {
+    info("Running test case: " + data.desc);
+
+    info("Highlighting the test node " + data.selector);
+    let node = yield getNodeFront(data.selector, inspector);
+    yield highlighter.show(node);
+
+    info("Checking the arrow coordinates before dragging");
+    yield checkArrows(highlighter, data.arrowsBefore);
+
+    info("Moving the node by dragging the highlighter");
+    yield dragDrop(highlighter, data.dragFrom, data.dragTo);
+
+    info("Checking the new arrow coordinates");
+    yield checkArrows(highlighter, data.arrowsAfter);
+
+    info("Hiding the highlighter");
+    yield highlighter.hide();
+  }
+
+  yield highlighter.finalize();
+});
+
+function* dragDrop(highlighter, from, to) {
+  info("Simulating drag and drop from " +
+    from.x + "/" + from.y + " to " + to.x + "/" + to.y);
+
+  yield executeInContent("Test:SynthesizeMouse",
+    {x: from.x, y: from.y, options: {type: "mousedown"}});
+  let onUpdated = waitForHighlighterEvent("updated", highlighter);
+  yield executeInContent("Test:SynthesizeMouse",
+    {x: to.x, y: to.y, options: {type: "mousemove"}});
+  yield executeInContent("Test:SynthesizeMouse",
+    {x: to.x, y: to.y, options: {type: "mouseup"}});
+
+  yield onUpdated;
+}
+
+function* checkArrows(highlighter, arrows) {
+  for (let side in arrows) {
+    yield checkArrow(highlighter, side, arrows[side]);
+  }
+}
+
+function* checkArrow(highlighter, name, expectedCoordinates) {
+  for (let coordinate in expectedCoordinates) {
+    let value = yield getHighlighterNodeAttribute(highlighter, ID + "arrow-" + name, coordinate);
+    is(Math.floor(value), expectedCoordinates[coordinate],
+      coordinate + " coordinate for arrow " + name + " is correct");
+  }
+}
diff --git a/browser/devtools/inspector/test/browser_inspector_highlighter-geometry_07.js b/browser/devtools/inspector/test/browser_inspector_highlighter-geometry_07.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/inspector/test/browser_inspector_highlighter-geometry_07.js
@@ -0,0 +1,80 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+// Test that when DOM elements change, the highlighter changes too.
+
+const TEST_URL = TEST_URL_ROOT + "doc_inspector_highlighter-geometry_01.html";
+const ID = "geometry-editor-";
+
+add_task(function*() {
+  let {inspector, toolbox} = yield openInspectorForURL(TEST_URL);
+  let front = inspector.inspector;
+
+  info("Getting the test node");
+  let node = yield getNodeFront("#absolute-container", inspector);
+
+  info("Highlighting the node");
+  let highlighter = yield front.getHighlighterByType("GeometryEditorHighlighter");
+  yield highlighter.show(node);
+
+  info("Checking the arrow coordinates before updating the node");
+  yield checkArrows(highlighter, {
+   "top": {x1: 651, y1: 0, x2: 651, y2: 50},
+   "left": {x1: 0, y1: 251, x2: 400, y2: 251},
+  });
+
+  info("Modifying the node's top and left positions");
+  yield setHighlightedNodeStyle(highlighter, "top: 100px; left: 300px;");
+
+  info("Checking the arrow coordinates now that the node has changed");
+  yield checkArrows(highlighter, {
+   "top": {x1: 551, y1: 0, x2: 551, y2: 100},
+   "left": {x1: 0, y1: 301, x2: 300, y2: 301},
+  });
+
+  info("Checking the size label before changing the node's size");
+  yield checkSizeLabel(highlighter, "500px", "400px");
+
+  info("Modifying the node's width and height");
+  yield setHighlightedNodeStyle(highlighter,
+    "top: 100px; left: 300px; width: 100px; height: 200px;");
+
+  info("Checking the size label now that the node's size has changed");
+  yield checkSizeLabel(highlighter, "100px", "200px");
+
+  info("Hiding the highlighter");
+  yield highlighter.hide();
+  yield highlighter.finalize();
+});
+
+function* checkSizeLabel(highlighter, width, height) {
+  let str = yield getHighlighterNodeTextContent(highlighter, ID + "label-text-size");
+  ok(str.contains(width) && str.contains(height), "The size label string is correct");
+}
+
+function* checkArrows(highlighter, arrows) {
+  for (let side in arrows) {
+    yield checkArrow(highlighter, side, arrows[side]);
+  }
+}
+
+function* checkArrow(highlighter, name, expectedCoordinates) {
+  for (let coordinate in expectedCoordinates) {
+    let value = yield getHighlighterNodeAttribute(highlighter, ID + "arrow-" + name, coordinate);
+    is(Math.floor(value), expectedCoordinates[coordinate],
+      coordinate + " coordinate for arrow " + name + " is correct");
+  }
+}
+
+function* setHighlightedNodeStyle(highlighter, style) {
+  let {actorID, connPrefix} = getHighlighterActorID(highlighter);
+  yield executeInContent("Test:ChangeHighlightedNodeWaitForUpdate", {
+    name: "style",
+    value: style,
+    actorID,
+    connPrefix
+  });
+}
diff --git a/browser/devtools/inspector/test/browser_inspector_highlighter-geometry_08.js b/browser/devtools/inspector/test/browser_inspector_highlighter-geometry_08.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/inspector/test/browser_inspector_highlighter-geometry_08.js
@@ -0,0 +1,101 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+// Test that elements with at least one of width or height can be resized in
+// content by dragging the resize handle of the GeometryEditorHighlighter.
+
+const TEST_URL = TEST_URL_ROOT + "doc_inspector_highlighter-geometry_01.html";
+const ID = "geometry-editor-";
+
+const TEST_DATA = [{
+  desc: "Change width of a fixed element",
+  selector: ".fixed",
+  sizeBefore: {
+   "width": "50px",
+   "height": "50px"
+  },
+  dragFrom: {x:50, y:450},
+  dragTo: {x:75, y:450},
+  sizeAfter: {
+   "width": "75px",
+   "height": "50px"
+  }
+}, {
+  desc: "Change both width and height of an element",
+  selector: "#node1",
+  sizeBefore: {
+   "width": "300px",
+   "height": "300px"
+  },
+  dragFrom: {x:304, y:304},
+  dragTo: {x:354, y:404},
+  sizeAfter: {
+   "width": "350px",
+   "height": "400px"
+  }
+}, {
+  desc: "Change the height only of an element, even when moving along both axis",
+  selector: ".relative",
+  sizeBefore: "10px",
+  dragFrom: {x:1150, y:100},
+  dragTo: {x:900, y:190},
+  sizeAfter: "100px"
+}];
+
+add_task(function*() {
+  let {inspector, toolbox} = yield openInspectorForURL(TEST_URL);
+  let front = inspector.inspector;
+
+  for (let data of TEST_DATA) {
+    info("Running test case: " + data.desc);
+
+    info("Highlighting the test node " + data.selector);
+    let highlighter = yield front.getHighlighterByType("GeometryEditorHighlighter");
+    let node = yield getNodeFront(data.selector, inspector);
+    yield highlighter.show(node);
+
+    info("Checking the size label before dragging");
+    yield checkSize(highlighter, data.sizeBefore);
+
+    info("Resizing the node by dragging the handle");
+    yield dragDrop(highlighter, data.dragFrom, data.dragTo);
+
+    info("Checking the new arrow coordinates");
+    yield checkSize(highlighter, data.sizeAfter);
+
+    info("Hiding the highlighter");
+    yield highlighter.hide();
+    yield highlighter.finalize();
+  }
+});
+
+function* dragDrop(highlighter, from, to) {
+  info("Simulating drag and drop from " +
+    from.x + "/" + from.y + " to " + to.x + "/" + to.y);
+
+  yield executeInContent("Test:SynthesizeMouse",
+    {x: from.x, y: from.y, options: {type: "mousedown"}});
+  let onUpdated = waitForHighlighterEvent("updated", highlighter);
+  yield executeInContent("Test:SynthesizeMouse",
+    {x: to.x, y: to.y, options: {type: "mousemove"}});
+  yield executeInContent("Test:SynthesizeMouse",
+    {x: to.x, y: to.y, options: {type: "mouseup"}});
+
+  yield onUpdated;
+}
+
+function* checkSize(highlighter, sizes) {
+  let size = yield getHighlighterNodeTextContent(highlighter, ID + "label-text-size");
+  size = size.split(" ");
+  if (size.length === 4) {
+    let [,width,,height] = size;
+    is(width, sizes.width, "The size label contains the width " + sizes.width);
+    is(height, sizes.height, "The size label contains the height " + sizes.height);
+  } else if (size.length === 2) {
+    let [,dim] = size;
+    is(dim, sizes, "The size label contains the dimension " + sizes);
+  }
+}
diff --git a/browser/devtools/inspector/test/doc_frame_script.js b/browser/devtools/inspector/test/doc_frame_script.js
--- a/browser/devtools/inspector/test/doc_frame_script.js
+++ b/browser/devtools/inspector/test/doc_frame_script.js
@@ -248,20 +248,22 @@ addMessageListener("Test:GetAllAdjustedQ
 addMessageListener("Test:SynthesizeMouse", function(msg) {
   let {x, y, center, options, selector} = msg.data;
   let {node} = msg.objects;
 
   if (!node && selector) {
     node = content.document.querySelector(selector);
   }
 
-  if (center) {
+  if (center && node) {
     EventUtils.synthesizeMouseAtCenter(node, options, node.ownerDocument.defaultView);
+  } else if (node) {
+    EventUtils.synthesizeMouse(node, x, y, options, node.ownerDocument.defaultView);
   } else {
-    EventUtils.synthesizeMouse(node, x, y, options, node.ownerDocument.defaultView);
+    EventUtils.synthesizeMouseAtPoint(x, y, options, content);
   }
 
   // Most consumers won't need to listen to this message, unless they want to
   // wait for the mouse event to be synthesized and don't have another event
   // to listen to instead.
   sendAsyncMessage("Test:SynthesizeMouse");
 });
 
diff --git a/browser/devtools/inspector/test/doc_inspector_highlighter-geometry_01.html b/browser/devtools/inspector/test/doc_inspector_highlighter-geometry_01.html
--- a/browser/devtools/inspector/test/doc_inspector_highlighter-geometry_01.html
+++ b/browser/devtools/inspector/test/doc_inspector_highlighter-geometry_01.html
@@ -57,16 +57,33 @@
     .relative {
       position: relative;
       top: 10%;
       left: 50%;
       height: 10px;
       border: 1px solid blue;
     }
 
+    .absolute-top-bottom {
+      position: absolute;
+      top: 220px;
+      bottom: 30px;
+      width: 90px;
+      background: red;
+    }
+
+    .absolute-right {
+      position: absolute;
+      right: 50px;
+      width: 50px;
+      height: 50px;
+      background: green;
+      margin-top: 100px;
+    }
+
     .fixed {
       position: fixed;
       top: 400px;
       left: 0;
       width: 50px;
       height: 50px;
       border-radius: 50%;
       background: green;
@@ -78,13 +95,15 @@
     <div id="node2" class="positioned-child pos-top-left pos-bottom-right">
       <div id="node3" class="inline-positioned positioned-child pos-top-left" style="width:50px;height:50px;"></div>
     </div>
   </div>
 
   <div id="absolute-container">
     <div class="absolute-all-4"></div>
     <div class="relative"></div>
+    <div class="absolute-top-bottom"></div>
+    <div class="absolute-right"></div>
   </div>
 
   <div class="fixed"></div>
 </body>
 </html>
diff --git a/browser/locales/en-US/chrome/browser/devtools/gclicommands.properties b/browser/locales/en-US/chrome/browser/devtools/gclicommands.properties
--- a/browser/locales/en-US/chrome/browser/devtools/gclicommands.properties
+++ b/browser/locales/en-US/chrome/browser/devtools/gclicommands.properties
@@ -211,16 +211,26 @@ highlightFillManual=Override the default
 # dialog when the user is using this command.
 highlightKeepDesc=Keep existing highlighters
 
 # LOCALIZATION NOTE (highlightKeepManual) A fuller description of the 'keep'
 # option parameter to the 'highlight' command, displayed when the user asks for
 # help on what it does.
 highlightKeepManual=By default, existing highlighters are hidden when running the command, unless this option is set
 
+# LOCALIZATION NOTE (highlightGeometryDesc) A very short string to describe the
+# 'geometry' option parameter to the 'highlight' command, which is displayed in a
+# dialog when the user is using this command.
+highlightGeometryDesc=Show node's geometry
+
+# LOCALIZATION NOTE (highlightGeometryManual) A fuller description of the
+# 'geometry' option parameter to the 'highlight' command, displayed when the
+# user asks for help on what it does.
+highlightGeometryManual=Set this option to display the node's top, right, bottom, left, width and height CSS properties, if they are set
+
 # LOCALIZATION NOTE (highlightOutputConfirm) A confirmation message for the
 # 'highlight' command, displayed to the user once the command has been entered,
 # informing the user how many nodes have been highlighted successfully and how
 # to turn highlighting off
 highlightOutputConfirm2=%1$S node highlighted;%1$S nodes highlighted
 
 # LOCALIZATION NOTE (highlightOutputMaxReached) A confirmation message for the
 # 'highlight' command, displayed to the user once the command has been entered,
diff --git a/toolkit/devtools/LayoutHelpers.jsm b/toolkit/devtools/LayoutHelpers.jsm
--- a/toolkit/devtools/LayoutHelpers.jsm
+++ b/toolkit/devtools/LayoutHelpers.jsm
@@ -595,22 +595,23 @@ LayoutHelpers.isShadowAnonymous = functi
   return parent.shadowRoot && parent.shadowRoot.contains(node);
 };
 
 /**
  * Get the current zoom factor applied to the container window of a given node.
  * Container windows are used as a weakmap key to store the corresponding
  * nsIDOMWindowUtils instance to avoid querying it every time.
  *
- * @param {DOMNode} The node for which the zoom factor should be calculated
+ * @param {DOMNode|DOMWindow} The node for which the zoom factor should be
+ * calculated, or its owner window.
  * @return {Number}
  */
 let windowUtils = new WeakMap;
-LayoutHelpers.getCurrentZoom = function(node, map = z=>z) {
-  let win = node.ownerDocument.defaultView;
+LayoutHelpers.getCurrentZoom = function(node) {
+  let win = node.self === node ? node : node.ownerDocument.defaultView;
   let utils = windowUtils.get(win);
   if (utils) {
     return utils.fullZoom;
   }
 
   utils = win.QueryInterface(Ci.nsIInterfaceRequestor)
              .getInterface(Ci.nsIDOMWindowUtils);
   windowUtils.set(win, utils);
diff --git a/toolkit/devtools/gcli/commands/highlight.js b/toolkit/devtools/gcli/commands/highlight.js
--- a/toolkit/devtools/gcli/commands/highlight.js
+++ b/toolkit/devtools/gcli/commands/highlight.js
@@ -2,17 +2,18 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
 const {Cc, Ci, Cu} = require("chrome");
 const gcli = require("gcli/index");
 require("devtools/server/actors/inspector");
-const {BoxModelHighlighter} = require("devtools/server/actors/highlighter");
+const {BoxModelHighlighter,
+       GeometryEditorHighlighter} = require("devtools/server/actors/highlighter");
 
 XPCOMUtils.defineLazyGetter(this, "nodesSelected", function() {
   return Services.strings.createBundle("chrome://browser/locale/devtools/gclicommands.properties");
 });
 XPCOMUtils.defineLazyModuleGetter(this, "PluralForm","resource://gre/modules/PluralForm.jsm");
 
 // How many maximum nodes can be highlighted in parallel
 const MAX_HIGHLIGHTED_ELEMENTS = 100;
@@ -20,23 +21,35 @@ const MAX_HIGHLIGHTED_ELEMENTS = 100;
 // Stores the highlighters instances so they can be destroyed later.
 // also export them so tests can access those and assert they got created
 // correctly.
 exports.highlighters = [];
 
 /**
  * Destroy all existing highlighters
  */
-function unhighlightAll() {
+function destroyHighlighters() {
   for (let highlighter of exports.highlighters) {
     highlighter.destroy();
   }
   exports.highlighters.length = 0;
 }
 
+/**
+ * Get an object that looks like a TabActor for instantiating highlighters
+ */
+function getTabActorContext(env) {
+  let browser = env.chromeWindow.gBrowser.getBrowserForDocument(env.document);
+  return {
+    browser: browser,
+    window: env.window,
+    chromeEventHandler: browser.docShell.chromeEventHandler
+  };
+}
+
 exports.items = [
   {
     name: "highlight",
     description: gcli.lookup("highlightDesc"),
     manual: gcli.lookup("highlightManual"),
     params: [
       {
         name: "selector",
@@ -82,53 +95,59 @@ exports.items = [
             manual: gcli.lookup("highlightFillManual"),
             defaultValue: null
           },
           {
             name: "keep",
             type: "boolean",
             description: gcli.lookup("highlightKeepDesc"),
             manual: gcli.lookup("highlightKeepManual"),
+          },
+          {
+            name: "geometry",
+            type: "boolean",
+            description: gcli.lookup("highlightGeometryDesc"),
+            manual: gcli.lookup("highlightGeometryManual"),
           }
         ]
       }
     ],
     exec: function(args, context) {
       // Remove all existing highlighters unless told otherwise
       if (!args.keep) {
-        unhighlightAll();
+        destroyHighlighters();
       }
 
       let env = context.environment;
 
       // Unhighlight on navigate
-      env.target.once("navigate", unhighlightAll);
-
-      // Build a tab context for the highlighter (which normally takes a
-      // TabActor as parameter to its constructor)
-      let tabContext = {
-        browser: env.chromeWindow.gBrowser.getBrowserForDocument(env.document),
-        window: env.window
-      };
+      env.target.once("navigate", destroyHighlighters);
 
       let i = 0;
       for (let node of args.selector) {
         if (!args.showall && i >= MAX_HIGHLIGHTED_ELEMENTS) {
           break;
         }
 
-        let highlighter = new BoxModelHighlighter(tabContext);
-        if (args.fill) {
+        let highlighter;
+        if (args.geometry) {
+          highlighter = new GeometryEditorHighlighter(getTabActorContext(env));
+        } else {
+          highlighter = new BoxModelHighlighter(getTabActorContext(env));
+        }
+
+        if (args.fill && highlighter.regionFill) {
           highlighter.regionFill[args.region] = args.fill;
         }
         highlighter.show(node, {
           region: args.region,
           hideInfoBar: !args.showinfobar,
           hideGuides: args.hideguides,
-          showOnly: args.region
+          showOnly: args.region,
+          hideOffsetParent: true
         });
         exports.highlighters.push(highlighter);
         i ++;
       }
 
       let highlightText = nodesSelected.GetStringFromName("highlightOutputConfirm2");
       let output = PluralForm.get(args.selector.length, highlightText)
                              .replace("%1$S", args.selector.length);
@@ -139,11 +158,13 @@ exports.items = [
 
       return output;
     }
   },
   {
     name: "unhighlight",
     description: gcli.lookup("unhighlightDesc"),
     manual: gcli.lookup("unhighlightManual"),
-    exec: unhighlightAll
+    exec: () => {
+      destroyHighlighters();
+    }
   }
 ];
diff --git a/toolkit/devtools/server/actors/highlighter.css b/toolkit/devtools/server/actors/highlighter.css
--- a/toolkit/devtools/server/actors/highlighter.css
+++ b/toolkit/devtools/server/actors/highlighter.css
@@ -9,20 +9,25 @@
   This stylesheet is loaded as a ua stylesheet via the addon sdk, so having this
   pseudo-class is important.
   Having bug 1086532 fixed would make it possible to load this stylesheet in a
   <style scoped> node instead, directly in the native anonymous container
   element.
 */
 
 :-moz-native-anonymous .highlighter-container {
-  pointer-events: none;
   position: absolute;
   width: 100%;
   height: 100%;
+  /* The container for all highlighters doesn't react to pointer-events by
+     default. This is because most highlighters cover the whole viewport but
+     don't contain UIs that need to be accessed.
+     If your highlighter has UI that needs to be interacted with, add
+     'pointer-events:auto;' on its container element. */
+  pointer-events: none;
 }
 
 :-moz-native-anonymous .highlighter-container [hidden] {
   display: none;
 }
 
 /* Box model highlighter */
 
@@ -176,39 +181,62 @@
 :-moz-native-anonymous .highlighted-rect {
   position: absolute;
   background: #80d4ff;
   opacity: 0.8;
 }
 
 /* Element geometry highlighter */
 
+:-moz-native-anonymous .geometry-editor-root {
+  /* The geometry editor can be interacted with, so it needs to react to
+     pointer events */
+  pointer-events: auto;
+}
+
+:-moz-native-anonymous .geometry-editor-root[moving] {
+  cursor: move;
+}
+
 :-moz-native-anonymous .geometry-editor-offset-parent {
   stroke: #08c;
   shape-rendering: crispEdges;
   stroke-dasharray: 5 3;
   fill: transparent;
 }
 
 :-moz-native-anonymous .geometry-editor-current-node {
   stroke: #08c;
   shape-rendering: crispEdges;
   fill: #87ceeb;
   opacity: 0.6;
 }
 
+:-moz-native-anonymous .geometry-editor-current-node.movable {
+  cursor: move;
+}
+
 :-moz-native-anonymous .geometry-editor-arrow {
   stroke: #08c;
   shape-rendering: crispEdges;
 }
 
 :-moz-native-anonymous .geometry-editor-label-bubble {
   fill: hsl(214,13%,24%);
   shape-rendering: crispEdges;
 }
 
 :-moz-native-anonymous .geometry-editor-label-text {
   fill: hsl(216,33%,97%);
   font: message-box;
   font-size: 10px;
   text-anchor: middle;
   dominant-baseline: middle;
+  -moz-user-select: none;
 }
+
+:-moz-native-anonymous .geometry-editor-handle {
+  stroke: #08c;
+  fill: white;
+  shape-rendering: crispEdges;
+  opacity: 0.6;
+  cursor: move;
+}
diff --git a/toolkit/devtools/server/actors/highlighter.js b/toolkit/devtools/server/actors/highlighter.js
--- a/toolkit/devtools/server/actors/highlighter.js
+++ b/toolkit/devtools/server/actors/highlighter.js
@@ -120,16 +120,17 @@ let HighlighterActor = exports.Highlight
     this._inspector = inspector;
     this._walker = this._inspector.walker;
     this._tabActor = this._inspector.tabActor;
 
     this._highlighterReady = this._highlighterReady.bind(this);
     this._highlighterHidden = this._highlighterHidden.bind(this);
     this._onNavigate = this._onNavigate.bind(this);
 
+    this._layoutHelpers = new LayoutHelpers(this._tabActor.window);
     this._createHighlighter();
 
     // Listen to navigation events to switch from the BoxModelHighlighter to the
     // SimpleOutlineHighlighter, and back, if the top level window changes.
     events.on(this._tabActor, "navigate", this._onNavigate);
   },
 
   get conn() this._inspector && this._inspector.conn,
@@ -174,16 +175,17 @@ let HighlighterActor = exports.Highlight
     protocol.Actor.prototype.destroy.call(this);
 
     this._destroyHighlighter();
     events.off(this._tabActor, "navigate", this._onNavigate);
     this._autohide = null;
     this._inspector = null;
     this._walker = null;
     this._tabActor = null;
+    this._layoutHelpers = null;
   },
 
   /**
    * Display the box model highlighting on a given NodeActor.
    * There is only one instance of the box model highlighter, so calling this
    * method several times won't display several highlighters, it will just move
    * the highlighter instance to these nodes.
    *
@@ -328,22 +330,23 @@ let HighlighterActor = exports.Highlight
 
     this._tabActor.window.focus();
     this._startPickerListeners();
 
     return null;
   }),
 
   _findAndAttachElement: function(event) {
-    let doc = event.target.ownerDocument;
-
     let x = event.clientX;
     let y = event.clientY;
 
-    let node = doc.elementFromPoint(x, y);
+    // Search for the node using elementFromPoint starting from the root window
+    // and going into nested iframes if needed.
+    let node = this._layoutHelpers.getElementFromPoint(
+      this._tabActor.window.document, x, y);
     return this._walker.attachElement(node);
   },
 
   _startPickerListeners: function() {
     let target = getPageListenerTarget(this._tabActor);
     target.addEventListener("mousemove", this._onHovered, true);
     target.addEventListener("click", this._onPick, true);
     target.addEventListener("mousedown", this._preventContentEvent, true);
@@ -507,30 +510,36 @@ function CanvasFrameAnonymousContentHelp
   this.anonymousContentDocument = this.tabActor.window.document;
   // XXX the next line is a wallpaper for bug 1123362.
   this.anonymousContentGlobal = Cu.getGlobalForObject(this.anonymousContentDocument);
 
   this._insert();
 
   this._onNavigate = this._onNavigate.bind(this);
   events.on(this.tabActor, "navigate", this._onNavigate);
+
+  this.listeners = new Map();
 }
 
+exports.CanvasFrameAnonymousContentHelper = CanvasFrameAnonymousContentHelper;
+
 CanvasFrameAnonymousContentHelper.prototype = {
   destroy: function() {
     // If the current window isn't the one the content was inserted into, this
     // will fail, but that's fine.
     try {
       let doc = this.anonymousContentDocument;
       doc.removeAnonymousContent(this._content);
     } catch (e) {}
     events.off(this.tabActor, "navigate", this._onNavigate);
     this.tabActor = this.nodeBuilder = this._content = null;
     this.anonymousContentDocument = null;
     this.anonymousContentGlobal = null;
+
+    this._removeAllListeners();
   },
 
   _insert: function() {
     // Re-insert the content node after page navigation only if the new page
     // isn't XUL.
     if (isXUL(this.tabActor)) {
       return;
     }
@@ -557,17 +566,19 @@ CanvasFrameAnonymousContentHelper.protot
     installHelperSheet(this.tabActor.window,
       "@import url('" + HIGHLIGHTER_STYLESHEET_URI + "');");
     let node = this.nodeBuilder();
     this._content = doc.insertAnonymousContent(node);
   },
 
   _onNavigate: function({isTopLevel}) {
     if (isTopLevel) {
+      this._removeAllListeners();
       this._insert();
+      this.anonymousContentDocument = this.tabActor.window.document;
     }
   },
 
   getTextContentForElement: function(id) {
     if (!this.content) {
       return null;
     }
     return this.content.getTextContentForElement(id);
@@ -593,24 +604,132 @@ CanvasFrameAnonymousContentHelper.protot
   },
 
   removeAttributeForElement: function(id, name) {
     if (this.content) {
       this.content.removeAttributeForElement(id, name);
     }
   },
 
+  /**
+   * Add an event listener to one of the elements inserted in the canvasFrame
+   * native anonymous container.
+   * Like other methods in this helper, this requires the ID of the element to
+   * be passed in.
+   *
+   * Note that if the content page navigates, the event listeners won't be
+   * added again.
+   *
+   * Also note that unlike traditional DOM events, the events handled by
+   * listeners added here will *not* propagate through the document (neither
+   * capture nor bubble). This means that when adding a listener on a parent and
+   * one on one of its children, only the child handler will be executed.
+   *
+   * A single event listener is added per event types only, at the browser level
+   * and if the event originalTarget is found to have the provided ID, the
+   * callback is executed.
+   *
+   * IMPORTANT: the chrome-only canvasFrame insertion API takes great care of
+   * not leaking references to inserted elements to chrome JS code. That's
+   * because otherwise, chrome JS code could freely modify native anon elements
+   * inside the canvasFrame and probably change things that are assumed not to
+   * change by the C++ code managing this frame.
+   * See https://wiki.mozilla.org/DevTools/Highlighter#The_AnonymousContent_API
+   * Unfortunately, the inserted nodes are still available via
+   * event.originalTarget, and that's what the event handler here uses to check
+   * that the event actually occured on the right element, but that also means
+   * consumers of this code would be able to access the inserted elements.
+   * Therefore, the originalTarget property will be nullified before the event
+   * is passed to your handler.
+   *
+   * @param {String} id
+   * @param {String} type
+   * @param {Function} handler
+   */
+  addNoPropagationEventListenerForElement: function(id, type, handler) {
+    // If noone is listening for this type of event yet, add one listener.
+    if (!this.listeners.has(type)) {
+      let target = getPageListenerTarget(this.tabActor);
+      target.addEventListener(type, this, true);
+      // Each type entry in the map is a map of ids:handlers.
+      this.listeners.set(type, new Map);
+    }
+
+    let listeners = this.listeners.get(type);
+    listeners.set(id, handler);
+  },
+
+  /**
+   * Remove an event listener from one of the elements inserted in the
+   * canvasFrame native anonymous container.
+   * @param {String} id
+   * @param {String} type
+   * @param {Function} handler
+   */
+  removeNoPropagationEventListenerForElement: function(id, type, handler) {
+    let listeners = this.listeners.get(type);
+    if (!listeners) {
+      return;
+    }
+    listeners.delete(id);
+
+    // If noone is listening for event type anymore, remove the listener.
+    if (!this.listeners.has(type)) {
+      let target = getPageListenerTarget(this.tabActor);
+      target.removeEventListener(type, this, true);
+    }
+  },
+
+  handleEvent: function(event) {
+    let listeners = this.listeners.get(event.type);
+    if (!listeners) {
+      return;
+    }
+
+    let targetID = event.originalTarget.id;
+
+    // Hide the originalTarget property to avoid exposing references to native
+    // anonymous elements. See addEventListenerForElement's comment.
+    var eventProxy = new Proxy(event, {
+      get: function(target, name) {
+        return name === "originalTarget" ? null : target[name];
+      }
+    });
+
+    for (let [id, handler] of listeners) {
+      if (targetID === id) {
+        handler(eventProxy, id);
+      }
+    }
+  },
+
+  _removeAllListeners: function() {
+    if (this.tabActor) {
+      let target = getPageListenerTarget(this.tabActor);
+      for (let [type] of this.listeners) {
+        target.removeEventListener(type, this, true);
+      }
+    }
+    this.listeners.clear();
+  },
+
   getElement: function(id) {
     let self = this;
     return {
       getTextContent: () => self.getTextContentForElement(id),
       setTextContent: text => self.setTextContentForElement(id, text),
       setAttribute: (name, value) => self.setAttributeForElement(id, name, value),
       getAttribute: name => self.getAttributeForElement(id, name),
-      removeAttribute: name => self.removeAttributeForElement(id, name)
+      removeAttribute: name => self.removeAttributeForElement(id, name),
+      addNoPropagationEventListener: (type, handler) => {
+        return self.addNoPropagationEventListenerForElement(id, type, handler);
+      },
+      removeNoPropagationEventListener: (type, handler) => {
+        return self.removeNoPropagationEventListenerForElement(id, type, handler);
+      }
     };
   },
 
   get content() {
     if (!this._content || Cu.isDeadWrapper(this._content)) {
       return null;
     }
     return this._content;
@@ -898,21 +1017,16 @@ function BoxModelHighlighter(tabActor) {
   this._currentNode = null;
 }
 
 BoxModelHighlighter.prototype = Heritage.extend(AutoRefreshHighlighter.prototype, {
   typeName: "BoxModelHighlighter",
 
   ID_CLASS_PREFIX: "box-model-",
 
-  get zoom() {
-    return this.win.QueryInterface(Ci.nsIInterfaceRequestor)
-               .getInterface(Ci.nsIDOMWindowUtils).fullZoom;
-  },
-
   get currentNode() {
     return this._currentNode;
   },
 
   set currentNode(node) {
     this._currentNode = node;
     this._computedStyle = null;
   },
@@ -937,17 +1051,16 @@ BoxModelHighlighter.prototype = Heritage
 
     let svg = createSVGNode(this.win, {
       nodeType: "svg",
       parent: rootWrapper,
       attributes: {
         "id": "elements",
         "width": "100%",
         "height": "100%",
-        "style": "width:100%;height:100%;",
         "hidden": "true"
       },
       prefix: this.ID_CLASS_PREFIX
     });
 
     let regions = createSVGNode(this.win, {
       nodeType: "g",
       parent: svg,
@@ -1065,16 +1178,20 @@ BoxModelHighlighter.prototype = Heritage
   destroy: function() {
     AutoRefreshHighlighter.prototype.destroy.call(this);
 
     this.markup.destroy();
 
     this._currentNode = null;
   },
 
+  getElement: function(id) {
+    return this.markup.getElement(this.ID_CLASS_PREFIX + id);
+  },
+
   /**
    * Show the highlighter on a given node
    */
   _show: function() {
     if (BOX_MODEL_REGIONS.indexOf(this.options.region) == -1)  {
       this.options.region = "content";
     }
 
@@ -1137,74 +1254,68 @@ BoxModelHighlighter.prototype = Heritage
 
     setIgnoreLayoutChanges(false, this.currentNode.ownerDocument.documentElement);
   },
 
   /**
    * Hide the infobar
    */
   _hideInfobar: function() {
-    this.markup.setAttributeForElement(
-      this.ID_CLASS_PREFIX + "nodeinfobar-container", "hidden", "true");
+    this.getElement("nodeinfobar-container").setAttribute("hidden", "true");
   },
 
   /**
    * Show the infobar
    */
   _showInfobar: function() {
-    this.markup.removeAttributeForElement(
-      this.ID_CLASS_PREFIX + "nodeinfobar-container", "hidden");
+    this.getElement("nodeinfobar-container").removeAttribute("hidden");
     this._updateInfobar();
   },
 
   /**
    * Hide the box model
    */
   _hideBoxModel: function() {
-    this.markup.setAttributeForElement(this.ID_CLASS_PREFIX + "elements",
-      "hidden", "true");
+    this.getElement("elements").setAttribute("hidden", "true");
   },
 
   /**
    * Show the box model
    */
   _showBoxModel: function() {
-    this.markup.removeAttributeForElement(this.ID_CLASS_PREFIX + "elements",
-      "hidden");
+    this.getElement("elements").removeAttribute("hidden");
   },
 
   /**
    * Update the box model as per the current node.
    *
    * @return {boolean}
    *         True if the current node has a box model to be highlighted
    */
   _updateBoxModel: function() {
     this.options.region = this.options.region || "content";
 
     if (this._nodeNeedsHighlighting()) {
       for (let boxType of BOX_MODEL_REGIONS) {
         let {p1, p2, p3, p4} = this.currentQuads[boxType];
+        let box = this.getElement(boxType);
 
         if (this.regionFill[boxType]) {
-          this.markup.setAttributeForElement(this.ID_CLASS_PREFIX + boxType,
-            "style", "fill:" + this.regionFill[boxType]);
+          box.setAttribute("style", "fill:" + this.regionFill[boxType]);
         } else {
-          this.markup.setAttributeForElement(this.ID_CLASS_PREFIX + boxType,
-            "style", "");
+          box.setAttribute("style", "");
         }
 
         if (!this.options.showOnly || this.options.showOnly === boxType) {
-          this.markup.setAttributeForElement(this.ID_CLASS_PREFIX + boxType,
-            "points", p1.x + "," + p1.y + " " +
-                      p2.x + "," + p2.y + " " +
-                      p3.x + "," + p3.y + " " +
-                      p4.x + "," + p4.y);
+          box.setAttribute("points", p1.x + "," + p1.y + " " +
+                                     p2.x + "," + p2.y + " " +
+                                     p3.x + "," + p3.y + " " +
+                                     p4.x + "," + p4.y);
         } else {
-          this.markup.removeAttributeForElement(this.ID_CLASS_PREFIX + boxType, "points");
+          box.removeAttribute("points");
         }
 
         if (boxType === this.options.region && !this.options.hideGuides) {
           this._showGuides(p1, p2, p3, p4);
         } else if (this.options.hideGuides) {
           this._hideGuides();
         }
       }
@@ -1303,59 +1414,58 @@ BoxModelHighlighter.prototype = Heritage
     this._updateGuide("top", toShowY[0]);
     this._updateGuide("right", toShowX[1]);
     this._updateGuide("bottom", toShowY[1]);
     this._updateGuide("left", toShowX[0]);
   },
 
   _hideGuides: function() {
     for (let side of BOX_MODEL_SIDES) {
-      this.markup.setAttributeForElement(
-        this.ID_CLASS_PREFIX + "guide-" + side, "hidden", "true");
+      this.getElement("guide-" + side).setAttribute("hidden", "true");
     }
   },
 
   /**
    * Move a guide to the appropriate position and display it. If no point is
    * passed then the guide is hidden.
    *
    * @param  {String} side
    *         The guide to update
    * @param  {Integer} point
    *         x or y co-ordinate. If this is undefined we hide the guide.
    */
   _updateGuide: function(side, point=-1) {
-    let guideId = this.ID_CLASS_PREFIX + "guide-" + side;
+    let guide = this.getElement("guide-" + side);
 
     if (point <= 0) {
-      this.markup.setAttributeForElement(guideId, "hidden", "true");
+      guide.setAttribute("hidden", "true");
       return false;
     }
 
     let offset = GUIDE_STROKE_WIDTH / 2;
 
     if (side === "top" || side === "left") {
       point -= offset;
     } else {
       point += offset;
     }
 
     if (side === "top" || side === "bottom") {
-      this.markup.setAttributeForElement(guideId, "x1", "0");
-      this.markup.setAttributeForElement(guideId, "y1", point + "");
-      this.markup.setAttributeForElement(guideId, "x2", "100%");
-      this.markup.setAttributeForElement(guideId, "y2", point + "");
+      guide.setAttribute("x1", "0");
+      guide.setAttribute("y1", point + "");
+      guide.setAttribute("x2", "100%");
+      guide.setAttribute("y2", point + "");
     } else {
-      this.markup.setAttributeForElement(guideId, "x1", point + "");
-      this.markup.setAttributeForElement(guideId, "y1", "0");
-      this.markup.setAttributeForElement(guideId, "x2", point + "");
-      this.markup.setAttributeForElement(guideId, "y2", "100%");
+      guide.setAttribute("x1", point + "");
+      guide.setAttribute("y1", "0");
+      guide.setAttribute("x2", point + "");
+      guide.setAttribute("y2", "100%");
     }
 
-    this.markup.removeAttributeForElement(guideId, "hidden");
+    guide.removeAttribute("hidden");
 
     return true;
   },
 
   /**
    * Update node information (tagName#id.class)
    */
   _updateInfobar: function() {
@@ -1379,75 +1489,74 @@ BoxModelHighlighter.prototype = Heritage
     if (pseudo) {
       // Display :after as ::after
       pseudos += ":" + pseudo;
     }
 
     let rect = this.currentQuads.border.bounds;
     let dim = parseFloat(rect.width.toPrecision(6)) + " \u00D7 " + parseFloat(rect.height.toPrecision(6));
 
-    let elementId = this.ID_CLASS_PREFIX + "nodeinfobar-";
-    this.markup.setTextContentForElement(elementId + "tagname", tagName);
-    this.markup.setTextContentForElement(elementId + "id", id);
-    this.markup.setTextContentForElement(elementId + "classes", classList);
-    this.markup.setTextContentForElement(elementId + "pseudo-classes", pseudos);
-    this.markup.setTextContentForElement(elementId + "dimensions", dim);
+    this.getElement("nodeinfobar-tagname").setTextContent(tagName);
+    this.getElement("nodeinfobar-id").setTextContent(id);
+    this.getElement("nodeinfobar-classes").setTextContent(classList);
+    this.getElement("nodeinfobar-pseudo-classes").setTextContent(pseudos);
+    this.getElement("nodeinfobar-dimensions").setTextContent(dim);
 
     this._moveInfobar();
   },
 
   /**
    * Move the Infobar to the right place in the highlighter.
    */
   _moveInfobar: function() {
     let bounds = this._getOuterBounds();
-    let winHeight = this.win.innerHeight * this.zoom;
-    let winWidth = this.win.innerWidth * this.zoom;
+    let winHeight = this.win.innerHeight * LayoutHelpers.getCurrentZoom(this.win);
+    let winWidth = this.win.innerWidth * LayoutHelpers.getCurrentZoom(this.win);
 
     // Ensure that containerBottom and containerTop are at least zero to avoid
     // showing tooltips outside the viewport.
     let containerBottom = Math.max(0, bounds.bottom) + NODE_INFOBAR_ARROW_SIZE;
     let containerTop = Math.min(winHeight, bounds.top);
-    let containerId = this.ID_CLASS_PREFIX + "nodeinfobar-container";
+    let container = this.getElement("nodeinfobar-container");
 
     // Can the bar be above the node?
     let top;
     if (containerTop < NODE_INFOBAR_HEIGHT) {
       // No. Can we move the bar under the node?
       if (containerBottom + NODE_INFOBAR_HEIGHT > winHeight) {
         // No. Let's move it inside.
         top = containerTop;
-        this.markup.setAttributeForElement(containerId, "position", "overlap");
+        container.setAttribute("position", "overlap");
       } else {
         // Yes. Let's move it under the node.
         top = containerBottom;
-        this.markup.setAttributeForElement(containerId, "position", "bottom");
+        container.setAttribute("position", "bottom");
       }
     } else {
       // Yes. Let's move it on top of the node.
       top = containerTop - NODE_INFOBAR_HEIGHT;
-      this.markup.setAttributeForElement(containerId, "position", "top");
+      container.setAttribute("position", "top");
     }
 
     // Align the bar with the box's center if possible.
     let left = bounds.right - bounds.width / 2;
     // Make sure the while infobar is visible.
     let buffer = 100;
     if (left < buffer) {
       left = buffer;
-      this.markup.setAttributeForElement(containerId, "hide-arrow", "true");
+      container.setAttribute("hide-arrow", "true");
     } else if (left > winWidth - buffer) {
       left = winWidth - buffer;
-      this.markup.setAttributeForElement(containerId, "hide-arrow", "true");
+      container.setAttribute("hide-arrow", "true");
     } else {
-      this.markup.removeAttributeForElement(containerId, "hide-arrow");
+      container.removeAttribute("hide-arrow");
     }
 
     let style = "top:" + top + "px;left:" + left + "px;";
-    this.markup.setAttributeForElement(containerId, "style", style);
+    container.setAttribute("style", style);
   }
 });
 register(BoxModelHighlighter);
 exports.BoxModelHighlighter = BoxModelHighlighter;
 
 /**
  * The CssTransformHighlighter is the class that draws an outline around a
  * transformed element and an outline around where it would be if untransformed
@@ -1570,16 +1679,20 @@ CssTransformHighlighter.prototype = Heri
   /**
    * Destroy the nodes. Remove listeners.
    */
   destroy: function() {
     AutoRefreshHighlighter.prototype.destroy.call(this);
     this.markup.destroy();
   },
 
+  getElement: function(id) {
+    return this.markup.getElement(this.ID_CLASS_PREFIX + id);
+  },
+
   /**
    * Show the highlighter on a given node
    * @param {DOMNode} node
    */
   _show: function() {
     if (!this._isTransformed(this.currentNode)) {
       this.hide();
       return;
@@ -1596,33 +1709,31 @@ CssTransformHighlighter.prototype = Heri
     return style && (style.transform !== "none" && style.display !== "inline");
   },
 
   _setPolygonPoints: function(quad, id) {
     let points = [];
     for (let point of ["p1","p2", "p3", "p4"]) {
       points.push(quad[point].x + "," + quad[point].y);
     }
-    this.markup.setAttributeForElement(this.ID_CLASS_PREFIX + id,
-                                       "points",
-                                       points.join(" "));
+    this.getElement(id).setAttribute("points", points.join(" "));
   },
 
   _setLinePoints: function(p1, p2, id) {
-    this.markup.setAttributeForElement(this.ID_CLASS_PREFIX + id, "x1", p1.x);
-    this.markup.setAttributeForElement(this.ID_CLASS_PREFIX + id, "y1", p1.y);
-    this.markup.setAttributeForElement(this.ID_CLASS_PREFIX + id, "x2", p2.x);
-    this.markup.setAttributeForElement(this.ID_CLASS_PREFIX + id, "y2", p2.y);
+    let line = this.getElement(id);
+    line.setAttribute("x1", p1.x);
+    line.setAttribute("y1", p1.y);
+    line.setAttribute("x2", p2.x);
+    line.setAttribute("y2", p2.y);
 
     let dist = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
     if (dist < ARROW_LINE_MIN_DISTANCE) {
-      this.markup.removeAttributeForElement(this.ID_CLASS_PREFIX + id, "marker-end");
+      line.removeAttribute("marker-end");
     } else {
-      this.markup.setAttributeForElement(this.ID_CLASS_PREFIX + id, "marker-end",
-                                         "url(#" + this.markerId + ")");
+      line.setAttribute("marker-end", "url(#" + this.markerId + ")");
     }
   },
 
   /**
    * Update the highlighter on the current highlighted node (the one that was
    * passed as an argument to show(node)).
    * Should be called whenever node size or attributes change
    */
@@ -1658,41 +1769,39 @@ CssTransformHighlighter.prototype = Heri
    */
   _hide: function() {
     setIgnoreLayoutChanges(true);
     this._hideShapes();
     setIgnoreLayoutChanges(false, this.currentNode.ownerDocument.documentElement);
   },
 
   _hideShapes: function() {
-    this.markup.setAttributeForElement(this.ID_CLASS_PREFIX + "elements",
-      "hidden", "true");
+    this.getElement("elements").setAttribute("hidden", "true");
   },
 
   _showShapes: function() {
-    this.markup.removeAttributeForElement(this.ID_CLASS_PREFIX + "elements",
-      "hidden");
+    this.getElement("elements").removeAttribute("hidden");
   }
 });
 register(CssTransformHighlighter);
 exports.CssTransformHighlighter = CssTransformHighlighter;
 
-
 /**
  * The SelectorHighlighter runs a given selector through querySelectorAll on the
  * document of the provided context node and then uses the BoxModelHighlighter
  * to highlight the matching nodes
  */
 function SelectorHighlighter(tabActor) {
   this.tabActor = tabActor;
   this._highlighters = [];
 }
 
 SelectorHighlighter.prototype = {
   typeName: "SelectorHighlighter",
+
   /**
    * Show BoxModelHighlighter on each node that matches that provided selector.
    * @param {DOMNode} node A context node that is used to get the document on
    * which querySelectorAll should be executed. This node will NOT be
    * highlighted.
    * @param {Object} options Should at least contain the 'selector' option, a
    * string that will be used in querySelectorAll. On top of this, all of the
    * valid options to BoxModelHighlighter.show are also valid here.
@@ -1771,16 +1880,20 @@ RectHighlighter.prototype = {
   },
 
   destroy: function() {
     this.win = null;
     this.layoutHelpers = null;
     this.markup.destroy();
   },
 
+  getElement: function(id) {
+    return this.markup.getElement(id);
+  },
+
   _hasValidOptions: function(options) {
     let isValidNb = n => typeof n === "number" && n >= 0 && isFinite(n);
     return options && options.rect &&
            isValidNb(options.rect.x) &&
            isValidNb(options.rect.y) &&
            options.rect.width && isValidNb(options.rect.width) &&
            options.rect.height && isValidNb(options.rect.height);
   },
@@ -1810,22 +1923,23 @@ RectHighlighter.prototype = {
     let height = "height:" + options.rect.height + "px;";
 
     let style = x + y + width + height;
     if (options.fill) {
       style += "background:" + options.fill + ";";
     }
 
     // Set the coordinates of the highlighter and show it
-    this.markup.setAttributeForElement("highlighted-rect", "style", style);
-    this.markup.removeAttributeForElement("highlighted-rect", "hidden");
+    let rect = this.getElement("highlighted-rect");
+    rect.setAttribute("style", style);
+    rect.removeAttribute("hidden");
   },
 
   hide: function() {
-    this.markup.setAttributeForElement("highlighted-rect", "hidden", "true");
+    this.getElement("highlighted-rect").setAttribute("hidden", "true");
   }
 };
 register(RectHighlighter);
 exports.RectHighlighter = RectHighlighter;
 
 /**
  * Element geometry properties helper that gives names of position and size
  * properties.
@@ -1908,16 +2022,20 @@ let GeoProp = {
 function GeometryEditorHighlighter(tabActor) {
   AutoRefreshHighlighter.call(this, tabActor);
 
   // The list of element geometry properties that can be set.
   this.definedProperties = new Map();
 
   this.markup = new CanvasFrameAnonymousContentHelper(tabActor,
     this._buildMarkup.bind(this));
+
+  this.onMouseDown = this.onMouseDown.bind(this);
+  this.onMouseUp = this.onMouseUp.bind(this);
+  this.onMouseMove = this.onMouseMove.bind(this);
 }
 
 GeometryEditorHighlighter.prototype = Heritage.extend(AutoRefreshHighlighter.prototype, {
   typeName: "GeometryEditorHighlighter",
 
   ID_CLASS_PREFIX: "geometry-editor-",
 
   _buildMarkup: function() {
@@ -1935,18 +2053,17 @@ GeometryEditorHighlighter.prototype = He
     });
 
     let svg = createSVGNode(this.win, {
       nodeType: "svg",
       parent: root,
       attributes: {
         "id": "elements",
         "width": "100%",
-        "height": "100%",
-        "style": "width:100%;height:100%;"
+        "height": "100%"
       },
       prefix: this.ID_CLASS_PREFIX
     });
 
     // Offset parent node highlighter.
     createSVGNode(this.win, {
       nodeType: "polygon",
       parent: svg,
@@ -2027,17 +2144,17 @@ GeometryEditorHighlighter.prototype = He
           "id": "label-text-" + name,
           "x": GeoProp.isHorizontal(name) ? "30" : "35",
           "y": "10"
         },
         prefix: this.ID_CLASS_PREFIX
       });
     }
 
-    // Build the width/height label and resize handle.
+    // Build the width/height label.
     let labelSizeG = createSVGNode(this.win, {
       nodeType: "g",
       parent: svg,
       attributes: {
         "id": "label-size",
         "hidden": "true"
       },
       prefix: this.ID_CLASS_PREFIX
@@ -2068,28 +2185,47 @@ GeometryEditorHighlighter.prototype = He
         "class": "label-text",
         "id": "label-text-size",
         "x": "50",
         "y": "10"
       },
       prefix: this.ID_CLASS_PREFIX
     });
 
+    // Build the resize handle.
+    createSVGNode(this.win, {
+      nodeType: "rect",
+      parent: svg,
+      attributes: {
+        "class": "handle",
+        "id": "resize-handle",
+        "width": "6",
+        "height": "6",
+        "transform": "translate(-3 -3)",
+        "hidden": "true"
+      },
+      prefix: this.ID_CLASS_PREFIX
+    });
+
     return container;
   },
 
   destroy: function() {
     AutoRefreshHighlighter.prototype.destroy.call(this);
 
     this.markup.destroy();
     this.definedProperties.clear();
     this.definedProperties = null;
     this.offsetParent = null;
   },
 
+  getElement: function(id) {
+    return this.markup.getElement(this.ID_CLASS_PREFIX + id);
+  },
+
   /**
    * Get the list of geometry properties that are actually set on the current
    * node.
    * @return {Map} A map indexed by property name and where the value is an
    * object having the cssRule property.
    */
   getDefinedGeometryProperties: function() {
     let props = new Map();
@@ -2144,29 +2280,54 @@ GeometryEditorHighlighter.prototype = He
       if (pos === "relative" && (hasRightAndLeft || hasBottomAndTop)) {
         props.delete(name);
       }
     }
 
     return props;
   },
 
+  get hasAtLeastOneSide() {
+    return GeoProp.containsSide([...this.definedProperties.keys()]) &&
+           this.computedStyle.position !== "static";
+  },
+
+  get hasAtLeastOneSize() {
+    return GeoProp.containsSize([...this.definedProperties.keys()])
+  },
+
   _show: function() {
     this.computedStyle = CssLogic.getComputedStyle(this.currentNode);
     let pos = this.computedStyle.position;
     // XXX: sticky positioning is ignored for now. To be implemented next.
     if (pos === "sticky") {
       this.hide();
       return;
     }
 
     let hasUpdated = this._update();
     if (!hasUpdated) {
       this.hide();
     }
+
+    // Make the current node movable if the defined properties allow it.
+    if (this.hasAtLeastOneSide) {
+      let box = this.getElement("current-node");
+      box.addNoPropagationEventListener("mousedown", this.onMouseDown);
+      box.setAttribute("movable", "");
+    }
+
+    // Make the size handle movable, if the defined properties allow it.
+    let handle = this.getElement("resize-handle");
+    if (this.hasAtLeastOneSize) {
+      handle.addNoPropagationEventListener("mousedown", this.onMouseDown);
+      handle.removeAttribute("hidden");
+    } else {
+      handle.setAttribute("hidden", "true");
+    }
   },
 
   _update: function() {
     // At each update, the position or/and size may have changed, so get the
     // list of defined properties, and re-position the arrows and highlighters.
     this.definedProperties = this.getDefinedGeometryProperties();
 
     let isStatic = this.computedStyle.position === "static";
@@ -2206,17 +2367,17 @@ GeometryEditorHighlighter.prototype = He
    */
   updateOffsetParent: function() {
     // Get the offsetParent, if any.
     this.offsetParent = getOffsetParent(this.currentNode);
     // And the offsetParent quads.
     this.parentQuads = this.layoutHelpers
                        .getAdjustedQuads(this.offsetParent.element, "padding");
 
-    let el = this.markup.getElement(this.ID_CLASS_PREFIX + "offset-parent");
+    let el = this.getElement("offset-parent");
 
     let isPositioned = this.computedStyle.position === "absolute" ||
                        this.computedStyle.position === "fixed";
     let isRelative = this.computedStyle.position === "relative";
     let isHighlighted = false;
 
     if (this.offsetParent.element && isPositioned) {
       let {p1, p2, p3, p4} = this.parentQuads;
@@ -2243,51 +2404,60 @@ GeometryEditorHighlighter.prototype = He
     if (isHighlighted) {
       el.removeAttribute("hidden");
     } else {
       el.setAttribute("hidden", "true");
     }
   },
 
   updateCurrentNode: function() {
-    let box = this.markup.getElement(this.ID_CLASS_PREFIX + "current-node");
+    let box = this.getElement("current-node");
     let {p1, p2, p3, p4} = this.currentQuads.margin;
     let attr = p1.x + "," + p1.y + " " +
                p2.x + "," + p2.y + " " +
                p3.x + "," + p3.y + " " +
                p4.x + "," + p4.y;
     box.setAttribute("points", attr);
     box.removeAttribute("hidden");
   },
 
   _hide: function() {
     setIgnoreLayoutChanges(true);
 
-    let id = this.ID_CLASS_PREFIX;
-    this.markup.setAttributeForElement(id + "current-node", "hidden", "true");
-    this.markup.setAttributeForElement(id + "offset-parent", "hidden", "true");
+    this.getElement("current-node").setAttribute("hidden", "true");
+    this.getElement("offset-parent").setAttribute("hidden", "true");
+    this.getElement("elements").setAttribute("hidden", "true");
     this.hideArrows();
     this.hideSize();
 
+    if (this.hasAtLeastOneSide) {
+      let box = this.getElement("current-node");
+      box.removeNoPropagationEventListener("mousedown", this.onMouseDown);
+      box.removeAttribute("movable");
+    }
+
+    if (this.hasAtLeastOneSize) {
+      let handle = this.getElement("resize-handle");
+      handle.removeNoPropagationEventListener("mousedown", this.onMouseDown);
+     }
+
     this.definedProperties.clear();
 
     setIgnoreLayoutChanges(false, this.currentNode.ownerDocument.documentElement);
   },
 
   hideArrows: function() {
     for (let side of GeoProp.SIDES) {
-      let id = this.ID_CLASS_PREFIX;
-      this.markup.setAttributeForElement(id + "arrow-" + side, "hidden", "true");
-      this.markup.setAttributeForElement(id + "label-" + side, "hidden", "true");
+      this.getElement("arrow-" + side).setAttribute("hidden", "true");
+      this.getElement("label-" + side).setAttribute("hidden", "true");
     }
   },
 
   hideSize: function() {
-    this.markup.setAttributeForElement(this.ID_CLASS_PREFIX + "label-size",
-      "hidden", "true");
+    this.getElement("label-size").setAttribute("hidden", "true");
   },
 
   updateSize: function() {
     this.hideSize();
 
     let labels = [];
     let width = this.definedProperties.get("width");
     let height = this.definedProperties.get("height");
@@ -2295,27 +2465,32 @@ GeometryEditorHighlighter.prototype = He
     if (width) {
       labels.push(" " + width.cssRule.style.getPropertyValue("width"));
     }
     if (height) {
       labels.push(" " + height.cssRule.style.getPropertyValue("height"));
     }
 
     if (labels.length) {
-      let id = this.ID_CLASS_PREFIX;
-      let labelEl = this.markup.getElement(id + "label-size");
-      let labelTextEl = this.markup.getElement(id + "label-text-size");
+      let labelEl = this.getElement("label-size");
+      let labelTextEl = this.getElement("label-text-size");
+      let handleEl = this.getElement("resize-handle");
 
       let {bounds} = this.currentQuads.margin;
 
+      // Update and position the label.
       labelEl.setAttribute("transform", "translate(" +
         (bounds.left + bounds.width/2) + " " +
         (bounds.top + bounds.height/2) + ")");
       labelEl.removeAttribute("hidden");
       labelTextEl.setTextContent(labels.join(" "));
+
+      // Position the resize handle.
+      handleEl.setAttribute("x", bounds.left + bounds.width);
+      handleEl.setAttribute("y", bounds.top + bounds.height);
     }
   },
 
   updateArrows: function() {
     this.hideArrows();
 
     // Position arrows always end at the node's margin box.
     let marginBox = this.currentQuads.margin.bounds;
@@ -2375,20 +2550,19 @@ GeometryEditorHighlighter.prototype = He
                          marginBox[GeoProp.crossAxisSize(side)] / 2;
 
       this.updateArrow(side, mainAxisStartPos, mainAxisEndPos, crossAxisPos,
                        sideProp.cssRule.style.getPropertyValue(side));
     }
   },
 
   updateArrow: function(side, mainStart, mainEnd, crossPos, labelValue) {
-    let id = this.ID_CLASS_PREFIX;
-    let arrowEl = this.markup.getElement(id + "arrow-" + side);
-    let labelEl = this.markup.getElement(id + "label-" + side);
-    let labelTextEl = this.markup.getElement(id + "label-text-" + side);
+    let arrowEl = this.getElement("arrow-" + side);
+    let labelEl = this.getElement("label-" + side);
+    let labelTextEl = this.getElement("label-text-" + side);
 
     // Position the arrow <line>.
     arrowEl.setAttribute(GeoProp.axis(side) + "1", mainStart);
     arrowEl.setAttribute(GeoProp.crossAxis(side) + "1", crossPos);
     arrowEl.setAttribute(GeoProp.axis(side) + "2", mainEnd);
     arrowEl.setAttribute(GeoProp.crossAxis(side) + "2", crossPos);
     arrowEl.removeAttribute("hidden");
 
@@ -2406,16 +2580,87 @@ GeometryEditorHighlighter.prototype = He
       }
     }
     let labelCross = crossPos;
     labelEl.setAttribute("transform", GeoProp.isHorizontal(side)
                          ? "translate(" + labelMain + " " + labelCross + ")"
                          : "translate(" + labelCross + " " + labelMain + ")");
     labelEl.removeAttribute("hidden");
     labelTextEl.setTextContent(labelValue);
+  },
+
+  onMouseDown: function(e, id) {
+    if (this.isMoving) {
+      return;
+    }
+
+    let target = getPageListenerTarget(this.tabActor);
+    target.addEventListener("mouseup", this.onMouseUp);
+    target.addEventListener("mousemove", this.onMouseMove);
+
+    this.moveStartPos = {x: e.clientX, y: e.clientY};
+    this.movingElement = id;
+    this.isMoving = true;
+    this.getElement("root").setAttribute("moving", "");
+  },
+
+  onMouseUp: function(e) {
+    if (!this.isMoving) {
+      return;
+    }
+
+    let target = getPageListenerTarget(this.tabActor);
+    target.removeEventListener("mouseup", this.onMouseUp);
+    target.removeEventListener("mousemove", this.onMouseMove);
+
+    this.movingElement = null;
+    this.isMoving = false;
+    this.getElement("root").removeAttribute("moving");
+  },
+
+  onMouseMove: function(e) {
+    if (!this.isMoving) {
+      return;
+    }
+
+    let delta = {
+      x: e.clientX - this.moveStartPos.x,
+      y: e.clientY - this.moveStartPos.y
+    };
+
+    let props = this.movingElement.contains("resize-handle")
+                ? GeoProp.SIZES
+                : GeoProp.SIDES;
+    for (let prop of props) {
+      this.updateProperty(prop, delta);
+    }
+
+    this.moveStartPos = {x: e.clientX, y: e.clientY};
+  },
+
+  updateProperty: function(name, delta={x:0, y:0}) {
+    let prop = this.definedProperties.get(name);
+    if (!prop) {
+      return;
+    }
+
+    let moveBy = delta[GeoProp.axis(name)];
+    if (GeoProp.isInverted(name)) {
+      moveBy *= -1;
+    }
+
+    let value = prop.cssRule.style.getPropertyValue(name);
+    let computedValue = this.computedStyle.getPropertyValue(name);
+    let [unit] = /[^\d.-]+/g.exec(value) || [""];
+    let ratio = parseFloat(value) / parseFloat(computedValue);
+
+    moveBy *= ratio || 1;
+    let newValue = (parseFloat(value) + moveBy) + unit;
+
+    prop.cssRule.style.setProperty(name, newValue);
   }
 });
 register(GeometryEditorHighlighter);
 exports.GeometryEditorHighlighter = GeometryEditorHighlighter;
 
 /**
  * The SimpleOutlineHighlighter is a class that has the same API than the
  * BoxModelHighlighter, but adds a pseudo-class on the target element itself
diff --git a/toolkit/devtools/server/tests/browser/browser.ini b/toolkit/devtools/server/tests/browser/browser.ini
--- a/toolkit/devtools/server/tests/browser/browser.ini
+++ b/toolkit/devtools/server/tests/browser/browser.ini
@@ -20,16 +20,21 @@ support-files =
 [browser_animation_actors_03.js]
 [browser_animation_actors_04.js]
 [browser_animation_actors_05.js]
 [browser_animation_actors_06.js]
 [browser_animation_actors_07.js]
 [browser_animation_actors_08.js]
 [browser_animation_actors_09.js]
 [browser_animation_actors_10.js]
+[browser_canvasframe_helper_01.js]
+[browser_canvasframe_helper_02.js]
+[browser_canvasframe_helper_03.js]
+[browser_canvasframe_helper_04.js]
+[browser_canvasframe_helper_05.js]
 [browser_navigateEvents.js]
 [browser_storage_dynamic_windows.js]
 [browser_storage_listings.js]
 [browser_storage_updates.js]
 [browser_timeline.js]
 skip-if = buildapp == 'mulet'
 [browser_timeline_actors.js]
 skip-if = buildapp == 'mulet'
diff --git a/toolkit/devtools/server/tests/browser/browser_canvasframe_helper_01.js b/toolkit/devtools/server/tests/browser/browser_canvasframe_helper_01.js
new file mode 100644
--- /dev/null
+++ b/toolkit/devtools/server/tests/browser/browser_canvasframe_helper_01.js
@@ -0,0 +1,89 @@
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Simple CanvasFrameAnonymousContentHelper tests.
+
+// This makes sure the 'domnode' protocol actor type is known when importing
+// highlighter.
+require("devtools/server/actors/inspector");
+const {CanvasFrameAnonymousContentHelper} = require("devtools/server/actors/highlighter");
+const TEST_URL = "data:text/html;charset=utf-8,CanvasFrameAnonymousContentHelper test";
+
+add_task(function*() {
+  let doc = yield addTab(TEST_URL);
+
+  let nodeBuilder = () => {
+    let root = doc.createElement("div");
+    let child = doc.createElement("div");
+    child.style = "width:200px;height:200px;background:red;";
+    child.id = "child-element";
+    child.className = "child-element";
+    child.textContent = "test element";
+    root.appendChild(child);
+    return root;
+  };
+
+  info("Building the helper");
+  let helper = new CanvasFrameAnonymousContentHelper(getTabActor(doc.defaultView),
+                                                     nodeBuilder);
+
+  ok(helper.content instanceof AnonymousContent,
+    "The helper owns the AnonymousContent object");
+  ok(helper.getTextContentForElement,
+    "The helper has the getTextContentForElement method");
+  ok(helper.setTextContentForElement,
+    "The helper has the setTextContentForElement method");
+  ok(helper.setAttributeForElement,
+    "The helper has the setAttributeForElement method");
+  ok(helper.getAttributeForElement,
+    "The helper has the getAttributeForElement method");
+  ok(helper.removeAttributeForElement,
+    "The helper has the removeAttributeForElement method");
+  ok(helper.addNoPropagationEventListenerForElement,
+    "The helper has the addEventListenerForElement method");
+  ok(helper.removeNoPropagationEventListenerForElement,
+    "The helper has the removeEventListenerForElement method");
+  ok(helper.getElement,
+    "The helper has the getElement method");
+  ok(helper.scaleRootElement,
+    "The helper has the scaleRootElement method");
+
+  is(helper.getTextContentForElement("child-element"), "test element",
+    "The text content was retrieve correctly");
+  is(helper.getAttributeForElement("child-element", "id"), "child-element",
+    "The ID attribute was retrieve correctly");
+  is(helper.getAttributeForElement("child-element", "class"), "child-element",
+    "The class attribute was retrieve correctly");
+
+  let el = helper.getElement("child-element");
+  ok(el, "The DOMNode-like element was created");
+
+  is(el.getTextContent(), "test element",
+    "The text content was retrieve correctly");
+  is(el.getAttribute("id"), "child-element",
+    "The ID attribute was retrieve correctly");
+  is(el.getAttribute("class"), "child-element",
+    "The class attribute was retrieve correctly");
+
+  info("Destroying the helper");
+  helper.destroy();
+
+  ok(!helper.getTextContentForElement("child-element"),
+    "No text content was retrieved after the helper was destroyed");
+  ok(!helper.getAttributeForElement("child-element", "id"),
+    "No ID attribute was retrieved after the helper was destroyed");
+  ok(!helper.getAttributeForElement("child-element", "class"),
+    "No class attribute was retrieved after the helper was destroyed");
+
+  gBrowser.removeCurrentTab();
+});
+
+function getTabActor(win) {
+  return {
+    window: win,
+    isRootActor: true
+  };
+}
diff --git a/toolkit/devtools/server/tests/browser/browser_canvasframe_helper_02.js b/toolkit/devtools/server/tests/browser/browser_canvasframe_helper_02.js
new file mode 100644
--- /dev/null
+++ b/toolkit/devtools/server/tests/browser/browser_canvasframe_helper_02.js
@@ -0,0 +1,44 @@
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Test that the CanvasFrameAnonymousContentHelper does not insert content in
+// XUL windows.
+
+// This makes sure the 'domnode' protocol actor type is known when importing
+// highlighter.
+require("devtools/server/actors/inspector");
+const {CanvasFrameAnonymousContentHelper} = require("devtools/server/actors/highlighter");
+
+add_task(function*() {
+  let doc = yield addTab("about:preferences");
+
+  let nodeBuilder = () => {
+    let root = doc.createElement("div");
+    let child = doc.createElement("div");
+    child.style = "width:200px;height:200px;background:red;";
+    child.id = "child-element";
+    child.className = "child-element";
+    child.textContent = "test element";
+    root.appendChild(child);
+    return root;
+  };
+
+  info("Building the helper");
+  let helper = new CanvasFrameAnonymousContentHelper(getTabActor(doc.defaultView),
+                                                     nodeBuilder);
+  ok(!helper.content, "The AnonymousContent was not inserted in the window");
+  ok(!helper.getTextContentForElement("child-element"),
+    "No text content is returned");
+
+  gBrowser.removeCurrentTab();
+});
+
+function getTabActor(win) {
+  return {
+    window: win,
+    isRootActor: true
+  };
+}
diff --git a/toolkit/devtools/server/tests/browser/browser_canvasframe_helper_03.js b/toolkit/devtools/server/tests/browser/browser_canvasframe_helper_03.js
new file mode 100644
--- /dev/null
+++ b/toolkit/devtools/server/tests/browser/browser_canvasframe_helper_03.js
@@ -0,0 +1,99 @@
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Test the CanvasFrameAnonymousContentHelper event handling mechanism.
+
+// This makes sure the 'domnode' protocol actor type is known when importing
+// highlighter.
+require("devtools/server/actors/inspector");
+const {CanvasFrameAnonymousContentHelper} = require("devtools/server/actors/highlighter");
+const TEST_URL = "data:text/html;charset=utf-8,CanvasFrameAnonymousContentHelper test";
+
+add_task(function*() {
+  let doc = yield addTab(TEST_URL);
+
+  let nodeBuilder = () => {
+    let root = doc.createElement("div");
+    let child = doc.createElement("div");
+    child.style = "pointer-events:auto;width:200px;height:200px;background:red;";
+    child.id = "child-element";
+    child.className = "child-element";
+    root.appendChild(child);
+    return root;
+  };
+
+  info("Building the helper");
+  let helper = new CanvasFrameAnonymousContentHelper(getTabActor(doc.defaultView),
+                                                     nodeBuilder);
+
+  let el = helper.getElement("child-element");
+
+  info("Adding an event listener on the inserted element");
+  let mouseDownHandled = 0;
+  function onMouseDown(e, id) {
+    is(id, "child-element", "The mousedown event was triggered on the element");
+    mouseDownHandled ++;
+  }
+  el.addNoPropagationEventListener("mousedown", onMouseDown);
+
+  info("Synthesizing an event on the inserted element");
+  let onDocMouseDown = once(doc, "mousedown");
+  synthesizeMouseDown(100, 100, doc.defaultView);
+  yield onDocMouseDown;
+
+  is(mouseDownHandled, 1, "The mousedown event was handled once on the element");
+
+  info("Synthesizing an event somewhere else");
+  onDocMouseDown = once(doc, "mousedown");
+  synthesizeMouseDown(400, 400, doc.defaultView);
+  yield onDocMouseDown;
+
+  is(mouseDownHandled, 1, "The mousedown event was not handled on the element");
+
+  info("Removing the event listener");
+  el.removeNoPropagationEventListener("mousedown", onMouseDown);
+
+  info("Synthesizing another event after the listener has been removed");
+  // Using a document event listener to know when the event has been synthesized.
+  onDocMouseDown = once(doc, "mousedown");
+  synthesizeMouseDown(100, 100, doc.defaultView);
+  yield onDocMouseDown;
+
+  is(mouseDownHandled, 1,
+    "The mousedown event hasn't been handled after the listener was removed");
+
+  info("Adding again the event listener");
+  el.addNoPropagationEventListener("mousedown", onMouseDown);
+
+  info("Destroying the helper");
+  helper.destroy();
+
+  info("Synthesizing another event after the helper has been destroyed");
+  // Using a document event listener to know when the event has been synthesized.
+  onDocMouseDown = once(doc, "mousedown");
+  synthesizeMouseDown(100, 100, doc.defaultView);
+  yield onDocMouseDown;
+
+  is(mouseDownHandled, 1,
+    "The mousedown event hasn't been handled after the helper was destroyed");
+
+  gBrowser.removeCurrentTab();
+});
+
+function getTabActor(win) {
+  return {
+    window: win,
+    isRootActor: true
+  };
+}
+
+function synthesizeMouseDown(x, y, win) {
+  // It looks like we need to wait a bit before synthesizing the event if we
+  // want it to be handled by the native anonymous content.
+  setTimeout(() => {
+    EventUtils.synthesizeMouseAtPoint(x, y, {type: "mousedown"}, win);
+  }, 100);
+}
diff --git a/toolkit/devtools/server/tests/browser/browser_canvasframe_helper_04.js b/toolkit/devtools/server/tests/browser/browser_canvasframe_helper_04.js
new file mode 100644
--- /dev/null
+++ b/toolkit/devtools/server/tests/browser/browser_canvasframe_helper_04.js
@@ -0,0 +1,100 @@
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Test the CanvasFrameAnonymousContentHelper re-inserts the content when the
+// page reloads.
+
+// This makes sure the 'domnode' protocol actor type is known when importing
+// highlighter.
+require("devtools/server/actors/inspector");
+const {CanvasFrameAnonymousContentHelper} = require("devtools/server/actors/highlighter");
+const events = require("sdk/event/core");
+const TEST_URL_1 = "data:text/html;charset=utf-8,CanvasFrameAnonymousContentHelper test 1";
+const TEST_URL_2 = "data:text/html;charset=utf-8,CanvasFrameAnonymousContentHelper test 2";
+
+add_task(function*() {
+  let doc = yield addTab(TEST_URL_2);
+
+  let tabActor = getTabActor(doc.defaultView);
+
+  let nodeBuilder = () => {
+    let root = doc.createElement("div");
+    let child = doc.createElement("div");
+    child.style = "pointer-events:auto;width:200px;height:200px;background:red;";
+    child.id = "child-element";
+    child.className = "child-element";
+    child.textContent= "test content";
+    root.appendChild(child);
+    return root;
+  };
+
+  info("Building the helper");
+  let helper = new CanvasFrameAnonymousContentHelper(tabActor, nodeBuilder);
+
+  info("Get an element from the helper");
+  let el = helper.getElement("child-element");
+
+  info("Try to access the element");
+  is(el.getAttribute("class"), "child-element",
+    "The attribute is correct before navigation");
+  is(el.getTextContent(), "test content",
+    "The text content is correct before navigation");
+
+  info("Add an event listener on the element");
+  let mouseDownHandled = 0;
+  function onMouseDown(e, id) {
+    is(id, "child-element", "The mousedown event was triggered on the element");
+    mouseDownHandled ++;
+  }
+  el.addNoPropagationEventListener("mousedown", onMouseDown);
+
+  info("Synthesizing an event on the element");
+  let onDocMouseDown = once(doc, "mousedown");
+  synthesizeMouseDown(100, 100, doc.defaultView);
+  yield onDocMouseDown;
+  is(mouseDownHandled, 1, "The mousedown event was handled once before navigation");
+
+  info("Navigating to a new page");
+  let loaded = once(gBrowser.selectedBrowser, "load", true);
+  content.location = TEST_URL_2;
+  yield loaded;
+  doc = gBrowser.selectedBrowser.contentWindow.document;
+
+  info("And faking the 'navigate' event on the tabActor");
+  events.emit(tabActor, "navigate", {window: doc.defaultView, isTopLevel: true});
+
+  info("Try to access the element again");
+  is(el.getAttribute("class"), "child-element",
+    "The attribute is correct after navigation");
+  is(el.getTextContent(), "test content",
+    "The text content is correct after navigation");
+
+  info("Synthesizing an event on the element again");
+  onDocMouseDown = once(doc, "mousedown");
+  synthesizeMouseDown(100, 100, doc.defaultView);
+  yield onDocMouseDown;
+  is(mouseDownHandled, 1, "The mousedown event was not handled after navigation");
+
+  info("Destroying the helper");
+  helper.destroy();
+
+  gBrowser.removeCurrentTab();
+});
+
+function getTabActor(win) {
+  return {
+    window: win,
+    isRootActor: true
+  };
+}
+
+function synthesizeMouseDown(x, y, win) {
+  // It looks like we need to wait a bit before synthesizing the event if we
+  // want it to be handled by the native anonymous content.
+  setTimeout(() => {
+    EventUtils.synthesizeMouseAtPoint(x, y, {type: "mousedown"}, win);
+  }, 100);
+}
diff --git a/toolkit/devtools/server/tests/browser/browser_canvasframe_helper_05.js b/toolkit/devtools/server/tests/browser/browser_canvasframe_helper_05.js
new file mode 100644
--- /dev/null
+++ b/toolkit/devtools/server/tests/browser/browser_canvasframe_helper_05.js
@@ -0,0 +1,90 @@
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* Any copyright is dedicated to the Public Domain.
+   http://creativecommons.org/publicdomain/zero/1.0/ */
+
+"use strict";
+
+// Test some edge cases of the CanvasFrameAnonymousContentHelper event handling
+// mechanism.
+
+// This makes sure the 'domnode' protocol actor type is known when importing
+// highlighter.
+require("devtools/server/actors/inspector");
+const {CanvasFrameAnonymousContentHelper} = require("devtools/server/actors/highlighter");
+const TEST_URL = "data:text/html;charset=utf-8,CanvasFrameAnonymousContentHelper test";
+
+add_task(function*() {
+  let doc = yield addTab(TEST_URL);
+
+  let nodeBuilder = () => {
+    let root = doc.createElement("div");
+
+    let parent = doc.createElement("div");
+    parent.style = "pointer-events:auto;width:300px;height:300px;background:yellow;";
+    parent.id = "parent-element";
+    root.appendChild(parent);
+
+    let child = doc.createElement("div");
+    child.style = "pointer-events:auto;width:200px;height:200px;background:red;";
+    child.id = "child-element";
+    parent.appendChild(child);
+
+    return root;
+  };
+
+  info("Building the helper");
+  let helper = new CanvasFrameAnonymousContentHelper(getTabActor(doc.defaultView),
+                                                     nodeBuilder);
+
+  info("Getting the parent and child elements");
+  let parentEl = helper.getElement("parent-element");
+  let childEl = helper.getElement("child-element");
+
+  info("Adding an event listener on both elements");
+  let mouseDownHandled = [];
+  function onMouseDown(e, id) {
+    mouseDownHandled.push(id);
+  }
+  parentEl.addNoPropagationEventListener("mousedown", onMouseDown);
+  childEl.addNoPropagationEventListener("mousedown", onMouseDown);
+
+  info("Synthesizing an event on the child element");
+  let onDocMouseDown = once(doc, "mousedown");
+  synthesizeMouseDown(100, 100, doc.defaultView);
+  yield onDocMouseDown;
+
+  is(mouseDownHandled.length, 1, "The mousedown event was handled only once");
+  is(mouseDownHandled[0], "child-element",
+    "The mousedown event was handled on the child element");
+
+  info("Synthesizing an event on the parent, outside of the child element");
+  mouseDownHandled = [];
+  onDocMouseDown = once(doc, "mousedown");
+  synthesizeMouseDown(250, 250, doc.defaultView);
+  yield onDocMouseDown;
+
+  is(mouseDownHandled.length, 1, "The mousedown event was handled only once");
+  is(mouseDownHandled[0], "parent-element",
+    "The mousedown event was handled on the parent element");
+
+  info("Removing the event listener");
+  parentEl.removeNoPropagationEventListener("mousedown", onMouseDown);
+  childEl.removeNoPropagationEventListener("mousedown", onMouseDown);
+
+  gBrowser.removeCurrentTab();
+});
+
+function getTabActor(win) {
+  return {
+    window: win,
+    isRootActor: true
+  };
+}
+
+function synthesizeMouseDown(x, y, win) {
+  // It looks like we need to wait a bit before synthesizing the event if we
+  // want it to be handled by the native anonymous content.
+  setTimeout(() => {
+    EventUtils.synthesizeMouseAtPoint(x, y, {type: "mousedown"}, win);
+  }, 100);
+}
