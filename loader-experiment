# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  c60886d5c003908affbe74e56a7c5b88021b4c6e
Bug 1291049 - Attempt to bunlde the inspector with webpack

diff --git a/.hgignore b/.hgignore
--- a/.hgignore
+++ b/.hgignore
@@ -70,16 +70,17 @@
 ^python/psutil/.*\.so
 ^python/psutil/.*\.pyd
 ^python/psutil/build/
 
 # Git repositories
 .git/
 
 # Ignore chrome.manifest files from the devtools loader
+^devtools/client/node_modules
 ^devtools/client/chrome.manifest$
 ^devtools/shared/chrome.manifest$
 
 # git checkout of libstagefright
 ^media/libstagefright/android$
 
 # Tag files generated by GNU Global
 GTAGS
diff --git a/devtools/client/.babelrc b/devtools/client/.babelrc
new file mode 100644
--- /dev/null
+++ b/devtools/client/.babelrc
@@ -0,0 +1,1 @@
+ { "presets": [ "es2015" ] }
\ No newline at end of file
diff --git a/devtools/client/inspector/app.bundle.js b/devtools/client/inspector/app.bundle.js
new file mode 100644
--- /dev/null
+++ b/devtools/client/inspector/app.bundle.js
@@ -0,0 +1,1771 @@
+/******/ (function(modules) { // webpackBootstrap
+/******/ 	// The module cache
+/******/ 	var installedModules = {};
+
+/******/ 	// The require function
+/******/ 	function __webpack_require__(moduleId) {
+
+/******/ 		// Check if module is in cache
+/******/ 		if(installedModules[moduleId])
+/******/ 			return installedModules[moduleId].exports;
+
+/******/ 		// Create a new module (and put it into the cache)
+/******/ 		var module = installedModules[moduleId] = {
+/******/ 			exports: {},
+/******/ 			id: moduleId,
+/******/ 			loaded: false
+/******/ 		};
+
+/******/ 		// Execute the module function
+/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
+
+/******/ 		// Flag the module as loaded
+/******/ 		module.loaded = true;
+
+/******/ 		// Return the exports of the module
+/******/ 		return module.exports;
+/******/ 	}
+
+
+/******/ 	// expose the modules object (__webpack_modules__)
+/******/ 	__webpack_require__.m = modules;
+
+/******/ 	// expose the module cache
+/******/ 	__webpack_require__.c = installedModules;
+
+/******/ 	// __webpack_public_path__
+/******/ 	__webpack_require__.p = "";
+
+/******/ 	// Load entry module and return exports
+/******/ 	return __webpack_require__(0);
+/******/ })
+/************************************************************************/
+/******/ ([
+/* 0 */
+/***/ function(module, exports, __webpack_require__) {
+
+	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
+	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+	/* This Source Code Form is subject to the terms of the Mozilla Public
+	 * License, v. 2.0. If a copy of the MPL was not distributed with this
+	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+	/* Experimenting with 100 char long lines */
+	/* eslint max-len: [2, 100, 2, {ignoreUrls: true, "ignorePattern": "\\s*require\\s*\\(|^\\s*loader\\.lazy|-\\*-"}] */ // eslint-disable-line
+
+	"use strict";
+
+	/* eslint-disable mozilla/reject-some-requires */
+	const {Cc, Ci} = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"chrome\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
+	/* eslint-enable mozilla/reject-some-requires */
+
+	var Services = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"Services\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
+	var promise = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"promise\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
+	var defer = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"devtools/shared/defer\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
+	var EventEmitter = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"devtools/shared/event-emitter\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
+	var clipboard = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"sdk/clipboard\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
+	const {executeSoon} = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"devtools/shared/DevToolsUtils\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
+	var {KeyShortcuts} = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"devtools/client/shared/key-shortcuts\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
+	var {Task} = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"devtools/shared/task\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
+	const {initCssProperties} = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"devtools/shared/fronts/css-properties\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
+	const nodeConstants = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"devtools/shared/dom-node-constants\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
+	const Telemetry = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"devtools/client/shared/telemetry\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
+
+	const Menu = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"devtools/client/framework/menu\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
+	const MenuItem = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"devtools/client/framework/menu-item\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
+
+	loader.lazyRequireGetter(this, "CSS", "CSS");
+
+	loader.lazyRequireGetter(this, "CommandUtils", "devtools/client/shared/developer-toolbar", true);
+	loader.lazyRequireGetter(this, "ComputedViewTool", "devtools/client/inspector/computed/computed", true);
+	loader.lazyRequireGetter(this, "FontInspector", "devtools/client/inspector/fonts/fonts", true);
+	loader.lazyRequireGetter(this, "HTMLBreadcrumbs", "devtools/client/inspector/breadcrumbs", true);
+	loader.lazyRequireGetter(this, "InspectorSearch", "devtools/client/inspector/inspector-search", true);
+	loader.lazyRequireGetter(this, "MarkupView", "devtools/client/inspector/markup/markup", true);
+	loader.lazyRequireGetter(this, "RuleViewTool", "devtools/client/inspector/rules/rules", true);
+	loader.lazyRequireGetter(this, "ToolSidebar", "devtools/client/inspector/toolsidebar", true);
+	loader.lazyRequireGetter(this, "ViewHelpers", "devtools/client/shared/widgets/view-helpers", true);
+
+	loader.lazyGetter(this, "strings", () => {
+	  return Services.strings.createBundle("chrome://devtools/locale/inspector.properties");
+	});
+	loader.lazyGetter(this, "toolboxStrings", () => {
+	  return Services.strings.createBundle("chrome://devtools/locale/toolbox.properties");
+	});
+	loader.lazyGetter(this, "clipboardHelper", () => {
+	  return Cc["@mozilla.org/widget/clipboardhelper;1"].getService(Ci.nsIClipboardHelper);
+	});
+
+	/**
+	 * Represents an open instance of the Inspector for a tab.
+	 * The inspector controls the breadcrumbs, the markup view, and the sidebar
+	 * (computed view, rule view, font view and layout view).
+	 *
+	 * Events:
+	 * - ready
+	 *      Fired when the inspector panel is opened for the first time and ready to
+	 *      use
+	 * - new-root
+	 *      Fired after a new root (navigation to a new page) event was fired by
+	 *      the walker, and taken into account by the inspector (after the markup
+	 *      view has been reloaded)
+	 * - markuploaded
+	 *      Fired when the markup-view frame has loaded
+	 * - breadcrumbs-updated
+	 *      Fired when the breadcrumb widget updates to a new node
+	 * - layoutview-updated
+	 *      Fired when the layoutview (box model) updates to a new node
+	 * - markupmutation
+	 *      Fired after markup mutations have been processed by the markup-view
+	 * - computed-view-refreshed
+	 *      Fired when the computed rules view updates to a new node
+	 * - computed-view-property-expanded
+	 *      Fired when a property is expanded in the computed rules view
+	 * - computed-view-property-collapsed
+	 *      Fired when a property is collapsed in the computed rules view
+	 * - computed-view-sourcelinks-updated
+	 *      Fired when the stylesheet source links have been updated (when switching
+	 *      to source-mapped files)
+	 * - computed-view-filtered
+	 *      Fired when the computed rules view is filtered
+	 * - rule-view-refreshed
+	 *      Fired when the rule view updates to a new node
+	 * - rule-view-sourcelinks-updated
+	 *      Fired when the stylesheet source links have been updated (when switching
+	 *      to source-mapped files)
+	 */
+	function InspectorPanel(iframeWindow, toolbox) {
+	  this._toolbox = toolbox;
+	  this._target = toolbox._target;
+	  this.panelDoc = iframeWindow.document;
+	  this.panelWin = iframeWindow;
+	  this.panelWin.inspector = this;
+
+	  this.telemetry = new Telemetry();
+
+	  this.nodeMenuTriggerInfo = null;
+
+	  this._handleRejectionIfNotDestroyed = this._handleRejectionIfNotDestroyed.bind(this);
+	  this._onBeforeNavigate = this._onBeforeNavigate.bind(this);
+	  this.onNewRoot = this.onNewRoot.bind(this);
+	  this._onContextMenu = this._onContextMenu.bind(this);
+	  this._updateSearchResultsLabel = this._updateSearchResultsLabel.bind(this);
+	  this.onNewSelection = this.onNewSelection.bind(this);
+	  this.onBeforeNewSelection = this.onBeforeNewSelection.bind(this);
+	  this.onDetached = this.onDetached.bind(this);
+	  this.onPaneToggleButtonClicked = this.onPaneToggleButtonClicked.bind(this);
+	  this._onMarkupFrameLoad = this._onMarkupFrameLoad.bind(this);
+
+	  this._target.on("will-navigate", this._onBeforeNavigate);
+	  this._detectingActorFeatures = this._detectActorFeatures();
+
+	  EventEmitter.decorate(this);
+	}
+
+	exports.InspectorPanel = InspectorPanel;
+
+	InspectorPanel.prototype = {
+	  /**
+	   * open is effectively an asynchronous constructor
+	   */
+	  open: Task.async(function* () {
+	    this._cssPropertiesLoaded = initCssProperties(this.toolbox);
+	    yield this._cssPropertiesLoaded;
+	    yield this.target.makeRemote();
+	    yield this._getPageStyle();
+	    let defaultSelection = yield this._getDefaultNodeForSelection();
+	    return yield this._deferredOpen(defaultSelection);
+	  }),
+
+	  get toolbox() {
+	    return this._toolbox;
+	  },
+
+	  get inspector() {
+	    return this._toolbox.inspector;
+	  },
+
+	  get walker() {
+	    return this._toolbox.walker;
+	  },
+
+	  get selection() {
+	    return this._toolbox.selection;
+	  },
+
+	  get isOuterHTMLEditable() {
+	    return this._target.client.traits.editOuterHTML;
+	  },
+
+	  get hasUrlToImageDataResolver() {
+	    return this._target.client.traits.urlToImageDataResolver;
+	  },
+
+	  get canGetUniqueSelector() {
+	    return this._target.client.traits.getUniqueSelector;
+	  },
+
+	  get canGetUsedFontFaces() {
+	    return this._target.client.traits.getUsedFontFaces;
+	  },
+
+	  get canPasteInnerOrAdjacentHTML() {
+	    return this._target.client.traits.pasteHTML;
+	  },
+
+	  /**
+	   * Handle promise rejections for various asynchronous actions, and only log errors if
+	   * the inspector panel still exists.
+	   * This is useful to silence useless errors that happen when the inspector is closed
+	   * while still initializing (and making protocol requests).
+	   */
+	  _handleRejectionIfNotDestroyed: function (e) {
+	    if (!this._panelDestroyer) {
+	      console.error(e);
+	    }
+	  },
+
+	  /**
+	   * Figure out what features the backend supports
+	   */
+	  _detectActorFeatures: function () {
+	    this._supportsDuplicateNode = false;
+	    this._supportsScrollIntoView = false;
+	    this._supportsResolveRelativeURL = false;
+
+	    return promise.all([
+	      this._target.actorHasMethod("domwalker", "duplicateNode").then(value => {
+	        this._supportsDuplicateNode = value;
+	      }).catch(e => console.error(e)),
+	      this._target.actorHasMethod("domnode", "scrollIntoView").then(value => {
+	        this._supportsScrollIntoView = value;
+	      }).catch(e => console.error(e)),
+	      this._target.actorHasMethod("inspector", "resolveRelativeURL").then(value => {
+	        this._supportsResolveRelativeURL = value;
+	      }).catch(e => console.error(e)),
+	    ]);
+	  },
+
+	  _deferredOpen: function (defaultSelection) {
+	    let deferred = defer();
+
+	    this.walker.on("new-root", this.onNewRoot);
+
+	    this.selection.on("new-node-front", this.onNewSelection);
+	    this.selection.on("before-new-node-front", this.onBeforeNewSelection);
+	    this.selection.on("detached-front", this.onDetached);
+
+	    this.breadcrumbs = new HTMLBreadcrumbs(this);
+
+	    if (this.target.isLocalTab) {
+	      // Show a warning when the debugger is paused.
+	      // We show the warning only when the inspector
+	      // is selected.
+	      this.updateDebuggerPausedWarning = () => {
+	        let notificationBox = this._toolbox.getNotificationBox();
+	        let notification = notificationBox.getNotificationWithValue("inspector-script-paused");
+	        if (!notification && this._toolbox.currentToolId == "inspector" &&
+	            this._toolbox.threadClient.paused) {
+	          let message = strings.GetStringFromName("debuggerPausedWarning.message");
+	          notificationBox.appendNotification(message,
+	            "inspector-script-paused", "", notificationBox.PRIORITY_WARNING_HIGH);
+	        }
+
+	        if (notification && this._toolbox.currentToolId != "inspector") {
+	          notificationBox.removeNotification(notification);
+	        }
+
+	        if (notification && !this._toolbox.threadClient.paused) {
+	          notificationBox.removeNotification(notification);
+	        }
+	      };
+	      this.target.on("thread-paused", this.updateDebuggerPausedWarning);
+	      this.target.on("thread-resumed", this.updateDebuggerPausedWarning);
+	      this._toolbox.on("select", this.updateDebuggerPausedWarning);
+	      this.updateDebuggerPausedWarning();
+	    }
+
+	    this._initMarkup();
+	    this.isReady = false;
+
+	    this.once("markuploaded", () => {
+	      this.isReady = true;
+
+	      // All the components are initialized. Let's select a node.
+	      this.selection.setNodeFront(defaultSelection, "inspector-open");
+
+	      this.markup.expandNode(this.selection.nodeFront);
+
+	      this.emit("ready");
+	      deferred.resolve(this);
+	    });
+
+	    this.setupSearchBox();
+	    this.setupSidebar();
+	    this.setupToolbar();
+
+	    return deferred.promise;
+	  },
+
+	  _onBeforeNavigate: function () {
+	    this._defaultNode = null;
+	    this.selection.setNodeFront(null);
+	    this._destroyMarkup();
+	    this.isDirty = false;
+	    this._pendingSelection = null;
+	  },
+
+	  _getPageStyle: function () {
+	    return this._toolbox.inspector.getPageStyle().then(pageStyle => {
+	      this.pageStyle = pageStyle;
+	    }, this._handleRejectionIfNotDestroyed);
+	  },
+
+	  /**
+	   * Return a promise that will resolve to the default node for selection.
+	   */
+	  _getDefaultNodeForSelection: function () {
+	    if (this._defaultNode) {
+	      return this._defaultNode;
+	    }
+	    let walker = this.walker;
+	    let rootNode = null;
+	    let pendingSelection = this._pendingSelection;
+
+	    // A helper to tell if the target has or is about to navigate.
+	    // this._pendingSelection changes on "will-navigate" and "new-root" events.
+	    let hasNavigated = () => pendingSelection !== this._pendingSelection;
+
+	    // If available, set either the previously selected node or the body
+	    // as default selected, else set documentElement
+	    return walker.getRootNode().then(node => {
+	      if (hasNavigated()) {
+	        return promise.reject("navigated; resolution of _defaultNode aborted");
+	      }
+
+	      rootNode = node;
+	      if (this.selectionCssSelector) {
+	        return walker.querySelector(rootNode, this.selectionCssSelector);
+	      }
+	      return null;
+	    }).then(front => {
+	      if (hasNavigated()) {
+	        return promise.reject("navigated; resolution of _defaultNode aborted");
+	      }
+
+	      if (front) {
+	        return front;
+	      }
+	      return walker.querySelector(rootNode, "body");
+	    }).then(front => {
+	      if (hasNavigated()) {
+	        return promise.reject("navigated; resolution of _defaultNode aborted");
+	      }
+
+	      if (front) {
+	        return front;
+	      }
+	      return this.walker.documentElement();
+	    }).then(node => {
+	      if (hasNavigated()) {
+	        return promise.reject("navigated; resolution of _defaultNode aborted");
+	      }
+	      this._defaultNode = node;
+	      return node;
+	    });
+	  },
+
+	  /**
+	   * Target getter.
+	   */
+	  get target() {
+	    return this._target;
+	  },
+
+	  /**
+	   * Target setter.
+	   */
+	  set target(value) {
+	    this._target = value;
+	  },
+
+	  /**
+	   * Indicate that a tool has modified the state of the page.  Used to
+	   * decide whether to show the "are you sure you want to navigate"
+	   * notification.
+	   */
+	  markDirty: function () {
+	    this.isDirty = true;
+	  },
+
+	  /**
+	   * Hooks the searchbar to show result and auto completion suggestions.
+	   */
+	  setupSearchBox: function () {
+	    this.searchBox = this.panelDoc.getElementById("inspector-searchbox");
+	    this.searchResultsLabel = this.panelDoc.getElementById("inspector-searchlabel");
+
+	    this.search = new InspectorSearch(this, this.searchBox);
+	    this.search.on("search-cleared", this._updateSearchResultsLabel);
+	    this.search.on("search-result", this._updateSearchResultsLabel);
+
+	    let shortcuts = new KeyShortcuts({
+	      window: this.panelDoc.defaultView,
+	    });
+	    let key = strings.GetStringFromName("inspector.searchHTML.key");
+	    shortcuts.on(key, (name, event) => {
+	      // Prevent overriding same shortcut from the computed/rule views
+	      if (event.target.closest("#sidebar-panel-ruleview") ||
+	          event.target.closest("#sidebar-panel-computedview")) {
+	        return;
+	      }
+	      event.preventDefault();
+	      this.searchBox.focus();
+	    });
+	  },
+
+	  get searchSuggestions() {
+	    return this.search.autocompleter;
+	  },
+
+	  _updateSearchResultsLabel: function (event, result) {
+	    let str = "";
+	    if (event !== "search-cleared") {
+	      if (result) {
+	        str = strings.formatStringFromName(
+	          "inspector.searchResultsCount2",
+	          [result.resultsIndex + 1, result.resultsLength], 2);
+	      } else {
+	        str = strings.GetStringFromName("inspector.searchResultsNone");
+	      }
+	    }
+
+	    this.searchResultsLabel.textContent = str;
+	  },
+
+	  get React() {
+	    return this._toolbox.React;
+	  },
+
+	  get ReactDOM() {
+	    return this._toolbox.ReactDOM;
+	  },
+
+	  get browserRequire() {
+	    return this._toolbox.browserRequire;
+	  },
+
+	  /**
+	   * Build the sidebar.
+	   */
+	  setupSidebar: function () {
+	    let tabbox = this.panelDoc.querySelector("#inspector-sidebar");
+	    this.sidebar = new ToolSidebar(tabbox, this, "inspector", {
+	      showAllTabsMenu: true
+	    });
+
+	    let defaultTab = Services.prefs.getCharPref("devtools.inspector.activeSidebar");
+
+	    if (!Services.prefs.getBoolPref("devtools.fontinspector.enabled") &&
+	       defaultTab == "fontinspector") {
+	      defaultTab = "ruleview";
+	    }
+
+	    // Append all side panels
+	    this.sidebar.addExistingTab(
+	      "ruleview",
+	      strings.GetStringFromName("inspector.sidebar.ruleViewTitle"),
+	      defaultTab == "ruleview");
+
+	    this.sidebar.addExistingTab(
+	      "computedview",
+	      strings.GetStringFromName("inspector.sidebar.computedViewTitle"),
+	      defaultTab == "computedview");
+
+	    this._setDefaultSidebar = (event, toolId) => {
+	      Services.prefs.setCharPref("devtools.inspector.activeSidebar", toolId);
+	    };
+
+	    this.sidebar.on("select", this._setDefaultSidebar);
+
+	    this.ruleview = new RuleViewTool(this, this.panelWin);
+	    this.computedview = new ComputedViewTool(this, this.panelWin);
+
+	    if (this.target.form.animationsActor) {
+	      this.sidebar.addFrameTab(
+	        "animationinspector",
+	        strings.GetStringFromName("inspector.sidebar.animationInspectorTitle"),
+	        "chrome://devtools/content/animationinspector/animation-inspector.xhtml",
+	        defaultTab == "animationinspector");
+	    }
+
+	    if (Services.prefs.getBoolPref("devtools.fontinspector.enabled") &&
+	        this.canGetUsedFontFaces) {
+	      this.sidebar.addExistingTab(
+	        "fontinspector",
+	        strings.GetStringFromName("inspector.sidebar.fontInspectorTitle"),
+	        defaultTab == "fontinspector");
+
+	      this.fontInspector = new FontInspector(this, this.panelWin);
+	      this.sidebar.toggleTab(true, "fontinspector");
+	    }
+
+	    this.setupSidebarSize();
+
+	    this.sidebar.show(defaultTab);
+	  },
+
+	  /**
+	   * Sidebar size is currently driven by vbox.inspector-sidebar-container
+	   * element, which is located at the left/bottom side of the side bar splitter.
+	   * Its size is changed by the splitter and stored into preferences.
+	   * As soon as bug 1260552 is fixed and new HTML based splitter in place
+	   * the size can be driven by div.inspector-sidebar element. This element
+	   * represents the ToolSidebar and so, the entire logic related to size
+	   * persistence can be done inside the ToolSidebar.
+	   */
+	  setupSidebarSize: function () {
+	    let sidePaneContainer = this.panelDoc.querySelector(
+	      "#inspector-sidebar-container");
+
+	    this.sidebar.on("show", () => {
+	      try {
+	        sidePaneContainer.width = Services.prefs.getIntPref(
+	          "devtools.toolsidebar-width.inspector");
+	        sidePaneContainer.height = Services.prefs.getIntPref(
+	          "devtools.toolsidebar-height.inspector");
+	      } catch (e) {
+	        // The default width is the min-width set in CSS
+	        // for #inspector-sidebar-container
+	        // Set width and height of the sidebar container. Only one
+	        // value is really useful at a time depending on the current
+	        // toolbox orientation and having both doesn't break anything.
+	        sidePaneContainer.width = 450;
+	        sidePaneContainer.height = 450;
+	      }
+	    });
+
+	    this.sidebar.on("hide", () => {
+	      Services.prefs.setIntPref("devtools.toolsidebar-width.inspector",
+	        sidePaneContainer.width);
+	      Services.prefs.setIntPref("devtools.toolsidebar-height.inspector",
+	        sidePaneContainer.height);
+	    });
+
+	    this.sidebar.on("destroy", () => {
+	      Services.prefs.setIntPref("devtools.toolsidebar-width.inspector",
+	        sidePaneContainer.width);
+	      Services.prefs.setIntPref("devtools.toolsidebar-height.inspector",
+	        sidePaneContainer.height);
+	    });
+	  },
+
+	  setupToolbar: function () {
+	    // Setup the sidebar toggle button.
+	    let SidebarToggle = this.React.createFactory(this.browserRequire(
+	      "devtools/client/shared/components/sidebar-toggle"));
+
+	    let sidebarToggle = SidebarToggle({
+	      onClick: this.onPaneToggleButtonClicked,
+	      collapsed: false,
+	      expandPaneTitle: strings.GetStringFromName("inspector.expandPane"),
+	      collapsePaneTitle: strings.GetStringFromName("inspector.collapsePane"),
+	    });
+
+	    let parentBox = this.panelDoc.getElementById("inspector-sidebar-toggle-box");
+	    this._sidebarToggle = this.ReactDOM.render(sidebarToggle, parentBox);
+
+	    // Setup the add-node button.
+	    this.addNode = this.addNode.bind(this);
+	    this.addNodeButton = this.panelDoc.getElementById("inspector-element-add-button");
+	    this.addNodeButton.addEventListener("click", this.addNode);
+
+	    // Setup the eye-dropper icon.
+	    this.toolbox.target.actorHasMethod("inspector", "pickColorFromPage").then(value => {
+	      if (!value) {
+	        return;
+	      }
+
+	      this.onEyeDropperDone = this.onEyeDropperDone.bind(this);
+	      this.onEyeDropperButtonClicked = this.onEyeDropperButtonClicked.bind(this);
+	      this.eyeDropperButton = this.panelDoc.getElementById("inspector-eyedropper-toggle");
+	      this.eyeDropperButton.style.display = "initial";
+	      this.eyeDropperButton.addEventListener("click", this.onEyeDropperButtonClicked);
+	    }, e => console.error(e));
+	  },
+
+	  teardownToolbar: function () {
+	    if (this.addNodeButton) {
+	      this.addNodeButton.removeEventListener("click", this.addNode);
+	      this.addNodeButton = null;
+	    }
+
+	    if (this.eyeDropperButton) {
+	      this.eyeDropperButton.removeEventListener("click", this.onEyeDropperButtonClicked);
+	      this.eyeDropperButton = null;
+	    }
+	  },
+
+	  /**
+	   * Reset the inspector on new root mutation.
+	   */
+	  onNewRoot: function () {
+	    this._defaultNode = null;
+	    this.selection.setNodeFront(null);
+	    this._destroyMarkup();
+	    this.isDirty = false;
+
+	    let onNodeSelected = defaultNode => {
+	      // Cancel this promise resolution as a new one had
+	      // been queued up.
+	      if (this._pendingSelection != onNodeSelected) {
+	        return;
+	      }
+	      this._pendingSelection = null;
+	      this.selection.setNodeFront(defaultNode, "navigateaway");
+
+	      this._initMarkup();
+	      this.once("markuploaded", () => {
+	        if (!this.markup) {
+	          return;
+	        }
+	        this.markup.expandNode(this.selection.nodeFront);
+	        this.emit("new-root");
+	      });
+	    };
+	    this._pendingSelection = onNodeSelected;
+	    this._getDefaultNodeForSelection()
+	        .then(onNodeSelected, this._handleRejectionIfNotDestroyed);
+	  },
+
+	  _selectionCssSelector: null,
+
+	  /**
+	   * Set the currently selected node unique css selector.
+	   * Will store the current target url along with it to allow pre-selection at
+	   * reload
+	   */
+	  set selectionCssSelector(cssSelector = null) {
+	    if (this._panelDestroyer) {
+	      return;
+	    }
+
+	    this._selectionCssSelector = {
+	      selector: cssSelector,
+	      url: this._target.url
+	    };
+	  },
+
+	  /**
+	   * Get the current selection unique css selector if any, that is, if a node
+	   * is actually selected and that node has been selected while on the same url
+	   */
+	  get selectionCssSelector() {
+	    if (this._selectionCssSelector &&
+	        this._selectionCssSelector.url === this._target.url) {
+	      return this._selectionCssSelector.selector;
+	    }
+	    return null;
+	  },
+
+	  /**
+	   * Can a new HTML element be inserted into the currently selected element?
+	   * @return {Boolean}
+	   */
+	  canAddHTMLChild: function () {
+	    let selection = this.selection;
+
+	    // Don't allow to insert an element into these elements. This should only
+	    // contain elements where walker.insertAdjacentHTML has no effect.
+	    let invalidTagNames = ["html", "iframe"];
+
+	    return selection.isHTMLNode() &&
+	           selection.isElementNode() &&
+	           !selection.isPseudoElementNode() &&
+	           !selection.isAnonymousNode() &&
+	           invalidTagNames.indexOf(
+	            selection.nodeFront.nodeName.toLowerCase()) === -1;
+	  },
+
+	  /**
+	   * When a new node is selected.
+	   */
+	  onNewSelection: function (event, value, reason) {
+	    if (reason === "selection-destroy") {
+	      return;
+	    }
+
+	    // Wait for all the known tools to finish updating and then let the
+	    // client know.
+	    let selection = this.selection.nodeFront;
+
+	    // Update the state of the add button in the toolbar depending on the
+	    // current selection.
+	    let btn = this.panelDoc.querySelector("#inspector-element-add-button");
+	    if (this.canAddHTMLChild()) {
+	      btn.removeAttribute("disabled");
+	    } else {
+	      btn.setAttribute("disabled", "true");
+	    }
+
+	    // On any new selection made by the user, store the unique css selector
+	    // of the selected node so it can be restored after reload of the same page
+	    if (this.canGetUniqueSelector &&
+	        this.selection.isElementNode()) {
+	      selection.getUniqueSelector().then(selector => {
+	        this.selectionCssSelector = selector;
+	      }, this._handleRejectionIfNotDestroyed);
+	    }
+
+	    let selfUpdate = this.updating("inspector-panel");
+	    executeSoon(() => {
+	      try {
+	        selfUpdate(selection);
+	      } catch (ex) {
+	        console.error(ex);
+	      }
+	    });
+	  },
+
+	  /**
+	   * Delay the "inspector-updated" notification while a tool
+	   * is updating itself.  Returns a function that must be
+	   * invoked when the tool is done updating with the node
+	   * that the tool is viewing.
+	   */
+	  updating: function (name) {
+	    if (this._updateProgress && this._updateProgress.node != this.selection.nodeFront) {
+	      this.cancelUpdate();
+	    }
+
+	    if (!this._updateProgress) {
+	      // Start an update in progress.
+	      let self = this;
+	      this._updateProgress = {
+	        node: this.selection.nodeFront,
+	        outstanding: new Set(),
+	        checkDone: function () {
+	          if (this !== self._updateProgress) {
+	            return;
+	          }
+	          // Cancel update if there is no `selection` anymore.
+	          // It can happen if the inspector panel is already destroyed.
+	          if (!self.selection || (this.node !== self.selection.nodeFront)) {
+	            self.cancelUpdate();
+	            return;
+	          }
+	          if (this.outstanding.size !== 0) {
+	            return;
+	          }
+
+	          self._updateProgress = null;
+	          self.emit("inspector-updated", name);
+	        },
+	      };
+	    }
+
+	    let progress = this._updateProgress;
+	    let done = function () {
+	      progress.outstanding.delete(done);
+	      progress.checkDone();
+	    };
+	    progress.outstanding.add(done);
+	    return done;
+	  },
+
+	  /**
+	   * Cancel notification of inspector updates.
+	   */
+	  cancelUpdate: function () {
+	    this._updateProgress = null;
+	  },
+
+	  /**
+	   * When a new node is selected, before the selection has changed.
+	   */
+	  onBeforeNewSelection: function (event, node) {
+	    if (this.breadcrumbs.indexOf(node) == -1) {
+	      // only clear locks if we'd have to update breadcrumbs
+	      this.clearPseudoClasses();
+	    }
+	  },
+
+	  /**
+	   * When a node is deleted, select its parent node or the defaultNode if no
+	   * parent is found (may happen when deleting an iframe inside which the
+	   * node was selected).
+	   */
+	  onDetached: function (event, parentNode) {
+	    this.breadcrumbs.cutAfter(this.breadcrumbs.indexOf(parentNode));
+	    this.selection.setNodeFront(parentNode ? parentNode : this._defaultNode, "detached");
+	  },
+
+	  /**
+	   * Destroy the inspector.
+	   */
+	  destroy: function () {
+	    if (this._panelDestroyer) {
+	      return this._panelDestroyer;
+	    }
+
+	    if (this.walker) {
+	      this.walker.off("new-root", this.onNewRoot);
+	      this.pageStyle = null;
+	    }
+
+	    this.cancelUpdate();
+
+	    this.target.off("will-navigate", this._onBeforeNavigate);
+
+	    this.target.off("thread-paused", this.updateDebuggerPausedWarning);
+	    this.target.off("thread-resumed", this.updateDebuggerPausedWarning);
+	    this._toolbox.off("select", this.updateDebuggerPausedWarning);
+
+	    if (this.ruleview) {
+	      this.ruleview.destroy();
+	    }
+
+	    if (this.computedview) {
+	      this.computedview.destroy();
+	    }
+
+	    if (this.fontInspector) {
+	      this.fontInspector.destroy();
+	    }
+
+	    let cssPropertiesDestroyer = this._cssPropertiesLoaded.then(({front}) => {
+	      if (front) {
+	        front.destroy();
+	      }
+	    });
+
+	    this.sidebar.off("select", this._setDefaultSidebar);
+	    let sidebarDestroyer = this.sidebar.destroy();
+	    this.sidebar = null;
+
+	    this.teardownToolbar();
+	    this.breadcrumbs.destroy();
+	    this.selection.off("new-node-front", this.onNewSelection);
+	    this.selection.off("before-new-node", this.onBeforeNewSelection);
+	    this.selection.off("before-new-node-front", this.onBeforeNewSelection);
+	    this.selection.off("detached-front", this.onDetached);
+	    let markupDestroyer = this._destroyMarkup();
+	    this.panelWin.inspector = null;
+	    this.target = null;
+	    this.panelDoc = null;
+	    this.panelWin = null;
+	    this.breadcrumbs = null;
+	    this._toolbox = null;
+	    this.search.destroy();
+	    this.search = null;
+	    this.searchBox = null;
+
+	    this._panelDestroyer = promise.all([
+	      sidebarDestroyer,
+	      markupDestroyer,
+	      cssPropertiesDestroyer
+	    ]);
+
+	    return this._panelDestroyer;
+	  },
+
+	  /**
+	   * Returns the clipboard content if it is appropriate for pasting
+	   * into the current node's outer HTML, otherwise returns null.
+	   */
+	  _getClipboardContentForPaste: function () {
+	    let flavors = clipboard.currentFlavors;
+	    if (flavors.indexOf("text") != -1 ||
+	        (flavors.indexOf("html") != -1 && flavors.indexOf("image") == -1)) {
+	      let content = clipboard.get();
+	      if (content && content.trim().length > 0) {
+	        return content;
+	      }
+	    }
+	    return null;
+	  },
+
+	  _onContextMenu: function (e) {
+	    e.preventDefault();
+	    this._openMenu({
+	      screenX: e.screenX,
+	      screenY: e.screenY,
+	      target: e.target,
+	    });
+	  },
+
+	  _openMenu: function ({ target, screenX = 0, screenY = 0 } = { }) {
+	    let markupContainer = this.markup.getContainer(this.selection.nodeFront);
+
+	    this.contextMenuTarget = target;
+	    this.nodeMenuTriggerInfo = markupContainer &&
+	      markupContainer.editor.getInfoAtNode(target);
+
+	    let isSelectionElement = this.selection.isElementNode() &&
+	                             !this.selection.isPseudoElementNode();
+	    let isEditableElement = isSelectionElement &&
+	                            !this.selection.isAnonymousNode();
+	    let isDuplicatableElement = isSelectionElement &&
+	                                !this.selection.isAnonymousNode() &&
+	                                !this.selection.isRoot();
+	    let isScreenshotable = isSelectionElement &&
+	                           this.canGetUniqueSelector &&
+	                           this.selection.nodeFront.isTreeDisplayed;
+
+	    let menu = new Menu();
+	    menu.append(new MenuItem({
+	      id: "node-menu-edithtml",
+	      label: strings.GetStringFromName("inspectorHTMLEdit.label"),
+	      accesskey: strings.GetStringFromName("inspectorHTMLEdit.accesskey"),
+	      disabled: !isEditableElement || !this.isOuterHTMLEditable,
+	      click: () => this.editHTML(),
+	    }));
+	    menu.append(new MenuItem({
+	      id: "node-menu-add",
+	      label: strings.GetStringFromName("inspectorAddNode.label"),
+	      accesskey: strings.GetStringFromName("inspectorAddNode.accesskey"),
+	      disabled: !this.canAddHTMLChild(),
+	      click: () => this.addNode(),
+	    }));
+	    menu.append(new MenuItem({
+	      id: "node-menu-duplicatenode",
+	      label: strings.GetStringFromName("inspectorDuplicateNode.label"),
+	      hidden: !this._supportsDuplicateNode,
+	      disabled: !isDuplicatableElement,
+	      click: () => this.duplicateNode(),
+	    }));
+	    menu.append(new MenuItem({
+	      id: "node-menu-delete",
+	      label: strings.GetStringFromName("inspectorHTMLDelete.label"),
+	      accesskey: strings.GetStringFromName("inspectorHTMLDelete.accesskey"),
+	      disabled: !isEditableElement,
+	      click: () => this.deleteNode(),
+	    }));
+
+	    menu.append(new MenuItem({
+	      label: strings.GetStringFromName("inspectorAttributesSubmenu.label"),
+	      accesskey:
+	        strings.GetStringFromName("inspectorAttributesSubmenu.accesskey"),
+	      submenu: this._getAttributesSubmenu(isEditableElement),
+	    }));
+
+	    menu.append(new MenuItem({
+	      type: "separator",
+	    }));
+
+	    // Set the pseudo classes
+	    for (let name of ["hover", "active", "focus"]) {
+	      let menuitem = new MenuItem({
+	        id: "node-menu-pseudo-" + name,
+	        label: name,
+	        type: "checkbox",
+	        click: this.togglePseudoClass.bind(this, ":" + name),
+	      });
+
+	      if (isSelectionElement) {
+	        let checked = this.selection.nodeFront.hasPseudoClassLock(":" + name);
+	        menuitem.checked = checked;
+	      } else {
+	        menuitem.disabled = true;
+	      }
+
+	      menu.append(menuitem);
+	    }
+
+	    menu.append(new MenuItem({
+	      type: "separator",
+	    }));
+
+	    let copySubmenu = new Menu();
+	    copySubmenu.append(new MenuItem({
+	      id: "node-menu-copyinner",
+	      label: strings.GetStringFromName("inspectorCopyInnerHTML.label"),
+	      accesskey: strings.GetStringFromName("inspectorCopyInnerHTML.accesskey"),
+	      disabled: !isSelectionElement,
+	      click: () => this.copyInnerHTML(),
+	    }));
+	    copySubmenu.append(new MenuItem({
+	      id: "node-menu-copyouter",
+	      label: strings.GetStringFromName("inspectorCopyOuterHTML.label"),
+	      accesskey: strings.GetStringFromName("inspectorCopyOuterHTML.accesskey"),
+	      disabled: !isSelectionElement,
+	      click: () => this.copyOuterHTML(),
+	    }));
+	    copySubmenu.append(new MenuItem({
+	      id: "node-menu-copyuniqueselector",
+	      label: strings.GetStringFromName("inspectorCopyCSSSelector.label"),
+	      accesskey:
+	        strings.GetStringFromName("inspectorCopyCSSSelector.accesskey"),
+	      disabled: !isSelectionElement,
+	      hidden: !this.canGetUniqueSelector,
+	      click: () => this.copyUniqueSelector(),
+	    }));
+	    copySubmenu.append(new MenuItem({
+	      id: "node-menu-copyimagedatauri",
+	      label: strings.GetStringFromName("inspectorImageDataUri.label"),
+	      disabled: !isSelectionElement || !markupContainer ||
+	                !markupContainer.isPreviewable(),
+	      click: () => this.copyImageDataUri(),
+	    }));
+
+	    menu.append(new MenuItem({
+	      label: strings.GetStringFromName("inspectorCopyHTMLSubmenu.label"),
+	      submenu: copySubmenu,
+	    }));
+
+	    menu.append(new MenuItem({
+	      label: strings.GetStringFromName("inspectorPasteHTMLSubmenu.label"),
+	      submenu: this._getPasteSubmenu(isEditableElement),
+	    }));
+
+	    menu.append(new MenuItem({
+	      type: "separator",
+	    }));
+
+	    let isNodeWithChildren = this.selection.isNode() &&
+	                             markupContainer.hasChildren;
+	    menu.append(new MenuItem({
+	      id: "node-menu-expand",
+	      label: strings.GetStringFromName("inspectorExpandNode.label"),
+	      disabled: !isNodeWithChildren,
+	      click: () => this.expandNode(),
+	    }));
+	    menu.append(new MenuItem({
+	      id: "node-menu-collapse",
+	      label: strings.GetStringFromName("inspectorCollapseNode.label"),
+	      disabled: !isNodeWithChildren || !markupContainer.expanded,
+	      click: () => this.collapseNode(),
+	    }));
+
+	    menu.append(new MenuItem({
+	      type: "separator",
+	    }));
+
+	    menu.append(new MenuItem({
+	      id: "node-menu-scrollnodeintoview",
+	      label: strings.GetStringFromName("inspectorScrollNodeIntoView.label"),
+	      accesskey:
+	        strings.GetStringFromName("inspectorScrollNodeIntoView.accesskey"),
+	      hidden: !this._supportsScrollIntoView,
+	      disabled: !isSelectionElement,
+	      click: () => this.scrollNodeIntoView(),
+	    }));
+	    menu.append(new MenuItem({
+	      id: "node-menu-screenshotnode",
+	      label: strings.GetStringFromName("inspectorScreenshotNode.label"),
+	      disabled: !isScreenshotable,
+	      click: () => this.screenshotNode(),
+	    }));
+	    menu.append(new MenuItem({
+	      id: "node-menu-useinconsole",
+	      label: strings.GetStringFromName("inspectorUseInConsole.label"),
+	      click: () => this.useInConsole(),
+	    }));
+	    menu.append(new MenuItem({
+	      id: "node-menu-showdomproperties",
+	      label: strings.GetStringFromName("inspectorShowDOMProperties.label"),
+	      click: () => this.showDOMProperties(),
+	    }));
+
+	    let nodeLinkMenuItems = this._getNodeLinkMenuItems();
+	    if (nodeLinkMenuItems.filter(item => item.visible).length > 0) {
+	      menu.append(new MenuItem({
+	        id: "node-menu-link-separator",
+	        type: "separator",
+	      }));
+	    }
+
+	    for (let menuitem of nodeLinkMenuItems) {
+	      menu.append(menuitem);
+	    }
+
+	    menu.popup(screenX, screenY, this._toolbox);
+	    return menu;
+	  },
+
+	  _getPasteSubmenu: function (isEditableElement) {
+	    let isPasteable = isEditableElement && this._getClipboardContentForPaste();
+	    let disableAdjacentPaste = !isPasteable ||
+	          !this.canPasteInnerOrAdjacentHTML || this.selection.isRoot() ||
+	          this.selection.isBodyNode() || this.selection.isHeadNode();
+	    let disableFirstLastPaste = !isPasteable ||
+	          !this.canPasteInnerOrAdjacentHTML || (this.selection.isHTMLNode() &&
+	          this.selection.isRoot());
+
+	    let pasteSubmenu = new Menu();
+	    pasteSubmenu.append(new MenuItem({
+	      id: "node-menu-pasteinnerhtml",
+	      label: strings.GetStringFromName("inspectorPasteInnerHTML.label"),
+	      accesskey: strings.GetStringFromName("inspectorPasteInnerHTML.accesskey"),
+	      disabled: !isPasteable || !this.canPasteInnerOrAdjacentHTML,
+	      click: () => this.pasteInnerHTML(),
+	    }));
+	    pasteSubmenu.append(new MenuItem({
+	      id: "node-menu-pasteouterhtml",
+	      label: strings.GetStringFromName("inspectorPasteOuterHTML.label"),
+	      accesskey: strings.GetStringFromName("inspectorPasteOuterHTML.accesskey"),
+	      disabled: !isPasteable || !this.isOuterHTMLEditable,
+	      click: () => this.pasteOuterHTML(),
+	    }));
+	    pasteSubmenu.append(new MenuItem({
+	      id: "node-menu-pastebefore",
+	      label: strings.GetStringFromName("inspectorHTMLPasteBefore.label"),
+	      accesskey:
+	        strings.GetStringFromName("inspectorHTMLPasteBefore.accesskey"),
+	      disabled: disableAdjacentPaste,
+	      click: () => this.pasteAdjacentHTML("beforeBegin"),
+	    }));
+	    pasteSubmenu.append(new MenuItem({
+	      id: "node-menu-pasteafter",
+	      label: strings.GetStringFromName("inspectorHTMLPasteAfter.label"),
+	      accesskey:
+	        strings.GetStringFromName("inspectorHTMLPasteAfter.accesskey"),
+	      disabled: disableAdjacentPaste,
+	      click: () => this.pasteAdjacentHTML("afterEnd"),
+	    }));
+	    pasteSubmenu.append(new MenuItem({
+	      id: "node-menu-pastefirstchild",
+	      label: strings.GetStringFromName("inspectorHTMLPasteFirstChild.label"),
+	      accesskey:
+	        strings.GetStringFromName("inspectorHTMLPasteFirstChild.accesskey"),
+	      disabled: disableFirstLastPaste,
+	      click: () => this.pasteAdjacentHTML("afterBegin"),
+	    }));
+	    pasteSubmenu.append(new MenuItem({
+	      id: "node-menu-pastelastchild",
+	      label: strings.GetStringFromName("inspectorHTMLPasteLastChild.label"),
+	      accesskey:
+	        strings.GetStringFromName("inspectorHTMLPasteLastChild.accesskey"),
+	      disabled: disableFirstLastPaste,
+	      click: () => this.pasteAdjacentHTML("beforeEnd"),
+	    }));
+
+	    return pasteSubmenu;
+	  },
+
+	  _getAttributesSubmenu: function (isEditableElement) {
+	    let attributesSubmenu = new Menu();
+	    let nodeInfo = this.nodeMenuTriggerInfo;
+	    let isAttributeClicked = isEditableElement && nodeInfo &&
+	                              nodeInfo.type === "attribute";
+
+	    attributesSubmenu.append(new MenuItem({
+	      id: "node-menu-add-attribute",
+	      label: strings.GetStringFromName("inspectorAddAttribute.label"),
+	      accesskey: strings.GetStringFromName("inspectorAddAttribute.accesskey"),
+	      disabled: !isEditableElement,
+	      click: () => this.onAddAttribute(),
+	    }));
+	    attributesSubmenu.append(new MenuItem({
+	      id: "node-menu-edit-attribute",
+	      label: strings.formatStringFromName("inspectorEditAttribute.label",
+	                 [isAttributeClicked ? `"${nodeInfo.name}"` : ""], 1),
+	      accesskey: strings.GetStringFromName("inspectorEditAttribute.accesskey"),
+	      disabled: !isAttributeClicked,
+	      click: () => this.onEditAttribute(),
+	    }));
+
+	    attributesSubmenu.append(new MenuItem({
+	      id: "node-menu-remove-attribute",
+	      label: strings.formatStringFromName("inspectorRemoveAttribute.label",
+	                [isAttributeClicked ? `"${nodeInfo.name}"` : ""], 1),
+	      accesskey:
+	        strings.GetStringFromName("inspectorRemoveAttribute.accesskey"),
+	      disabled: !isAttributeClicked,
+	      click: () => this.onRemoveAttribute(),
+	    }));
+
+	    return attributesSubmenu;
+	  },
+
+	  /**
+	   * Link menu items can be shown or hidden depending on the context and
+	   * selected node, and their labels can vary.
+	   *
+	   * @return {Array} list of visible menu items related to links.
+	   */
+	  _getNodeLinkMenuItems: function () {
+	    let linkFollow = new MenuItem({
+	      id: "node-menu-link-follow",
+	      visible: false,
+	      click: () => this.onFollowLink(),
+	    });
+	    let linkCopy = new MenuItem({
+	      id: "node-menu-link-copy",
+	      visible: false,
+	      click: () => this.onCopyLink(),
+	    });
+
+	    // Get information about the right-clicked node.
+	    let popupNode = this.contextMenuTarget;
+	    if (!popupNode || !popupNode.classList.contains("link")) {
+	      return [linkFollow, linkCopy];
+	    }
+
+	    let type = popupNode.dataset.type;
+	    if (this._supportsResolveRelativeURL &&
+	        (type === "uri" || type === "cssresource" || type === "jsresource")) {
+	      // Links can't be opened in new tabs in the browser toolbox.
+	      if (type === "uri" && !this.target.chrome) {
+	        linkFollow.visible = true;
+	        linkFollow.label = strings.GetStringFromName(
+	          "inspector.menu.openUrlInNewTab.label");
+	      } else if (type === "cssresource") {
+	        linkFollow.visible = true;
+	        linkFollow.label = toolboxStrings.GetStringFromName(
+	          "toolbox.viewCssSourceInStyleEditor.label");
+	      } else if (type === "jsresource") {
+	        linkFollow.visible = true;
+	        linkFollow.label = toolboxStrings.GetStringFromName(
+	          "toolbox.viewJsSourceInDebugger.label");
+	      }
+
+	      linkCopy.visible = true;
+	      linkCopy.label = strings.GetStringFromName(
+	        "inspector.menu.copyUrlToClipboard.label");
+	    } else if (type === "idref") {
+	      linkFollow.visible = true;
+	      linkFollow.label = strings.formatStringFromName(
+	        "inspector.menu.selectElement.label", [popupNode.dataset.link], 1);
+	    }
+
+	    return [linkFollow, linkCopy];
+	  },
+
+	  _initMarkup: function () {
+	    let doc = this.panelDoc;
+
+	    this._markupBox = doc.getElementById("markup-box");
+
+	    // create tool iframe
+	    this._markupFrame = doc.createElement("iframe");
+	    this._markupFrame.setAttribute("flex", "1");
+	    this._markupFrame.setAttribute("tooltip", "aHTMLTooltip");
+	    this._markupFrame.addEventListener("contextmenu", this._onContextMenu, true);
+
+	    // This is needed to enable tooltips inside the iframe document.
+	    this._markupFrame.addEventListener("load", this._onMarkupFrameLoad, true);
+
+	    this._markupBox.setAttribute("collapsed", true);
+	    this._markupBox.appendChild(this._markupFrame);
+	    this._markupFrame.setAttribute("src", "chrome://devtools/content/inspector/markup/markup.xhtml");
+	    this._markupFrame.setAttribute("aria-label",
+	      strings.GetStringFromName("inspector.panelLabel.markupView"));
+	  },
+
+	  _onMarkupFrameLoad: function () {
+	    this._markupFrame.removeEventListener("load", this._onMarkupFrameLoad, true);
+
+	    this._markupFrame.contentWindow.focus();
+
+	    this._markupBox.removeAttribute("collapsed");
+
+	    this.markup = new MarkupView(this, this._markupFrame, this._toolbox.win);
+
+	    this.emit("markuploaded");
+	  },
+
+	  _destroyMarkup: function () {
+	    let destroyPromise;
+
+	    if (this._markupFrame) {
+	      this._markupFrame.removeEventListener("load", this._onMarkupFrameLoad, true);
+	      this._markupFrame.removeEventListener("contextmenu", this._onContextMenu, true);
+	    }
+
+	    if (this.markup) {
+	      destroyPromise = this.markup.destroy();
+	      this.markup = null;
+	    } else {
+	      destroyPromise = promise.resolve();
+	    }
+
+	    if (this._markupFrame) {
+	      this._markupFrame.parentNode.removeChild(this._markupFrame);
+	      this._markupFrame = null;
+	    }
+
+	    this._markupBox = null;
+
+	    return destroyPromise;
+	  },
+
+	  /**
+	   * When the pane toggle button is clicked or pressed, toggle the pane, change the button
+	   * state and tooltip.
+	   */
+	  onPaneToggleButtonClicked: function (e) {
+	    let sidePaneContainer = this.panelDoc.querySelector("#inspector-sidebar-container");
+	    let isVisible = !this._sidebarToggle.state.collapsed;
+
+	    // Make sure the sidebar has width and height attributes before collapsing
+	    // because ViewHelpers needs it.
+	    if (isVisible) {
+	      let rect = sidePaneContainer.getBoundingClientRect();
+	      if (!sidePaneContainer.hasAttribute("width")) {
+	        sidePaneContainer.setAttribute("width", rect.width);
+	      }
+	      // always refresh the height attribute before collapsing, it could have
+	      // been modified by resizing the container.
+	      sidePaneContainer.setAttribute("height", rect.height);
+	    }
+
+	    let onAnimationDone = () => {
+	      if (isVisible) {
+	        this._sidebarToggle.setState({collapsed: true});
+	      } else {
+	        this._sidebarToggle.setState({collapsed: false});
+	      }
+	    };
+
+	    ViewHelpers.togglePane({
+	      visible: !isVisible,
+	      animated: true,
+	      delayed: true,
+	      callback: onAnimationDone
+	    }, sidePaneContainer);
+	  },
+
+	  onEyeDropperButtonClicked: function () {
+	    this.eyeDropperButton.hasAttribute("checked")
+	      ? this.hideEyeDropper()
+	      : this.showEyeDropper();
+	  },
+
+	  startEyeDropperListeners: function () {
+	    this.inspector.once("color-pick-canceled", this.onEyeDropperDone);
+	    this.inspector.once("color-picked", this.onEyeDropperDone);
+	    this.walker.once("new-root", this.onEyeDropperDone);
+	  },
+
+	  stopEyeDropperListeners: function () {
+	    this.inspector.off("color-pick-canceled", this.onEyeDropperDone);
+	    this.inspector.off("color-picked", this.onEyeDropperDone);
+	    this.walker.off("new-root", this.onEyeDropperDone);
+	  },
+
+	  onEyeDropperDone: function () {
+	    this.eyeDropperButton.removeAttribute("checked");
+	    this.stopEyeDropperListeners();
+	  },
+
+	  /**
+	   * Show the eyedropper on the page.
+	   * @return {Promise} resolves when the eyedropper is visible.
+	   */
+	  showEyeDropper: function () {
+	    this.telemetry.toolOpened("toolbareyedropper");
+	    this.eyeDropperButton.setAttribute("checked", "true");
+	    this.startEyeDropperListeners();
+	    return this.inspector.pickColorFromPage({copyOnSelect: true})
+	                         .catch(e => console.error(e));
+	  },
+
+	  /**
+	   * Hide the eyedropper.
+	   * @return {Promise} resolves when the eyedropper is hidden.
+	   */
+	  hideEyeDropper: function () {
+	    this.eyeDropperButton.removeAttribute("checked");
+	    this.stopEyeDropperListeners();
+	    return this.inspector.cancelPickColorFromPage()
+	                         .catch(e => console.error(e));
+	  },
+
+	  /**
+	   * Create a new node as the last child of the current selection, expand the
+	   * parent and select the new node.
+	   */
+	  addNode: Task.async(function* () {
+	    if (!this.canAddHTMLChild()) {
+	      return;
+	    }
+
+	    let html = "<div></div>";
+
+	    // Insert the html and expect a childList markup mutation.
+	    let onMutations = this.once("markupmutation");
+	    let {nodes} = yield this.walker.insertAdjacentHTML(this.selection.nodeFront,
+	                                                       "beforeEnd", html);
+	    yield onMutations;
+
+	    // Select the new node (this will auto-expand its parent).
+	    this.selection.setNodeFront(nodes[0], "node-inserted");
+	  }),
+
+	  /**
+	   * Toggle a pseudo class.
+	   */
+	  togglePseudoClass: function (pseudo) {
+	    if (this.selection.isElementNode()) {
+	      let node = this.selection.nodeFront;
+	      if (node.hasPseudoClassLock(pseudo)) {
+	        return this.walker.removePseudoClassLock(node, pseudo, {parents: true});
+	      }
+
+	      let hierarchical = pseudo == ":hover" || pseudo == ":active";
+	      return this.walker.addPseudoClassLock(node, pseudo, {parents: hierarchical});
+	    }
+	    return promise.resolve();
+	  },
+
+	  /**
+	   * Show DOM properties
+	   */
+	  showDOMProperties: function () {
+	    this._toolbox.openSplitConsole().then(() => {
+	      let panel = this._toolbox.getPanel("webconsole");
+	      let jsterm = panel.hud.jsterm;
+
+	      jsterm.execute("inspect($0)");
+	      jsterm.focus();
+	    });
+	  },
+
+	  /**
+	   * Use in Console.
+	   *
+	   * Takes the currently selected node in the inspector and assigns it to a
+	   * temp variable on the content window.  Also opens the split console and
+	   * autofills it with the temp variable.
+	   */
+	  useInConsole: function () {
+	    this._toolbox.openSplitConsole().then(() => {
+	      let panel = this._toolbox.getPanel("webconsole");
+	      let jsterm = panel.hud.jsterm;
+
+	      let evalString = `{ let i = 0;
+	        while (window.hasOwnProperty("temp" + i) && i < 1000) {
+	          i++;
+	        }
+	        window["temp" + i] = $0;
+	        "temp" + i;
+	      }`;
+
+	      let options = {
+	        selectedNodeActor: this.selection.nodeFront.actorID,
+	      };
+	      jsterm.requestEvaluation(evalString, options).then((res) => {
+	        jsterm.setInputValue(res.result);
+	        this.emit("console-var-ready");
+	      });
+	    });
+	  },
+
+	  /**
+	   * Clear any pseudo-class locks applied to the current hierarchy.
+	   */
+	  clearPseudoClasses: function () {
+	    if (!this.walker) {
+	      return promise.resolve();
+	    }
+	    return this.walker.clearPseudoClassLocks().catch(this._handleRejectionIfNotDestroyed);
+	  },
+
+	  /**
+	   * Edit the outerHTML of the selected Node.
+	   */
+	  editHTML: function () {
+	    if (!this.selection.isNode()) {
+	      return;
+	    }
+	    if (this.markup) {
+	      this.markup.beginEditingOuterHTML(this.selection.nodeFront);
+	    }
+	  },
+
+	  /**
+	   * Paste the contents of the clipboard into the selected Node's outer HTML.
+	   */
+	  pasteOuterHTML: function () {
+	    let content = this._getClipboardContentForPaste();
+	    if (!content) {
+	      return promise.reject("No clipboard content for paste");
+	    }
+
+	    let node = this.selection.nodeFront;
+	    return this.markup.getNodeOuterHTML(node).then(oldContent => {
+	      this.markup.updateNodeOuterHTML(node, content, oldContent);
+	    });
+	  },
+
+	  /**
+	   * Paste the contents of the clipboard into the selected Node's inner HTML.
+	   */
+	  pasteInnerHTML: function () {
+	    let content = this._getClipboardContentForPaste();
+	    if (!content) {
+	      return promise.reject("No clipboard content for paste");
+	    }
+
+	    let node = this.selection.nodeFront;
+	    return this.markup.getNodeInnerHTML(node).then(oldContent => {
+	      this.markup.updateNodeInnerHTML(node, content, oldContent);
+	    });
+	  },
+
+	  /**
+	   * Paste the contents of the clipboard as adjacent HTML to the selected Node.
+	   * @param position The position as specified for Element.insertAdjacentHTML
+	   *        (i.e. "beforeBegin", "afterBegin", "beforeEnd", "afterEnd").
+	   */
+	  pasteAdjacentHTML: function (position) {
+	    let content = this._getClipboardContentForPaste();
+	    if (!content) {
+	      return promise.reject("No clipboard content for paste");
+	    }
+
+	    let node = this.selection.nodeFront;
+	    return this.markup.insertAdjacentHTMLToNode(node, position, content);
+	  },
+
+	  /**
+	   * Copy the innerHTML of the selected Node to the clipboard.
+	   */
+	  copyInnerHTML: function () {
+	    if (!this.selection.isNode()) {
+	      return;
+	    }
+	    this._copyLongString(this.walker.innerHTML(this.selection.nodeFront));
+	  },
+
+	  /**
+	   * Copy the outerHTML of the selected Node to the clipboard.
+	   */
+	  copyOuterHTML: function () {
+	    if (!this.selection.isNode()) {
+	      return;
+	    }
+	    let node = this.selection.nodeFront;
+
+	    switch (node.nodeType) {
+	      case nodeConstants.ELEMENT_NODE :
+	        this._copyLongString(this.walker.outerHTML(node));
+	        break;
+	      case nodeConstants.COMMENT_NODE :
+	        this._getLongString(node.getNodeValue()).then(comment => {
+	          clipboardHelper.copyString("<!--" + comment + "-->");
+	        });
+	        break;
+	      case nodeConstants.DOCUMENT_TYPE_NODE :
+	        clipboardHelper.copyString(node.doctypeString);
+	        break;
+	    }
+	  },
+
+	  /**
+	   * Copy the data-uri for the currently selected image in the clipboard.
+	   */
+	  copyImageDataUri: function () {
+	    let container = this.markup.getContainer(this.selection.nodeFront);
+	    if (container && container.isPreviewable()) {
+	      container.copyImageDataUri();
+	    }
+	  },
+
+	  /**
+	   * Copy the content of a longString (via a promise resolving a LongStringActor) to the clipboard
+	   * @param  {Promise} longStringActorPromise promise expected to resolve a LongStringActor instance
+	   * @return {Promise} promise resolving (with no argument) when the string is sent to the clipboard
+	   */
+	  _copyLongString: function (longStringActorPromise) {
+	    return this._getLongString(longStringActorPromise).then(string => {
+	      clipboardHelper.copyString(string);
+	    }).catch(e => console.error(e));
+	  },
+
+	  /**
+	   * Retrieve the content of a longString (via a promise resolving a LongStringActor)
+	   * @param  {Promise} longStringActorPromise promise expected to resolve a LongStringActor instance
+	   * @return {Promise} promise resolving with the retrieved string as argument
+	   */
+	  _getLongString: function (longStringActorPromise) {
+	    return longStringActorPromise.then(longStringActor => {
+	      return longStringActor.string().then(string => {
+	        longStringActor.release().catch(e => console.error(e));
+	        return string;
+	      });
+	    }).catch(e => console.error(e));
+	  },
+
+	  /**
+	   * Copy a unique selector of the selected Node to the clipboard.
+	   */
+	  copyUniqueSelector: function () {
+	    if (!this.selection.isNode()) {
+	      return;
+	    }
+
+	    this.selection.nodeFront.getUniqueSelector().then((selector) => {
+	      clipboardHelper.copyString(selector);
+	    }).then(null, console.error);
+	  },
+
+	  /**
+	   * Initiate gcli screenshot command on selected node
+	   */
+	  screenshotNode: function () {
+	    CommandUtils.createRequisition(this._target, {
+	      environment: CommandUtils.createEnvironment(this, "_target")
+	    }).then(requisition => {
+	      // Bug 1180314 -  CssSelector might contain white space so need to make sure it is
+	      // passed to screenshot as a single parameter.  More work *might* be needed if
+	      // CssSelector could contain escaped single- or double-quotes, backslashes, etc.
+	      requisition.updateExec("screenshot --selector '" + this.selectionCssSelector + "'");
+	    });
+	  },
+
+	  /**
+	   * Scroll the node into view.
+	   */
+	  scrollNodeIntoView: function () {
+	    if (!this.selection.isNode()) {
+	      return;
+	    }
+
+	    this.selection.nodeFront.scrollIntoView();
+	  },
+
+	  /**
+	   * Duplicate the selected node
+	   */
+	  duplicateNode: function () {
+	    let selection = this.selection;
+	    if (!selection.isElementNode() ||
+	        selection.isRoot() ||
+	        selection.isAnonymousNode() ||
+	        selection.isPseudoElementNode()) {
+	      return;
+	    }
+	    this.walker.duplicateNode(selection.nodeFront).catch(e => console.error(e));
+	  },
+
+	  /**
+	   * Delete the selected node.
+	   */
+	  deleteNode: function () {
+	    if (!this.selection.isNode() ||
+	         this.selection.isRoot()) {
+	      return;
+	    }
+
+	    // If the markup panel is active, use the markup panel to delete
+	    // the node, making this an undoable action.
+	    if (this.markup) {
+	      this.markup.deleteNode(this.selection.nodeFront);
+	    } else {
+	      // remove the node from content
+	      this.walker.removeNode(this.selection.nodeFront);
+	    }
+	  },
+
+	  /**
+	   * Add attribute to node.
+	   * Used for node context menu and shouldn't be called directly.
+	   */
+	  onAddAttribute: function () {
+	    let container = this.markup.getContainer(this.selection.nodeFront);
+	    container.addAttribute();
+	  },
+
+	  /**
+	   * Edit attribute for node.
+	   * Used for node context menu and shouldn't be called directly.
+	   */
+	  onEditAttribute: function () {
+	    let container = this.markup.getContainer(this.selection.nodeFront);
+	    container.editAttribute(this.nodeMenuTriggerInfo.name);
+	  },
+
+	  /**
+	   * Remove attribute from node.
+	   * Used for node context menu and shouldn't be called directly.
+	   */
+	  onRemoveAttribute: function () {
+	    let container = this.markup.getContainer(this.selection.nodeFront);
+	    container.removeAttribute(this.nodeMenuTriggerInfo.name);
+	  },
+
+	  expandNode: function () {
+	    this.markup.expandAll(this.selection.nodeFront);
+	  },
+
+	  collapseNode: function () {
+	    this.markup.collapseNode(this.selection.nodeFront);
+	  },
+
+	  /**
+	   * This method is here for the benefit of the node-menu-link-follow menu item
+	   * in the inspector contextual-menu.
+	   */
+	  onFollowLink: function () {
+	    let type = this.contextMenuTarget.dataset.type;
+	    let link = this.contextMenuTarget.dataset.link;
+
+	    this.followAttributeLink(type, link);
+	  },
+
+	  /**
+	   * Given a type and link found in a node's attribute in the markup-view,
+	   * attempt to follow that link (which may result in opening a new tab, the
+	   * style editor or debugger).
+	   */
+	  followAttributeLink: function (type, link) {
+	    if (!type || !link) {
+	      return;
+	    }
+
+	    if (type === "uri" || type === "cssresource" || type === "jsresource") {
+	      // Open link in a new tab.
+	      // When the inspector menu was setup on click (see _getNodeLinkMenuItems), we
+	      // already checked that resolveRelativeURL existed.
+	      this.inspector.resolveRelativeURL(
+	        link, this.selection.nodeFront).then(url => {
+	          if (type === "uri") {
+	            let browserWin = this.target.tab.ownerDocument.defaultView;
+	            browserWin.openUILinkIn(url, "tab");
+	          } else if (type === "cssresource") {
+	            return this.toolbox.viewSourceInStyleEditor(url);
+	          } else if (type === "jsresource") {
+	            return this.toolbox.viewSourceInDebugger(url);
+	          }
+	          return null;
+	        }).catch(e => console.error(e));
+	    } else if (type == "idref") {
+	      // Select the node in the same document.
+	      this.walker.document(this.selection.nodeFront).then(doc => {
+	        return this.walker.querySelector(doc, "#" + CSS.escape(link)).then(node => {
+	          if (!node) {
+	            this.emit("idref-attribute-link-failed");
+	            return;
+	          }
+	          this.selection.setNodeFront(node);
+	        });
+	      }).catch(e => console.error(e));
+	    }
+	  },
+
+	  /**
+	   * This method is here for the benefit of the node-menu-link-copy menu item
+	   * in the inspector contextual-menu.
+	   */
+	  onCopyLink: function () {
+	    let link = this.contextMenuTarget.dataset.link;
+
+	    this.copyAttributeLink(link);
+	  },
+
+	  /**
+	   * This method is here for the benefit of copying links.
+	   */
+	  copyAttributeLink: function (link) {
+	    // When the inspector menu was setup on click (see _getNodeLinkMenuItems), we
+	    // already checked that resolveRelativeURL existed.
+	    this.inspector.resolveRelativeURL(link, this.selection.nodeFront).then(url => {
+	      clipboardHelper.copyString(url);
+	    }, console.error);
+	  }
+	};
+
+
+/***/ }
+/******/ ]);
\ No newline at end of file
diff --git a/devtools/client/inspector/inspector-panel.js b/devtools/client/inspector/inspector-panel.js
--- a/devtools/client/inspector/inspector-panel.js
+++ b/devtools/client/inspector/inspector-panel.js
@@ -44,16 +44,18 @@ loader.lazyGetter(this, "strings", () =>
 });
 loader.lazyGetter(this, "toolboxStrings", () => {
   return Services.strings.createBundle("chrome://devtools/locale/toolbox.properties");
 });
 loader.lazyGetter(this, "clipboardHelper", () => {
   return Cc["@mozilla.org/widget/clipboardhelper;1"].getService(Ci.nsIClipboardHelper);
 });
 
+
+
 /**
  * Represents an open instance of the Inspector for a tab.
  * The inspector controls the breadcrumbs, the markup view, and the sidebar
  * (computed view, rule view, font view and layout view).
  *
  * Events:
  * - ready
  *      Fired when the inspector panel is opened for the first time and ready to
@@ -593,23 +595,23 @@ InspectorPanel.prototype = {
 
   _selectionCssSelector: null,
 
   /**
    * Set the currently selected node unique css selector.
    * Will store the current target url along with it to allow pre-selection at
    * reload
    */
-  set selectionCssSelector(cssSelector = null) {
+  set selectionCssSelector(cssSelector) {
     if (this._panelDestroyer) {
       return;
     }
 
     this._selectionCssSelector = {
-      selector: cssSelector,
+      selector: cssSelector || null,
       url: this._target.url
     };
   },
 
   /**
    * Get the current selection unique css selector if any, that is, if a node
    * is actually selected and that node has been selected while on the same url
    */
diff --git a/devtools/client/inspector/inspector.bundle.js b/devtools/client/inspector/inspector.bundle.js
new file mode 100644
--- /dev/null
+++ b/devtools/client/inspector/inspector.bundle.js
@@ -0,0 +1,8126 @@
+/******/ (function(modules) { // webpackBootstrap
+/******/ 	// The module cache
+/******/ 	var installedModules = {};
+
+/******/ 	// The require function
+/******/ 	function __webpack_require__(moduleId) {
+
+/******/ 		// Check if module is in cache
+/******/ 		if(installedModules[moduleId])
+/******/ 			return installedModules[moduleId].exports;
+
+/******/ 		// Create a new module (and put it into the cache)
+/******/ 		var module = installedModules[moduleId] = {
+/******/ 			exports: {},
+/******/ 			id: moduleId,
+/******/ 			loaded: false
+/******/ 		};
+
+/******/ 		// Execute the module function
+/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
+
+/******/ 		// Flag the module as loaded
+/******/ 		module.loaded = true;
+
+/******/ 		// Return the exports of the module
+/******/ 		return module.exports;
+/******/ 	}
+
+
+/******/ 	// expose the modules object (__webpack_modules__)
+/******/ 	__webpack_require__.m = modules;
+
+/******/ 	// expose the module cache
+/******/ 	__webpack_require__.c = installedModules;
+
+/******/ 	// __webpack_public_path__
+/******/ 	__webpack_require__.p = "";
+
+/******/ 	// Load entry module and return exports
+/******/ 	return __webpack_require__(0);
+/******/ })
+/************************************************************************/
+/******/ ({
+
+/***/ 0:
+/***/ function(module, exports, __webpack_require__) {
+
+	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
+	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+	/* This Source Code Form is subject to the terms of the Mozilla Public
+	 * License, v. 2.0. If a copy of the MPL was not distributed with this
+	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+	/* Experimenting with 100 char long lines */
+	/* eslint max-len: [2, 100, 2, {ignoreUrls: true, "ignorePattern": "\\s*require\\s*\\(|^\\s*loader\\.lazy|-\\*-"}] */ // eslint-disable-line
+
+	"use strict";
+
+	/* eslint-disable mozilla/reject-some-requires */
+
+	var _require = __webpack_require__(1);
+
+	var Cc = _require.Cc;
+	var Ci = _require.Ci;
+	/* eslint-enable mozilla/reject-some-requires */
+
+	var Services = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"Services\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
+	var promise = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"promise\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
+	var defer = __webpack_require__(2);
+	var EventEmitter = __webpack_require__(3);
+	var clipboard = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"sdk/clipboard\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
+
+	var _require2 = __webpack_require__(177);
+
+	var executeSoon = _require2.executeSoon;
+
+	var _require3 = __webpack_require__(180);
+
+	var KeyShortcuts = _require3.KeyShortcuts;
+
+	var _require4 = __webpack_require__(181);
+
+	var Task = _require4.Task;
+
+	var _require5 = __webpack_require__(182);
+
+	var initCssProperties = _require5.initCssProperties;
+
+	var nodeConstants = __webpack_require__(183);
+	var Telemetry = __webpack_require__(184);
+
+	var Menu = __webpack_require__(185);
+	var MenuItem = __webpack_require__(186);
+
+	loader.lazyRequireGetter(undefined, "CSS", "CSS");
+
+	loader.lazyRequireGetter(undefined, "CommandUtils", "devtools/client/shared/developer-toolbar", true);
+	loader.lazyRequireGetter(undefined, "ComputedViewTool", "devtools/client/inspector/computed/computed", true);
+	loader.lazyRequireGetter(undefined, "FontInspector", "devtools/client/inspector/fonts/fonts", true);
+	loader.lazyRequireGetter(undefined, "HTMLBreadcrumbs", "devtools/client/inspector/breadcrumbs", true);
+	loader.lazyRequireGetter(undefined, "InspectorSearch", "devtools/client/inspector/inspector-search", true);
+	loader.lazyRequireGetter(undefined, "MarkupView", "devtools/client/inspector/markup/markup", true);
+	loader.lazyRequireGetter(undefined, "RuleViewTool", "devtools/client/inspector/rules/rules", true);
+	loader.lazyRequireGetter(undefined, "ToolSidebar", "devtools/client/inspector/toolsidebar", true);
+	loader.lazyRequireGetter(undefined, "ViewHelpers", "devtools/client/shared/widgets/view-helpers", true);
+
+	loader.lazyGetter(undefined, "strings", function () {
+	  return Services.strings.createBundle("chrome://devtools/locale/inspector.properties");
+	});
+	loader.lazyGetter(undefined, "toolboxStrings", function () {
+	  return Services.strings.createBundle("chrome://devtools/locale/toolbox.properties");
+	});
+	loader.lazyGetter(undefined, "clipboardHelper", function () {
+	  return Cc["@mozilla.org/widget/clipboardhelper;1"].getService(Ci.nsIClipboardHelper);
+	});
+
+	/**
+	 * Represents an open instance of the Inspector for a tab.
+	 * The inspector controls the breadcrumbs, the markup view, and the sidebar
+	 * (computed view, rule view, font view and layout view).
+	 *
+	 * Events:
+	 * - ready
+	 *      Fired when the inspector panel is opened for the first time and ready to
+	 *      use
+	 * - new-root
+	 *      Fired after a new root (navigation to a new page) event was fired by
+	 *      the walker, and taken into account by the inspector (after the markup
+	 *      view has been reloaded)
+	 * - markuploaded
+	 *      Fired when the markup-view frame has loaded
+	 * - breadcrumbs-updated
+	 *      Fired when the breadcrumb widget updates to a new node
+	 * - layoutview-updated
+	 *      Fired when the layoutview (box model) updates to a new node
+	 * - markupmutation
+	 *      Fired after markup mutations have been processed by the markup-view
+	 * - computed-view-refreshed
+	 *      Fired when the computed rules view updates to a new node
+	 * - computed-view-property-expanded
+	 *      Fired when a property is expanded in the computed rules view
+	 * - computed-view-property-collapsed
+	 *      Fired when a property is collapsed in the computed rules view
+	 * - computed-view-sourcelinks-updated
+	 *      Fired when the stylesheet source links have been updated (when switching
+	 *      to source-mapped files)
+	 * - computed-view-filtered
+	 *      Fired when the computed rules view is filtered
+	 * - rule-view-refreshed
+	 *      Fired when the rule view updates to a new node
+	 * - rule-view-sourcelinks-updated
+	 *      Fired when the stylesheet source links have been updated (when switching
+	 *      to source-mapped files)
+	 */
+	function InspectorPanel(iframeWindow, toolbox) {
+	  this._toolbox = toolbox;
+	  this._target = toolbox._target;
+	  this.panelDoc = iframeWindow.document;
+	  this.panelWin = iframeWindow;
+	  this.panelWin.inspector = this;
+
+	  this.telemetry = new Telemetry();
+
+	  this.nodeMenuTriggerInfo = null;
+
+	  this._handleRejectionIfNotDestroyed = this._handleRejectionIfNotDestroyed.bind(this);
+	  this._onBeforeNavigate = this._onBeforeNavigate.bind(this);
+	  this.onNewRoot = this.onNewRoot.bind(this);
+	  this._onContextMenu = this._onContextMenu.bind(this);
+	  this._updateSearchResultsLabel = this._updateSearchResultsLabel.bind(this);
+	  this.onNewSelection = this.onNewSelection.bind(this);
+	  this.onBeforeNewSelection = this.onBeforeNewSelection.bind(this);
+	  this.onDetached = this.onDetached.bind(this);
+	  this.onPaneToggleButtonClicked = this.onPaneToggleButtonClicked.bind(this);
+	  this._onMarkupFrameLoad = this._onMarkupFrameLoad.bind(this);
+
+	  this._target.on("will-navigate", this._onBeforeNavigate);
+	  this._detectingActorFeatures = this._detectActorFeatures();
+
+	  EventEmitter.decorate(this);
+	}
+
+	exports.InspectorPanel = InspectorPanel;
+
+	InspectorPanel.prototype = {
+	  /**
+	   * open is effectively an asynchronous constructor
+	   */
+	  open: Task.async(regeneratorRuntime.mark(function _callee() {
+	    var defaultSelection;
+	    return regeneratorRuntime.wrap(function _callee$(_context) {
+	      while (1) {
+	        switch (_context.prev = _context.next) {
+	          case 0:
+	            this._cssPropertiesLoaded = initCssProperties(this.toolbox);
+	            _context.next = 3;
+	            return this._cssPropertiesLoaded;
+
+	          case 3:
+	            _context.next = 5;
+	            return this.target.makeRemote();
+
+	          case 5:
+	            _context.next = 7;
+	            return this._getPageStyle();
+
+	          case 7:
+	            _context.next = 9;
+	            return this._getDefaultNodeForSelection();
+
+	          case 9:
+	            defaultSelection = _context.sent;
+	            _context.next = 12;
+	            return this._deferredOpen(defaultSelection);
+
+	          case 12:
+	            return _context.abrupt("return", _context.sent);
+
+	          case 13:
+	          case "end":
+	            return _context.stop();
+	        }
+	      }
+	    }, _callee, this);
+	  })),
+
+	  get toolbox() {
+	    return this._toolbox;
+	  },
+
+	  get inspector() {
+	    return this._toolbox.inspector;
+	  },
+
+	  get walker() {
+	    return this._toolbox.walker;
+	  },
+
+	  get selection() {
+	    return this._toolbox.selection;
+	  },
+
+	  get isOuterHTMLEditable() {
+	    return this._target.client.traits.editOuterHTML;
+	  },
+
+	  get hasUrlToImageDataResolver() {
+	    return this._target.client.traits.urlToImageDataResolver;
+	  },
+
+	  get canGetUniqueSelector() {
+	    return this._target.client.traits.getUniqueSelector;
+	  },
+
+	  get canGetUsedFontFaces() {
+	    return this._target.client.traits.getUsedFontFaces;
+	  },
+
+	  get canPasteInnerOrAdjacentHTML() {
+	    return this._target.client.traits.pasteHTML;
+	  },
+
+	  /**
+	   * Handle promise rejections for various asynchronous actions, and only log errors if
+	   * the inspector panel still exists.
+	   * This is useful to silence useless errors that happen when the inspector is closed
+	   * while still initializing (and making protocol requests).
+	   */
+	  _handleRejectionIfNotDestroyed: function _handleRejectionIfNotDestroyed(e) {
+	    if (!this._panelDestroyer) {
+	      console.error(e);
+	    }
+	  },
+
+	  /**
+	   * Figure out what features the backend supports
+	   */
+	  _detectActorFeatures: function _detectActorFeatures() {
+	    var _this = this;
+
+	    this._supportsDuplicateNode = false;
+	    this._supportsScrollIntoView = false;
+	    this._supportsResolveRelativeURL = false;
+
+	    return promise.all([this._target.actorHasMethod("domwalker", "duplicateNode").then(function (value) {
+	      _this._supportsDuplicateNode = value;
+	    }).catch(function (e) {
+	      return console.error(e);
+	    }), this._target.actorHasMethod("domnode", "scrollIntoView").then(function (value) {
+	      _this._supportsScrollIntoView = value;
+	    }).catch(function (e) {
+	      return console.error(e);
+	    }), this._target.actorHasMethod("inspector", "resolveRelativeURL").then(function (value) {
+	      _this._supportsResolveRelativeURL = value;
+	    }).catch(function (e) {
+	      return console.error(e);
+	    })]);
+	  },
+
+	  _deferredOpen: function _deferredOpen(defaultSelection) {
+	    var _this2 = this;
+
+	    var deferred = defer();
+
+	    this.walker.on("new-root", this.onNewRoot);
+
+	    this.selection.on("new-node-front", this.onNewSelection);
+	    this.selection.on("before-new-node-front", this.onBeforeNewSelection);
+	    this.selection.on("detached-front", this.onDetached);
+
+	    this.breadcrumbs = new HTMLBreadcrumbs(this);
+
+	    if (this.target.isLocalTab) {
+	      // Show a warning when the debugger is paused.
+	      // We show the warning only when the inspector
+	      // is selected.
+	      this.updateDebuggerPausedWarning = function () {
+	        var notificationBox = _this2._toolbox.getNotificationBox();
+	        var notification = notificationBox.getNotificationWithValue("inspector-script-paused");
+	        if (!notification && _this2._toolbox.currentToolId == "inspector" && _this2._toolbox.threadClient.paused) {
+	          var message = strings.GetStringFromName("debuggerPausedWarning.message");
+	          notificationBox.appendNotification(message, "inspector-script-paused", "", notificationBox.PRIORITY_WARNING_HIGH);
+	        }
+
+	        if (notification && _this2._toolbox.currentToolId != "inspector") {
+	          notificationBox.removeNotification(notification);
+	        }
+
+	        if (notification && !_this2._toolbox.threadClient.paused) {
+	          notificationBox.removeNotification(notification);
+	        }
+	      };
+	      this.target.on("thread-paused", this.updateDebuggerPausedWarning);
+	      this.target.on("thread-resumed", this.updateDebuggerPausedWarning);
+	      this._toolbox.on("select", this.updateDebuggerPausedWarning);
+	      this.updateDebuggerPausedWarning();
+	    }
+
+	    this._initMarkup();
+	    this.isReady = false;
+
+	    this.once("markuploaded", function () {
+	      _this2.isReady = true;
+
+	      // All the components are initialized. Let's select a node.
+	      _this2.selection.setNodeFront(defaultSelection, "inspector-open");
+
+	      _this2.markup.expandNode(_this2.selection.nodeFront);
+
+	      _this2.emit("ready");
+	      deferred.resolve(_this2);
+	    });
+
+	    this.setupSearchBox();
+	    this.setupSidebar();
+	    this.setupToolbar();
+
+	    return deferred.promise;
+	  },
+
+	  _onBeforeNavigate: function _onBeforeNavigate() {
+	    this._defaultNode = null;
+	    this.selection.setNodeFront(null);
+	    this._destroyMarkup();
+	    this.isDirty = false;
+	    this._pendingSelection = null;
+	  },
+
+	  _getPageStyle: function _getPageStyle() {
+	    var _this3 = this;
+
+	    return this._toolbox.inspector.getPageStyle().then(function (pageStyle) {
+	      _this3.pageStyle = pageStyle;
+	    }, this._handleRejectionIfNotDestroyed);
+	  },
+
+	  /**
+	   * Return a promise that will resolve to the default node for selection.
+	   */
+	  _getDefaultNodeForSelection: function _getDefaultNodeForSelection() {
+	    var _this4 = this;
+
+	    if (this._defaultNode) {
+	      return this._defaultNode;
+	    }
+	    var walker = this.walker;
+	    var rootNode = null;
+	    var pendingSelection = this._pendingSelection;
+
+	    // A helper to tell if the target has or is about to navigate.
+	    // this._pendingSelection changes on "will-navigate" and "new-root" events.
+	    var hasNavigated = function hasNavigated() {
+	      return pendingSelection !== _this4._pendingSelection;
+	    };
+
+	    // If available, set either the previously selected node or the body
+	    // as default selected, else set documentElement
+	    return walker.getRootNode().then(function (node) {
+	      if (hasNavigated()) {
+	        return promise.reject("navigated; resolution of _defaultNode aborted");
+	      }
+
+	      rootNode = node;
+	      if (_this4.selectionCssSelector) {
+	        return walker.querySelector(rootNode, _this4.selectionCssSelector);
+	      }
+	      return null;
+	    }).then(function (front) {
+	      if (hasNavigated()) {
+	        return promise.reject("navigated; resolution of _defaultNode aborted");
+	      }
+
+	      if (front) {
+	        return front;
+	      }
+	      return walker.querySelector(rootNode, "body");
+	    }).then(function (front) {
+	      if (hasNavigated()) {
+	        return promise.reject("navigated; resolution of _defaultNode aborted");
+	      }
+
+	      if (front) {
+	        return front;
+	      }
+	      return _this4.walker.documentElement();
+	    }).then(function (node) {
+	      if (hasNavigated()) {
+	        return promise.reject("navigated; resolution of _defaultNode aborted");
+	      }
+	      _this4._defaultNode = node;
+	      return node;
+	    });
+	  },
+
+	  /**
+	   * Target getter.
+	   */
+	  get target() {
+	    return this._target;
+	  },
+
+	  /**
+	   * Target setter.
+	   */
+	  set target(value) {
+	    this._target = value;
+	  },
+
+	  /**
+	   * Indicate that a tool has modified the state of the page.  Used to
+	   * decide whether to show the "are you sure you want to navigate"
+	   * notification.
+	   */
+	  markDirty: function markDirty() {
+	    this.isDirty = true;
+	  },
+
+	  /**
+	   * Hooks the searchbar to show result and auto completion suggestions.
+	   */
+	  setupSearchBox: function setupSearchBox() {
+	    var _this5 = this;
+
+	    this.searchBox = this.panelDoc.getElementById("inspector-searchbox");
+	    this.searchResultsLabel = this.panelDoc.getElementById("inspector-searchlabel");
+
+	    this.search = new InspectorSearch(this, this.searchBox);
+	    this.search.on("search-cleared", this._updateSearchResultsLabel);
+	    this.search.on("search-result", this._updateSearchResultsLabel);
+
+	    var shortcuts = new KeyShortcuts({
+	      window: this.panelDoc.defaultView
+	    });
+	    var key = strings.GetStringFromName("inspector.searchHTML.key");
+	    shortcuts.on(key, function (name, event) {
+	      // Prevent overriding same shortcut from the computed/rule views
+	      if (event.target.closest("#sidebar-panel-ruleview") || event.target.closest("#sidebar-panel-computedview")) {
+	        return;
+	      }
+	      event.preventDefault();
+	      _this5.searchBox.focus();
+	    });
+	  },
+
+	  get searchSuggestions() {
+	    return this.search.autocompleter;
+	  },
+
+	  _updateSearchResultsLabel: function _updateSearchResultsLabel(event, result) {
+	    var str = "";
+	    if (event !== "search-cleared") {
+	      if (result) {
+	        str = strings.formatStringFromName("inspector.searchResultsCount2", [result.resultsIndex + 1, result.resultsLength], 2);
+	      } else {
+	        str = strings.GetStringFromName("inspector.searchResultsNone");
+	      }
+	    }
+
+	    this.searchResultsLabel.textContent = str;
+	  },
+
+	  get React() {
+	    return this._toolbox.React;
+	  },
+
+	  get ReactDOM() {
+	    return this._toolbox.ReactDOM;
+	  },
+
+	  get browserRequire() {
+	    return this._toolbox.browserRequire;
+	  },
+
+	  /**
+	   * Build the sidebar.
+	   */
+	  setupSidebar: function setupSidebar() {
+	    var tabbox = this.panelDoc.querySelector("#inspector-sidebar");
+	    this.sidebar = new ToolSidebar(tabbox, this, "inspector", {
+	      showAllTabsMenu: true
+	    });
+
+	    var defaultTab = Services.prefs.getCharPref("devtools.inspector.activeSidebar");
+
+	    if (!Services.prefs.getBoolPref("devtools.fontinspector.enabled") && defaultTab == "fontinspector") {
+	      defaultTab = "ruleview";
+	    }
+
+	    // Append all side panels
+	    this.sidebar.addExistingTab("ruleview", strings.GetStringFromName("inspector.sidebar.ruleViewTitle"), defaultTab == "ruleview");
+
+	    this.sidebar.addExistingTab("computedview", strings.GetStringFromName("inspector.sidebar.computedViewTitle"), defaultTab == "computedview");
+
+	    this._setDefaultSidebar = function (event, toolId) {
+	      Services.prefs.setCharPref("devtools.inspector.activeSidebar", toolId);
+	    };
+
+	    this.sidebar.on("select", this._setDefaultSidebar);
+
+	    this.ruleview = new RuleViewTool(this, this.panelWin);
+	    this.computedview = new ComputedViewTool(this, this.panelWin);
+
+	    if (this.target.form.animationsActor) {
+	      this.sidebar.addFrameTab("animationinspector", strings.GetStringFromName("inspector.sidebar.animationInspectorTitle"), "chrome://devtools/content/animationinspector/animation-inspector.xhtml", defaultTab == "animationinspector");
+	    }
+
+	    if (Services.prefs.getBoolPref("devtools.fontinspector.enabled") && this.canGetUsedFontFaces) {
+	      this.sidebar.addExistingTab("fontinspector", strings.GetStringFromName("inspector.sidebar.fontInspectorTitle"), defaultTab == "fontinspector");
+
+	      this.fontInspector = new FontInspector(this, this.panelWin);
+	      this.sidebar.toggleTab(true, "fontinspector");
+	    }
+
+	    this.setupSidebarSize();
+
+	    this.sidebar.show(defaultTab);
+	  },
+
+	  /**
+	   * Sidebar size is currently driven by vbox.inspector-sidebar-container
+	   * element, which is located at the left/bottom side of the side bar splitter.
+	   * Its size is changed by the splitter and stored into preferences.
+	   * As soon as bug 1260552 is fixed and new HTML based splitter in place
+	   * the size can be driven by div.inspector-sidebar element. This element
+	   * represents the ToolSidebar and so, the entire logic related to size
+	   * persistence can be done inside the ToolSidebar.
+	   */
+	  setupSidebarSize: function setupSidebarSize() {
+	    var sidePaneContainer = this.panelDoc.querySelector("#inspector-sidebar-container");
+
+	    this.sidebar.on("show", function () {
+	      try {
+	        sidePaneContainer.width = Services.prefs.getIntPref("devtools.toolsidebar-width.inspector");
+	        sidePaneContainer.height = Services.prefs.getIntPref("devtools.toolsidebar-height.inspector");
+	      } catch (e) {
+	        // The default width is the min-width set in CSS
+	        // for #inspector-sidebar-container
+	        // Set width and height of the sidebar container. Only one
+	        // value is really useful at a time depending on the current
+	        // toolbox orientation and having both doesn't break anything.
+	        sidePaneContainer.width = 450;
+	        sidePaneContainer.height = 450;
+	      }
+	    });
+
+	    this.sidebar.on("hide", function () {
+	      Services.prefs.setIntPref("devtools.toolsidebar-width.inspector", sidePaneContainer.width);
+	      Services.prefs.setIntPref("devtools.toolsidebar-height.inspector", sidePaneContainer.height);
+	    });
+
+	    this.sidebar.on("destroy", function () {
+	      Services.prefs.setIntPref("devtools.toolsidebar-width.inspector", sidePaneContainer.width);
+	      Services.prefs.setIntPref("devtools.toolsidebar-height.inspector", sidePaneContainer.height);
+	    });
+	  },
+
+	  setupToolbar: function setupToolbar() {
+	    var _this6 = this;
+
+	    // Setup the sidebar toggle button.
+	    var SidebarToggle = this.React.createFactory(this.browserRequire("devtools/client/shared/components/sidebar-toggle"));
+
+	    var sidebarToggle = SidebarToggle({
+	      onClick: this.onPaneToggleButtonClicked,
+	      collapsed: false,
+	      expandPaneTitle: strings.GetStringFromName("inspector.expandPane"),
+	      collapsePaneTitle: strings.GetStringFromName("inspector.collapsePane")
+	    });
+
+	    var parentBox = this.panelDoc.getElementById("inspector-sidebar-toggle-box");
+	    this._sidebarToggle = this.ReactDOM.render(sidebarToggle, parentBox);
+
+	    // Setup the add-node button.
+	    this.addNode = this.addNode.bind(this);
+	    this.addNodeButton = this.panelDoc.getElementById("inspector-element-add-button");
+	    this.addNodeButton.addEventListener("click", this.addNode);
+
+	    // Setup the eye-dropper icon.
+	    this.toolbox.target.actorHasMethod("inspector", "pickColorFromPage").then(function (value) {
+	      if (!value) {
+	        return;
+	      }
+
+	      _this6.onEyeDropperDone = _this6.onEyeDropperDone.bind(_this6);
+	      _this6.onEyeDropperButtonClicked = _this6.onEyeDropperButtonClicked.bind(_this6);
+	      _this6.eyeDropperButton = _this6.panelDoc.getElementById("inspector-eyedropper-toggle");
+	      _this6.eyeDropperButton.style.display = "initial";
+	      _this6.eyeDropperButton.addEventListener("click", _this6.onEyeDropperButtonClicked);
+	    }, function (e) {
+	      return console.error(e);
+	    });
+	  },
+
+	  teardownToolbar: function teardownToolbar() {
+	    if (this.addNodeButton) {
+	      this.addNodeButton.removeEventListener("click", this.addNode);
+	      this.addNodeButton = null;
+	    }
+
+	    if (this.eyeDropperButton) {
+	      this.eyeDropperButton.removeEventListener("click", this.onEyeDropperButtonClicked);
+	      this.eyeDropperButton = null;
+	    }
+	  },
+
+	  /**
+	   * Reset the inspector on new root mutation.
+	   */
+	  onNewRoot: function onNewRoot() {
+	    var _this7 = this;
+
+	    this._defaultNode = null;
+	    this.selection.setNodeFront(null);
+	    this._destroyMarkup();
+	    this.isDirty = false;
+
+	    var onNodeSelected = function onNodeSelected(defaultNode) {
+	      // Cancel this promise resolution as a new one had
+	      // been queued up.
+	      if (_this7._pendingSelection != onNodeSelected) {
+	        return;
+	      }
+	      _this7._pendingSelection = null;
+	      _this7.selection.setNodeFront(defaultNode, "navigateaway");
+
+	      _this7._initMarkup();
+	      _this7.once("markuploaded", function () {
+	        if (!_this7.markup) {
+	          return;
+	        }
+	        _this7.markup.expandNode(_this7.selection.nodeFront);
+	        _this7.emit("new-root");
+	      });
+	    };
+	    this._pendingSelection = onNodeSelected;
+	    this._getDefaultNodeForSelection().then(onNodeSelected, this._handleRejectionIfNotDestroyed);
+	  },
+
+	  _selectionCssSelector: null,
+
+	  /**
+	   * Set the currently selected node unique css selector.
+	   * Will store the current target url along with it to allow pre-selection at
+	   * reload
+	   */
+	  set selectionCssSelector(cssSelector) {
+	    if (this._panelDestroyer) {
+	      return;
+	    }
+
+	    this._selectionCssSelector = {
+	      selector: cssSelector || null,
+	      url: this._target.url
+	    };
+	  },
+
+	  /**
+	   * Get the current selection unique css selector if any, that is, if a node
+	   * is actually selected and that node has been selected while on the same url
+	   */
+	  get selectionCssSelector() {
+	    if (this._selectionCssSelector && this._selectionCssSelector.url === this._target.url) {
+	      return this._selectionCssSelector.selector;
+	    }
+	    return null;
+	  },
+
+	  /**
+	   * Can a new HTML element be inserted into the currently selected element?
+	   * @return {Boolean}
+	   */
+	  canAddHTMLChild: function canAddHTMLChild() {
+	    var selection = this.selection;
+
+	    // Don't allow to insert an element into these elements. This should only
+	    // contain elements where walker.insertAdjacentHTML has no effect.
+	    var invalidTagNames = ["html", "iframe"];
+
+	    return selection.isHTMLNode() && selection.isElementNode() && !selection.isPseudoElementNode() && !selection.isAnonymousNode() && invalidTagNames.indexOf(selection.nodeFront.nodeName.toLowerCase()) === -1;
+	  },
+
+	  /**
+	   * When a new node is selected.
+	   */
+	  onNewSelection: function onNewSelection(event, value, reason) {
+	    var _this8 = this;
+
+	    if (reason === "selection-destroy") {
+	      return;
+	    }
+
+	    // Wait for all the known tools to finish updating and then let the
+	    // client know.
+	    var selection = this.selection.nodeFront;
+
+	    // Update the state of the add button in the toolbar depending on the
+	    // current selection.
+	    var btn = this.panelDoc.querySelector("#inspector-element-add-button");
+	    if (this.canAddHTMLChild()) {
+	      btn.removeAttribute("disabled");
+	    } else {
+	      btn.setAttribute("disabled", "true");
+	    }
+
+	    // On any new selection made by the user, store the unique css selector
+	    // of the selected node so it can be restored after reload of the same page
+	    if (this.canGetUniqueSelector && this.selection.isElementNode()) {
+	      selection.getUniqueSelector().then(function (selector) {
+	        _this8.selectionCssSelector = selector;
+	      }, this._handleRejectionIfNotDestroyed);
+	    }
+
+	    var selfUpdate = this.updating("inspector-panel");
+	    executeSoon(function () {
+	      try {
+	        selfUpdate(selection);
+	      } catch (ex) {
+	        console.error(ex);
+	      }
+	    });
+	  },
+
+	  /**
+	   * Delay the "inspector-updated" notification while a tool
+	   * is updating itself.  Returns a function that must be
+	   * invoked when the tool is done updating with the node
+	   * that the tool is viewing.
+	   */
+	  updating: function updating(name) {
+	    var _this9 = this;
+
+	    if (this._updateProgress && this._updateProgress.node != this.selection.nodeFront) {
+	      this.cancelUpdate();
+	    }
+
+	    if (!this._updateProgress) {
+	      (function () {
+	        // Start an update in progress.
+	        var self = _this9;
+	        _this9._updateProgress = {
+	          node: _this9.selection.nodeFront,
+	          outstanding: new Set(),
+	          checkDone: function checkDone() {
+	            if (this !== self._updateProgress) {
+	              return;
+	            }
+	            // Cancel update if there is no `selection` anymore.
+	            // It can happen if the inspector panel is already destroyed.
+	            if (!self.selection || this.node !== self.selection.nodeFront) {
+	              self.cancelUpdate();
+	              return;
+	            }
+	            if (this.outstanding.size !== 0) {
+	              return;
+	            }
+
+	            self._updateProgress = null;
+	            self.emit("inspector-updated", name);
+	          }
+	        };
+	      })();
+	    }
+
+	    var progress = this._updateProgress;
+	    var done = function done() {
+	      progress.outstanding.delete(done);
+	      progress.checkDone();
+	    };
+	    progress.outstanding.add(done);
+	    return done;
+	  },
+
+	  /**
+	   * Cancel notification of inspector updates.
+	   */
+	  cancelUpdate: function cancelUpdate() {
+	    this._updateProgress = null;
+	  },
+
+	  /**
+	   * When a new node is selected, before the selection has changed.
+	   */
+	  onBeforeNewSelection: function onBeforeNewSelection(event, node) {
+	    if (this.breadcrumbs.indexOf(node) == -1) {
+	      // only clear locks if we'd have to update breadcrumbs
+	      this.clearPseudoClasses();
+	    }
+	  },
+
+	  /**
+	   * When a node is deleted, select its parent node or the defaultNode if no
+	   * parent is found (may happen when deleting an iframe inside which the
+	   * node was selected).
+	   */
+	  onDetached: function onDetached(event, parentNode) {
+	    this.breadcrumbs.cutAfter(this.breadcrumbs.indexOf(parentNode));
+	    this.selection.setNodeFront(parentNode ? parentNode : this._defaultNode, "detached");
+	  },
+
+	  /**
+	   * Destroy the inspector.
+	   */
+	  destroy: function destroy() {
+	    if (this._panelDestroyer) {
+	      return this._panelDestroyer;
+	    }
+
+	    if (this.walker) {
+	      this.walker.off("new-root", this.onNewRoot);
+	      this.pageStyle = null;
+	    }
+
+	    this.cancelUpdate();
+
+	    this.target.off("will-navigate", this._onBeforeNavigate);
+
+	    this.target.off("thread-paused", this.updateDebuggerPausedWarning);
+	    this.target.off("thread-resumed", this.updateDebuggerPausedWarning);
+	    this._toolbox.off("select", this.updateDebuggerPausedWarning);
+
+	    if (this.ruleview) {
+	      this.ruleview.destroy();
+	    }
+
+	    if (this.computedview) {
+	      this.computedview.destroy();
+	    }
+
+	    if (this.fontInspector) {
+	      this.fontInspector.destroy();
+	    }
+
+	    var cssPropertiesDestroyer = this._cssPropertiesLoaded.then(function (_ref) {
+	      var front = _ref.front;
+
+	      if (front) {
+	        front.destroy();
+	      }
+	    });
+
+	    this.sidebar.off("select", this._setDefaultSidebar);
+	    var sidebarDestroyer = this.sidebar.destroy();
+	    this.sidebar = null;
+
+	    this.teardownToolbar();
+	    this.breadcrumbs.destroy();
+	    this.selection.off("new-node-front", this.onNewSelection);
+	    this.selection.off("before-new-node", this.onBeforeNewSelection);
+	    this.selection.off("before-new-node-front", this.onBeforeNewSelection);
+	    this.selection.off("detached-front", this.onDetached);
+	    var markupDestroyer = this._destroyMarkup();
+	    this.panelWin.inspector = null;
+	    this.target = null;
+	    this.panelDoc = null;
+	    this.panelWin = null;
+	    this.breadcrumbs = null;
+	    this._toolbox = null;
+	    this.search.destroy();
+	    this.search = null;
+	    this.searchBox = null;
+
+	    this._panelDestroyer = promise.all([sidebarDestroyer, markupDestroyer, cssPropertiesDestroyer]);
+
+	    return this._panelDestroyer;
+	  },
+
+	  /**
+	   * Returns the clipboard content if it is appropriate for pasting
+	   * into the current node's outer HTML, otherwise returns null.
+	   */
+	  _getClipboardContentForPaste: function _getClipboardContentForPaste() {
+	    var flavors = clipboard.currentFlavors;
+	    if (flavors.indexOf("text") != -1 || flavors.indexOf("html") != -1 && flavors.indexOf("image") == -1) {
+	      var content = clipboard.get();
+	      if (content && content.trim().length > 0) {
+	        return content;
+	      }
+	    }
+	    return null;
+	  },
+
+	  _onContextMenu: function _onContextMenu(e) {
+	    e.preventDefault();
+	    this._openMenu({
+	      screenX: e.screenX,
+	      screenY: e.screenY,
+	      target: e.target
+	    });
+	  },
+
+	  _openMenu: function _openMenu() {
+	    var _this10 = this;
+
+	    var _ref2 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
+
+	    var target = _ref2.target;
+	    var _ref2$screenX = _ref2.screenX;
+	    var screenX = _ref2$screenX === undefined ? 0 : _ref2$screenX;
+	    var _ref2$screenY = _ref2.screenY;
+	    var screenY = _ref2$screenY === undefined ? 0 : _ref2$screenY;
+
+	    var markupContainer = this.markup.getContainer(this.selection.nodeFront);
+
+	    this.contextMenuTarget = target;
+	    this.nodeMenuTriggerInfo = markupContainer && markupContainer.editor.getInfoAtNode(target);
+
+	    var isSelectionElement = this.selection.isElementNode() && !this.selection.isPseudoElementNode();
+	    var isEditableElement = isSelectionElement && !this.selection.isAnonymousNode();
+	    var isDuplicatableElement = isSelectionElement && !this.selection.isAnonymousNode() && !this.selection.isRoot();
+	    var isScreenshotable = isSelectionElement && this.canGetUniqueSelector && this.selection.nodeFront.isTreeDisplayed;
+
+	    var menu = new Menu();
+	    menu.append(new MenuItem({
+	      id: "node-menu-edithtml",
+	      label: strings.GetStringFromName("inspectorHTMLEdit.label"),
+	      accesskey: strings.GetStringFromName("inspectorHTMLEdit.accesskey"),
+	      disabled: !isEditableElement || !this.isOuterHTMLEditable,
+	      click: function click() {
+	        return _this10.editHTML();
+	      }
+	    }));
+	    menu.append(new MenuItem({
+	      id: "node-menu-add",
+	      label: strings.GetStringFromName("inspectorAddNode.label"),
+	      accesskey: strings.GetStringFromName("inspectorAddNode.accesskey"),
+	      disabled: !this.canAddHTMLChild(),
+	      click: function click() {
+	        return _this10.addNode();
+	      }
+	    }));
+	    menu.append(new MenuItem({
+	      id: "node-menu-duplicatenode",
+	      label: strings.GetStringFromName("inspectorDuplicateNode.label"),
+	      hidden: !this._supportsDuplicateNode,
+	      disabled: !isDuplicatableElement,
+	      click: function click() {
+	        return _this10.duplicateNode();
+	      }
+	    }));
+	    menu.append(new MenuItem({
+	      id: "node-menu-delete",
+	      label: strings.GetStringFromName("inspectorHTMLDelete.label"),
+	      accesskey: strings.GetStringFromName("inspectorHTMLDelete.accesskey"),
+	      disabled: !isEditableElement,
+	      click: function click() {
+	        return _this10.deleteNode();
+	      }
+	    }));
+
+	    menu.append(new MenuItem({
+	      label: strings.GetStringFromName("inspectorAttributesSubmenu.label"),
+	      accesskey: strings.GetStringFromName("inspectorAttributesSubmenu.accesskey"),
+	      submenu: this._getAttributesSubmenu(isEditableElement)
+	    }));
+
+	    menu.append(new MenuItem({
+	      type: "separator"
+	    }));
+
+	    // Set the pseudo classes
+	    var _arr = ["hover", "active", "focus"];
+	    for (var _i = 0; _i < _arr.length; _i++) {
+	      var name = _arr[_i];
+	      var menuitem = new MenuItem({
+	        id: "node-menu-pseudo-" + name,
+	        label: name,
+	        type: "checkbox",
+	        click: this.togglePseudoClass.bind(this, ":" + name)
+	      });
+
+	      if (isSelectionElement) {
+	        var checked = this.selection.nodeFront.hasPseudoClassLock(":" + name);
+	        menuitem.checked = checked;
+	      } else {
+	        menuitem.disabled = true;
+	      }
+
+	      menu.append(menuitem);
+	    }
+
+	    menu.append(new MenuItem({
+	      type: "separator"
+	    }));
+
+	    var copySubmenu = new Menu();
+	    copySubmenu.append(new MenuItem({
+	      id: "node-menu-copyinner",
+	      label: strings.GetStringFromName("inspectorCopyInnerHTML.label"),
+	      accesskey: strings.GetStringFromName("inspectorCopyInnerHTML.accesskey"),
+	      disabled: !isSelectionElement,
+	      click: function click() {
+	        return _this10.copyInnerHTML();
+	      }
+	    }));
+	    copySubmenu.append(new MenuItem({
+	      id: "node-menu-copyouter",
+	      label: strings.GetStringFromName("inspectorCopyOuterHTML.label"),
+	      accesskey: strings.GetStringFromName("inspectorCopyOuterHTML.accesskey"),
+	      disabled: !isSelectionElement,
+	      click: function click() {
+	        return _this10.copyOuterHTML();
+	      }
+	    }));
+	    copySubmenu.append(new MenuItem({
+	      id: "node-menu-copyuniqueselector",
+	      label: strings.GetStringFromName("inspectorCopyCSSSelector.label"),
+	      accesskey: strings.GetStringFromName("inspectorCopyCSSSelector.accesskey"),
+	      disabled: !isSelectionElement,
+	      hidden: !this.canGetUniqueSelector,
+	      click: function click() {
+	        return _this10.copyUniqueSelector();
+	      }
+	    }));
+	    copySubmenu.append(new MenuItem({
+	      id: "node-menu-copyimagedatauri",
+	      label: strings.GetStringFromName("inspectorImageDataUri.label"),
+	      disabled: !isSelectionElement || !markupContainer || !markupContainer.isPreviewable(),
+	      click: function click() {
+	        return _this10.copyImageDataUri();
+	      }
+	    }));
+
+	    menu.append(new MenuItem({
+	      label: strings.GetStringFromName("inspectorCopyHTMLSubmenu.label"),
+	      submenu: copySubmenu
+	    }));
+
+	    menu.append(new MenuItem({
+	      label: strings.GetStringFromName("inspectorPasteHTMLSubmenu.label"),
+	      submenu: this._getPasteSubmenu(isEditableElement)
+	    }));
+
+	    menu.append(new MenuItem({
+	      type: "separator"
+	    }));
+
+	    var isNodeWithChildren = this.selection.isNode() && markupContainer.hasChildren;
+	    menu.append(new MenuItem({
+	      id: "node-menu-expand",
+	      label: strings.GetStringFromName("inspectorExpandNode.label"),
+	      disabled: !isNodeWithChildren,
+	      click: function click() {
+	        return _this10.expandNode();
+	      }
+	    }));
+	    menu.append(new MenuItem({
+	      id: "node-menu-collapse",
+	      label: strings.GetStringFromName("inspectorCollapseNode.label"),
+	      disabled: !isNodeWithChildren || !markupContainer.expanded,
+	      click: function click() {
+	        return _this10.collapseNode();
+	      }
+	    }));
+
+	    menu.append(new MenuItem({
+	      type: "separator"
+	    }));
+
+	    menu.append(new MenuItem({
+	      id: "node-menu-scrollnodeintoview",
+	      label: strings.GetStringFromName("inspectorScrollNodeIntoView.label"),
+	      accesskey: strings.GetStringFromName("inspectorScrollNodeIntoView.accesskey"),
+	      hidden: !this._supportsScrollIntoView,
+	      disabled: !isSelectionElement,
+	      click: function click() {
+	        return _this10.scrollNodeIntoView();
+	      }
+	    }));
+	    menu.append(new MenuItem({
+	      id: "node-menu-screenshotnode",
+	      label: strings.GetStringFromName("inspectorScreenshotNode.label"),
+	      disabled: !isScreenshotable,
+	      click: function click() {
+	        return _this10.screenshotNode();
+	      }
+	    }));
+	    menu.append(new MenuItem({
+	      id: "node-menu-useinconsole",
+	      label: strings.GetStringFromName("inspectorUseInConsole.label"),
+	      click: function click() {
+	        return _this10.useInConsole();
+	      }
+	    }));
+	    menu.append(new MenuItem({
+	      id: "node-menu-showdomproperties",
+	      label: strings.GetStringFromName("inspectorShowDOMProperties.label"),
+	      click: function click() {
+	        return _this10.showDOMProperties();
+	      }
+	    }));
+
+	    var nodeLinkMenuItems = this._getNodeLinkMenuItems();
+	    if (nodeLinkMenuItems.filter(function (item) {
+	      return item.visible;
+	    }).length > 0) {
+	      menu.append(new MenuItem({
+	        id: "node-menu-link-separator",
+	        type: "separator"
+	      }));
+	    }
+
+	    var _iteratorNormalCompletion = true;
+	    var _didIteratorError = false;
+	    var _iteratorError = undefined;
+
+	    try {
+	      for (var _iterator = nodeLinkMenuItems[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
+	        var _menuitem = _step.value;
+
+	        menu.append(_menuitem);
+	      }
+	    } catch (err) {
+	      _didIteratorError = true;
+	      _iteratorError = err;
+	    } finally {
+	      try {
+	        if (!_iteratorNormalCompletion && _iterator.return) {
+	          _iterator.return();
+	        }
+	      } finally {
+	        if (_didIteratorError) {
+	          throw _iteratorError;
+	        }
+	      }
+	    }
+
+	    menu.popup(screenX, screenY, this._toolbox);
+	    return menu;
+	  },
+
+	  _getPasteSubmenu: function _getPasteSubmenu(isEditableElement) {
+	    var _this11 = this;
+
+	    var isPasteable = isEditableElement && this._getClipboardContentForPaste();
+	    var disableAdjacentPaste = !isPasteable || !this.canPasteInnerOrAdjacentHTML || this.selection.isRoot() || this.selection.isBodyNode() || this.selection.isHeadNode();
+	    var disableFirstLastPaste = !isPasteable || !this.canPasteInnerOrAdjacentHTML || this.selection.isHTMLNode() && this.selection.isRoot();
+
+	    var pasteSubmenu = new Menu();
+	    pasteSubmenu.append(new MenuItem({
+	      id: "node-menu-pasteinnerhtml",
+	      label: strings.GetStringFromName("inspectorPasteInnerHTML.label"),
+	      accesskey: strings.GetStringFromName("inspectorPasteInnerHTML.accesskey"),
+	      disabled: !isPasteable || !this.canPasteInnerOrAdjacentHTML,
+	      click: function click() {
+	        return _this11.pasteInnerHTML();
+	      }
+	    }));
+	    pasteSubmenu.append(new MenuItem({
+	      id: "node-menu-pasteouterhtml",
+	      label: strings.GetStringFromName("inspectorPasteOuterHTML.label"),
+	      accesskey: strings.GetStringFromName("inspectorPasteOuterHTML.accesskey"),
+	      disabled: !isPasteable || !this.isOuterHTMLEditable,
+	      click: function click() {
+	        return _this11.pasteOuterHTML();
+	      }
+	    }));
+	    pasteSubmenu.append(new MenuItem({
+	      id: "node-menu-pastebefore",
+	      label: strings.GetStringFromName("inspectorHTMLPasteBefore.label"),
+	      accesskey: strings.GetStringFromName("inspectorHTMLPasteBefore.accesskey"),
+	      disabled: disableAdjacentPaste,
+	      click: function click() {
+	        return _this11.pasteAdjacentHTML("beforeBegin");
+	      }
+	    }));
+	    pasteSubmenu.append(new MenuItem({
+	      id: "node-menu-pasteafter",
+	      label: strings.GetStringFromName("inspectorHTMLPasteAfter.label"),
+	      accesskey: strings.GetStringFromName("inspectorHTMLPasteAfter.accesskey"),
+	      disabled: disableAdjacentPaste,
+	      click: function click() {
+	        return _this11.pasteAdjacentHTML("afterEnd");
+	      }
+	    }));
+	    pasteSubmenu.append(new MenuItem({
+	      id: "node-menu-pastefirstchild",
+	      label: strings.GetStringFromName("inspectorHTMLPasteFirstChild.label"),
+	      accesskey: strings.GetStringFromName("inspectorHTMLPasteFirstChild.accesskey"),
+	      disabled: disableFirstLastPaste,
+	      click: function click() {
+	        return _this11.pasteAdjacentHTML("afterBegin");
+	      }
+	    }));
+	    pasteSubmenu.append(new MenuItem({
+	      id: "node-menu-pastelastchild",
+	      label: strings.GetStringFromName("inspectorHTMLPasteLastChild.label"),
+	      accesskey: strings.GetStringFromName("inspectorHTMLPasteLastChild.accesskey"),
+	      disabled: disableFirstLastPaste,
+	      click: function click() {
+	        return _this11.pasteAdjacentHTML("beforeEnd");
+	      }
+	    }));
+
+	    return pasteSubmenu;
+	  },
+
+	  _getAttributesSubmenu: function _getAttributesSubmenu(isEditableElement) {
+	    var _this12 = this;
+
+	    var attributesSubmenu = new Menu();
+	    var nodeInfo = this.nodeMenuTriggerInfo;
+	    var isAttributeClicked = isEditableElement && nodeInfo && nodeInfo.type === "attribute";
+
+	    attributesSubmenu.append(new MenuItem({
+	      id: "node-menu-add-attribute",
+	      label: strings.GetStringFromName("inspectorAddAttribute.label"),
+	      accesskey: strings.GetStringFromName("inspectorAddAttribute.accesskey"),
+	      disabled: !isEditableElement,
+	      click: function click() {
+	        return _this12.onAddAttribute();
+	      }
+	    }));
+	    attributesSubmenu.append(new MenuItem({
+	      id: "node-menu-edit-attribute",
+	      label: strings.formatStringFromName("inspectorEditAttribute.label", [isAttributeClicked ? "\"" + nodeInfo.name + "\"" : ""], 1),
+	      accesskey: strings.GetStringFromName("inspectorEditAttribute.accesskey"),
+	      disabled: !isAttributeClicked,
+	      click: function click() {
+	        return _this12.onEditAttribute();
+	      }
+	    }));
+
+	    attributesSubmenu.append(new MenuItem({
+	      id: "node-menu-remove-attribute",
+	      label: strings.formatStringFromName("inspectorRemoveAttribute.label", [isAttributeClicked ? "\"" + nodeInfo.name + "\"" : ""], 1),
+	      accesskey: strings.GetStringFromName("inspectorRemoveAttribute.accesskey"),
+	      disabled: !isAttributeClicked,
+	      click: function click() {
+	        return _this12.onRemoveAttribute();
+	      }
+	    }));
+
+	    return attributesSubmenu;
+	  },
+
+	  /**
+	   * Link menu items can be shown or hidden depending on the context and
+	   * selected node, and their labels can vary.
+	   *
+	   * @return {Array} list of visible menu items related to links.
+	   */
+	  _getNodeLinkMenuItems: function _getNodeLinkMenuItems() {
+	    var _this13 = this;
+
+	    var linkFollow = new MenuItem({
+	      id: "node-menu-link-follow",
+	      visible: false,
+	      click: function click() {
+	        return _this13.onFollowLink();
+	      }
+	    });
+	    var linkCopy = new MenuItem({
+	      id: "node-menu-link-copy",
+	      visible: false,
+	      click: function click() {
+	        return _this13.onCopyLink();
+	      }
+	    });
+
+	    // Get information about the right-clicked node.
+	    var popupNode = this.contextMenuTarget;
+	    if (!popupNode || !popupNode.classList.contains("link")) {
+	      return [linkFollow, linkCopy];
+	    }
+
+	    var type = popupNode.dataset.type;
+	    if (this._supportsResolveRelativeURL && (type === "uri" || type === "cssresource" || type === "jsresource")) {
+	      // Links can't be opened in new tabs in the browser toolbox.
+	      if (type === "uri" && !this.target.chrome) {
+	        linkFollow.visible = true;
+	        linkFollow.label = strings.GetStringFromName("inspector.menu.openUrlInNewTab.label");
+	      } else if (type === "cssresource") {
+	        linkFollow.visible = true;
+	        linkFollow.label = toolboxStrings.GetStringFromName("toolbox.viewCssSourceInStyleEditor.label");
+	      } else if (type === "jsresource") {
+	        linkFollow.visible = true;
+	        linkFollow.label = toolboxStrings.GetStringFromName("toolbox.viewJsSourceInDebugger.label");
+	      }
+
+	      linkCopy.visible = true;
+	      linkCopy.label = strings.GetStringFromName("inspector.menu.copyUrlToClipboard.label");
+	    } else if (type === "idref") {
+	      linkFollow.visible = true;
+	      linkFollow.label = strings.formatStringFromName("inspector.menu.selectElement.label", [popupNode.dataset.link], 1);
+	    }
+
+	    return [linkFollow, linkCopy];
+	  },
+
+	  _initMarkup: function _initMarkup() {
+	    var doc = this.panelDoc;
+
+	    this._markupBox = doc.getElementById("markup-box");
+
+	    // create tool iframe
+	    this._markupFrame = doc.createElement("iframe");
+	    this._markupFrame.setAttribute("flex", "1");
+	    this._markupFrame.setAttribute("tooltip", "aHTMLTooltip");
+	    this._markupFrame.addEventListener("contextmenu", this._onContextMenu, true);
+
+	    // This is needed to enable tooltips inside the iframe document.
+	    this._markupFrame.addEventListener("load", this._onMarkupFrameLoad, true);
+
+	    this._markupBox.setAttribute("collapsed", true);
+	    this._markupBox.appendChild(this._markupFrame);
+	    this._markupFrame.setAttribute("src", "chrome://devtools/content/inspector/markup/markup.xhtml");
+	    this._markupFrame.setAttribute("aria-label", strings.GetStringFromName("inspector.panelLabel.markupView"));
+	  },
+
+	  _onMarkupFrameLoad: function _onMarkupFrameLoad() {
+	    this._markupFrame.removeEventListener("load", this._onMarkupFrameLoad, true);
+
+	    this._markupFrame.contentWindow.focus();
+
+	    this._markupBox.removeAttribute("collapsed");
+
+	    this.markup = new MarkupView(this, this._markupFrame, this._toolbox.win);
+
+	    this.emit("markuploaded");
+	  },
+
+	  _destroyMarkup: function _destroyMarkup() {
+	    var destroyPromise = void 0;
+
+	    if (this._markupFrame) {
+	      this._markupFrame.removeEventListener("load", this._onMarkupFrameLoad, true);
+	      this._markupFrame.removeEventListener("contextmenu", this._onContextMenu, true);
+	    }
+
+	    if (this.markup) {
+	      destroyPromise = this.markup.destroy();
+	      this.markup = null;
+	    } else {
+	      destroyPromise = promise.resolve();
+	    }
+
+	    if (this._markupFrame) {
+	      this._markupFrame.parentNode.removeChild(this._markupFrame);
+	      this._markupFrame = null;
+	    }
+
+	    this._markupBox = null;
+
+	    return destroyPromise;
+	  },
+
+	  /**
+	   * When the pane toggle button is clicked or pressed, toggle the pane, change the button
+	   * state and tooltip.
+	   */
+	  onPaneToggleButtonClicked: function onPaneToggleButtonClicked(e) {
+	    var _this14 = this;
+
+	    var sidePaneContainer = this.panelDoc.querySelector("#inspector-sidebar-container");
+	    var isVisible = !this._sidebarToggle.state.collapsed;
+
+	    // Make sure the sidebar has width and height attributes before collapsing
+	    // because ViewHelpers needs it.
+	    if (isVisible) {
+	      var rect = sidePaneContainer.getBoundingClientRect();
+	      if (!sidePaneContainer.hasAttribute("width")) {
+	        sidePaneContainer.setAttribute("width", rect.width);
+	      }
+	      // always refresh the height attribute before collapsing, it could have
+	      // been modified by resizing the container.
+	      sidePaneContainer.setAttribute("height", rect.height);
+	    }
+
+	    var onAnimationDone = function onAnimationDone() {
+	      if (isVisible) {
+	        _this14._sidebarToggle.setState({ collapsed: true });
+	      } else {
+	        _this14._sidebarToggle.setState({ collapsed: false });
+	      }
+	    };
+
+	    ViewHelpers.togglePane({
+	      visible: !isVisible,
+	      animated: true,
+	      delayed: true,
+	      callback: onAnimationDone
+	    }, sidePaneContainer);
+	  },
+
+	  onEyeDropperButtonClicked: function onEyeDropperButtonClicked() {
+	    this.eyeDropperButton.hasAttribute("checked") ? this.hideEyeDropper() : this.showEyeDropper();
+	  },
+
+	  startEyeDropperListeners: function startEyeDropperListeners() {
+	    this.inspector.once("color-pick-canceled", this.onEyeDropperDone);
+	    this.inspector.once("color-picked", this.onEyeDropperDone);
+	    this.walker.once("new-root", this.onEyeDropperDone);
+	  },
+
+	  stopEyeDropperListeners: function stopEyeDropperListeners() {
+	    this.inspector.off("color-pick-canceled", this.onEyeDropperDone);
+	    this.inspector.off("color-picked", this.onEyeDropperDone);
+	    this.walker.off("new-root", this.onEyeDropperDone);
+	  },
+
+	  onEyeDropperDone: function onEyeDropperDone() {
+	    this.eyeDropperButton.removeAttribute("checked");
+	    this.stopEyeDropperListeners();
+	  },
+
+	  /**
+	   * Show the eyedropper on the page.
+	   * @return {Promise} resolves when the eyedropper is visible.
+	   */
+	  showEyeDropper: function showEyeDropper() {
+	    this.telemetry.toolOpened("toolbareyedropper");
+	    this.eyeDropperButton.setAttribute("checked", "true");
+	    this.startEyeDropperListeners();
+	    return this.inspector.pickColorFromPage({ copyOnSelect: true }).catch(function (e) {
+	      return console.error(e);
+	    });
+	  },
+
+	  /**
+	   * Hide the eyedropper.
+	   * @return {Promise} resolves when the eyedropper is hidden.
+	   */
+	  hideEyeDropper: function hideEyeDropper() {
+	    this.eyeDropperButton.removeAttribute("checked");
+	    this.stopEyeDropperListeners();
+	    return this.inspector.cancelPickColorFromPage().catch(function (e) {
+	      return console.error(e);
+	    });
+	  },
+
+	  /**
+	   * Create a new node as the last child of the current selection, expand the
+	   * parent and select the new node.
+	   */
+	  addNode: Task.async(regeneratorRuntime.mark(function _callee2() {
+	    var html, onMutations, _ref3, nodes;
+
+	    return regeneratorRuntime.wrap(function _callee2$(_context2) {
+	      while (1) {
+	        switch (_context2.prev = _context2.next) {
+	          case 0:
+	            if (this.canAddHTMLChild()) {
+	              _context2.next = 2;
+	              break;
+	            }
+
+	            return _context2.abrupt("return");
+
+	          case 2:
+	            html = "<div></div>";
+
+	            // Insert the html and expect a childList markup mutation.
+
+	            onMutations = this.once("markupmutation");
+	            _context2.next = 6;
+	            return this.walker.insertAdjacentHTML(this.selection.nodeFront, "beforeEnd", html);
+
+	          case 6:
+	            _ref3 = _context2.sent;
+	            nodes = _ref3.nodes;
+	            _context2.next = 10;
+	            return onMutations;
+
+	          case 10:
+
+	            // Select the new node (this will auto-expand its parent).
+	            this.selection.setNodeFront(nodes[0], "node-inserted");
+
+	          case 11:
+	          case "end":
+	            return _context2.stop();
+	        }
+	      }
+	    }, _callee2, this);
+	  })),
+
+	  /**
+	   * Toggle a pseudo class.
+	   */
+	  togglePseudoClass: function togglePseudoClass(pseudo) {
+	    if (this.selection.isElementNode()) {
+	      var node = this.selection.nodeFront;
+	      if (node.hasPseudoClassLock(pseudo)) {
+	        return this.walker.removePseudoClassLock(node, pseudo, { parents: true });
+	      }
+
+	      var hierarchical = pseudo == ":hover" || pseudo == ":active";
+	      return this.walker.addPseudoClassLock(node, pseudo, { parents: hierarchical });
+	    }
+	    return promise.resolve();
+	  },
+
+	  /**
+	   * Show DOM properties
+	   */
+	  showDOMProperties: function showDOMProperties() {
+	    var _this15 = this;
+
+	    this._toolbox.openSplitConsole().then(function () {
+	      var panel = _this15._toolbox.getPanel("webconsole");
+	      var jsterm = panel.hud.jsterm;
+
+	      jsterm.execute("inspect($0)");
+	      jsterm.focus();
+	    });
+	  },
+
+	  /**
+	   * Use in Console.
+	   *
+	   * Takes the currently selected node in the inspector and assigns it to a
+	   * temp variable on the content window.  Also opens the split console and
+	   * autofills it with the temp variable.
+	   */
+	  useInConsole: function useInConsole() {
+	    var _this16 = this;
+
+	    this._toolbox.openSplitConsole().then(function () {
+	      var panel = _this16._toolbox.getPanel("webconsole");
+	      var jsterm = panel.hud.jsterm;
+
+	      var evalString = "{ let i = 0;\n        while (window.hasOwnProperty(\"temp\" + i) && i < 1000) {\n          i++;\n        }\n        window[\"temp\" + i] = $0;\n        \"temp\" + i;\n      }";
+
+	      var options = {
+	        selectedNodeActor: _this16.selection.nodeFront.actorID
+	      };
+	      jsterm.requestEvaluation(evalString, options).then(function (res) {
+	        jsterm.setInputValue(res.result);
+	        _this16.emit("console-var-ready");
+	      });
+	    });
+	  },
+
+	  /**
+	   * Clear any pseudo-class locks applied to the current hierarchy.
+	   */
+	  clearPseudoClasses: function clearPseudoClasses() {
+	    if (!this.walker) {
+	      return promise.resolve();
+	    }
+	    return this.walker.clearPseudoClassLocks().catch(this._handleRejectionIfNotDestroyed);
+	  },
+
+	  /**
+	   * Edit the outerHTML of the selected Node.
+	   */
+	  editHTML: function editHTML() {
+	    if (!this.selection.isNode()) {
+	      return;
+	    }
+	    if (this.markup) {
+	      this.markup.beginEditingOuterHTML(this.selection.nodeFront);
+	    }
+	  },
+
+	  /**
+	   * Paste the contents of the clipboard into the selected Node's outer HTML.
+	   */
+	  pasteOuterHTML: function pasteOuterHTML() {
+	    var _this17 = this;
+
+	    var content = this._getClipboardContentForPaste();
+	    if (!content) {
+	      return promise.reject("No clipboard content for paste");
+	    }
+
+	    var node = this.selection.nodeFront;
+	    return this.markup.getNodeOuterHTML(node).then(function (oldContent) {
+	      _this17.markup.updateNodeOuterHTML(node, content, oldContent);
+	    });
+	  },
+
+	  /**
+	   * Paste the contents of the clipboard into the selected Node's inner HTML.
+	   */
+	  pasteInnerHTML: function pasteInnerHTML() {
+	    var _this18 = this;
+
+	    var content = this._getClipboardContentForPaste();
+	    if (!content) {
+	      return promise.reject("No clipboard content for paste");
+	    }
+
+	    var node = this.selection.nodeFront;
+	    return this.markup.getNodeInnerHTML(node).then(function (oldContent) {
+	      _this18.markup.updateNodeInnerHTML(node, content, oldContent);
+	    });
+	  },
+
+	  /**
+	   * Paste the contents of the clipboard as adjacent HTML to the selected Node.
+	   * @param position The position as specified for Element.insertAdjacentHTML
+	   *        (i.e. "beforeBegin", "afterBegin", "beforeEnd", "afterEnd").
+	   */
+	  pasteAdjacentHTML: function pasteAdjacentHTML(position) {
+	    var content = this._getClipboardContentForPaste();
+	    if (!content) {
+	      return promise.reject("No clipboard content for paste");
+	    }
+
+	    var node = this.selection.nodeFront;
+	    return this.markup.insertAdjacentHTMLToNode(node, position, content);
+	  },
+
+	  /**
+	   * Copy the innerHTML of the selected Node to the clipboard.
+	   */
+	  copyInnerHTML: function copyInnerHTML() {
+	    if (!this.selection.isNode()) {
+	      return;
+	    }
+	    this._copyLongString(this.walker.innerHTML(this.selection.nodeFront));
+	  },
+
+	  /**
+	   * Copy the outerHTML of the selected Node to the clipboard.
+	   */
+	  copyOuterHTML: function copyOuterHTML() {
+	    if (!this.selection.isNode()) {
+	      return;
+	    }
+	    var node = this.selection.nodeFront;
+
+	    switch (node.nodeType) {
+	      case nodeConstants.ELEMENT_NODE:
+	        this._copyLongString(this.walker.outerHTML(node));
+	        break;
+	      case nodeConstants.COMMENT_NODE:
+	        this._getLongString(node.getNodeValue()).then(function (comment) {
+	          clipboardHelper.copyString("<!--" + comment + "-->");
+	        });
+	        break;
+	      case nodeConstants.DOCUMENT_TYPE_NODE:
+	        clipboardHelper.copyString(node.doctypeString);
+	        break;
+	    }
+	  },
+
+	  /**
+	   * Copy the data-uri for the currently selected image in the clipboard.
+	   */
+	  copyImageDataUri: function copyImageDataUri() {
+	    var container = this.markup.getContainer(this.selection.nodeFront);
+	    if (container && container.isPreviewable()) {
+	      container.copyImageDataUri();
+	    }
+	  },
+
+	  /**
+	   * Copy the content of a longString (via a promise resolving a LongStringActor) to the clipboard
+	   * @param  {Promise} longStringActorPromise promise expected to resolve a LongStringActor instance
+	   * @return {Promise} promise resolving (with no argument) when the string is sent to the clipboard
+	   */
+	  _copyLongString: function _copyLongString(longStringActorPromise) {
+	    return this._getLongString(longStringActorPromise).then(function (string) {
+	      clipboardHelper.copyString(string);
+	    }).catch(function (e) {
+	      return console.error(e);
+	    });
+	  },
+
+	  /**
+	   * Retrieve the content of a longString (via a promise resolving a LongStringActor)
+	   * @param  {Promise} longStringActorPromise promise expected to resolve a LongStringActor instance
+	   * @return {Promise} promise resolving with the retrieved string as argument
+	   */
+	  _getLongString: function _getLongString(longStringActorPromise) {
+	    return longStringActorPromise.then(function (longStringActor) {
+	      return longStringActor.string().then(function (string) {
+	        longStringActor.release().catch(function (e) {
+	          return console.error(e);
+	        });
+	        return string;
+	      });
+	    }).catch(function (e) {
+	      return console.error(e);
+	    });
+	  },
+
+	  /**
+	   * Copy a unique selector of the selected Node to the clipboard.
+	   */
+	  copyUniqueSelector: function copyUniqueSelector() {
+	    if (!this.selection.isNode()) {
+	      return;
+	    }
+
+	    this.selection.nodeFront.getUniqueSelector().then(function (selector) {
+	      clipboardHelper.copyString(selector);
+	    }).then(null, console.error);
+	  },
+
+	  /**
+	   * Initiate gcli screenshot command on selected node
+	   */
+	  screenshotNode: function screenshotNode() {
+	    var _this19 = this;
+
+	    CommandUtils.createRequisition(this._target, {
+	      environment: CommandUtils.createEnvironment(this, "_target")
+	    }).then(function (requisition) {
+	      // Bug 1180314 -  CssSelector might contain white space so need to make sure it is
+	      // passed to screenshot as a single parameter.  More work *might* be needed if
+	      // CssSelector could contain escaped single- or double-quotes, backslashes, etc.
+	      requisition.updateExec("screenshot --selector '" + _this19.selectionCssSelector + "'");
+	    });
+	  },
+
+	  /**
+	   * Scroll the node into view.
+	   */
+	  scrollNodeIntoView: function scrollNodeIntoView() {
+	    if (!this.selection.isNode()) {
+	      return;
+	    }
+
+	    this.selection.nodeFront.scrollIntoView();
+	  },
+
+	  /**
+	   * Duplicate the selected node
+	   */
+	  duplicateNode: function duplicateNode() {
+	    var selection = this.selection;
+	    if (!selection.isElementNode() || selection.isRoot() || selection.isAnonymousNode() || selection.isPseudoElementNode()) {
+	      return;
+	    }
+	    this.walker.duplicateNode(selection.nodeFront).catch(function (e) {
+	      return console.error(e);
+	    });
+	  },
+
+	  /**
+	   * Delete the selected node.
+	   */
+	  deleteNode: function deleteNode() {
+	    if (!this.selection.isNode() || this.selection.isRoot()) {
+	      return;
+	    }
+
+	    // If the markup panel is active, use the markup panel to delete
+	    // the node, making this an undoable action.
+	    if (this.markup) {
+	      this.markup.deleteNode(this.selection.nodeFront);
+	    } else {
+	      // remove the node from content
+	      this.walker.removeNode(this.selection.nodeFront);
+	    }
+	  },
+
+	  /**
+	   * Add attribute to node.
+	   * Used for node context menu and shouldn't be called directly.
+	   */
+	  onAddAttribute: function onAddAttribute() {
+	    var container = this.markup.getContainer(this.selection.nodeFront);
+	    container.addAttribute();
+	  },
+
+	  /**
+	   * Edit attribute for node.
+	   * Used for node context menu and shouldn't be called directly.
+	   */
+	  onEditAttribute: function onEditAttribute() {
+	    var container = this.markup.getContainer(this.selection.nodeFront);
+	    container.editAttribute(this.nodeMenuTriggerInfo.name);
+	  },
+
+	  /**
+	   * Remove attribute from node.
+	   * Used for node context menu and shouldn't be called directly.
+	   */
+	  onRemoveAttribute: function onRemoveAttribute() {
+	    var container = this.markup.getContainer(this.selection.nodeFront);
+	    container.removeAttribute(this.nodeMenuTriggerInfo.name);
+	  },
+
+	  expandNode: function expandNode() {
+	    this.markup.expandAll(this.selection.nodeFront);
+	  },
+
+	  collapseNode: function collapseNode() {
+	    this.markup.collapseNode(this.selection.nodeFront);
+	  },
+
+	  /**
+	   * This method is here for the benefit of the node-menu-link-follow menu item
+	   * in the inspector contextual-menu.
+	   */
+	  onFollowLink: function onFollowLink() {
+	    var type = this.contextMenuTarget.dataset.type;
+	    var link = this.contextMenuTarget.dataset.link;
+
+	    this.followAttributeLink(type, link);
+	  },
+
+	  /**
+	   * Given a type and link found in a node's attribute in the markup-view,
+	   * attempt to follow that link (which may result in opening a new tab, the
+	   * style editor or debugger).
+	   */
+	  followAttributeLink: function followAttributeLink(type, link) {
+	    var _this20 = this;
+
+	    if (!type || !link) {
+	      return;
+	    }
+
+	    if (type === "uri" || type === "cssresource" || type === "jsresource") {
+	      // Open link in a new tab.
+	      // When the inspector menu was setup on click (see _getNodeLinkMenuItems), we
+	      // already checked that resolveRelativeURL existed.
+	      this.inspector.resolveRelativeURL(link, this.selection.nodeFront).then(function (url) {
+	        if (type === "uri") {
+	          var browserWin = _this20.target.tab.ownerDocument.defaultView;
+	          browserWin.openUILinkIn(url, "tab");
+	        } else if (type === "cssresource") {
+	          return _this20.toolbox.viewSourceInStyleEditor(url);
+	        } else if (type === "jsresource") {
+	          return _this20.toolbox.viewSourceInDebugger(url);
+	        }
+	        return null;
+	      }).catch(function (e) {
+	        return console.error(e);
+	      });
+	    } else if (type == "idref") {
+	      // Select the node in the same document.
+	      this.walker.document(this.selection.nodeFront).then(function (doc) {
+	        return _this20.walker.querySelector(doc, "#" + CSS.escape(link)).then(function (node) {
+	          if (!node) {
+	            _this20.emit("idref-attribute-link-failed");
+	            return;
+	          }
+	          _this20.selection.setNodeFront(node);
+	        });
+	      }).catch(function (e) {
+	        return console.error(e);
+	      });
+	    }
+	  },
+
+	  /**
+	   * This method is here for the benefit of the node-menu-link-copy menu item
+	   * in the inspector contextual-menu.
+	   */
+	  onCopyLink: function onCopyLink() {
+	    var link = this.contextMenuTarget.dataset.link;
+
+	    this.copyAttributeLink(link);
+	  },
+
+	  /**
+	   * This method is here for the benefit of copying links.
+	   */
+	  copyAttributeLink: function copyAttributeLink(link) {
+	    // When the inspector menu was setup on click (see _getNodeLinkMenuItems), we
+	    // already checked that resolveRelativeURL existed.
+	    this.inspector.resolveRelativeURL(link, this.selection.nodeFront).then(function (url) {
+	      clipboardHelper.copyString(url);
+	    }, console.error);
+	  }
+	};
+
+/***/ },
+
+/***/ 1:
+/***/ function(module, exports) {
+
+	module.exports = chrome;
+
+/***/ },
+
+/***/ 2:
+/***/ function(module, exports, __webpack_require__) {
+
+	/* This Source Code Form is subject to the terms of the Mozilla Public
+	 * License, v. 2.0. If a copy of the MPL was not distributed with this
+	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+	"use strict";
+
+	// See bug 1273941 to understand this choice of promise.
+
+	const Promise = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"promise\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
+
+	/**
+	 * Returns a deferred object, with a resolve and reject property.
+	 * https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred
+	 */
+	module.exports = function defer() {
+	  let resolve, reject;
+	  let promise = new Promise(function () {
+	    resolve = arguments[0];
+	    reject = arguments[1];
+	  });
+	  return {
+	    resolve: resolve,
+	    reject: reject,
+	    promise: promise
+	  };
+	};
+
+/***/ },
+
+/***/ 3:
+/***/ function(module, exports, __webpack_require__) {
+
+	/* WEBPACK VAR INJECTION */(function(module) {/* This Source Code Form is subject to the terms of the Mozilla Public
+	 * License, v. 2.0. If a copy of the MPL was not distributed with this
+	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+	"use strict";
+
+	(function (factory) {
+	  // This file can be loaded in several different ways.  It can be
+	  // require()d, either from the main thread or from a worker thread;
+	  // or it can be imported via Cu.import.  These different forms
+	  // explain some of the hairiness of this code.
+	  //
+	  // It's important for the devtools-as-html project that a require()
+	  // on the main thread not use any chrome privileged APIs.  Instead,
+	  // the body of the main function can only require() (not Cu.import)
+	  // modules that are available in the devtools content mode.  This,
+	  // plus the lack of |console| in workers, results in some gyrations
+	  // in the definition of |console|.
+	  if (this.module && module.id.indexOf("event-emitter") >= 0) {
+	    let console;
+	    if (isWorker) {
+	      console = {
+	        error: () => {}
+	      };
+	    } else {
+	      console = this.console;
+	    }
+	    // require
+	    factory.call(this, __webpack_require__(5), exports, module, console);
+	  } else {
+	    // Cu.import.  This snippet implements a sort of miniature loader,
+	    // which is responsible for appropriately translating require()
+	    // requests from the client function.  This code can use
+	    // Cu.import, because it is never run in the devtools-in-content
+	    // mode.
+	    this.isWorker = false;
+	    const Cu = Components.utils;
+	    let console = Cu.import("resource://gre/modules/Console.jsm", {}).console;
+	    // Bug 1259045: This module is loaded early in firefox startup as a JSM,
+	    // but it doesn't depends on any real module. We can save a few cycles
+	    // and bytes by not loading Loader.jsm.
+	    let require = function (module) {
+	      switch (module) {
+	        case "devtools/shared/defer":
+	          return Cu.import("resource://gre/modules/Promise.jsm", {}).Promise.defer;
+	        case "Services":
+	          return Cu.import("resource://gre/modules/Services.jsm", {}).Services;
+	        case "chrome":
+	          return {
+	            Cu,
+	            components: Components
+	          };
+	      }
+	      return null;
+	    };
+	    factory.call(this, require, this, { exports: this }, console);
+	    this.EXPORTED_SYMBOLS = ["EventEmitter"];
+	  }
+	}).call(this, function (require, exports, module, console) {
+	  // 
+	  // After this point the code may not use Cu.import, and should only
+	  // require() modules that are "clean-for-content".
+	  let EventEmitter = this.EventEmitter = function () {};
+	  module.exports = EventEmitter;
+
+	  // See comment in JSM module boilerplate when adding a new dependency.
+	  const { components } = require("chrome");
+	  const Services = require("Services");
+	  const defer = require("devtools/shared/defer");
+	  let loggingEnabled = true;
+
+	  if (!isWorker) {
+	    loggingEnabled = Services.prefs.getBoolPref("devtools.dump.emit");
+	    Services.prefs.addObserver("devtools.dump.emit", {
+	      observe: () => {
+	        loggingEnabled = Services.prefs.getBoolPref("devtools.dump.emit");
+	      }
+	    }, false);
+	  }
+
+	  /**
+	   * Decorate an object with event emitter functionality.
+	   *
+	   * @param Object objectToDecorate
+	   *        Bind all public methods of EventEmitter to
+	   *        the objectToDecorate object.
+	   */
+	  EventEmitter.decorate = function (objectToDecorate) {
+	    let emitter = new EventEmitter();
+	    objectToDecorate.on = emitter.on.bind(emitter);
+	    objectToDecorate.off = emitter.off.bind(emitter);
+	    objectToDecorate.once = emitter.once.bind(emitter);
+	    objectToDecorate.emit = emitter.emit.bind(emitter);
+	  };
+
+	  EventEmitter.prototype = {
+	    /**
+	     * Connect a listener.
+	     *
+	     * @param string event
+	     *        The event name to which we're connecting.
+	     * @param function listener
+	     *        Called when the event is fired.
+	     */
+	    on(event, listener) {
+	      if (!this._eventEmitterListeners) {
+	        this._eventEmitterListeners = new Map();
+	      }
+	      if (!this._eventEmitterListeners.has(event)) {
+	        this._eventEmitterListeners.set(event, []);
+	      }
+	      this._eventEmitterListeners.get(event).push(listener);
+	    },
+
+	    /**
+	     * Listen for the next time an event is fired.
+	     *
+	     * @param string event
+	     *        The event name to which we're connecting.
+	     * @param function listener
+	     *        (Optional) Called when the event is fired. Will be called at most
+	     *        one time.
+	     * @return promise
+	     *        A promise which is resolved when the event next happens. The
+	     *        resolution value of the promise is the first event argument. If
+	     *        you need access to second or subsequent event arguments (it's rare
+	     *        that this is needed) then use listener
+	     */
+	    once(event, listener) {
+	      let deferred = defer();
+
+	      let handler = (_, first, ...rest) => {
+	        this.off(event, handler);
+	        if (listener) {
+	          listener.apply(null, [event, first, ...rest]);
+	        }
+	        deferred.resolve(first);
+	      };
+
+	      handler._originalListener = listener;
+	      this.on(event, handler);
+
+	      return deferred.promise;
+	    },
+
+	    /**
+	     * Remove a previously-registered event listener.  Works for events
+	     * registered with either on or once.
+	     *
+	     * @param string event
+	     *        The event name whose listener we're disconnecting.
+	     * @param function listener
+	     *        The listener to remove.
+	     */
+	    off(event, listener) {
+	      if (!this._eventEmitterListeners) {
+	        return;
+	      }
+	      let listeners = this._eventEmitterListeners.get(event);
+	      if (listeners) {
+	        this._eventEmitterListeners.set(event, listeners.filter(l => {
+	          return l !== listener && l._originalListener !== listener;
+	        }));
+	      }
+	    },
+
+	    /**
+	     * Emit an event.  All arguments to this method will
+	     * be sent to listener functions.
+	     */
+	    emit(event) {
+	      this.logEvent(event, arguments);
+
+	      if (!this._eventEmitterListeners || !this._eventEmitterListeners.has(event)) {
+	        return;
+	      }
+
+	      let originalListeners = this._eventEmitterListeners.get(event);
+	      for (let listener of this._eventEmitterListeners.get(event)) {
+	        // If the object was destroyed during event emission, stop
+	        // emitting.
+	        if (!this._eventEmitterListeners) {
+	          break;
+	        }
+
+	        // If listeners were removed during emission, make sure the
+	        // event handler we're going to fire wasn't removed.
+	        if (originalListeners === this._eventEmitterListeners.get(event) || this._eventEmitterListeners.get(event).some(l => l === listener)) {
+	          try {
+	            listener.apply(null, arguments);
+	          } catch (ex) {
+	            // Prevent a bad listener from interfering with the others.
+	            let msg = ex + ": " + ex.stack;
+	            console.error(msg);
+	            dump(msg + "\n");
+	          }
+	        }
+	      }
+	    },
+
+	    logEvent(event, args) {
+	      if (!loggingEnabled) {
+	        return;
+	      }
+
+	      let caller, func, path;
+	      if (!isWorker) {
+	        caller = components.stack.caller.caller;
+	        func = caller.name;
+	        let file = caller.filename;
+	        if (file.includes(" -> ")) {
+	          file = caller.filename.split(/ -> /)[1];
+	        }
+	        path = file + ":" + caller.lineNumber;
+	      }
+
+	      let argOut = "(";
+	      if (args.length === 1) {
+	        argOut += event;
+	      }
+
+	      let out = "EMITTING: ";
+
+	      // We need this try / catch to prevent any dead object errors.
+	      try {
+	        for (let i = 1; i < args.length; i++) {
+	          if (i === 1) {
+	            argOut = "(" + event + ", ";
+	          } else {
+	            argOut += ", ";
+	          }
+
+	          let arg = args[i];
+	          argOut += arg;
+
+	          if (arg && arg.nodeName) {
+	            argOut += " (" + arg.nodeName;
+	            if (arg.id) {
+	              argOut += "#" + arg.id;
+	            }
+	            if (arg.className) {
+	              argOut += "." + arg.className;
+	            }
+	            argOut += ")";
+	          }
+	        }
+	      } catch (e) {
+	        // Object is dead so the toolbox is most likely shutting down,
+	        // do nothing.
+	      }
+
+	      argOut += ")";
+	      out += "emit" + argOut + " from " + func + "() -> " + path + "\n";
+
+	      dump(out);
+	    }
+	  };
+	});
+	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)(module)))
+
+/***/ },
+
+/***/ 4:
+/***/ function(module, exports) {
+
+	module.exports = function(module) {
+		if(!module.webpackPolyfill) {
+			module.deprecate = function() {};
+			module.paths = [];
+			// module.parent = undefined by default
+			module.children = [];
+			module.webpackPolyfill = 1;
+		}
+		return module;
+	}
+
+
+/***/ },
+
+/***/ 5:
+/***/ function(module, exports, __webpack_require__) {
+
+	var map = {
+		"./Loader.jsm": 6,
+		"./Parser.jsm": 7,
+		"./apps/Devices.jsm": 12,
+		"./apps/Simulator.jsm": 13,
+		"./apps/tests/redirect.sjs": 22,
+		"./heapsnapshot/tests/unit/Census.jsm": 86,
+		"./loader-plugin-raw.jsm": 97,
+		"./shims/Console.jsm": 123,
+		"./shims/Loader.jsm": 124,
+		"./shims/Simulator.jsm": 125,
+		"./shims/dbg-client.jsm": 126
+	};
+	function webpackContext(req) {
+		return __webpack_require__(webpackContextResolve(req));
+	};
+	function webpackContextResolve(req) {
+		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
+	};
+	webpackContext.keys = function webpackContextKeys() {
+		return Object.keys(map);
+	};
+	webpackContext.resolve = webpackContextResolve;
+	module.exports = webpackContext;
+	webpackContext.id = 5;
+
+
+/***/ },
+
+/***/ 6:
+/***/ function(module, exports) {
+
+	/* This Source Code Form is subject to the terms of the Mozilla Public
+	 * License, v. 2.0. If a copy of the MPL was not distributed with this
+	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+	"use strict";
+
+	/**
+	 * Manages the addon-sdk loader instance used to load the developer tools.
+	 */
+
+	var { utils: Cu } = Components;
+	var { Services } = Cu.import("resource://gre/modules/Services.jsm", {});
+	var { Loader, descriptor, resolveURI } = Cu.import("resource://gre/modules/commonjs/toolkit/loader.js", {});
+	var { requireRawId } = Cu.import("resource://devtools/shared/loader-plugin-raw.jsm", {});
+
+	this.EXPORTED_SYMBOLS = ["DevToolsLoader", "devtools", "BuiltinProvider",
+	                         "require", "loader"];
+
+	/**
+	 * Providers are different strategies for loading the devtools.
+	 */
+
+	var sharedGlobalBlocklist = ["sdk/indexed-db"];
+
+	/**
+	 * Used when the tools should be loaded from the Firefox package itself.
+	 * This is the default case.
+	 */
+	function BuiltinProvider() {}
+	BuiltinProvider.prototype = {
+	  load: function () {
+	    const paths = {
+	      //  DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING 
+	      "": "resource://gre/modules/commonjs/",
+	      //  DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING 
+	      "devtools": "resource://devtools",
+	      //  DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING 
+	      "gcli": "resource://devtools/shared/gcli/source/lib/gcli",
+	      //  DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING 
+	      "acorn": "resource://devtools/acorn",
+	      //  DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING 
+	      "acorn/util/walk": "resource://devtools/acorn/walk.js",
+	      //  DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING 
+	      "source-map": "resource://devtools/shared/sourcemap/source-map.js",
+	      //  DISCUSSION ON DEV-DEVELOPER-TOOLS REQUIRED BEFORE MODIFYING 
+	      // Allow access to xpcshell test items from the loader.
+	      "xpcshell-test": "resource://test",
+	    };
+	    // When creating a Loader invisible to the Debugger, we have to ensure
+	    // using only modules and not depend on any JSM. As everything that is
+	    // not loaded with Loader isn't going to respect `invisibleToDebugger`.
+	    // But we have to keep using Promise.jsm for other loader to prevent
+	    // breaking unhandled promise rejection in tests.
+	    if (this.invisibleToDebugger) {
+	      paths.promise = "resource://gre/modules/Promise-backend.js";
+	    }
+	    this.loader = new Loader.Loader({
+	      id: "fx-devtools",
+	      paths,
+	      invisibleToDebugger: this.invisibleToDebugger,
+	      sharedGlobal: true,
+	      sharedGlobalBlocklist,
+	      requireHook: (id, require) => {
+	        if (id.startsWith("raw!")) {
+	          return requireRawId(id, require);
+	        }
+	        return require(id);
+	      },
+	    });
+	  },
+
+	  unload: function (reason) {
+	    Loader.unload(this.loader, reason);
+	    delete this.loader;
+	  },
+	};
+
+	var gNextLoaderID = 0;
+
+	/**
+	 * The main devtools API. The standard instance of this loader is exported as
+	 * |devtools| below, but if a fresh copy of the loader is needed, then a new
+	 * one can also be created.
+	 */
+	this.DevToolsLoader = function DevToolsLoader() {
+	  this.require = this.require.bind(this);
+
+	  Services.obs.addObserver(this, "devtools-unload", false);
+	};
+
+	DevToolsLoader.prototype = {
+	  destroy: function (reason = "shutdown") {
+	    Services.obs.removeObserver(this, "devtools-unload");
+
+	    if (this._provider) {
+	      this._provider.unload(reason);
+	      delete this._provider;
+	    }
+	  },
+
+	  get provider() {
+	    if (!this._provider) {
+	      this._loadProvider();
+	    }
+	    return this._provider;
+	  },
+
+	  _provider: null,
+
+	  get id() {
+	    if (this._id) {
+	      return this._id;
+	    }
+	    this._id = ++gNextLoaderID;
+	    return this._id;
+	  },
+
+	  /**
+	   * A dummy version of require, in case a provider hasn't been chosen yet when
+	   * this is first called.  This will then be replaced by the real version.
+	   * @see setProvider
+	   */
+	  require: function () {
+	    if (!this._provider) {
+	      this._loadProvider();
+	    }
+	    return this.require.apply(this, arguments);
+	  },
+
+	  /**
+	   * Return true if |id| refers to something requiring help from a
+	   * loader plugin.
+	   */
+	  isLoaderPluginId: function (id) {
+	    return id.startsWith("raw!");
+	  },
+
+	  /**
+	   * Override the provider used to load the tools.
+	   */
+	  setProvider: function (provider) {
+	    if (provider === this._provider) {
+	      return;
+	    }
+
+	    if (this._provider) {
+	      delete this.require;
+	      this._provider.unload("newprovider");
+	    }
+	    this._provider = provider;
+
+	    // Pass through internal loader settings specific to this loader instance
+	    this._provider.invisibleToDebugger = this.invisibleToDebugger;
+
+	    this._provider.load();
+	    this.require = Loader.Require(this._provider.loader, { id: "devtools" });
+
+	    // Fetch custom pseudo modules and globals
+	    let { modules, globals } = this.require("devtools/shared/builtin-modules");
+
+	    // When creating a Loader for the browser toolbox, we have to use
+	    // Promise-backend.js, as a Loader module. Instead of Promise.jsm which
+	    // can't be flagged as invisible to debugger.
+	    if (this.invisibleToDebugger) {
+	      delete modules.promise;
+	    }
+
+	    // Register custom pseudo modules to the current loader instance
+	    let loader = this._provider.loader;
+	    for (let id in modules) {
+	      let exports = modules[id];
+	      let uri = resolveURI(id, loader.mapping);
+	      loader.modules[uri] = { exports };
+	    }
+
+	    // Register custom globals to the current loader instance
+	    globals.loader.id = this.id;
+	    Object.defineProperties(loader.globals, descriptor(globals));
+
+	    // Expose lazy helpers on loader
+	    this.lazyGetter = globals.loader.lazyGetter;
+	    this.lazyImporter = globals.loader.lazyImporter;
+	    this.lazyServiceGetter = globals.loader.lazyServiceGetter;
+	    this.lazyRequireGetter = globals.loader.lazyRequireGetter;
+	  },
+
+	  /**
+	   * Choose a default tools provider based on the preferences.
+	   */
+	  _loadProvider: function () {
+	    this.setProvider(new BuiltinProvider());
+	  },
+
+	  /**
+	   * Handles "devtools-unload" event
+	   *
+	   * @param String data
+	   *    reason passed to modules when unloaded
+	   */
+	  observe: function (subject, topic, data) {
+	    if (topic != "devtools-unload") {
+	      return;
+	    }
+	    this.destroy(data);
+	  },
+
+	  /**
+	   * Sets whether the compartments loaded by this instance should be invisible
+	   * to the debugger.  Invisibility is needed for loaders that support debugging
+	   * of chrome code.  This is true of remote target environments, like Fennec or
+	   * B2G.  It is not the default case for desktop Firefox because we offer the
+	   * Browser Toolbox for chrome debugging there, which uses its own, separate
+	   * loader instance.
+	   * @see devtools/client/framework/ToolboxProcess.jsm
+	   */
+	  invisibleToDebugger: Services.appinfo.name !== "Firefox"
+	};
+
+	// Export the standard instance of DevToolsLoader used by the tools.
+	this.devtools = this.loader = new DevToolsLoader();
+
+	this.require = this.devtools.require.bind(this.devtools);
+
+	// For compatibility reasons, expose these symbols on "devtools":
+	Object.defineProperty(this.devtools, "Toolbox", {
+	  get: () => this.require("devtools/client/framework/toolbox").Toolbox
+	});
+	Object.defineProperty(this.devtools, "TargetFactory", {
+	  get: () => this.require("devtools/client/framework/target").TargetFactory
+	});
+
+
+/***/ },
+
+/***/ 7:
+/***/ function(module, exports, __webpack_require__) {
+
+	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
+	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+	/* This Source Code Form is subject to the terms of the Mozilla Public
+	 * License, v. 2.0. If a copy of the MPL was not distributed with this
+	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+	"use strict";
+
+	const Cu = Components.utils;
+
+	const { require } = Cu.import("resource://devtools/shared/Loader.jsm", {});
+	const { XPCOMUtils } = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"resource://gre/modules/XPCOMUtils.jsm\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
+	const { console } = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"resource://gre/modules/Console.jsm\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
+	const DevToolsUtils = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"devtools/shared/DevToolsUtils\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
+
+	XPCOMUtils.defineLazyModuleGetter(this,
+	  "Reflect", "resource://gre/modules/reflect.jsm");
+
+	this.EXPORTED_SYMBOLS = ["Parser", "ParserHelpers", "SyntaxTreeVisitor"];
+
+	/**
+	 * A JS parser using the reflection API.
+	 */
+	this.Parser = function Parser() {
+	  this._cache = new Map();
+	  this.errors = [];
+	  this.logExceptions = true;
+	};
+
+	Parser.prototype = {
+	  /**
+	   * Gets a collection of parser methods for a specified source.
+	   *
+	   * @param string source
+	   *        The source text content.
+	   * @param string url [optional]
+	   *        The source url. The AST nodes will be cached, so you can use this
+	   *        identifier to avoid parsing the whole source again.
+	   */
+	  get(source, url = "") {
+	    // Try to use the cached AST nodes, to avoid useless parsing operations.
+	    if (this._cache.has(url)) {
+	      return this._cache.get(url);
+	    }
+
+	    // The source may not necessarily be JS, in which case we need to extract
+	    // all the scripts. Fastest/easiest way is with a regular expression.
+	    // Don't worry, the rules of using a <script> tag are really strict,
+	    // this will work.
+	    let regexp = /<script[^>]*?(?:>([^]*?)<\/script\s*>|\/>)/gim;
+	    let syntaxTrees = [];
+	    let scriptMatches = [];
+	    let scriptMatch;
+
+	    if (source.match(/^\s*</)) {
+	      // First non whitespace character is &lt, so most definitely HTML.
+	      while ((scriptMatch = regexp.exec(source))) {
+	        // Contents are captured at index 1 or nothing: Self-closing scripts
+	        // won't capture code content
+	        scriptMatches.push(scriptMatch[1] || "");
+	      }
+	    }
+
+	    // If there are no script matches, send the whole source directly to the
+	    // reflection API to generate the AST nodes.
+	    if (!scriptMatches.length) {
+	      // Reflect.parse throws when encounters a syntax error.
+	      try {
+	        let nodes = Reflect.parse(source);
+	        let length = source.length;
+	        syntaxTrees.push(new SyntaxTree(nodes, url, length));
+	      } catch (e) {
+	        this.errors.push(e);
+	        if (this.logExceptions) {
+	          DevToolsUtils.reportException(url, e);
+	        }
+	      }
+	    } else {
+	      // Generate the AST nodes for each script.
+	      for (let script of scriptMatches) {
+	        // Reflect.parse throws when encounters a syntax error.
+	        try {
+	          let nodes = Reflect.parse(script);
+	          let offset = source.indexOf(script);
+	          let length = script.length;
+	          syntaxTrees.push(new SyntaxTree(nodes, url, length, offset));
+	        } catch (e) {
+	          this.errors.push(e);
+	          if (this.logExceptions) {
+	            DevToolsUtils.reportException(url, e);
+	          }
+	        }
+	      }
+	    }
+
+	    let pool = new SyntaxTreesPool(syntaxTrees, url);
+
+	    // Cache the syntax trees pool by the specified url. This is entirely
+	    // optional, but it's strongly encouraged to cache ASTs because
+	    // generating them can be costly with big/complex sources.
+	    if (url) {
+	      this._cache.set(url, pool);
+	    }
+
+	    return pool;
+	  },
+
+	  /**
+	   * Clears all the parsed sources from cache.
+	   */
+	  clearCache() {
+	    this._cache.clear();
+	  },
+
+	  /**
+	   * Clears the AST for a particular source.
+	   *
+	   * @param String url
+	   *        The URL of the source that is being cleared.
+	   */
+	  clearSource(url) {
+	    this._cache.delete(url);
+	  },
+
+	  _cache: null,
+	  errors: null
+	};
+
+	/**
+	 * A pool handling a collection of AST nodes generated by the reflection API.
+	 *
+	 * @param object syntaxTrees
+	 *        A collection of AST nodes generated for a source.
+	 * @param string url [optional]
+	 *        The source url.
+	 */
+	function SyntaxTreesPool(syntaxTrees, url = "<unknown>") {
+	  this._trees = syntaxTrees;
+	  this._url = url;
+	  this._cache = new Map();
+	}
+
+	SyntaxTreesPool.prototype = {
+	  /**
+	   * @see SyntaxTree.prototype.getIdentifierAt
+	   */
+	  getIdentifierAt({ line, column, scriptIndex, ignoreLiterals }) {
+	    return this._call("getIdentifierAt",
+	      scriptIndex, line, column, ignoreLiterals)[0];
+	  },
+
+	  /**
+	   * @see SyntaxTree.prototype.getNamedFunctionDefinitions
+	   */
+	  getNamedFunctionDefinitions(substring) {
+	    return this._call("getNamedFunctionDefinitions", -1, substring);
+	  },
+
+	  /**
+	   * @return SyntaxTree
+	   *         The last tree in this._trees
+	   */
+	  getLastSyntaxTree() {
+	    return this._trees[this._trees.length - 1];
+	  },
+
+	  /**
+	   * Gets the total number of scripts in the parent source.
+	   * @return number
+	   */
+	  get scriptCount() {
+	    return this._trees.length;
+	  },
+
+	  /**
+	   * Finds the start and length of the script containing the specified offset
+	   * relative to its parent source.
+	   *
+	   * @param number atOffset
+	   *        The offset relative to the parent source.
+	   * @return object
+	   *         The offset and length relative to the enclosing script.
+	   */
+	  getScriptInfo(atOffset) {
+	    let info = { start: -1, length: -1, index: -1 };
+
+	    for (let { offset, length } of this._trees) {
+	      info.index++;
+	      if (offset <= atOffset && offset + length >= atOffset) {
+	        info.start = offset;
+	        info.length = length;
+	        return info;
+	      }
+	    }
+
+	    info.index = -1;
+	    return info;
+	  },
+
+	  /**
+	   * Handles a request for a specific or all known syntax trees.
+	   *
+	   * @param string functionName
+	   *        The function name to call on the SyntaxTree instances.
+	   * @param number syntaxTreeIndex
+	   *        The syntax tree for which to handle the request. If the tree at
+	   *        the specified index isn't found, the accumulated results for all
+	   *        syntax trees are returned.
+	   * @param any params
+	   *        Any kind params to pass to the request function.
+	   * @return array
+	   *         The results given by all known syntax trees.
+	   */
+	  _call(functionName, syntaxTreeIndex, ...params) {
+	    let results = [];
+	    let requestId = [functionName, syntaxTreeIndex, params].toSource();
+
+	    if (this._cache.has(requestId)) {
+	      return this._cache.get(requestId);
+	    }
+
+	    let requestedTree = this._trees[syntaxTreeIndex];
+	    let targettedTrees = requestedTree ? [requestedTree] : this._trees;
+
+	    for (let syntaxTree of targettedTrees) {
+	      try {
+	        let parseResults = syntaxTree[functionName].apply(syntaxTree, params);
+	        if (parseResults) {
+	          parseResults.sourceUrl = syntaxTree.url;
+	          parseResults.scriptLength = syntaxTree.length;
+	          parseResults.scriptOffset = syntaxTree.offset;
+	          results.push(parseResults);
+	        }
+	      } catch (e) {
+	        // Can't guarantee that the tree traversal logic is forever perfect :)
+	        // Language features may be added, in which case the recursive methods
+	        // need to be updated. If an exception is thrown here, file a bug.
+	        DevToolsUtils.reportException(
+	          `Syntax tree visitor for ${this._url}`, e);
+	      }
+	    }
+	    this._cache.set(requestId, results);
+	    return results;
+	  },
+
+	  _trees: null,
+	  _cache: null
+	};
+
+	/**
+	 * A collection of AST nodes generated by the reflection API.
+	 *
+	 * @param object nodes
+	 *        The AST nodes.
+	 * @param string url
+	 *        The source url.
+	 * @param number length
+	 *        The total number of chars of the parsed script in the parent source.
+	 * @param number offset [optional]
+	 *        The char offset of the parsed script in the parent source.
+	 */
+	function SyntaxTree(nodes, url, length, offset = 0) {
+	  this.AST = nodes;
+	  this.url = url;
+	  this.length = length;
+	  this.offset = offset;
+	}
+
+	SyntaxTree.prototype = {
+	  /**
+	   * Gets the identifier at the specified location.
+	   *
+	   * @param number line
+	   *        The line in the source.
+	   * @param number column
+	   *        The column in the source.
+	   * @param boolean ignoreLiterals
+	   *        Specifies if alone literals should be ignored.
+	   * @return object
+	   *         An object containing identifier information as { name, location,
+	   *         evalString } properties, or null if nothing is found.
+	   */
+	  getIdentifierAt(line, column, ignoreLiterals) {
+	    let info = null;
+
+	    SyntaxTreeVisitor.walk(this.AST, {
+	      /**
+	       * Callback invoked for each identifier node.
+	       * @param Node node
+	       */
+	      onIdentifier(node) {
+	        if (ParserHelpers.nodeContainsPoint(node, line, column)) {
+	          info = {
+	            name: node.name,
+	            location: ParserHelpers.getNodeLocation(node),
+	            evalString: ParserHelpers.getIdentifierEvalString(node)
+	          };
+
+	          // Abruptly halt walking the syntax tree.
+	          SyntaxTreeVisitor.break = true;
+	        }
+	      },
+
+	      /**
+	       * Callback invoked for each literal node.
+	       * @param Node node
+	       */
+	      onLiteral(node) {
+	        if (!ignoreLiterals) {
+	          this.onIdentifier(node);
+	        }
+	      },
+
+	      /**
+	       * Callback invoked for each 'this' node.
+	       * @param Node node
+	       */
+	      onThisExpression(node) {
+	        this.onIdentifier(node);
+	      }
+	    });
+
+	    return info;
+	  },
+
+	  /**
+	   * Searches for all function definitions (declarations and expressions)
+	   * whose names (or inferred names) contain a string.
+	   *
+	   * @param string substring
+	   *        The string to be contained in the function name (or inferred name).
+	   *        Can be an empty string to match all functions.
+	   * @return array
+	   *         All the matching function declarations and expressions, as
+	   *         { functionName, functionLocation ... } object hashes.
+	   */
+	  getNamedFunctionDefinitions(substring) {
+	    let lowerCaseToken = substring.toLowerCase();
+	    let store = [];
+
+	    function includesToken(name) {
+	      return name && name.toLowerCase().includes(lowerCaseToken);
+	    }
+
+	    SyntaxTreeVisitor.walk(this.AST, {
+	      /**
+	       * Callback invoked for each function declaration node.
+	       * @param Node node
+	       */
+	      onFunctionDeclaration(node) {
+	        let functionName = node.id.name;
+	        if (includesToken(functionName)) {
+	          store.push({
+	            functionName: functionName,
+	            functionLocation: ParserHelpers.getNodeLocation(node)
+	          });
+	        }
+	      },
+
+	      /**
+	       * Callback invoked for each function expression node.
+	       * @param Node node
+	       */
+	      onFunctionExpression(node) {
+	        // Function expressions don't necessarily have a name.
+	        let functionName = node.id ? node.id.name : "";
+	        let functionLocation = ParserHelpers.getNodeLocation(node);
+
+	        // Infer the function's name from an enclosing syntax tree node.
+	        let inferredInfo = ParserHelpers.inferFunctionExpressionInfo(node);
+	        let inferredName = inferredInfo.name;
+	        let inferredChain = inferredInfo.chain;
+	        let inferredLocation = inferredInfo.loc;
+
+	        // Current node may be part of a larger assignment expression stack.
+	        if (node._parent.type == "AssignmentExpression") {
+	          this.onFunctionExpression(node._parent);
+	        }
+
+	        if (includesToken(functionName) || includesToken(inferredName)) {
+	          store.push({
+	            functionName: functionName,
+	            functionLocation: functionLocation,
+	            inferredName: inferredName,
+	            inferredChain: inferredChain,
+	            inferredLocation: inferredLocation
+	          });
+	        }
+	      },
+
+	      /**
+	       * Callback invoked for each arrow expression node.
+	       * @param Node node
+	       */
+	      onArrowFunctionExpression(node) {
+	        // Infer the function's name from an enclosing syntax tree node.
+	        let inferredInfo = ParserHelpers.inferFunctionExpressionInfo(node);
+	        let inferredName = inferredInfo.name;
+	        let inferredChain = inferredInfo.chain;
+	        let inferredLocation = inferredInfo.loc;
+
+	        // Current node may be part of a larger assignment expression stack.
+	        if (node._parent.type == "AssignmentExpression") {
+	          this.onFunctionExpression(node._parent);
+	        }
+
+	        if (includesToken(inferredName)) {
+	          store.push({
+	            inferredName: inferredName,
+	            inferredChain: inferredChain,
+	            inferredLocation: inferredLocation
+	          });
+	        }
+	      }
+	    });
+
+	    return store;
+	  },
+
+	  AST: null,
+	  url: "",
+	  length: 0,
+	  offset: 0
+	};
+
+	/**
+	 * Parser utility methods.
+	 */
+	var ParserHelpers = {
+	  /**
+	   * Gets the location information for a node. Not all nodes have a
+	   * location property directly attached, or the location information
+	   * is incorrect, in which cases it's accessible via the parent.
+	   *
+	   * @param Node node
+	   *        The node who's location needs to be retrieved.
+	   * @return object
+	   *         An object containing { line, column } information.
+	   */
+	  getNodeLocation(node) {
+	    if (node.type != "Identifier") {
+	      return node.loc;
+	    }
+	    // Work around the fact that some identifier nodes don't have the
+	    // correct location attached.
+	    let { loc: parentLocation, type: parentType } = node._parent;
+	    let { loc: nodeLocation } = node;
+	    if (!nodeLocation) {
+	      if (parentType == "FunctionDeclaration" ||
+	          parentType == "FunctionExpression") {
+	        // e.g. "function foo() {}" or "{ bar: function foo() {} }"
+	        // The location is unavailable for the identifier node "foo".
+	        let loc = Cu.cloneInto(parentLocation, {});
+	        loc.end.line = loc.start.line;
+	        loc.end.column = loc.start.column + node.name.length;
+	        return loc;
+	      }
+	      if (parentType == "MemberExpression") {
+	        // e.g. "foo.bar"
+	        // The location is unavailable for the identifier node "bar".
+	        let loc = Cu.cloneInto(parentLocation, {});
+	        loc.start.line = loc.end.line;
+	        loc.start.column = loc.end.column - node.name.length;
+	        return loc;
+	      }
+	      if (parentType == "LabeledStatement") {
+	        // e.g. label: ...
+	        // The location is unavailable for the identifier node "label".
+	        let loc = Cu.cloneInto(parentLocation, {});
+	        loc.end.line = loc.start.line;
+	        loc.end.column = loc.start.column + node.name.length;
+	        return loc;
+	      }
+	      if (parentType == "ContinueStatement" || parentType == "BreakStatement") {
+	        // e.g. continue label; or break label;
+	        // The location is unavailable for the identifier node "label".
+	        let loc = Cu.cloneInto(parentLocation, {});
+	        loc.start.line = loc.end.line;
+	        loc.start.column = loc.end.column - node.name.length;
+	        return loc;
+	      }
+	    } else if (parentType == "VariableDeclarator") {
+	      // e.g. "let foo = 42"
+	      // The location incorrectly spans across the whole variable declaration,
+	      // not just the identifier node "foo".
+	      let loc = Cu.cloneInto(nodeLocation, {});
+	      loc.end.line = loc.start.line;
+	      loc.end.column = loc.start.column + node.name.length;
+	      return loc;
+	    }
+	    return node.loc;
+	  },
+
+	  /**
+	   * Checks if a node's bounds contains a specified line.
+	   *
+	   * @param Node node
+	   *        The node's bounds used as reference.
+	   * @param number line
+	   *        The line number to check.
+	   * @return boolean
+	   *         True if the line and column is contained in the node's bounds.
+	   */
+	  nodeContainsLine(node, line) {
+	    let { start: s, end: e } = this.getNodeLocation(node);
+	    return s.line <= line && e.line >= line;
+	  },
+
+	  /**
+	   * Checks if a node's bounds contains a specified line and column.
+	   *
+	   * @param Node node
+	   *        The node's bounds used as reference.
+	   * @param number line
+	   *        The line number to check.
+	   * @param number column
+	   *        The column number to check.
+	   * @return boolean
+	   *         True if the line and column is contained in the node's bounds.
+	   */
+	  nodeContainsPoint(node, line, column) {
+	    let { start: s, end: e } = this.getNodeLocation(node);
+	    return s.line == line && e.line == line &&
+	           s.column <= column && e.column >= column;
+	  },
+
+	  /**
+	   * Try to infer a function expression's name & other details based on the
+	   * enclosing VariableDeclarator, AssignmentExpression or ObjectExpression.
+	   *
+	   * @param Node node
+	   *        The function expression node to get the name for.
+	   * @return object
+	   *         The inferred function name, or empty string can't infer the name,
+	   *         along with the chain (a generic "context", like a prototype chain)
+	   *         and location if available.
+	   */
+	  inferFunctionExpressionInfo(node) {
+	    let parent = node._parent;
+
+	    // A function expression may be defined in a variable declarator,
+	    // e.g. var foo = function(){}, in which case it is possible to infer
+	    // the variable name.
+	    if (parent.type == "VariableDeclarator") {
+	      return {
+	        name: parent.id.name,
+	        chain: null,
+	        loc: this.getNodeLocation(parent.id)
+	      };
+	    }
+
+	    // Function expressions can also be defined in assignment expressions,
+	    // e.g. foo = function(){} or foo.bar = function(){}, in which case it is
+	    // possible to infer the assignee name ("foo" and "bar" respectively).
+	    if (parent.type == "AssignmentExpression") {
+	      let propertyChain = this._getMemberExpressionPropertyChain(parent.left);
+	      let propertyLeaf = propertyChain.pop();
+	      return {
+	        name: propertyLeaf,
+	        chain: propertyChain,
+	        loc: this.getNodeLocation(parent.left)
+	      };
+	    }
+
+	    // If a function expression is defined in an object expression,
+	    // e.g. { foo: function(){} }, then it is possible to infer the name
+	    // from the corresponding property.
+	    if (parent.type == "ObjectExpression") {
+	      let propertyKey = this._getObjectExpressionPropertyKeyForValue(node);
+	      let propertyChain = this._getObjectExpressionPropertyChain(parent);
+	      let propertyLeaf = propertyKey.name;
+	      return {
+	        name: propertyLeaf,
+	        chain: propertyChain,
+	        loc: this.getNodeLocation(propertyKey)
+	      };
+	    }
+
+	    // Can't infer the function expression's name.
+	    return {
+	      name: "",
+	      chain: null,
+	      loc: null
+	    };
+	  },
+
+	  /**
+	   * Gets the name of an object expression's property to which a specified
+	   * value is assigned.
+	   *
+	   * Used for inferring function expression information and retrieving
+	   * an identifier evaluation string.
+	   *
+	   * For example, if "node" represents the "bar" identifier in a hypothetical
+	   * "{ foo: bar }" object expression, the returned node is the "foo"
+	   * identifier.
+	   *
+	   * @param Node node
+	   *        The value node in an object expression.
+	   * @return object
+	   *         The key identifier node in the object expression.
+	   */
+	  _getObjectExpressionPropertyKeyForValue(node) {
+	    let parent = node._parent;
+	    if (parent.type != "ObjectExpression") {
+	      return null;
+	    }
+	    for (let property of parent.properties) {
+	      if (property.value == node) {
+	        return property.key;
+	      }
+	    }
+	    return null;
+	  },
+
+	  /**
+	   * Gets an object expression's property chain to its parent
+	   * variable declarator or assignment expression, if available.
+	   *
+	   * Used for inferring function expression information and retrieving
+	   * an identifier evaluation string.
+	   *
+	   * For example, if node represents the "baz: {}" object expression in a
+	   * hypothetical "foo = { bar: { baz: {} } }" assignment expression, the
+	   * returned chain is ["foo", "bar", "baz"].
+	   *
+	   * @param Node node
+	   *        The object expression node to begin the scan from.
+	   * @param array aStore [optional]
+	   *        The chain to store the nodes into.
+	   * @return array
+	   *         The chain to the parent variable declarator, as strings.
+	   */
+	  _getObjectExpressionPropertyChain(node, aStore = []) {
+	    switch (node.type) {
+	      case "ObjectExpression":
+	        this._getObjectExpressionPropertyChain(node._parent, aStore);
+	        let propertyKey = this._getObjectExpressionPropertyKeyForValue(node);
+	        if (propertyKey) {
+	          aStore.push(propertyKey.name);
+	        }
+	        break;
+	      // Handle "var foo = { ... }" variable declarators.
+	      case "VariableDeclarator":
+	        aStore.push(node.id.name);
+	        break;
+	      // Handle "foo.bar = { ... }" assignment expressions, since they're
+	      // commonly used when defining an object's prototype methods; e.g:
+	      // "Foo.prototype = { ... }".
+	      case "AssignmentExpression":
+	        this._getMemberExpressionPropertyChain(node.left, aStore);
+	        break;
+	      // Additionally handle stuff like "foo = bar.baz({ ... })", because it's
+	      // commonly used in prototype-based inheritance in many libraries; e.g:
+	      // "Foo = Bar.extend({ ... })".
+	      case "NewExpression":
+	      case "CallExpression":
+	        this._getObjectExpressionPropertyChain(node._parent, aStore);
+	        break;
+	    }
+	    return aStore;
+	  },
+
+	  /**
+	   * Gets a member expression's property chain.
+	   *
+	   * Used for inferring function expression information and retrieving
+	   * an identifier evaluation string.
+	   *
+	   * For example, if node represents a hypothetical "foo.bar.baz"
+	   * member expression, the returned chain ["foo", "bar", "baz"].
+	   *
+	   * More complex expressions like foo.bar().baz are intentionally not handled.
+	   *
+	   * @param Node node
+	   *        The member expression node to begin the scan from.
+	   * @param array store [optional]
+	   *        The chain to store the nodes into.
+	   * @return array
+	   *         The full member chain, as strings.
+	   */
+	  _getMemberExpressionPropertyChain(node, store = []) {
+	    switch (node.type) {
+	      case "MemberExpression":
+	        this._getMemberExpressionPropertyChain(node.object, store);
+	        this._getMemberExpressionPropertyChain(node.property, store);
+	        break;
+	      case "ThisExpression":
+	        store.push("this");
+	        break;
+	      case "Identifier":
+	        store.push(node.name);
+	        break;
+	    }
+	    return store;
+	  },
+
+	  /**
+	   * Returns an evaluation string which can be used to obtain the
+	   * current value for the respective identifier.
+	   *
+	   * @param Node node
+	   *        The leaf node (e.g. Identifier, Literal) to begin the scan from.
+	   * @return string
+	   *         The corresponding evaluation string, or empty string if
+	   *         the specified leaf node can't be used.
+	   */
+	  getIdentifierEvalString(node) {
+	    switch (node._parent.type) {
+	      case "ObjectExpression":
+	        // If the identifier is the actual property value, it can be used
+	        // directly as an evaluation string. Otherwise, construct the property
+	        // access chain, since the value might have changed.
+	        if (!this._getObjectExpressionPropertyKeyForValue(node)) {
+	          let propertyChain =
+	            this._getObjectExpressionPropertyChain(node._parent);
+	          let propertyLeaf = node.name;
+	          return [...propertyChain, propertyLeaf].join(".");
+	        }
+	        break;
+	      case "MemberExpression":
+	        // Make sure this is a property identifier, not the parent object.
+	        if (node._parent.property == node) {
+	          return this._getMemberExpressionPropertyChain(node._parent).join(".");
+	        }
+	        break;
+	    }
+	    switch (node.type) {
+	      case "ThisExpression":
+	        return "this";
+	      case "Identifier":
+	        return node.name;
+	      case "Literal":
+	        return uneval(node.value);
+	      default:
+	        return "";
+	    }
+	  }
+	};
+
+	/**
+	 * A visitor for a syntax tree generated by the reflection API.
+	 * See https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API.
+	 *
+	 * All node types implement the following interface:
+	 * interface Node {
+	 *   type: string;
+	 *   loc: SourceLocation | null;
+	 * }
+	 */
+	var SyntaxTreeVisitor = {
+	  /**
+	   * Walks a syntax tree.
+	   *
+	   * @param object tree
+	   *        The AST nodes generated by the reflection API
+	   * @param object callbacks
+	   *        A map of all the callbacks to invoke when passing through certain
+	   *        types of noes (e.g: onFunctionDeclaration, onBlockStatement etc.).
+	   */
+	  walk(tree, callbacks) {
+	    this.break = false;
+	    this[tree.type](tree, callbacks);
+	  },
+
+	  /**
+	   * Filters all the nodes in this syntax tree based on a predicate.
+	   *
+	   * @param object tree
+	   *        The AST nodes generated by the reflection API
+	   * @param function predicate
+	   *        The predicate ran on each node.
+	   * @return array
+	   *         An array of nodes validating the predicate.
+	   */
+	  filter(tree, predicate) {
+	    let store = [];
+	    this.walk(tree, {
+	      onNode: e => {
+	        if (predicate(e)) {
+	          store.push(e);
+	        }
+	      }
+	    });
+	    return store;
+	  },
+
+	  /**
+	   * A flag checked on each node in the syntax tree. If true, walking is
+	   * abruptly halted.
+	   */
+	  break: false,
+
+	  /**
+	   * A complete program source tree.
+	   *
+	   * interface Program <: Node {
+	   *   type: "Program";
+	   *   body: [ Statement ];
+	   * }
+	   */
+	  Program(node, callbacks) {
+	    if (callbacks.onProgram) {
+	      callbacks.onProgram(node);
+	    }
+	    for (let statement of node.body) {
+	      this[statement.type](statement, node, callbacks);
+	    }
+	  },
+
+	  /**
+	   * Any statement.
+	   *
+	   * interface Statement <: Node { }
+	   */
+	  Statement(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onStatement) {
+	      callbacks.onStatement(node);
+	    }
+	  },
+
+	  /**
+	   * An empty statement, i.e., a solitary semicolon.
+	   *
+	   * interface EmptyStatement <: Statement {
+	   *   type: "EmptyStatement";
+	   * }
+	   */
+	  EmptyStatement(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onEmptyStatement) {
+	      callbacks.onEmptyStatement(node);
+	    }
+	  },
+
+	  /**
+	   * A block statement, i.e., a sequence of statements surrounded by braces.
+	   *
+	   * interface BlockStatement <: Statement {
+	   *   type: "BlockStatement";
+	   *   body: [ Statement ];
+	   * }
+	   */
+	  BlockStatement(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onBlockStatement) {
+	      callbacks.onBlockStatement(node);
+	    }
+	    for (let statement of node.body) {
+	      this[statement.type](statement, node, callbacks);
+	    }
+	  },
+
+	  /**
+	   * An expression statement, i.e., a statement consisting of a single
+	   * expression.
+	   *
+	   * interface ExpressionStatement <: Statement {
+	   *   type: "ExpressionStatement";
+	   *   expression: Expression;
+	   * }
+	   */
+	  ExpressionStatement(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onExpressionStatement) {
+	      callbacks.onExpressionStatement(node);
+	    }
+	    this[node.expression.type](node.expression, node, callbacks);
+	  },
+
+	  /**
+	   * An if statement.
+	   *
+	   * interface IfStatement <: Statement {
+	   *   type: "IfStatement";
+	   *   test: Expression;
+	   *   consequent: Statement;
+	   *   alternate: Statement | null;
+	   * }
+	   */
+	  IfStatement(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onIfStatement) {
+	      callbacks.onIfStatement(node);
+	    }
+	    this[node.test.type](node.test, node, callbacks);
+	    this[node.consequent.type](node.consequent, node, callbacks);
+	    if (node.alternate) {
+	      this[node.alternate.type](node.alternate, node, callbacks);
+	    }
+	  },
+
+	  /**
+	   * A labeled statement, i.e., a statement prefixed by a break/continue label.
+	   *
+	   * interface LabeledStatement <: Statement {
+	   *   type: "LabeledStatement";
+	   *   label: Identifier;
+	   *   body: Statement;
+	   * }
+	   */
+	  LabeledStatement(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onLabeledStatement) {
+	      callbacks.onLabeledStatement(node);
+	    }
+	    this[node.label.type](node.label, node, callbacks);
+	    this[node.body.type](node.body, node, callbacks);
+	  },
+
+	  /**
+	   * A break statement.
+	   *
+	   * interface BreakStatement <: Statement {
+	   *   type: "BreakStatement";
+	   *   label: Identifier | null;
+	   * }
+	   */
+	  BreakStatement(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onBreakStatement) {
+	      callbacks.onBreakStatement(node);
+	    }
+	    if (node.label) {
+	      this[node.label.type](node.label, node, callbacks);
+	    }
+	  },
+
+	  /**
+	   * A continue statement.
+	   *
+	   * interface ContinueStatement <: Statement {
+	   *   type: "ContinueStatement";
+	   *   label: Identifier | null;
+	   * }
+	   */
+	  ContinueStatement(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onContinueStatement) {
+	      callbacks.onContinueStatement(node);
+	    }
+	    if (node.label) {
+	      this[node.label.type](node.label, node, callbacks);
+	    }
+	  },
+
+	  /**
+	   * A with statement.
+	   *
+	   * interface WithStatement <: Statement {
+	   *   type: "WithStatement";
+	   *   object: Expression;
+	   *   body: Statement;
+	   * }
+	   */
+	  WithStatement(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onWithStatement) {
+	      callbacks.onWithStatement(node);
+	    }
+	    this[node.object.type](node.object, node, callbacks);
+	    this[node.body.type](node.body, node, callbacks);
+	  },
+
+	  /**
+	   * A switch statement. The lexical flag is metadata indicating whether the
+	   * switch statement contains any unnested let declarations (and therefore
+	   * introduces a new lexical scope).
+	   *
+	   * interface SwitchStatement <: Statement {
+	   *   type: "SwitchStatement";
+	   *   discriminant: Expression;
+	   *   cases: [ SwitchCase ];
+	   *   lexical: boolean;
+	   * }
+	   */
+	  SwitchStatement(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onSwitchStatement) {
+	      callbacks.onSwitchStatement(node);
+	    }
+	    this[node.discriminant.type](node.discriminant, node, callbacks);
+	    for (let _case of node.cases) {
+	      this[_case.type](_case, node, callbacks);
+	    }
+	  },
+
+	  /**
+	   * A return statement.
+	   *
+	   * interface ReturnStatement <: Statement {
+	   *   type: "ReturnStatement";
+	   *   argument: Expression | null;
+	   * }
+	   */
+	  ReturnStatement(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onReturnStatement) {
+	      callbacks.onReturnStatement(node);
+	    }
+	    if (node.argument) {
+	      this[node.argument.type](node.argument, node, callbacks);
+	    }
+	  },
+
+	  /**
+	   * A throw statement.
+	   *
+	   * interface ThrowStatement <: Statement {
+	   *   type: "ThrowStatement";
+	   *   argument: Expression;
+	   * }
+	   */
+	  ThrowStatement(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onThrowStatement) {
+	      callbacks.onThrowStatement(node);
+	    }
+	    this[node.argument.type](node.argument, node, callbacks);
+	  },
+
+	  /**
+	   * A try statement.
+	   *
+	   * interface TryStatement <: Statement {
+	   *   type: "TryStatement";
+	   *   block: BlockStatement;
+	   *   handler: CatchClause | null;
+	   *   guardedHandlers: [ CatchClause ];
+	   *   finalizer: BlockStatement | null;
+	   * }
+	   */
+	  TryStatement(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onTryStatement) {
+	      callbacks.onTryStatement(node);
+	    }
+	    this[node.block.type](node.block, node, callbacks);
+	    if (node.handler) {
+	      this[node.handler.type](node.handler, node, callbacks);
+	    }
+	    for (let guardedHandler of node.guardedHandlers) {
+	      this[guardedHandler.type](guardedHandler, node, callbacks);
+	    }
+	    if (node.finalizer) {
+	      this[node.finalizer.type](node.finalizer, node, callbacks);
+	    }
+	  },
+
+	  /**
+	   * A while statement.
+	   *
+	   * interface WhileStatement <: Statement {
+	   *   type: "WhileStatement";
+	   *   test: Expression;
+	   *   body: Statement;
+	   * }
+	   */
+	  WhileStatement(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onWhileStatement) {
+	      callbacks.onWhileStatement(node);
+	    }
+	    this[node.test.type](node.test, node, callbacks);
+	    this[node.body.type](node.body, node, callbacks);
+	  },
+
+	  /**
+	   * A do/while statement.
+	   *
+	   * interface DoWhileStatement <: Statement {
+	   *   type: "DoWhileStatement";
+	   *   body: Statement;
+	   *   test: Expression;
+	   * }
+	   */
+	  DoWhileStatement(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onDoWhileStatement) {
+	      callbacks.onDoWhileStatement(node);
+	    }
+	    this[node.body.type](node.body, node, callbacks);
+	    this[node.test.type](node.test, node, callbacks);
+	  },
+
+	  /**
+	   * A for statement.
+	   *
+	   * interface ForStatement <: Statement {
+	   *   type: "ForStatement";
+	   *   init: VariableDeclaration | Expression | null;
+	   *   test: Expression | null;
+	   *   update: Expression | null;
+	   *   body: Statement;
+	   * }
+	   */
+	  ForStatement(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onForStatement) {
+	      callbacks.onForStatement(node);
+	    }
+	    if (node.init) {
+	      this[node.init.type](node.init, node, callbacks);
+	    }
+	    if (node.test) {
+	      this[node.test.type](node.test, node, callbacks);
+	    }
+	    if (node.update) {
+	      this[node.update.type](node.update, node, callbacks);
+	    }
+	    this[node.body.type](node.body, node, callbacks);
+	  },
+
+	  /**
+	   * A for/in statement, or, if each is true, a for each/in statement.
+	   *
+	   * interface ForInStatement <: Statement {
+	   *   type: "ForInStatement";
+	   *   left: VariableDeclaration | Expression;
+	   *   right: Expression;
+	   *   body: Statement;
+	   *   each: boolean;
+	   * }
+	   */
+	  ForInStatement(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onForInStatement) {
+	      callbacks.onForInStatement(node);
+	    }
+	    this[node.left.type](node.left, node, callbacks);
+	    this[node.right.type](node.right, node, callbacks);
+	    this[node.body.type](node.body, node, callbacks);
+	  },
+
+	  /**
+	   * A for/of statement.
+	   *
+	   * interface ForOfStatement <: Statement {
+	   *   type: "ForOfStatement";
+	   *   left: VariableDeclaration | Expression;
+	   *   right: Expression;
+	   *   body: Statement;
+	   * }
+	   */
+	  ForOfStatement(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onForOfStatement) {
+	      callbacks.onForOfStatement(node);
+	    }
+	    this[node.left.type](node.left, node, callbacks);
+	    this[node.right.type](node.right, node, callbacks);
+	    this[node.body.type](node.body, node, callbacks);
+	  },
+
+	  /**
+	   * A let statement.
+	   *
+	   * interface LetStatement <: Statement {
+	   *   type: "LetStatement";
+	   *   head: [ { id: Pattern, init: Expression | null } ];
+	   *   body: Statement;
+	   * }
+	   */
+	  LetStatement(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onLetStatement) {
+	      callbacks.onLetStatement(node);
+	    }
+	    for (let { id, init } of node.head) {
+	      this[id.type](id, node, callbacks);
+	      if (init) {
+	        this[init.type](init, node, callbacks);
+	      }
+	    }
+	    this[node.body.type](node.body, node, callbacks);
+	  },
+
+	  /**
+	   * A debugger statement.
+	   *
+	   * interface DebuggerStatement <: Statement {
+	   *   type: "DebuggerStatement";
+	   * }
+	   */
+	  DebuggerStatement(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onDebuggerStatement) {
+	      callbacks.onDebuggerStatement(node);
+	    }
+	  },
+
+	  /**
+	   * Any declaration node. Note that declarations are considered statements;
+	   * this is because declarations can appear in any statement context in the
+	   * language recognized by the SpiderMonkey parser.
+	   *
+	   * interface Declaration <: Statement { }
+	   */
+	  Declaration(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onDeclaration) {
+	      callbacks.onDeclaration(node);
+	    }
+	  },
+
+	  /**
+	   * A function declaration.
+	   *
+	   * interface FunctionDeclaration <: Function, Declaration {
+	   *   type: "FunctionDeclaration";
+	   *   id: Identifier;
+	   *   params: [ Pattern ];
+	   *   defaults: [ Expression ];
+	   *   rest: Identifier | null;
+	   *   body: BlockStatement | Expression;
+	   *   generator: boolean;
+	   *   expression: boolean;
+	   * }
+	   */
+	  FunctionDeclaration(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onFunctionDeclaration) {
+	      callbacks.onFunctionDeclaration(node);
+	    }
+	    this[node.id.type](node.id, node, callbacks);
+	    for (let param of node.params) {
+	      this[param.type](param, node, callbacks);
+	    }
+	    for (let _default of node.defaults) {
+	      if (_default) {
+	        this[_default.type](_default, node, callbacks);
+	      }
+	    }
+	    if (node.rest) {
+	      this[node.rest.type](node.rest, node, callbacks);
+	    }
+	    this[node.body.type](node.body, node, callbacks);
+	  },
+
+	  /**
+	   * A variable declaration, via one of var, let, or const.
+	   *
+	   * interface VariableDeclaration <: Declaration {
+	   *   type: "VariableDeclaration";
+	   *   declarations: [ VariableDeclarator ];
+	   *   kind: "var" | "let" | "const";
+	   * }
+	   */
+	  VariableDeclaration(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onVariableDeclaration) {
+	      callbacks.onVariableDeclaration(node);
+	    }
+	    for (let declaration of node.declarations) {
+	      this[declaration.type](declaration, node, callbacks);
+	    }
+	  },
+
+	  /**
+	   * A variable declarator.
+	   *
+	   * interface VariableDeclarator <: Node {
+	   *   type: "VariableDeclarator";
+	   *   id: Pattern;
+	   *   init: Expression | null;
+	   * }
+	   */
+	  VariableDeclarator(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onVariableDeclarator) {
+	      callbacks.onVariableDeclarator(node);
+	    }
+	    this[node.id.type](node.id, node, callbacks);
+	    if (node.init) {
+	      this[node.init.type](node.init, node, callbacks);
+	    }
+	  },
+
+	  /**
+	   * Any expression node. Since the left-hand side of an assignment may be any
+	   * expression in general, an expression can also be a pattern.
+	   *
+	   * interface Expression <: Node, Pattern { }
+	   */
+	  Expression(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onExpression) {
+	      callbacks.onExpression(node);
+	    }
+	  },
+
+	  /**
+	   * A this expression.
+	   *
+	   * interface ThisExpression <: Expression {
+	   *   type: "ThisExpression";
+	   * }
+	   */
+	  ThisExpression(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onThisExpression) {
+	      callbacks.onThisExpression(node);
+	    }
+	  },
+
+	  /**
+	   * An array expression.
+	   *
+	   * interface ArrayExpression <: Expression {
+	   *   type: "ArrayExpression";
+	   *   elements: [ Expression | null ];
+	   * }
+	   */
+	  ArrayExpression(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onArrayExpression) {
+	      callbacks.onArrayExpression(node);
+	    }
+	    for (let element of node.elements) {
+	      if (element) {
+	        this[element.type](element, node, callbacks);
+	      }
+	    }
+	  },
+
+	  /**
+	   * A spread expression.
+	   *
+	   * interface SpreadExpression <: Expression {
+	   *   type: "SpreadExpression";
+	   *   expression: Expression;
+	   * }
+	   */
+	  SpreadExpression(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onSpreadExpression) {
+	      callbacks.onSpreadExpression(node);
+	    }
+	    this[node.expression.type](node.expression, node, callbacks);
+	  },
+
+	  /**
+	   * An object expression. A literal property in an object expression can have
+	   * either a string or number as its value. Ordinary property initializers
+	   * have a kind value "init"; getters and setters have the kind values "get"
+	   * and "set", respectively.
+	   *
+	   * interface ObjectExpression <: Expression {
+	   *   type: "ObjectExpression";
+	   *   properties: [ { key: Literal | Identifier | ComputedName,
+	   *                   value: Expression,
+	   *                   kind: "init" | "get" | "set" } ];
+	   * }
+	   */
+	  ObjectExpression(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onObjectExpression) {
+	      callbacks.onObjectExpression(node);
+	    }
+	    for (let { key, value } of node.properties) {
+	      this[key.type](key, node, callbacks);
+	      this[value.type](value, node, callbacks);
+	    }
+	  },
+
+	  /**
+	   * A computed property name in object expression, like in { [a]: b }
+	   *
+	   * interface ComputedName <: Node {
+	   *   type: "ComputedName";
+	   *   name: Expression;
+	   * }
+	   */
+	  ComputedName(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onComputedName) {
+	      callbacks.onComputedName(node);
+	    }
+	    this[node.name.type](node.name, node, callbacks);
+	  },
+
+	  /**
+	   * A function expression.
+	   *
+	   * interface FunctionExpression <: Function, Expression {
+	   *   type: "FunctionExpression";
+	   *   id: Identifier | null;
+	   *   params: [ Pattern ];
+	   *   defaults: [ Expression ];
+	   *   rest: Identifier | null;
+	   *   body: BlockStatement | Expression;
+	   *   generator: boolean;
+	   *   expression: boolean;
+	   * }
+	   */
+	  FunctionExpression(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onFunctionExpression) {
+	      callbacks.onFunctionExpression(node);
+	    }
+	    if (node.id) {
+	      this[node.id.type](node.id, node, callbacks);
+	    }
+	    for (let param of node.params) {
+	      this[param.type](param, node, callbacks);
+	    }
+	    for (let _default of node.defaults) {
+	      if (_default) {
+	        this[_default.type](_default, node, callbacks);
+	      }
+	    }
+	    if (node.rest) {
+	      this[node.rest.type](node.rest, node, callbacks);
+	    }
+	    this[node.body.type](node.body, node, callbacks);
+	  },
+
+	  /**
+	   * An arrow expression.
+	   *
+	   * interface ArrowFunctionExpression <: Function, Expression {
+	   *   type: "ArrowFunctionExpression";
+	   *   params: [ Pattern ];
+	   *   defaults: [ Expression ];
+	   *   rest: Identifier | null;
+	   *   body: BlockStatement | Expression;
+	   *   generator: boolean;
+	   *   expression: boolean;
+	   * }
+	   */
+	  ArrowFunctionExpression(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onArrowFunctionExpression) {
+	      callbacks.onArrowFunctionExpression(node);
+	    }
+	    for (let param of node.params) {
+	      this[param.type](param, node, callbacks);
+	    }
+	    for (let _default of node.defaults) {
+	      if (_default) {
+	        this[_default.type](_default, node, callbacks);
+	      }
+	    }
+	    if (node.rest) {
+	      this[node.rest.type](node.rest, node, callbacks);
+	    }
+	    this[node.body.type](node.body, node, callbacks);
+	  },
+
+	  /**
+	   * A sequence expression, i.e., a comma-separated sequence of expressions.
+	   *
+	   * interface SequenceExpression <: Expression {
+	   *   type: "SequenceExpression";
+	   *   expressions: [ Expression ];
+	   * }
+	   */
+	  SequenceExpression(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onSequenceExpression) {
+	      callbacks.onSequenceExpression(node);
+	    }
+	    for (let expression of node.expressions) {
+	      this[expression.type](expression, node, callbacks);
+	    }
+	  },
+
+	  /**
+	   * A unary operator expression.
+	   *
+	   * interface UnaryExpression <: Expression {
+	   *   type: "UnaryExpression";
+	   *   operator: UnaryOperator;
+	   *   prefix: boolean;
+	   *   argument: Expression;
+	   * }
+	   */
+	  UnaryExpression(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onUnaryExpression) {
+	      callbacks.onUnaryExpression(node);
+	    }
+	    this[node.argument.type](node.argument, node, callbacks);
+	  },
+
+	  /**
+	   * A binary operator expression.
+	   *
+	   * interface BinaryExpression <: Expression {
+	   *   type: "BinaryExpression";
+	   *   operator: BinaryOperator;
+	   *   left: Expression;
+	   *   right: Expression;
+	   * }
+	   */
+	  BinaryExpression(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onBinaryExpression) {
+	      callbacks.onBinaryExpression(node);
+	    }
+	    this[node.left.type](node.left, node, callbacks);
+	    this[node.right.type](node.right, node, callbacks);
+	  },
+
+	  /**
+	   * An assignment operator expression.
+	   *
+	   * interface AssignmentExpression <: Expression {
+	   *   type: "AssignmentExpression";
+	   *   operator: AssignmentOperator;
+	   *   left: Expression;
+	   *   right: Expression;
+	   * }
+	   */
+	  AssignmentExpression(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onAssignmentExpression) {
+	      callbacks.onAssignmentExpression(node);
+	    }
+	    this[node.left.type](node.left, node, callbacks);
+	    this[node.right.type](node.right, node, callbacks);
+	  },
+
+	  /**
+	   * An update (increment or decrement) operator expression.
+	   *
+	   * interface UpdateExpression <: Expression {
+	   *   type: "UpdateExpression";
+	   *   operator: UpdateOperator;
+	   *   argument: Expression;
+	   *   prefix: boolean;
+	   * }
+	   */
+	  UpdateExpression(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onUpdateExpression) {
+	      callbacks.onUpdateExpression(node);
+	    }
+	    this[node.argument.type](node.argument, node, callbacks);
+	  },
+
+	  /**
+	   * A logical operator expression.
+	   *
+	   * interface LogicalExpression <: Expression {
+	   *   type: "LogicalExpression";
+	   *   operator: LogicalOperator;
+	   *   left: Expression;
+	   *   right: Expression;
+	   * }
+	   */
+	  LogicalExpression(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onLogicalExpression) {
+	      callbacks.onLogicalExpression(node);
+	    }
+	    this[node.left.type](node.left, node, callbacks);
+	    this[node.right.type](node.right, node, callbacks);
+	  },
+
+	  /**
+	   * A conditional expression, i.e., a ternary ?/: expression.
+	   *
+	   * interface ConditionalExpression <: Expression {
+	   *   type: "ConditionalExpression";
+	   *   test: Expression;
+	   *   alternate: Expression;
+	   *   consequent: Expression;
+	   * }
+	   */
+	  ConditionalExpression(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onConditionalExpression) {
+	      callbacks.onConditionalExpression(node);
+	    }
+	    this[node.test.type](node.test, node, callbacks);
+	    this[node.alternate.type](node.alternate, node, callbacks);
+	    this[node.consequent.type](node.consequent, node, callbacks);
+	  },
+
+	  /**
+	   * A new expression.
+	   *
+	   * interface NewExpression <: Expression {
+	   *   type: "NewExpression";
+	   *   callee: Expression;
+	   *   arguments: [ Expression | null ];
+	   * }
+	   */
+	  NewExpression(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onNewExpression) {
+	      callbacks.onNewExpression(node);
+	    }
+	    this[node.callee.type](node.callee, node, callbacks);
+	    for (let argument of node.arguments) {
+	      if (argument) {
+	        this[argument.type](argument, node, callbacks);
+	      }
+	    }
+	  },
+
+	  /**
+	   * A function or method call expression.
+	   *
+	   * interface CallExpression <: Expression {
+	   *   type: "CallExpression";
+	   *   callee: Expression;
+	   *   arguments: [ Expression | null ];
+	   * }
+	   */
+	  CallExpression(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onCallExpression) {
+	      callbacks.onCallExpression(node);
+	    }
+	    this[node.callee.type](node.callee, node, callbacks);
+	    for (let argument of node.arguments) {
+	      if (argument) {
+	        if (!this[argument.type]) {
+	          console.error("Unknown parser object:", argument.type);
+	        }
+	        this[argument.type](argument, node, callbacks);
+	      }
+	    }
+	  },
+
+	  /**
+	   * A member expression. If computed is true, the node corresponds to a
+	   * computed e1[e2] expression and property is an Expression. If computed is
+	   * false, the node corresponds to a static e1.x expression and property is an
+	   * Identifier.
+	   *
+	   * interface MemberExpression <: Expression {
+	   *   type: "MemberExpression";
+	   *   object: Expression;
+	   *   property: Identifier | Expression;
+	   *   computed: boolean;
+	   * }
+	   */
+	  MemberExpression(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onMemberExpression) {
+	      callbacks.onMemberExpression(node);
+	    }
+	    this[node.object.type](node.object, node, callbacks);
+	    this[node.property.type](node.property, node, callbacks);
+	  },
+
+	  /**
+	   * A yield expression.
+	   *
+	   * interface YieldExpression <: Expression {
+	   *   argument: Expression | null;
+	   * }
+	   */
+	  YieldExpression(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onYieldExpression) {
+	      callbacks.onYieldExpression(node);
+	    }
+	    if (node.argument) {
+	      this[node.argument.type](node.argument, node, callbacks);
+	    }
+	  },
+
+	  /**
+	   * An array comprehension. The blocks array corresponds to the sequence of
+	   * for and for each blocks. The optional filter expression corresponds to the
+	   * final if clause, if present.
+	   *
+	   * interface ComprehensionExpression <: Expression {
+	   *   body: Expression;
+	   *   blocks: [ ComprehensionBlock ];
+	   *   filter: Expression | null;
+	   * }
+	   */
+	  ComprehensionExpression(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onComprehensionExpression) {
+	      callbacks.onComprehensionExpression(node);
+	    }
+	    this[node.body.type](node.body, node, callbacks);
+	    for (let block of node.blocks) {
+	      this[block.type](block, node, callbacks);
+	    }
+	    if (node.filter) {
+	      this[node.filter.type](node.filter, node, callbacks);
+	    }
+	  },
+
+	  /**
+	   * A generator expression. As with array comprehensions, the blocks array
+	   * corresponds to the sequence of for and for each blocks, and the optional
+	   * filter expression corresponds to the final if clause, if present.
+	   *
+	   * interface GeneratorExpression <: Expression {
+	   *   body: Expression;
+	   *   blocks: [ ComprehensionBlock ];
+	   *   filter: Expression | null;
+	   * }
+	   */
+	  GeneratorExpression(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onGeneratorExpression) {
+	      callbacks.onGeneratorExpression(node);
+	    }
+	    this[node.body.type](node.body, node, callbacks);
+	    for (let block of node.blocks) {
+	      this[block.type](block, node, callbacks);
+	    }
+	    if (node.filter) {
+	      this[node.filter.type](node.filter, node, callbacks);
+	    }
+	  },
+
+	  /**
+	   * A graph expression, aka "sharp literal," such as #1={ self: #1# }.
+	   *
+	   * interface GraphExpression <: Expression {
+	   *   index: uint32;
+	   *   expression: Literal;
+	   * }
+	   */
+	  GraphExpression(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onGraphExpression) {
+	      callbacks.onGraphExpression(node);
+	    }
+	    this[node.expression.type](node.expression, node, callbacks);
+	  },
+
+	  /**
+	   * A graph index expression, aka "sharp variable," such as #1#.
+	   *
+	   * interface GraphIndexExpression <: Expression {
+	   *   index: uint32;
+	   * }
+	   */
+	  GraphIndexExpression(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onGraphIndexExpression) {
+	      callbacks.onGraphIndexExpression(node);
+	    }
+	  },
+
+	  /**
+	   * A let expression.
+	   *
+	   * interface LetExpression <: Expression {
+	   *   type: "LetExpression";
+	   *   head: [ { id: Pattern, init: Expression | null } ];
+	   *   body: Expression;
+	   * }
+	   */
+	  LetExpression(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onLetExpression) {
+	      callbacks.onLetExpression(node);
+	    }
+	    for (let { id, init } of node.head) {
+	      this[id.type](id, node, callbacks);
+	      if (init) {
+	        this[init.type](init, node, callbacks);
+	      }
+	    }
+	    this[node.body.type](node.body, node, callbacks);
+	  },
+
+	  /**
+	   * Any pattern.
+	   *
+	   * interface Pattern <: Node { }
+	   */
+	  Pattern(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onPattern) {
+	      callbacks.onPattern(node);
+	    }
+	  },
+
+	  /**
+	   * An object-destructuring pattern. A literal property in an object pattern
+	   * can have either a string or number as its value.
+	   *
+	   * interface ObjectPattern <: Pattern {
+	   *   type: "ObjectPattern";
+	   *   properties: [ { key: Literal | Identifier, value: Pattern } ];
+	   * }
+	   */
+	  ObjectPattern(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onObjectPattern) {
+	      callbacks.onObjectPattern(node);
+	    }
+	    for (let { key, value } of node.properties) {
+	      this[key.type](key, node, callbacks);
+	      this[value.type](value, node, callbacks);
+	    }
+	  },
+
+	  /**
+	   * An array-destructuring pattern.
+	   *
+	   * interface ArrayPattern <: Pattern {
+	   *   type: "ArrayPattern";
+	   *   elements: [ Pattern | null ];
+	   * }
+	   */
+	  ArrayPattern(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onArrayPattern) {
+	      callbacks.onArrayPattern(node);
+	    }
+	    for (let element of node.elements) {
+	      if (element) {
+	        this[element.type](element, node, callbacks);
+	      }
+	    }
+	  },
+
+	  /**
+	   * A case (if test is an Expression) or default (if test is null) clause in
+	   * the body of a switch statement.
+	   *
+	   * interface SwitchCase <: Node {
+	   *   type: "SwitchCase";
+	   *   test: Expression | null;
+	   *   consequent: [ Statement ];
+	   * }
+	   */
+	  SwitchCase(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onSwitchCase) {
+	      callbacks.onSwitchCase(node);
+	    }
+	    if (node.test) {
+	      this[node.test.type](node.test, node, callbacks);
+	    }
+	    for (let consequent of node.consequent) {
+	      this[consequent.type](consequent, node, callbacks);
+	    }
+	  },
+
+	  /**
+	   * A catch clause following a try block. The optional guard property
+	   * corresponds to the optional expression guard on the bound variable.
+	   *
+	   * interface CatchClause <: Node {
+	   *   type: "CatchClause";
+	   *   param: Pattern;
+	   *   guard: Expression | null;
+	   *   body: BlockStatement;
+	   * }
+	   */
+	  CatchClause(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onCatchClause) {
+	      callbacks.onCatchClause(node);
+	    }
+	    this[node.param.type](node.param, node, callbacks);
+	    if (node.guard) {
+	      this[node.guard.type](node.guard, node, callbacks);
+	    }
+	    this[node.body.type](node.body, node, callbacks);
+	  },
+
+	  /**
+	   * A for or for each block in an array comprehension or generator expression.
+	   *
+	   * interface ComprehensionBlock <: Node {
+	   *   left: Pattern;
+	   *   right: Expression;
+	   *   each: boolean;
+	   * }
+	   */
+	  ComprehensionBlock(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onComprehensionBlock) {
+	      callbacks.onComprehensionBlock(node);
+	    }
+	    this[node.left.type](node.left, node, callbacks);
+	    this[node.right.type](node.right, node, callbacks);
+	  },
+
+	  /**
+	   * An identifier. Note that an identifier may be an expression or a
+	   * destructuring pattern.
+	   *
+	   * interface Identifier <: Node, Expression, Pattern {
+	   *   type: "Identifier";
+	   *   name: string;
+	   * }
+	   */
+	  Identifier(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onIdentifier) {
+	      callbacks.onIdentifier(node);
+	    }
+	  },
+
+	  /**
+	   * A literal token. Note that a literal can be an expression.
+	   *
+	   * interface Literal <: Node, Expression {
+	   *   type: "Literal";
+	   *   value: string | boolean | null | number | RegExp;
+	   * }
+	   */
+	  Literal(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onLiteral) {
+	      callbacks.onLiteral(node);
+	    }
+	  },
+
+	  /**
+	   * A template string literal.
+	   *
+	   * interface TemplateLiteral <: Node {
+	   *   type: "TemplateLiteral";
+	   *   elements: [ Expression ];
+	   * }
+	   */
+	  TemplateLiteral(node, parent, callbacks) {
+	    node._parent = parent;
+
+	    if (this.break) {
+	      return;
+	    }
+	    if (callbacks.onNode) {
+	      if (callbacks.onNode(node, parent) === false) {
+	        return;
+	      }
+	    }
+	    if (callbacks.onTemplateLiteral) {
+	      callbacks.onTemplateLiteral(node);
+	    }
+	    for (let element of node.elements) {
+	      if (element) {
+	        this[element.type](element, node, callbacks);
+	      }
+	    }
+	  }
+	};
+
+	XPCOMUtils.defineLazyGetter(Parser, "reflectionAPI", () => Reflect);
+
+
+/***/ },
+
+/***/ 12:
+/***/ function(module, exports) {
+
+	/* This Source Code Form is subject to the terms of the Mozilla Public
+	 * License, v. 2.0. If a copy of the MPL was not distributed with this
+	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+	"use strict";
+
+	Components.utils.import("resource://devtools/shared/event-emitter.js");
+
+	const EXPORTED_SYMBOLS = ["Devices"];
+
+	var addonInstalled = false;
+
+	const Devices = {
+	  _devices: {},
+
+	  get helperAddonInstalled() {
+	    return addonInstalled;
+	  },
+	  set helperAddonInstalled(v) {
+	    addonInstalled = v;
+	    if (!addonInstalled) {
+	      for (let name in this._devices) {
+	        this.unregister(name);
+	      }
+	    }
+	    this.emit("addon-status-updated", v);
+	  },
+
+	  register: function (name, device) {
+	    this._devices[name] = device;
+	    this.emit("register");
+	  },
+
+	  unregister: function (name) {
+	    delete this._devices[name];
+	    this.emit("unregister");
+	  },
+
+	  available: function () {
+	    return Object.keys(this._devices).sort();
+	  },
+
+	  getByName: function (name) {
+	    return this._devices[name];
+	  }
+	};
+	Object.defineProperty(this, "Devices", {
+	  value: Devices,
+	  enumerable: true,
+	  writable: false
+	});
+
+	EventEmitter.decorate(Devices);
+
+
+/***/ },
+
+/***/ 13:
+/***/ function(module, exports) {
+
+	/* This Source Code Form is subject to the terms of the Mozilla Public
+	 * License, v. 2.0. If a copy of the MPL was not distributed with this
+	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+	"use strict";
+
+	Components.utils.import("resource://devtools/shared/event-emitter.js");
+
+	/**
+	 * TODO (Bug 1132453) The `Simulator` module is deprecated, and should be
+	 * removed once all simulator addons stop using it (see bug 1132452).
+	 *
+	 * If you want to register, unregister, or otherwise deal with installed
+	 * simulators, please use the `Simulators` module defined in:
+	 *
+	 *   devtools/client/webide/modules/simulators.js
+	 */
+
+	this.EXPORTED_SYMBOLS = ["Simulator"];
+
+	let Simulator = this.Simulator = {
+	  _simulators: {},
+
+	  register: function (name, simulator) {
+	    // simulators register themselves as "Firefox OS X.Y"
+	    this._simulators[name] = simulator;
+	    this.emit("register", name);
+	  },
+
+	  unregister: function (name) {
+	    delete this._simulators[name];
+	    this.emit("unregister", name);
+	  },
+
+	  availableNames: function () {
+	    return Object.keys(this._simulators).sort();
+	  },
+
+	  getByName: function (name) {
+	    return this._simulators[name];
+	  },
+	};
+
+	EventEmitter.decorate(Simulator);
+
+
+/***/ },
+
+/***/ 22:
+/***/ function(module, exports) {
+
+	const REDIRECTION_URL = "http://example.com/redirection-target.html";
+
+	function handleRequest(request, response) {
+	  response.setStatusLine(request.httpVersion, 301, "Moved Permanently");
+	  response.setHeader("Location", REDIRECTION_URL, false);
+	}
+
+
+
+/***/ },
+
+/***/ 86:
+/***/ function(module, exports) {
+
+	// Functions for checking results returned by
+	// Debugger.Memory.prototype.takeCensus and
+	// HeapSnapshot.prototype.takeCensus. Adapted from js/src/jit-test/lib/census.js.
+
+	this.EXPORTED_SYMBOLS = ["Census"];
+
+	this.Census = (function () {
+	  const Census = {};
+
+	  function dumpn(msg) {
+	    dump("DBG-TEST: Census.jsm: " + msg + "\n");
+	  }
+
+	  // Census.walkCensus(subject, name, walker)
+	  //
+	  // Use |walker| to check |subject|, a census object of the sort returned by
+	  // Debugger.Memory.prototype.takeCensus: a tree of objects with integers at the
+	  // leaves. Use |name| as the name for |subject| in diagnostic messages. Return
+	  // the number of leaves of |subject| we visited.
+	  //
+	  // A walker is an object with three methods:
+	  //
+	  // - enter(prop): Return the walker we should use to check the property of the
+	  //   subject census named |prop|. This is for recursing into the subobjects of
+	  //   the subject.
+	  //
+	  // - done(): Called after we have called 'enter' on every property of the
+	  //   subject.
+	  //
+	  // - check(value): Check |value|, a leaf in the subject.
+	  //
+	  // Walker methods are expected to simply throw if a node we visit doesn't look
+	  // right.
+	  Census.walkCensus = (subject, name, walker) => walk(subject, name, walker, 0);
+	  function walk(subject, name, walker, count) {
+	    if (typeof subject === "object") {
+	      dumpn(name);
+	      for (let prop in subject) {
+	        count = walk(subject[prop],
+	                     name + "[" + uneval(prop) + "]",
+	                     walker.enter(prop),
+	                     count);
+	      }
+	      walker.done();
+	    } else {
+	      dumpn(name + " = " + uneval(subject));
+	      walker.check(subject);
+	      count++;
+	    }
+
+	    return count;
+	  }
+
+	  // A walker that doesn't check anything.
+	  Census.walkAnything = {
+	    enter: () => Census.walkAnything,
+	    done: () => undefined,
+	    check: () => undefined
+	  };
+
+	  // A walker that requires all leaves to be zeros.
+	  Census.assertAllZeros = {
+	    enter: () => Census.assertAllZeros,
+	    done: () => undefined,
+	    check: elt => { if (elt !== 0) throw new Error("Census mismatch: expected zero, found " + elt); }
+	  };
+
+	  function expectedObject() {
+	    throw new Error("Census mismatch: subject has leaf where basis has nested object");
+	  }
+
+	  function expectedLeaf() {
+	    throw new Error("Census mismatch: subject has nested object where basis has leaf");
+	  }
+
+	  // Return a function that, given a 'basis' census, returns a census walker that
+	  // compares the subject census against the basis. The returned walker calls the
+	  // given |compare|, |missing|, and |extra| functions as follows:
+	  //
+	  // - compare(subjectLeaf, basisLeaf): Check a leaf of the subject against the
+	  //   corresponding leaf of the basis.
+	  //
+	  // - missing(prop, value): Called when the subject is missing a property named
+	  //   |prop| which is present in the basis with value |value|.
+	  //
+	  // - extra(prop): Called when the subject has a property named |prop|, but the
+	  //   basis has no such property. This should return a walker that can check
+	  //   the subject's value.
+	  function makeBasisChecker({compare, missing, extra}) {
+	    return function makeWalker(basis) {
+	      if (typeof basis === "object") {
+	        var unvisited = new Set(Object.getOwnPropertyNames(basis));
+	        return {
+	          enter: prop => {
+	            unvisited.delete(prop);
+	            if (prop in basis) {
+	              return makeWalker(basis[prop]);
+	            } else {
+	              return extra(prop);
+	            }
+	          },
+
+	          done: () => unvisited.forEach(prop => missing(prop, basis[prop])),
+	          check: expectedObject
+	        };
+	      } else {
+	        return {
+	          enter: expectedLeaf,
+	          done: expectedLeaf,
+	          check: elt => compare(elt, basis)
+	        };
+	      }
+	    };
+	  }
+
+	  function missingProp(prop) {
+	    throw new Error("Census mismatch: subject lacks property present in basis: " + prop);
+	  }
+
+	  function extraProp(prop) {
+	    throw new Error("Census mismatch: subject has property not present in basis: " + prop);
+	  }
+
+	  // Return a walker that checks that the subject census has counts all equal to
+	  // |basis|.
+	  Census.assertAllEqual = makeBasisChecker({
+	    compare: (a, b) => { if (a !== b) throw new Error("Census mismatch: expected " + a + " got " + b);},
+	    missing: missingProp,
+	    extra: extraProp
+	  });
+
+	  function ok(val) {
+	    if (!val) {
+	      throw new Error("Census mismatch: expected truthy, got " + val);
+	    }
+	  }
+
+	  // Return a walker that checks that the subject census has at least as many
+	  // items of each category as |basis|.
+	  Census.assertAllNotLessThan = makeBasisChecker({
+	    compare: (subject, basis) => ok(subject >= basis),
+	    missing: missingProp,
+	    extra: () => Census.walkAnything
+	  });
+
+	  // Return a walker that checks that the subject census has at most as many
+	  // items of each category as |basis|.
+	  Census.assertAllNotMoreThan = makeBasisChecker({
+	    compare: (subject, basis) => ok(subject <= basis),
+	    missing: missingProp,
+	    extra: () => Census.walkAnything
+	  });
+
+	  // Return a walker that checks that the subject census has within |fudge|
+	  // items of each category of the count in |basis|.
+	  Census.assertAllWithin = function (fudge, basis) {
+	    return makeBasisChecker({
+	      compare: (subject, basis) => ok(Math.abs(subject - basis) <= fudge),
+	      missing: missingProp,
+	      extra: () => Census.walkAnything
+	    })(basis);
+	  };
+
+	  return Census;
+	}());
+
+
+/***/ },
+
+/***/ 97:
+/***/ function(module, exports) {
+
+	/* This Source Code Form is subject to the terms of the Mozilla Public
+	 * License, v. 2.0. If a copy of the MPL was not distributed with this
+	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+	"use strict";
+
+	const { utils: Cu } = Components;
+	const { NetUtil } = Cu.import("resource://gre/modules/NetUtil.jsm", {});
+
+	/**
+	 * A function that can be used as part of a require hook for a
+	 * loader.js Loader.  This function only handles webpack-style "raw!"
+	 * requires; other requires should not be passed to this.  See
+	 * https://github.com/webpack/raw-loader.
+	 */
+	function requireRawId(id, require) {
+	  let uri = require.resolve(id.slice(4));
+	  // If the original string did not end with ".js", then
+	  // require.resolve might have added the suffix.  We don't want to
+	  // add a suffix for a raw load (if needed the caller can specify it
+	  // manually), so remove it here.
+	  if (!id.endsWith(".js") && uri.endsWith(".js")) {
+	    uri = uri.slice(0, -3);
+	  }
+	  let stream = NetUtil.newChannel({
+	    uri: NetUtil.newURI(uri, "UTF-8"),
+	    loadUsingSystemPrincipal: true
+	  }).open2();
+
+	  let count = stream.available();
+	  let data = NetUtil.readInputStreamToString(stream, count, {
+	    charset: "UTF-8"
+	  });
+	  stream.close();
+
+	  // For the time being it doesn't seem worthwhile to cache the
+	  // result here.
+	  return data;
+	}
+
+	this.EXPORTED_SYMBOLS = ["requireRawId"];
+
+
+/***/ },
+
+/***/ 123:
+/***/ function(module, exports) {
+
+	/* This Source Code Form is subject to the terms of the Mozilla Public
+	 * License, v. 2.0. If a copy of the MPL was not distributed with this
+	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+	"use strict";
+
+	/**
+	 * This file only exists to support add-ons which import this module at a
+	 * specific path.
+	 */
+
+	const Cu = Components.utils;
+
+	const { Services } = Cu.import("resource://gre/modules/Services.jsm", {});
+
+	const WARNING_PREF = "devtools.migration.warnings";
+	if (Services.prefs.getBoolPref(WARNING_PREF)) {
+	  const { Deprecated } = Cu.import("resource://gre/modules/Deprecated.jsm", {});
+	  Deprecated.warning("This path to Console.jsm is deprecated.  Please use " +
+	                     "Cu.import(\"resource://gre/modules/Console.jsm\") " +
+	                     "to load this module.",
+	                     "https://bugzil.la/912121");
+	}
+
+	this.EXPORTED_SYMBOLS = [
+	  "console",
+	  "ConsoleAPI"
+	];
+
+	const module =
+	  Cu.import("resource://gre/modules/Console.jsm", {});
+
+	for (let symbol of this.EXPORTED_SYMBOLS) {
+	  this[symbol] = module[symbol];
+	}
+
+
+/***/ },
+
+/***/ 124:
+/***/ function(module, exports) {
+
+	/* This Source Code Form is subject to the terms of the Mozilla Public
+	 * License, v. 2.0. If a copy of the MPL was not distributed with this
+	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+	"use strict";
+
+	/**
+	 * This file only exists to support add-ons which import this module at a
+	 * specific path.
+	 */
+
+	const Cu = Components.utils;
+
+	const { Services } = Cu.import("resource://gre/modules/Services.jsm", {});
+
+	const WARNING_PREF = "devtools.migration.warnings";
+	if (Services.prefs.getBoolPref(WARNING_PREF)) {
+	  const { Deprecated } = Cu.import("resource://gre/modules/Deprecated.jsm", {});
+	  Deprecated.warning("This path to Loader.jsm is deprecated.  Please use " +
+	                     "Cu.import(\"resource://devtools/shared/" +
+	                     "Loader.jsm\") to load this module.",
+	                     "https://bugzil.la/912121");
+	}
+
+	this.EXPORTED_SYMBOLS = [
+	  "DevToolsLoader",
+	  "devtools",
+	  "BuiltinProvider",
+	  "require",
+	  "loader"
+	];
+
+	const module =
+	  Cu.import("resource://devtools/shared/Loader.jsm", {});
+
+	for (let symbol of this.EXPORTED_SYMBOLS) {
+	  this[symbol] = module[symbol];
+	}
+
+
+/***/ },
+
+/***/ 125:
+/***/ function(module, exports) {
+
+	/* This Source Code Form is subject to the terms of the Mozilla Public
+	 * License, v. 2.0. If a copy of the MPL was not distributed with this
+	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+	"use strict";
+
+	/**
+	 * This file only exists to support add-ons which import this module at a
+	 * specific path.
+	 */
+
+	const Cu = Components.utils;
+
+	const { Services } = Cu.import("resource://gre/modules/Services.jsm", {});
+
+	const WARNING_PREF = "devtools.migration.warnings";
+	if (Services.prefs.getBoolPref(WARNING_PREF)) {
+	  const { Deprecated } = Cu.import("resource://gre/modules/Deprecated.jsm", {});
+	  Deprecated.warning("This path to Simulator.jsm is deprecated.  Please use " +
+	                     "Cu.import(\"resource://devtools/shared/" +
+	                     "apps/Simulator.jsm\") to load this module.",
+	                     "https://bugzil.la/912121");
+	}
+
+	this.EXPORTED_SYMBOLS = [
+	  "Simulator",
+	];
+
+	const module =
+	  Cu.import("resource://devtools/shared/apps/Simulator.jsm", {});
+
+	for (let symbol of this.EXPORTED_SYMBOLS) {
+	  this[symbol] = module[symbol];
+	}
+
+
+/***/ },
+
+/***/ 126:
+/***/ function(module, exports, __webpack_require__) {
+
+	/* This Source Code Form is subject to the terms of the Mozilla Public
+	 * License, v. 2.0. If a copy of the MPL was not distributed with this
+	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+	"use strict";
+
+	/**
+	 * This file only exists to support add-ons which import this module at a
+	 * specific path.
+	 */
+
+	const Cu = Components.utils;
+
+	const { Services } = Cu.import("resource://gre/modules/Services.jsm", {});
+
+	const WARNING_PREF = "devtools.migration.warnings";
+	if (Services.prefs.getBoolPref(WARNING_PREF)) {
+	  const { Deprecated } = Cu.import("resource://gre/modules/Deprecated.jsm", {});
+	  Deprecated.warning("dbg-client.jsm is deprecated.  Please use " +
+	                     "require(\"devtools/shared/client/main\") to load this " +
+	                     "module.", "https://bugzil.la/912121");
+	}
+
+	const { require } =
+	  Cu.import("resource://devtools/shared/Loader.jsm", {});
+
+	this.EXPORTED_SYMBOLS = ["DebuggerTransport",
+	                         "DebuggerClient",
+	                         "RootClient",
+	                         "LongStringClient",
+	                         "EnvironmentClient",
+	                         "ObjectClient"];
+
+	var client = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"devtools/shared/client/main\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
+
+	this.DebuggerClient = client.DebuggerClient;
+	this.RootClient = client.RootClient;
+	this.LongStringClient = client.LongStringClient;
+	this.EnvironmentClient = client.EnvironmentClient;
+	this.ObjectClient = client.ObjectClient;
+
+	this.DebuggerTransport =
+	  __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"devtools/shared/transport/transport\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).DebuggerTransport;
+
+
+/***/ },
+
+/***/ 177:
+/***/ function(module, exports, __webpack_require__) {
+
+	/* WEBPACK VAR INJECTION */(function(setImmediate) {/* This Source Code Form is subject to the terms of the Mozilla Public
+	 * License, v. 2.0. If a copy of the MPL was not distributed with this
+	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+	"use strict";
+
+	/* General utilities used throughout devtools. */
+
+	var _this = this;
+
+	var { Ci, Cu, Cc, components } = __webpack_require__(1);
+	var Services = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"Services\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
+	var promise = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"promise\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
+	var defer = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"devtools/shared/defer\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
+
+	loader.lazyRequireGetter(this, "FileUtils", "resource://gre/modules/FileUtils.jsm", true);
+
+	// Re-export the thread-safe utils.
+	const ThreadSafeDevToolsUtils = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"./ThreadSafeDevToolsUtils.js\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
+	for (let key of Object.keys(ThreadSafeDevToolsUtils)) {
+	  exports[key] = ThreadSafeDevToolsUtils[key];
+	}
+
+	/**
+	 * Waits for the next tick in the event loop to execute a callback.
+	 */
+	exports.executeSoon = function executeSoon(aFn) {
+	  if (isWorker) {
+	    setImmediate(aFn);
+	  } else {
+	    let executor;
+	    // Only enable async stack reporting when DEBUG_JS_MODULES is set
+	    // (customized local builds) to avoid a performance penalty.
+	    if (AppConstants.DEBUG_JS_MODULES || exports.testing) {
+	      let stack = components.stack;
+	      executor = () => {
+	        Cu.callFunctionWithAsyncStack(aFn, stack, "DevToolsUtils.executeSoon");
+	      };
+	    } else {
+	      executor = aFn;
+	    }
+	    Services.tm.mainThread.dispatch({
+	      run: exports.makeInfallible(executor)
+	    }, Ci.nsIThread.DISPATCH_NORMAL);
+	  }
+	};
+
+	/**
+	 * Waits for the next tick in the event loop.
+	 *
+	 * @return Promise
+	 *         A promise that is resolved after the next tick in the event loop.
+	 */
+	exports.waitForTick = function waitForTick() {
+	  let deferred = defer();
+	  exports.executeSoon(deferred.resolve);
+	  return deferred.promise;
+	};
+
+	/**
+	 * Waits for the specified amount of time to pass.
+	 *
+	 * @param number aDelay
+	 *        The amount of time to wait, in milliseconds.
+	 * @return Promise
+	 *         A promise that is resolved after the specified amount of time passes.
+	 */
+	exports.waitForTime = function waitForTime(aDelay) {
+	  let deferred = defer();
+	  setTimeout(deferred.resolve, aDelay);
+	  return deferred.promise;
+	};
+
+	/**
+	 * Like Array.prototype.forEach, but doesn't cause jankiness when iterating over
+	 * very large arrays by yielding to the browser and continuing execution on the
+	 * next tick.
+	 *
+	 * @param Array aArray
+	 *        The array being iterated over.
+	 * @param Function aFn
+	 *        The function called on each item in the array. If a promise is
+	 *        returned by this function, iterating over the array will be paused
+	 *        until the respective promise is resolved.
+	 * @returns Promise
+	 *          A promise that is resolved once the whole array has been iterated
+	 *          over, and all promises returned by the aFn callback are resolved.
+	 */
+	exports.yieldingEach = function yieldingEach(aArray, aFn) {
+	  const deferred = defer();
+
+	  let i = 0;
+	  let len = aArray.length;
+	  let outstanding = [deferred.promise];
+
+	  (function loop() {
+	    const start = Date.now();
+
+	    while (i < len) {
+	      // Don't block the main thread for longer than 16 ms at a time. To
+	      // maintain 60fps, you have to render every frame in at least 16ms; we
+	      // aren't including time spent in non-JS here, but this is Good
+	      // Enough(tm).
+	      if (Date.now() - start > 16) {
+	        exports.executeSoon(loop);
+	        return;
+	      }
+
+	      try {
+	        outstanding.push(aFn(aArray[i], i++));
+	      } catch (e) {
+	        deferred.reject(e);
+	        return;
+	      }
+	    }
+
+	    deferred.resolve();
+	  })();
+
+	  return promise.all(outstanding);
+	};
+
+	/**
+	 * Like XPCOMUtils.defineLazyGetter, but with a |this| sensitive getter that
+	 * allows the lazy getter to be defined on a prototype and work correctly with
+	 * instances.
+	 *
+	 * @param Object aObject
+	 *        The prototype object to define the lazy getter on.
+	 * @param String aKey
+	 *        The key to define the lazy getter on.
+	 * @param Function aCallback
+	 *        The callback that will be called to determine the value. Will be
+	 *        called with the |this| value of the current instance.
+	 */
+	exports.defineLazyPrototypeGetter = function defineLazyPrototypeGetter(aObject, aKey, aCallback) {
+	  Object.defineProperty(aObject, aKey, {
+	    configurable: true,
+	    get: function () {
+	      const value = aCallback.call(this);
+
+	      Object.defineProperty(this, aKey, {
+	        configurable: true,
+	        writable: true,
+	        value: value
+	      });
+
+	      return value;
+	    }
+	  });
+	};
+
+	/**
+	 * Safely get the property value from a Debugger.Object for a given key. Walks
+	 * the prototype chain until the property is found.
+	 *
+	 * @param Debugger.Object aObject
+	 *        The Debugger.Object to get the value from.
+	 * @param String aKey
+	 *        The key to look for.
+	 * @return Any
+	 */
+	exports.getProperty = function getProperty(aObj, aKey) {
+	  let root = aObj;
+	  try {
+	    do {
+	      const desc = aObj.getOwnPropertyDescriptor(aKey);
+	      if (desc) {
+	        if ("value" in desc) {
+	          return desc.value;
+	        }
+	        // Call the getter if it's safe.
+	        return exports.hasSafeGetter(desc) ? desc.get.call(root).return : undefined;
+	      }
+	      aObj = aObj.proto;
+	    } while (aObj);
+	  } catch (e) {
+	    // If anything goes wrong report the error and return undefined.
+	    exports.reportException("getProperty", e);
+	  }
+	  return undefined;
+	};
+
+	/**
+	 * Determines if a descriptor has a getter which doesn't call into JavaScript.
+	 *
+	 * @param Object aDesc
+	 *        The descriptor to check for a safe getter.
+	 * @return Boolean
+	 *         Whether a safe getter was found.
+	 */
+	exports.hasSafeGetter = function hasSafeGetter(aDesc) {
+	  // Scripted functions that are CCWs will not appear scripted until after
+	  // unwrapping.
+	  try {
+	    let fn = aDesc.get.unwrap();
+	    return fn && fn.callable && fn.class == "Function" && fn.script === undefined;
+	  } catch (e) {
+	    // Avoid exception 'Object in compartment marked as invisible to Debugger'
+	    return false;
+	  }
+	};
+
+	/**
+	 * Check if it is safe to read properties and execute methods from the given JS
+	 * object. Safety is defined as being protected from unintended code execution
+	 * from content scripts (or cross-compartment code).
+	 *
+	 * See bugs 945920 and 946752 for discussion.
+	 *
+	 * @type Object aObj
+	 *       The object to check.
+	 * @return Boolean
+	 *         True if it is safe to read properties from aObj, or false otherwise.
+	 */
+	exports.isSafeJSObject = function isSafeJSObject(aObj) {
+	  // If we are running on a worker thread, Cu is not available. In this case,
+	  // we always return false, just to be on the safe side.
+	  if (isWorker) {
+	    return false;
+	  }
+
+	  if (Cu.getGlobalForObject(aObj) == Cu.getGlobalForObject(exports.isSafeJSObject)) {
+	    return true; // aObj is not a cross-compartment wrapper.
+	  }
+
+	  let principal = Cu.getObjectPrincipal(aObj);
+	  if (Services.scriptSecurityManager.isSystemPrincipal(principal)) {
+	    return true; // allow chrome objects
+	  }
+
+	  return Cu.isXrayWrapper(aObj);
+	};
+
+	exports.dumpn = function dumpn(str) {
+	  if (exports.dumpn.wantLogging) {
+	    dump("DBG-SERVER: " + str + "\n");
+	  }
+	};
+
+	// We want wantLogging to be writable. The exports object is frozen by the
+	// loader, so define it on dumpn instead.
+	exports.dumpn.wantLogging = false;
+
+	/**
+	 * A verbose logger for low-level tracing.
+	 */
+	exports.dumpv = function (msg) {
+	  if (exports.dumpv.wantVerbose) {
+	    exports.dumpn(msg);
+	  }
+	};
+
+	// We want wantLogging to be writable. The exports object is frozen by the
+	// loader, so define it on dumpn instead.
+	exports.dumpv.wantVerbose = false;
+
+	/**
+	 * Defines a getter on a specified object that will be created upon first use.
+	 *
+	 * @param aObject
+	 *        The object to define the lazy getter on.
+	 * @param aName
+	 *        The name of the getter to define on aObject.
+	 * @param aLambda
+	 *        A function that returns what the getter should return.  This will
+	 *        only ever be called once.
+	 */
+	exports.defineLazyGetter = function defineLazyGetter(aObject, aName, aLambda) {
+	  Object.defineProperty(aObject, aName, {
+	    get: function () {
+	      delete aObject[aName];
+	      return aObject[aName] = aLambda.apply(aObject);
+	    },
+	    configurable: true,
+	    enumerable: true
+	  });
+	};
+
+	exports.defineLazyGetter(this, "AppConstants", () => {
+	  if (isWorker) {
+	    return {};
+	  }
+	  const scope = {};
+	  Cu.import("resource://gre/modules/AppConstants.jsm", scope);
+	  return scope.AppConstants;
+	});
+
+	/**
+	 * No operation. The empty function.
+	 */
+	exports.noop = function () {};
+
+	let assertionFailureCount = 0;
+
+	Object.defineProperty(exports, "assertionFailureCount", {
+	  get() {
+	    return assertionFailureCount;
+	  }
+	});
+
+	function reallyAssert(condition, message) {
+	  if (!condition) {
+	    assertionFailureCount++;
+	    const err = new Error("Assertion failure: " + message);
+	    exports.reportException("DevToolsUtils.assert", err);
+	    throw err;
+	  }
+	}
+
+	/**
+	 * DevToolsUtils.assert(condition, message)
+	 *
+	 * @param Boolean condition
+	 * @param String message
+	 *
+	 * Assertions are enabled when any of the following are true:
+	 *   - This is a DEBUG_JS_MODULES build
+	 *   - This is a DEBUG build
+	 *   - DevToolsUtils.testing is set to true
+	 *
+	 * If assertions are enabled, then `condition` is checked and if false-y, the
+	 * assertion failure is logged and then an error is thrown.
+	 *
+	 * If assertions are not enabled, then this function is a no-op.
+	 */
+	Object.defineProperty(exports, "assert", {
+	  get: () => AppConstants.DEBUG || AppConstants.DEBUG_JS_MODULES || _this.testing ? reallyAssert : exports.noop
+	});
+
+	/**
+	 * Defines a getter on a specified object for a module.  The module will not
+	 * be imported until first use.
+	 *
+	 * @param aObject
+	 *        The object to define the lazy getter on.
+	 * @param aName
+	 *        The name of the getter to define on aObject for the module.
+	 * @param aResource
+	 *        The URL used to obtain the module.
+	 * @param aSymbol
+	 *        The name of the symbol exported by the module.
+	 *        This parameter is optional and defaults to aName.
+	 */
+	exports.defineLazyModuleGetter = function defineLazyModuleGetter(aObject, aName, aResource, aSymbol) {
+	  this.defineLazyGetter(aObject, aName, function XPCU_moduleLambda() {
+	    var temp = {};
+	    Cu.import(aResource, temp);
+	    return temp[aSymbol || aName];
+	  });
+	};
+
+	exports.defineLazyGetter(this, "NetUtil", () => {
+	  return Cu.import("resource://gre/modules/NetUtil.jsm", {}).NetUtil;
+	});
+
+	exports.defineLazyGetter(this, "OS", () => {
+	  return Cu.import("resource://gre/modules/osfile.jsm", {}).OS;
+	});
+
+	exports.defineLazyGetter(this, "TextDecoder", () => {
+	  return Cu.import("resource://gre/modules/osfile.jsm", {}).TextDecoder;
+	});
+
+	exports.defineLazyGetter(this, "NetworkHelper", () => {
+	  return __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"devtools/shared/webconsole/network-helper\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
+	});
+
+	/**
+	 * Performs a request to load the desired URL and returns a promise.
+	 *
+	 * @param aURL String
+	 *        The URL we will request.
+	 * @param aOptions Object
+	 *        An object with the following optional properties:
+	 *        - loadFromCache: if false, will bypass the cache and
+	 *          always load fresh from the network (default: true)
+	 *        - policy: the nsIContentPolicy type to apply when fetching the URL
+	 *                  (only works when loading from system principal)
+	 *        - window: the window to get the loadGroup from
+	 *        - charset: the charset to use if the channel doesn't provide one
+	 *        - principal: the principal to use, if omitted, the request is loaded
+	 *                     with the system principal
+	 *        - cacheKey: when loading from cache, use this key to retrieve a cache
+	 *                    specific to a given SHEntry. (Allows loading POST
+	 *                    requests from cache)
+	 * @returns Promise that resolves with an object with the following members on
+	 *          success:
+	 *           - content: the document at that URL, as a string,
+	 *           - contentType: the content type of the document
+	 *
+	 *          If an error occurs, the promise is rejected with that error.
+	 *
+	 * XXX: It may be better to use nsITraceableChannel to get to the sources
+	 * without relying on caching when we can (not for eval, etc.):
+	 * http://www.softwareishard.com/blog/firebug/nsitraceablechannel-intercept-http-traffic/
+	 */
+	function mainThreadFetch(aURL, aOptions = { loadFromCache: true,
+	  policy: Ci.nsIContentPolicy.TYPE_OTHER,
+	  window: null,
+	  charset: null,
+	  principal: null,
+	  cacheKey: null }) {
+	  // Create a channel.
+	  let url = aURL.split(" -> ").pop();
+	  let channel;
+	  try {
+	    channel = newChannelForURL(url, aOptions);
+	  } catch (ex) {
+	    return promise.reject(ex);
+	  }
+
+	  // Set the channel options.
+	  channel.loadFlags = aOptions.loadFromCache ? channel.LOAD_FROM_CACHE : channel.LOAD_BYPASS_CACHE;
+
+	  // When loading from cache, the cacheKey allows us to target a specific
+	  // SHEntry and offer ways to restore POST requests from cache.
+	  if (aOptions.loadFromCache && aOptions.cacheKey && channel instanceof Ci.nsICacheInfoChannel) {
+	    channel.cacheKey = aOptions.cacheKey;
+	  }
+
+	  if (aOptions.window) {
+	    // Respect private browsing.
+	    channel.loadGroup = aOptions.window.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIWebNavigation).QueryInterface(Ci.nsIDocumentLoader).loadGroup;
+	  }
+
+	  let deferred = defer();
+	  let onResponse = (stream, status, request) => {
+	    if (!components.isSuccessCode(status)) {
+	      deferred.reject(new Error(`Failed to fetch ${ url }. Code ${ status }.`));
+	      return;
+	    }
+
+	    try {
+	      // We cannot use NetUtil to do the charset conversion as if charset
+	      // information is not available and our default guess is wrong the method
+	      // might fail and we lose the stream data. This means we can't fall back
+	      // to using the locale default encoding (bug 1181345).
+
+	      // Read and decode the data according to the locale default encoding.
+	      let available = stream.available();
+	      let source = NetUtil.readInputStreamToString(stream, available);
+	      stream.close();
+
+	      // If the channel or the caller has correct charset information, the
+	      // content will be decoded correctly. If we have to fall back to UTF-8 and
+	      // the guess is wrong, the conversion fails and convertToUnicode returns
+	      // the input unmodified. Essentially we try to decode the data as UTF-8
+	      // and if that fails, we use the locale specific default encoding. This is
+	      // the best we can do if the source does not provide charset info.
+	      let charset = channel.contentCharset || aOptions.charset || "UTF-8";
+	      let unicodeSource = NetworkHelper.convertToUnicode(source, charset);
+
+	      deferred.resolve({
+	        content: unicodeSource,
+	        contentType: request.contentType
+	      });
+	    } catch (ex) {
+	      let uri = request.originalURI;
+	      if (ex.name === "NS_BASE_STREAM_CLOSED" && uri instanceof Ci.nsIFileURL) {
+	        // Empty files cause NS_BASE_STREAM_CLOSED exception. Use OS.File to
+	        // differentiate between empty files and other errors (bug 1170864).
+	        // This can be removed when bug 982654 is fixed.
+
+	        uri.QueryInterface(Ci.nsIFileURL);
+	        let result = OS.File.read(uri.file.path).then(bytes => {
+	          // Convert the bytearray to a String.
+	          let decoder = new TextDecoder();
+	          let content = decoder.decode(bytes);
+
+	          // We can't detect the contentType without opening a channel
+	          // and that failed already. This is the best we can do here.
+	          return {
+	            content,
+	            contentType: "text/plain"
+	          };
+	        });
+
+	        deferred.resolve(result);
+	      } else {
+	        deferred.reject(ex);
+	      }
+	    }
+	  };
+
+	  // Open the channel
+	  try {
+	    NetUtil.asyncFetch(channel, onResponse);
+	  } catch (ex) {
+	    return promise.reject(ex);
+	  }
+
+	  return deferred.promise;
+	}
+
+	/**
+	 * Opens a channel for given URL. Tries a bit harder than NetUtil.newChannel.
+	 *
+	 * @param {String} url - The URL to open a channel for.
+	 * @param {Object} options - The options object passed to @method fetch.
+	 * @return {nsIChannel} - The newly created channel. Throws on failure.
+	 */
+	function newChannelForURL(url, { policy, window, principal }) {
+	  var securityFlags = Ci.nsILoadInfo.SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL;
+	  if (window) {
+	    // Respect private browsing.
+	    var req = window.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIWebNavigation).QueryInterface(Ci.nsIDocumentLoader).loadGroup;
+	    if (req) {
+	      var nc = req.notificationCallbacks;
+	      if (nc) {
+	        try {
+	          var lc = nc.getInterface(Ci.nsILoadContext);
+	          if (lc) {
+	            if (lc.usePrivateBrowsing) {
+	              securityFlags |= Ci.nsILoadInfo.SEC_FORCE_PRIVATE_BROWSING;
+	            }
+	          }
+	        } catch (ex) {}
+	      }
+	    }
+	  }
+
+	  let channelOptions = {
+	    contentPolicyType: policy,
+	    securityFlags: securityFlags,
+	    uri: url
+	  };
+	  if (principal) {
+	    // contentPolicyType is required when loading with a custom principal
+	    if (!channelOptions.contentPolicyType) {
+	      channelOptions.contentPolicyType = Ci.nsIContentPolicy.TYPE_OTHER;
+	    }
+	    channelOptions.loadingPrincipal = principal;
+	  } else {
+	    channelOptions.loadUsingSystemPrincipal = true;
+	  }
+
+	  try {
+	    return NetUtil.newChannel(channelOptions);
+	  } catch (e) {
+	    // In the xpcshell tests, the script url is the absolute path of the test
+	    // file, which will make a malformed URI error be thrown. Add the file
+	    // scheme to see if it helps.
+	    channelOptions.uri = "file://" + url;
+
+	    return NetUtil.newChannel(channelOptions);
+	  }
+	}
+
+	// Fetch is defined differently depending on whether we are on the main thread
+	// or a worker thread.
+	if (!this.isWorker) {
+	  exports.fetch = mainThreadFetch;
+	} else {
+	  // Services is not available in worker threads, nor is there any other way
+	  // to fetch a URL. We need to enlist the help from the main thread here, by
+	  // issuing an rpc request, to fetch the URL on our behalf.
+	  exports.fetch = function (url, options) {
+	    return rpc("fetch", url, options);
+	  };
+	}
+
+	/**
+	 * Returns a promise that is resolved or rejected when all promises have settled
+	 * (resolved or rejected).
+	 *
+	 * This differs from Promise.all, which will reject immediately after the first
+	 * rejection, instead of waiting for the remaining promises to settle.
+	 *
+	 * @param values
+	 *        Iterable of promises that may be pending, resolved, or rejected. When
+	 *        when all promises have settled (resolved or rejected), the returned
+	 *        promise will be resolved or rejected as well.
+	 *
+	 * @return A new promise that is fulfilled when all values have settled
+	 *         (resolved or rejected). Its resolution value will be an array of all
+	 *         resolved values in the given order, or undefined if values is an
+	 *         empty array. The reject reason will be forwarded from the first
+	 *         promise in the list of given promises to be rejected.
+	 */
+	exports.settleAll = values => {
+	  if (values === null || typeof values[Symbol.iterator] != "function") {
+	    throw new Error("settleAll() expects an iterable.");
+	  }
+
+	  let deferred = defer();
+
+	  values = Array.isArray(values) ? values : [...values];
+	  let countdown = values.length;
+	  let resolutionValues = new Array(countdown);
+	  let rejectionValue;
+	  let rejectionOccurred = false;
+
+	  if (!countdown) {
+	    deferred.resolve(resolutionValues);
+	    return deferred.promise;
+	  }
+
+	  function checkForCompletion() {
+	    if (--countdown > 0) {
+	      return;
+	    }
+	    if (!rejectionOccurred) {
+	      deferred.resolve(resolutionValues);
+	    } else {
+	      deferred.reject(rejectionValue);
+	    }
+	  }
+
+	  for (let i = 0; i < values.length; i++) {
+	    let index = i;
+	    let value = values[i];
+	    let resolver = result => {
+	      resolutionValues[index] = result;
+	      checkForCompletion();
+	    };
+	    let rejecter = error => {
+	      if (!rejectionOccurred) {
+	        rejectionValue = error;
+	        rejectionOccurred = true;
+	      }
+	      checkForCompletion();
+	    };
+
+	    if (value && typeof value.then == "function") {
+	      value.then(resolver, rejecter);
+	    } else {
+	      // Given value is not a promise, forward it as a resolution value.
+	      resolver(value);
+	    }
+	  }
+
+	  return deferred.promise;
+	};
+
+	/**
+	 * When the testing flag is set, various behaviors may be altered from
+	 * production mode, typically to enable easier testing or enhanced debugging.
+	 */
+	var testing = false;
+	Object.defineProperty(exports, "testing", {
+	  get: function () {
+	    return testing;
+	  },
+	  set: function (state) {
+	    testing = state;
+	  }
+	});
+
+	/**
+	 * Open the file at the given path for reading.
+	 *
+	 * @param {String} filePath
+	 *
+	 * @returns Promise<nsIInputStream>
+	 */
+	exports.openFileStream = function (filePath) {
+	  return new Promise((resolve, reject) => {
+	    const uri = NetUtil.newURI(new FileUtils.File(filePath));
+	    NetUtil.asyncFetch({ uri, loadUsingSystemPrincipal: true }, (stream, result) => {
+	      if (!components.isSuccessCode(result)) {
+	        reject(new Error(`Could not open "${ filePath }": result = ${ result }`));
+	        return;
+	      }
+
+	      resolve(stream);
+	    });
+	  });
+	};
+	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(178).setImmediate))
+
+/***/ },
+
+/***/ 178:
+/***/ function(module, exports, __webpack_require__) {
+
+	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(179).nextTick;
+	var apply = Function.prototype.apply;
+	var slice = Array.prototype.slice;
+	var immediateIds = {};
+	var nextImmediateId = 0;
+
+	// DOM APIs, for completeness
+
+	exports.setTimeout = function() {
+	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
+	};
+	exports.setInterval = function() {
+	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
+	};
+	exports.clearTimeout =
+	exports.clearInterval = function(timeout) { timeout.close(); };
+
+	function Timeout(id, clearFn) {
+	  this._id = id;
+	  this._clearFn = clearFn;
+	}
+	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
+	Timeout.prototype.close = function() {
+	  this._clearFn.call(window, this._id);
+	};
+
+	// Does not start the time, just sets up the members needed.
+	exports.enroll = function(item, msecs) {
+	  clearTimeout(item._idleTimeoutId);
+	  item._idleTimeout = msecs;
+	};
+
+	exports.unenroll = function(item) {
+	  clearTimeout(item._idleTimeoutId);
+	  item._idleTimeout = -1;
+	};
+
+	exports._unrefActive = exports.active = function(item) {
+	  clearTimeout(item._idleTimeoutId);
+
+	  var msecs = item._idleTimeout;
+	  if (msecs >= 0) {
+	    item._idleTimeoutId = setTimeout(function onTimeout() {
+	      if (item._onTimeout)
+	        item._onTimeout();
+	    }, msecs);
+	  }
+	};
+
+	// That's not how node.js implements it but the exposed api is the same.
+	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
+	  var id = nextImmediateId++;
+	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);
+
+	  immediateIds[id] = true;
+
+	  nextTick(function onNextTick() {
+	    if (immediateIds[id]) {
+	      // fn.call() is faster so we optimize for the common use-case
+	      // @see http://jsperf.com/call-apply-segu
+	      if (args) {
+	        fn.apply(null, args);
+	      } else {
+	        fn.call(null);
+	      }
+	      // Prevent ids from leaking
+	      exports.clearImmediate(id);
+	    }
+	  });
+
+	  return id;
+	};
+
+	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
+	  delete immediateIds[id];
+	};
+	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(178).setImmediate, __webpack_require__(178).clearImmediate))
+
+/***/ },
+
+/***/ 179:
+/***/ function(module, exports) {
+
+	// shim for using process in browser
+	var process = module.exports = {};
+
+	// cached from whatever global is present so that test runners that stub it
+	// don't break things.  But we need to wrap it in a try catch in case it is
+	// wrapped in strict mode code which doesn't define any globals.  It's inside a
+	// function because try/catches deoptimize in certain engines.
+
+	var cachedSetTimeout;
+	var cachedClearTimeout;
+
+	(function () {
+	    try {
+	        cachedSetTimeout = setTimeout;
+	    } catch (e) {
+	        cachedSetTimeout = function () {
+	            throw new Error('setTimeout is not defined');
+	        }
+	    }
+	    try {
+	        cachedClearTimeout = clearTimeout;
+	    } catch (e) {
+	        cachedClearTimeout = function () {
+	            throw new Error('clearTimeout is not defined');
+	        }
+	    }
+	} ())
+	function runTimeout(fun) {
+	    if (cachedSetTimeout === setTimeout) {
+	        return setTimeout(fun, 0);
+	    } else {
+	        return cachedSetTimeout.call(null, fun, 0);
+	    }
+	}
+	function runClearTimeout(marker) {
+	    if (cachedClearTimeout === clearTimeout) {
+	        clearTimeout(marker);
+	    } else {
+	        cachedClearTimeout.call(null, marker);
+	    }
+	}
+	var queue = [];
+	var draining = false;
+	var currentQueue;
+	var queueIndex = -1;
+
+	function cleanUpNextTick() {
+	    if (!draining || !currentQueue) {
+	        return;
+	    }
+	    draining = false;
+	    if (currentQueue.length) {
+	        queue = currentQueue.concat(queue);
+	    } else {
+	        queueIndex = -1;
+	    }
+	    if (queue.length) {
+	        drainQueue();
+	    }
+	}
+
+	function drainQueue() {
+	    if (draining) {
+	        return;
+	    }
+	    var timeout = runTimeout(cleanUpNextTick);
+	    draining = true;
+
+	    var len = queue.length;
+	    while(len) {
+	        currentQueue = queue;
+	        queue = [];
+	        while (++queueIndex < len) {
+	            if (currentQueue) {
+	                currentQueue[queueIndex].run();
+	            }
+	        }
+	        queueIndex = -1;
+	        len = queue.length;
+	    }
+	    currentQueue = null;
+	    draining = false;
+	    runClearTimeout(timeout);
+	}
+
+	process.nextTick = function (fun) {
+	    var args = new Array(arguments.length - 1);
+	    if (arguments.length > 1) {
+	        for (var i = 1; i < arguments.length; i++) {
+	            args[i - 1] = arguments[i];
+	        }
+	    }
+	    queue.push(new Item(fun, args));
+	    if (queue.length === 1 && !draining) {
+	        runTimeout(drainQueue);
+	    }
+	};
+
+	// v8 likes predictible objects
+	function Item(fun, array) {
+	    this.fun = fun;
+	    this.array = array;
+	}
+	Item.prototype.run = function () {
+	    this.fun.apply(null, this.array);
+	};
+	process.title = 'browser';
+	process.browser = true;
+	process.env = {};
+	process.argv = [];
+	process.version = ''; // empty string to avoid regexp issues
+	process.versions = {};
+
+	function noop() {}
+
+	process.on = noop;
+	process.addListener = noop;
+	process.once = noop;
+	process.off = noop;
+	process.removeListener = noop;
+	process.removeAllListeners = noop;
+	process.emit = noop;
+
+	process.binding = function (name) {
+	    throw new Error('process.binding is not supported');
+	};
+
+	process.cwd = function () { return '/' };
+	process.chdir = function (dir) {
+	    throw new Error('process.chdir is not supported');
+	};
+	process.umask = function() { return 0; };
+
+
+/***/ },
+
+/***/ 180:
+/***/ function(module, exports, __webpack_require__) {
+
+	/* This Source Code Form is subject to the terms of the Mozilla Public
+	 * License, v. 2.0. If a copy of the MPL was not distributed with this
+	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+	"use strict";
+
+	var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
+
+	var Services = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"Services\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
+	var EventEmitter = __webpack_require__(3);
+	var isOSX = Services.appinfo.OS === "Darwin";
+
+	// List of electron keys mapped to DOM API (DOM_VK_*) key code
+	var ElectronKeysMapping = {
+	  "F1": "DOM_VK_F1",
+	  "F2": "DOM_VK_F2",
+	  "F3": "DOM_VK_F3",
+	  "F4": "DOM_VK_F4",
+	  "F5": "DOM_VK_F5",
+	  "F6": "DOM_VK_F6",
+	  "F7": "DOM_VK_F7",
+	  "F8": "DOM_VK_F8",
+	  "F9": "DOM_VK_F9",
+	  "F10": "DOM_VK_F10",
+	  "F11": "DOM_VK_F11",
+	  "F12": "DOM_VK_F12",
+	  "F13": "DOM_VK_F13",
+	  "F14": "DOM_VK_F14",
+	  "F15": "DOM_VK_F15",
+	  "F16": "DOM_VK_F16",
+	  "F17": "DOM_VK_F17",
+	  "F18": "DOM_VK_F18",
+	  "F19": "DOM_VK_F19",
+	  "F20": "DOM_VK_F20",
+	  "F21": "DOM_VK_F21",
+	  "F22": "DOM_VK_F22",
+	  "F23": "DOM_VK_F23",
+	  "F24": "DOM_VK_F24",
+	  "Space": "DOM_VK_SPACE",
+	  "Backspace": "DOM_VK_BACK_SPACE",
+	  "Delete": "DOM_VK_DELETE",
+	  "Insert": "DOM_VK_INSERT",
+	  "Return": "DOM_VK_RETURN",
+	  "Enter": "DOM_VK_RETURN",
+	  "Up": "DOM_VK_UP",
+	  "Down": "DOM_VK_DOWN",
+	  "Left": "DOM_VK_LEFT",
+	  "Right": "DOM_VK_RIGHT",
+	  "Home": "DOM_VK_HOME",
+	  "End": "DOM_VK_END",
+	  "PageUp": "DOM_VK_PAGE_UP",
+	  "PageDown": "DOM_VK_PAGE_DOWN",
+	  "Escape": "DOM_VK_ESCAPE",
+	  "Esc": "DOM_VK_ESCAPE",
+	  "Tab": "DOM_VK_TAB",
+	  "VolumeUp": "DOM_VK_VOLUME_UP",
+	  "VolumeDown": "DOM_VK_VOLUME_DOWN",
+	  "VolumeMute": "DOM_VK_VOLUME_MUTE",
+	  "PrintScreen": "DOM_VK_PRINTSCREEN"
+	};
+
+	/**
+	 * Helper to listen for keyboard events decribed in .properties file.
+	 *
+	 * let shortcuts = new KeyShortcuts({
+	 *   window
+	 * });
+	 * shortcuts.on("Ctrl+F", event => {
+	 *   // `event` is the KeyboardEvent which relates to the key shortcuts
+	 * });
+	 *
+	 * @param DOMWindow window
+	 *        The window object of the document to listen events from.
+	 * @param DOMElement target
+	 *        Optional DOM Element on which we should listen events from.
+	 *        If omitted, we listen for all events fired on `window`.
+	 */
+	function KeyShortcuts(_ref) {
+	  var window = _ref.window;
+	  var target = _ref.target;
+
+	  this.window = window;
+	  this.target = target || window;
+	  this.keys = new Map();
+	  this.eventEmitter = new EventEmitter();
+	  this.target.addEventListener("keydown", this);
+	}
+
+	/*
+	 * Parse an electron-like key string and return a normalized object which
+	 * allow efficient match on DOM key event. The normalized object matches DOM
+	 * API.
+	 *
+	 * @param DOMWindow window
+	 *        Any DOM Window object, just to fetch its `KeyboardEvent` object
+	 * @param String str
+	 *        The shortcut string to parse, following this document:
+	 *        https://github.com/electron/electron/blob/master/docs/api/accelerator.md
+	 */
+	KeyShortcuts.parseElectronKey = function (window, str) {
+	  var modifiers = str.split("+");
+	  var key = modifiers.pop();
+
+	  var shortcut = {
+	    ctrl: false,
+	    meta: false,
+	    alt: false,
+	    shift: false,
+	    // Set for character keys
+	    key: undefined,
+	    // Set for non-character keys
+	    keyCode: undefined
+	  };
+	  var _iteratorNormalCompletion = true;
+	  var _didIteratorError = false;
+	  var _iteratorError = undefined;
+
+	  try {
+	    for (var _iterator = modifiers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
+	      var mod = _step.value;
+
+	      if (mod === "Alt") {
+	        shortcut.alt = true;
+	      } else if (["Command", "Cmd"].includes(mod)) {
+	        shortcut.meta = true;
+	      } else if (["CommandOrControl", "CmdOrCtrl"].includes(mod)) {
+	        if (isOSX) {
+	          shortcut.meta = true;
+	        } else {
+	          shortcut.ctrl = true;
+	        }
+	      } else if (["Control", "Ctrl"].includes(mod)) {
+	        shortcut.ctrl = true;
+	      } else if (mod === "Shift") {
+	        shortcut.shift = true;
+	      } else {
+	        console.error("Unsupported modifier:", mod, "from key:", str);
+	        return null;
+	      }
+	    }
+
+	    // Plus is a special case. It's a character key and shouldn't be matched
+	    // against a keycode as it is only accessible via Shift/Capslock
+	  } catch (err) {
+	    _didIteratorError = true;
+	    _iteratorError = err;
+	  } finally {
+	    try {
+	      if (!_iteratorNormalCompletion && _iterator.return) {
+	        _iterator.return();
+	      }
+	    } finally {
+	      if (_didIteratorError) {
+	        throw _iteratorError;
+	      }
+	    }
+	  }
+
+	  if (key === "Plus") {
+	    key = "+";
+	  }
+
+	  if (typeof key === "string" && key.length === 1) {
+	    // Match any single character
+	    shortcut.key = key.toLowerCase();
+	  } else if (key in ElectronKeysMapping) {
+	    // Maps the others manually to DOM API DOM_VK_*
+	    key = ElectronKeysMapping[key];
+	    shortcut.keyCode = window.KeyboardEvent[key];
+	    // Used only to stringify the shortcut
+	    shortcut.keyCodeString = key;
+	  } else {
+	    console.error("Unsupported key:", key);
+	    return null;
+	  }
+
+	  return shortcut;
+	};
+
+	KeyShortcuts.stringify = function (shortcut) {
+	  var list = [];
+	  if (shortcut.alt) {
+	    list.push("Alt");
+	  }
+	  if (shortcut.ctrl) {
+	    list.push("Ctrl");
+	  }
+	  if (shortcut.meta) {
+	    list.push("Cmd");
+	  }
+	  if (shortcut.shift) {
+	    list.push("Shift");
+	  }
+	  var key = void 0;
+	  if (shortcut.key) {
+	    key = shortcut.key.toUpperCase();
+	  } else {
+	    key = shortcut.keyCodeString;
+	  }
+	  list.push(key);
+	  return list.join("+");
+	};
+
+	KeyShortcuts.prototype = {
+	  destroy: function destroy() {
+	    this.target.removeEventListener("keydown", this);
+	    this.keys.clear();
+	  },
+	  doesEventMatchShortcut: function doesEventMatchShortcut(event, shortcut) {
+	    if (shortcut.meta != event.metaKey) {
+	      return false;
+	    }
+	    if (shortcut.ctrl != event.ctrlKey) {
+	      return false;
+	    }
+	    if (shortcut.alt != event.altKey) {
+	      return false;
+	    }
+	    // Shift is a special modifier, it may implicitely be required if the
+	    // expected key is a special character accessible via shift.
+	    if (shortcut.shift != event.shiftKey && event.key && event.key.match(/[a-zA-Z]/)) {
+	      return false;
+	    }
+	    if (shortcut.keyCode) {
+	      return event.keyCode == shortcut.keyCode;
+	    }
+	    // For character keys, we match if the final character is the expected one.
+	    // But for digits we also accept indirect match to please azerty keyboard,
+	    // which requires Shift to be pressed to get digits.
+	    return event.key.toLowerCase() == shortcut.key || shortcut.key.match(/[0-9]/) && event.keyCode == shortcut.key.charCodeAt(0);
+	  },
+	  handleEvent: function handleEvent(event) {
+	    var _iteratorNormalCompletion2 = true;
+	    var _didIteratorError2 = false;
+	    var _iteratorError2 = undefined;
+
+	    try {
+	      for (var _iterator2 = this.keys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
+	        var _step2$value = _slicedToArray(_step2.value, 2);
+
+	        var key = _step2$value[0];
+	        var shortcut = _step2$value[1];
+
+	        if (this.doesEventMatchShortcut(event, shortcut)) {
+	          this.eventEmitter.emit(key, event);
+	        }
+	      }
+	    } catch (err) {
+	      _didIteratorError2 = true;
+	      _iteratorError2 = err;
+	    } finally {
+	      try {
+	        if (!_iteratorNormalCompletion2 && _iterator2.return) {
+	          _iterator2.return();
+	        }
+	      } finally {
+	        if (_didIteratorError2) {
+	          throw _iteratorError2;
+	        }
+	      }
+	    }
+	  },
+	  on: function on(key, listener) {
+	    if (typeof listener !== "function") {
+	      throw new Error("KeyShortcuts.on() expects a function as " + "second argument");
+	    }
+	    if (!this.keys.has(key)) {
+	      var shortcut = KeyShortcuts.parseElectronKey(this.window, key);
+	      // The key string is wrong and we were unable to compute the key shortcut
+	      if (!shortcut) {
+	        return;
+	      }
+	      this.keys.set(key, shortcut);
+	    }
+	    this.eventEmitter.on(key, listener);
+	  },
+	  off: function off(key, listener) {
+	    this.eventEmitter.off(key, listener);
+	  }
+	};
+	exports.KeyShortcuts = KeyShortcuts;
+
+/***/ },
+
+/***/ 181:
+/***/ function(module, exports, __webpack_require__) {
+
+	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
+	/* vim: set ts=2 et sw=2 tw=80 filetype=javascript: */
+	/* This Source Code Form is subject to the terms of the Mozilla Public
+	 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+	 * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+	"use strict";
+
+	/* eslint-disable spaced-comment */
+	/* globals StopIteration */
+
+	/**
+	 * This module implements a subset of "Task.js" <http://taskjs.org/>.
+	 * It is a copy of toolkit/modules/Task.jsm.  Please try not to
+	 * diverge the API here.
+	 *
+	 * Paraphrasing from the Task.js site, tasks make sequential, asynchronous
+	 * operations simple, using the power of JavaScript's "yield" operator.
+	 *
+	 * Tasks are built upon generator functions and promises, documented here:
+	 *
+	 * <https://developer.mozilla.org/en/JavaScript/Guide/Iterators_and_Generators>
+	 * <http://wiki.commonjs.org/wiki/Promises/A>
+	 *
+	 * The "Task.spawn" function takes a generator function and starts running it as
+	 * a task.  Every time the task yields a promise, it waits until the promise is
+	 * fulfilled.  "Task.spawn" returns a promise that is resolved when the task
+	 * completes successfully, or is rejected if an exception occurs.
+	 *
+	 * -----------------------------------------------------------------------------
+	 *
+	 * const {Task} = require("devtools/shared/task");
+	 *
+	 * Task.spawn(function* () {
+	 *
+	 *   // This is our task. Let's create a promise object, wait on it and capture
+	 *   // its resolution value.
+	 *   let myPromise = getPromiseResolvedOnTimeoutWithValue(1000, "Value");
+	 *   let result = yield myPromise;
+	 *
+	 *   // This part is executed only after the promise above is fulfilled (after
+	 *   // one second, in this imaginary example).  We can easily loop while
+	 *   // calling asynchronous functions, and wait multiple times.
+	 *   for (let i = 0; i < 3; i++) {
+	 *     result += yield getPromiseResolvedOnTimeoutWithValue(50, "!");
+	 *   }
+	 *
+	 *   return "Resolution result for the task: " + result;
+	 * }).then(function (result) {
+	 *
+	 *   // result == "Resolution result for the task: Value!!!"
+	 *
+	 *   // The result is undefined if no value was returned.
+	 *
+	 * }, function (exception) {
+	 *
+	 *   // Failure!  We can inspect or report the exception.
+	 *
+	 * });
+	 *
+	 * -----------------------------------------------------------------------------
+	 *
+	 * This module implements only the "Task.js" interfaces described above, with no
+	 * additional features to control the task externally, or do custom scheduling.
+	 * It also provides the following extensions that simplify task usage in the
+	 * most common cases:
+	 *
+	 * - The "Task.spawn" function also accepts an iterator returned by a generator
+	 *   function, in addition to a generator function.  This way, you can call into
+	 *   the generator function with the parameters you want, and with "this" bound
+	 *   to the correct value.  Also, "this" is never bound to the task object when
+	 *   "Task.spawn" calls the generator function.
+	 *
+	 * - In addition to a promise object, a task can yield the iterator returned by
+	 *   a generator function.  The iterator is turned into a task automatically.
+	 *   This reduces the syntax overhead of calling "Task.spawn" explicitly when
+	 *   you want to recurse into other task functions.
+	 *
+	 * - The "Task.spawn" function also accepts a primitive value, or a function
+	 *   returning a primitive value, and treats the value as the result of the
+	 *   task.  This makes it possible to call an externally provided function and
+	 *   spawn a task from it, regardless of whether it is an asynchronous generator
+	 *   or a synchronous function.  This comes in handy when iterating over
+	 *   function lists where some items have been converted to tasks and some not.
+	 */
+
+	////////////////////////////////////////////////////////////////////////////////
+	//// Globals
+
+	const Promise = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"promise\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
+	const defer = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"devtools/shared/defer\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
+
+	// The following error types are considered programmer errors, which should be
+	// reported (possibly redundantly) so as to let programmers fix their code.
+	const ERRORS_TO_REPORT = ["EvalError", "RangeError", "ReferenceError", "TypeError"];
+
+	/**
+	 * The Task currently being executed
+	 */
+	var gCurrentTask = null;
+
+	/**
+	 * If `true`, capture stacks whenever entering a Task and rewrite the
+	 * stack any exception thrown through a Task.
+	 */
+	var gMaintainStack = false;
+
+	/**
+	 * Iterate through the lines of a string.
+	 *
+	 * @return Iterator<string>
+	 */
+	function* linesOf(string) {
+	  let reLine = /([^\r\n])+/g;
+	  let match;
+	  while (match = reLine.exec(string)) {
+	    yield [match[0], match.index];
+	  }
+	}
+
+	/**
+	 * Detect whether a value is a generator.
+	 *
+	 * @param aValue
+	 *        The value to identify.
+	 * @return A boolean indicating whether the value is a generator.
+	 */
+	function isGenerator(value) {
+	  return Object.prototype.toString.call(value) == "[object Generator]";
+	}
+
+	////////////////////////////////////////////////////////////////////////////////
+	//// Task
+
+	/**
+	 * This object provides the public module functions.
+	 */
+	this.Task = {
+	  /**
+	   * Creates and starts a new task.
+	   *
+	   * @param task
+	   *        - If you specify a generator function, it is called with no
+	   *          arguments to retrieve the associated iterator.  The generator
+	   *          function is a task, that is can yield promise objects to wait
+	   *          upon.
+	   *        - If you specify the iterator returned by a generator function you
+	   *          called, the generator function is also executed as a task.  This
+	   *          allows you to call the function with arguments.
+	   *        - If you specify a function that is not a generator, it is called
+	   *          with no arguments, and its return value is used to resolve the
+	   *          returned promise.
+	   *        - If you specify anything else, you get a promise that is already
+	   *          resolved with the specified value.
+	   *
+	   * @return A promise object where you can register completion callbacks to be
+	   *         called when the task terminates.
+	   */
+	  spawn: function (task) {
+	    return createAsyncFunction(task).call(undefined);
+	  },
+
+	  /**
+	   * Create and return an 'async function' that starts a new task.
+	   *
+	   * This is similar to 'spawn' except that it doesn't immediately start
+	   * the task, it binds the task to the async function's 'this' object and
+	   * arguments, and it requires the task to be a function.
+	   *
+	   * It simplifies the common pattern of implementing a method via a task,
+	   * like this simple object with a 'greet' method that has a 'name' parameter
+	   * and spawns a task to send a greeting and return its reply:
+	   *
+	   * let greeter = {
+	   *   message: "Hello, NAME!",
+	   *   greet: function(name) {
+	   *     return Task.spawn((function* () {
+	   *       return yield sendGreeting(this.message.replace(/NAME/, name));
+	   *     }).bind(this);
+	   *   })
+	   * };
+	   *
+	   * With Task.async, the method can be declared succinctly:
+	   *
+	   * let greeter = {
+	   *   message: "Hello, NAME!",
+	   *   greet: Task.async(function* (name) {
+	   *     return yield sendGreeting(this.message.replace(/NAME/, name));
+	   *   })
+	   * };
+	   *
+	   * While maintaining identical semantics:
+	   *
+	   * greeter.greet("Mitchell").then((reply) => { ... }); // behaves the same
+	   *
+	   * @param task
+	   *        The task function to start.
+	   *
+	   * @return A function that starts the task function and returns its promise.
+	   */
+	  async: function (task) {
+	    if (typeof task != "function") {
+	      throw new TypeError("task argument must be a function");
+	    }
+
+	    return createAsyncFunction(task);
+	  },
+
+	  /**
+	   * Constructs a special exception that, when thrown inside a legacy generator
+	   * function (non-star generator), allows the associated task to be resolved
+	   * with a specific value.
+	   *
+	   * Example: throw new Task.Result("Value");
+	   */
+	  Result: function (value) {
+	    this.value = value;
+	  }
+	};
+
+	function createAsyncFunction(task) {
+	  let asyncFunction = function () {
+	    let result = task;
+	    if (task && typeof task == "function") {
+	      if (task.isAsyncFunction) {
+	        throw new TypeError("Cannot use an async function in place of a promise. " + "You should either invoke the async function first " + "or use 'Task.spawn' instead of 'Task.async' to start " + "the Task and return its promise.");
+	      }
+
+	      try {
+	        // Let's call into the function ourselves.
+	        result = task.apply(this, arguments);
+	      } catch (ex) {
+	        if (ex instanceof Task.Result) {
+	          return Promise.resolve(ex.value);
+	        }
+	        return Promise.reject(ex);
+	      }
+	    }
+
+	    if (isGenerator(result)) {
+	      // This is an iterator resulting from calling a generator function.
+	      return new TaskImpl(result).deferred.promise;
+	    }
+
+	    // Just propagate the given value to the caller as a resolved promise.
+	    return Promise.resolve(result);
+	  };
+
+	  asyncFunction.isAsyncFunction = true;
+
+	  return asyncFunction;
+	}
+
+	////////////////////////////////////////////////////////////////////////////////
+	//// TaskImpl
+
+	/**
+	 * Executes the specified iterator as a task, and gives access to the promise
+	 * that is fulfilled when the task terminates.
+	 */
+	function TaskImpl(iterator) {
+	  if (gMaintainStack) {
+	    this._stack = new Error().stack;
+	  }
+	  this.deferred = defer();
+	  this._iterator = iterator;
+	  this._isStarGenerator = !("send" in iterator);
+	  this._run(true);
+	}
+
+	TaskImpl.prototype = {
+	  /**
+	   * Includes the promise object where task completion callbacks are registered,
+	   * and methods to resolve or reject the promise at task completion.
+	   */
+	  deferred: null,
+
+	  /**
+	   * The iterator returned by the generator function associated with this task.
+	   */
+	  _iterator: null,
+
+	  /**
+	   * Whether this Task is using a star generator.
+	   */
+	  _isStarGenerator: false,
+
+	  /**
+	   * Main execution routine, that calls into the generator function.
+	   *
+	   * @param sendResolved
+	   *        If true, indicates that we should continue into the generator
+	   *        function regularly (if we were waiting on a promise, it was
+	   *        resolved). If true, indicates that we should cause an exception to
+	   *        be thrown into the generator function (if we were waiting on a
+	   *        promise, it was rejected).
+	   * @param sendValue
+	   *        Resolution result or rejection exception, if any.
+	   */
+	  _run: function (sendResolved, sendValue) {
+	    try {
+	      gCurrentTask = this;
+
+	      if (this._isStarGenerator) {
+	        try {
+	          let result = sendResolved ? this._iterator.next(sendValue) : this._iterator.throw(sendValue);
+
+	          if (result.done) {
+	            // The generator function returned.
+	            this.deferred.resolve(result.value);
+	          } else {
+	            // The generator function yielded.
+	            this._handleResultValue(result.value);
+	          }
+	        } catch (ex) {
+	          // The generator function failed with an uncaught exception.
+	          this._handleException(ex);
+	        }
+	      } else {
+	        try {
+	          let yielded = sendResolved ? this._iterator.send(sendValue) : this._iterator.throw(sendValue);
+	          this._handleResultValue(yielded);
+	        } catch (ex) {
+	          if (ex instanceof Task.Result) {
+	            // The generator function threw the special exception that
+	            // allows it to return a specific value on resolution.
+	            this.deferred.resolve(ex.value);
+	          } else if (ex instanceof StopIteration) {
+	            // The generator function terminated with no specific result.
+	            this.deferred.resolve(undefined);
+	          } else {
+	            // The generator function failed with an uncaught exception.
+	            this._handleException(ex);
+	          }
+	        }
+	      }
+	    } finally {
+	      //
+	      // At this stage, the Task may have finished executing, or have
+	      // walked through a `yield` or passed control to a sub-Task.
+	      // Regardless, if we still own `gCurrentTask`, reset it. If we
+	      // have not finished execution of this Task, re-entering `_run`
+	      // will set `gCurrentTask` to `this` as needed.
+	      //
+	      // We just need to be careful here in case we hit the following
+	      // pattern:
+	      //
+	      //   Task.spawn(foo);
+	      //   Task.spawn(bar);
+	      //
+	      // Here, `foo` and `bar` may be interleaved, so when we finish
+	      // executing `foo`, `gCurrentTask` may actually either `foo` or
+	      // `bar`. If `gCurrentTask` has already been set to `bar`, leave
+	      // it be and it will be reset to `null` once `bar` is complete.
+	      //
+	      if (gCurrentTask == this) {
+	        gCurrentTask = null;
+	      }
+	    }
+	  },
+
+	  /**
+	   * Handle a value yielded by a generator.
+	   *
+	   * @param value
+	   *        The yielded value to handle.
+	   */
+	  _handleResultValue: function (value) {
+	    // If our task yielded an iterator resulting from calling another
+	    // generator function, automatically spawn a task from it, effectively
+	    // turning it into a promise that is fulfilled on task completion.
+	    if (isGenerator(value)) {
+	      value = Task.spawn(value);
+	    }
+
+	    if (value && typeof value.then == "function") {
+	      // We have a promise object now. When fulfilled, call again into this
+	      // function to continue the task, with either a resolution or rejection
+	      // condition.
+	      value.then(this._run.bind(this, true), this._run.bind(this, false));
+	    } else {
+	      // If our task yielded a value that is not a promise, just continue and
+	      // pass it directly as the result of the yield statement.
+	      this._run(true, value);
+	    }
+	  },
+
+	  /**
+	   * Handle an uncaught exception thrown from a generator.
+	   *
+	   * @param exception
+	   *        The uncaught exception to handle.
+	   */
+	  _handleException: function (exception) {
+	    gCurrentTask = this;
+
+	    if (exception && typeof exception == "object" && "stack" in exception) {
+	      let stack = exception.stack;
+
+	      if (gMaintainStack && exception._capturedTaskStack != this._stack && typeof stack == "string") {
+	        // Rewrite the stack for more readability.
+
+	        let bottomStack = this._stack;
+
+	        stack = Task.Debugging.generateReadableStack(stack);
+
+	        exception.stack = stack;
+
+	        // If exception is reinjected in the same task and rethrown,
+	        // we don't want to perform the rewrite again.
+	        exception._capturedTaskStack = bottomStack;
+	      } else if (!stack) {
+	        stack = "Not available";
+	      }
+
+	      if ("name" in exception && ERRORS_TO_REPORT.indexOf(exception.name) != -1) {
+	        // We suspect that the exception is a programmer error, so we now
+	        // display it using dump().  Note that we do not use Cu.reportError as
+	        // we assume that this is a programming error, so we do not want end
+	        // users to see it. Also, if the programmer handles errors correctly,
+	        // they will either treat the error or log them somewhere.
+
+	        dump("*************************\n");
+	        dump("A coding exception was thrown and uncaught in a Task.\n\n");
+	        dump("Full message: " + exception + "\n");
+	        dump("Full stack: " + exception.stack + "\n");
+	        dump("*************************\n");
+	      }
+	    }
+
+	    this.deferred.reject(exception);
+	  },
+
+	  get callerStack() {
+	    // Cut `this._stack` at the last line of the first block that
+	    // contains task.js, keep the tail.
+	    for (let [line, index] of linesOf(this._stack || "")) {
+	      if (line.indexOf("/task.js:") == -1) {
+	        return this._stack.substring(index);
+	      }
+	    }
+	    return "";
+	  }
+	};
+
+	Task.Debugging = {
+
+	  /**
+	   * Control stack rewriting.
+	   *
+	   * If `true`, any exception thrown from a Task will be rewritten to
+	   * provide a human-readable stack trace. Otherwise, stack traces will
+	   * be left unchanged.
+	   *
+	   * There is a (small but existing) runtime cost associated to stack
+	   * rewriting, so you should probably not activate this in production
+	   * code.
+	   *
+	   * @type {bool}
+	   */
+	  get maintainStack() {
+	    return gMaintainStack;
+	  },
+	  set maintainStack(x) {
+	    if (!x) {
+	      gCurrentTask = null;
+	    }
+	    gMaintainStack = x;
+	    return x;
+	  },
+
+	  /**
+	   * Generate a human-readable stack for an error raised in
+	   * a Task.
+	   *
+	   * @param {string} topStack The stack provided by the error.
+	   * @param {string=} prefix Optionally, a prefix for each line.
+	   */
+	  generateReadableStack: function (topStack, prefix = "") {
+	    if (!gCurrentTask) {
+	      return topStack;
+	    }
+
+	    // Cut `topStack` at the first line that contains task.js, keep the head.
+	    let lines = [];
+	    for (let [line] of linesOf(topStack)) {
+	      if (line.indexOf("/task.js:") != -1) {
+	        break;
+	      }
+	      lines.push(prefix + line);
+	    }
+	    if (!prefix) {
+	      lines.push(gCurrentTask.callerStack);
+	    } else {
+	      for (let [line] of linesOf(gCurrentTask.callerStack)) {
+	        lines.push(prefix + line);
+	      }
+	    }
+
+	    return lines.join("\n");
+	  }
+	};
+
+	exports.Task = Task;
+
+/***/ },
+
+/***/ 182:
+/***/ function(module, exports, __webpack_require__) {
+
+	/* This Source Code Form is subject to the terms of the Mozilla Public
+	 * License, v. 2.0. If a copy of the MPL was not distributed with this
+	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+	"use strict";
+
+	const { FrontClassWithSpec, Front } = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"devtools/shared/protocol\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
+	const { cssPropertiesSpec } = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"devtools/shared/specs/css-properties\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
+	const { Task } = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"devtools/shared/task\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
+	const { CSS_PROPERTIES_DB } = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"devtools/shared/css-properties-db\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
+	const { cssColors } = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"devtools/shared/css-color-db\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
+
+	/**
+	 * Build up a regular expression that matches a CSS variable token. This is an
+	 * ident token that starts with two dashes "--".
+	 *
+	 * https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
+	 */
+	var NON_ASCII = "[^\\x00-\\x7F]";
+	var ESCAPE = "\\\\[^\n\r]";
+	var FIRST_CHAR = ["[_a-z]", NON_ASCII, ESCAPE].join("|");
+	var TRAILING_CHAR = ["[_a-z0-9-]", NON_ASCII, ESCAPE].join("|");
+	var IS_VARIABLE_TOKEN = new RegExp(`^--(${ FIRST_CHAR })(${ TRAILING_CHAR })*$`, "i");
+	/**
+	 * Check that this is a CSS variable.
+	 *
+	 * @param {String} input
+	 * @return {Boolean}
+	 */
+	function isCssVariable(input) {
+	  return !!input.match(IS_VARIABLE_TOKEN);
+	}
+
+	var cachedCssProperties = new WeakMap();
+
+	/**
+	 * The CssProperties front provides a mechanism to have a one-time asynchronous
+	 * load of a CSS properties database. This is then fed into the CssProperties
+	 * interface that provides synchronous methods for finding out what CSS
+	 * properties the current server supports.
+	 */
+	const CssPropertiesFront = FrontClassWithSpec(cssPropertiesSpec, {
+	  initialize: function (client, { cssPropertiesActor }) {
+	    Front.prototype.initialize.call(this, client, { actor: cssPropertiesActor });
+	    this.manage(this);
+	  }
+	});
+
+	/**
+	 * Ask questions to a CSS database. This class does not care how the database
+	 * gets loaded in, only the questions that you can ask to it.
+	 * Prototype functions are bound to 'this' so they can be passed around as helper
+	 * functions.
+	 *
+	 * @param {Object} db
+	 *                 A database of CSS properties
+	 * @param {Object} inheritedList
+	 *                 The key is the property name, the value is whether or not
+	 *                 that property is inherited.
+	 */
+	function CssProperties(db) {
+	  this.properties = db.properties;
+	  this.pseudoElements = db.pseudoElements;
+
+	  this.isKnown = this.isKnown.bind(this);
+	  this.isInherited = this.isInherited.bind(this);
+	  this.supportsType = this.supportsType.bind(this);
+	}
+
+	CssProperties.prototype = {
+	  /**
+	   * Checks to see if the property is known by the browser. This function has
+	   * `this` already bound so that it can be passed around by reference.
+	   *
+	   * @param {String} property The property name to be checked.
+	   * @return {Boolean}
+	   */
+	  isKnown(property) {
+	    return !!this.properties[property] || isCssVariable(property);
+	  },
+
+	  /**
+	   * Checks to see if the property is an inherited one.
+	   *
+	   * @param {String} property The property name to be checked.
+	   * @return {Boolean}
+	   */
+	  isInherited(property) {
+	    return this.properties[property] && this.properties[property].isInherited;
+	  },
+
+	  /**
+	   * Checks if the property supports the given CSS type.
+	   * CSS types should come from devtools/shared/css-properties-db.js' CSS_TYPES.
+	   *
+	   * @param {String} property The property to be checked.
+	   * @param {Number} type One of the type values from CSS_TYPES.
+	   * @return {Boolean}
+	   */
+	  supportsType(property, type) {
+	    return this.properties[property] && this.properties[property].supports.includes(type);
+	  },
+
+	  /**
+	   * Gets the CSS values for a given property name.
+	   *
+	   * @param {String} property The property to use.
+	   * @return {Array} An array of strings.
+	   */
+	  getValues(property) {
+	    return this.properties[property] ? this.properties[property].values : [];
+	  }
+	};
+
+	/**
+	 * Create a CssProperties object with a fully loaded CSS database. The
+	 * CssProperties interface can be queried synchronously, but the initialization
+	 * is potentially async and should be handled up-front when the tool is created.
+	 *
+	 * The front is returned only with this function so that it can be destroyed
+	 * once the toolbox is destroyed.
+	 *
+	 * @param {Toolbox} The current toolbox.
+	 * @returns {Promise} Resolves to {cssProperties, cssPropertiesFront}.
+	 */
+	const initCssProperties = Task.async(function* (toolbox) {
+	  const client = toolbox.target.client;
+	  if (cachedCssProperties.has(client)) {
+	    return cachedCssProperties.get(client);
+	  }
+
+	  let db, front;
+
+	  // Get the list dynamically if the cssProperties actor exists.
+	  if (toolbox.target.hasActor("cssProperties")) {
+	    front = CssPropertiesFront(client, toolbox.target.form);
+	    const serverDB = yield front.getCSSDatabase(getClientBrowserVersion(toolbox));
+
+	    // The serverDB will be blank if the browser versions match, so use the static list.
+	    if (!serverDB.properties && !serverDB.margin) {
+	      db = CSS_PROPERTIES_DB;
+	    } else {
+	      db = normalizeCssData(serverDB);
+	    }
+	  } else {
+	    // The target does not support this actor, so require a static list of supported
+	    // properties.
+	    db = CSS_PROPERTIES_DB;
+	  }
+
+	  // Color values are omitted to save on space. Add them back here.
+	  reattachCssColorValues(db);
+
+	  const cssProperties = new CssProperties(db);
+	  cachedCssProperties.set(client, { cssProperties, front });
+	  return { cssProperties, front };
+	});
+
+	/**
+	 * Synchronously get a cached and initialized CssProperties.
+	 *
+	 * @param {Toolbox} The current toolbox.
+	 * @returns {CssProperties}
+	 */
+	function getCssProperties(toolbox) {
+	  if (!cachedCssProperties.has(toolbox.target.client)) {
+	    throw new Error("The CSS database has not been initialized, please make " + "sure initCssDatabase was called once before for this " + "toolbox.");
+	  }
+	  return cachedCssProperties.get(toolbox.target.client).cssProperties;
+	}
+
+	/**
+	 * Get the current browser version.
+	 * @returns {string} The browser version.
+	 */
+	function getClientBrowserVersion(toolbox) {
+	  if (!toolbox._host) {
+	    return "0";
+	  }
+	  const regexResult = toolbox._host.frame.contentWindow.navigator.userAgent.match(/Firefox\/(\d+)\.\d/);
+	  return Array.isArray(regexResult) ? regexResult[1] : "0";
+	}
+
+	/**
+	 * Even if the target has the cssProperties actor, the returned data may not be in the
+	 * same shape or have all of the data we need. This normalizes this data.
+	 *
+	 * @return {Object} The normalized CSS database.
+	 */
+	function normalizeCssData(db) {
+	  // Firefox 49's getCSSDatabase() just returned the properties object, but
+	  // now it returns an object with multiple types of CSS information.
+	  if (!db.properties) {
+	    db = { properties: db };
+	  }
+
+	  // Fill in any missing DB information from the static database.
+	  db = Object.assign({}, CSS_PROPERTIES_DB, db);
+
+	  // Add "supports" information to the css properties if it's missing.
+	  if (!db.properties.color.supports) {
+	    for (let name in db.properties) {
+	      if (typeof CSS_PROPERTIES_DB.properties[name] === "object") {
+	        db.properties[name].supports = CSS_PROPERTIES_DB.properties[name].supports;
+	      }
+	    }
+	  }
+
+	  // Add "values" information to the css properties if it's missing.
+	  if (!db.properties.color.values) {
+	    for (let name in db.properties) {
+	      if (typeof CSS_PROPERTIES_DB.properties[name] === "object") {
+	        db.properties[name].values = CSS_PROPERTIES_DB.properties[name].values;
+	      }
+	    }
+	  }
+
+	  return db;
+	}
+
+	/**
+	 * Color values are omitted to save on space. Add them back here.
+	 * @param {Object} The CSS database.
+	 */
+	function reattachCssColorValues(db) {
+	  if (db.properties.color.values[0] === "COLOR") {
+	    const colors = Object.keys(cssColors);
+
+	    for (let name in db.properties) {
+	      const property = db.properties[name];
+	      if (property.values[0] === "COLOR") {
+	        property.values.shift();
+	        property.values = property.values.concat(colors).sort();
+	      }
+	    }
+	  }
+	}
+
+	module.exports = {
+	  CssPropertiesFront,
+	  CssProperties,
+	  getCssProperties,
+	  initCssProperties
+	};
+
+/***/ },
+
+/***/ 183:
+/***/ function(module, exports) {
+
+	"use strict";
+
+	module.exports = {
+	  ELEMENT_NODE: 1,
+	  ATTRIBUTE_NODE: 2,
+	  TEXT_NODE: 3,
+	  CDATA_SECTION_NODE: 4,
+	  ENTITY_REFERENCE_NODE: 5,
+	  ENTITY_NODE: 6,
+	  PROCESSING_INSTRUCTION_NODE: 7,
+	  COMMENT_NODE: 8,
+	  DOCUMENT_NODE: 9,
+	  DOCUMENT_TYPE_NODE: 10,
+	  DOCUMENT_FRAGMENT_NODE: 11,
+	  NOTATION_NODE: 12,
+
+	  // DocumentPosition
+	  DOCUMENT_POSITION_DISCONNECTED: 0x01,
+	  DOCUMENT_POSITION_PRECEDING: 0x02,
+	  DOCUMENT_POSITION_FOLLOWING: 0x04,
+	  DOCUMENT_POSITION_CONTAINS: 0x08,
+	  DOCUMENT_POSITION_CONTAINED_BY: 0x10,
+	  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: 0x20
+	};
+
+/***/ },
+
+/***/ 184:
+/***/ function(module, exports, __webpack_require__) {
+
+	/* This Source Code Form is subject to the terms of the Mozilla Public
+	 * License, v. 2.0. If a copy of the MPL was not distributed with this
+	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+	/**
+	 * Telemetry.
+	 *
+	 * To add metrics for a tool:
+	 *
+	 * 1. Create count, flag, and exponential entries in
+	 *    toolkit/components/telemetry/Histograms.json. Each type is optional but it
+	 *    is best if all three can be included.
+	 *
+	 * 2. Add your chart entries to devtools/client/shared/telemetry.js
+	 *    (Telemetry.prototype._histograms):
+	 *    mytoolname: {
+	 *      histogram: "DEVTOOLS_MYTOOLNAME_OPENED_COUNT",
+	 *      userHistogram: "DEVTOOLS_MYTOOLNAME_OPENED_PER_USER_FLAG",
+	 *      timerHistogram: "DEVTOOLS_MYTOOLNAME_TIME_ACTIVE_SECONDS"
+	 *    },
+	 *
+	 * 3. Include this module at the top of your tool. Use:
+	 *      let Telemetry = require("devtools/client/shared/telemetry")
+	 *
+	 * 4. Create a telemetry instance in your tool's constructor:
+	 *      this._telemetry = new Telemetry();
+	 *
+	 * 5. When your tool is opened call:
+	 *      this._telemetry.toolOpened("mytoolname");
+	 *
+	 * 6. When your tool is closed call:
+	 *      this._telemetry.toolClosed("mytoolname");
+	 *
+	 * Note:
+	 * You can view telemetry stats for your local Firefox instance via
+	 * about:telemetry.
+	 *
+	 * You can view telemetry stats for large groups of Firefox users at
+	 * telemetry.mozilla.org.
+	 */
+
+	"use strict";
+
+	var TOOLS_OPENED_PREF = "devtools.telemetry.tools.opened.version";
+
+	undefined.Telemetry = function () {
+	  // Bind pretty much all functions so that callers do not need to.
+	  this.toolOpened = this.toolOpened.bind(this);
+	  this.toolClosed = this.toolClosed.bind(this);
+	  this.log = this.log.bind(this);
+	  this.logOncePerBrowserVersion = this.logOncePerBrowserVersion.bind(this);
+	  this.destroy = this.destroy.bind(this);
+
+	  this._timers = new Map();
+	};
+
+	module.exports = Telemetry;
+
+	var Services = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"Services\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
+
+	Telemetry.prototype = {
+	  _histograms: {
+	    toolbox: {
+	      histogram: "DEVTOOLS_TOOLBOX_OPENED_COUNT",
+	      userHistogram: "DEVTOOLS_TOOLBOX_OPENED_PER_USER_FLAG",
+	      timerHistogram: "DEVTOOLS_TOOLBOX_TIME_ACTIVE_SECONDS"
+	    },
+	    options: {
+	      histogram: "DEVTOOLS_OPTIONS_OPENED_COUNT",
+	      userHistogram: "DEVTOOLS_OPTIONS_OPENED_PER_USER_FLAG",
+	      timerHistogram: "DEVTOOLS_OPTIONS_TIME_ACTIVE_SECONDS"
+	    },
+	    webconsole: {
+	      histogram: "DEVTOOLS_WEBCONSOLE_OPENED_COUNT",
+	      userHistogram: "DEVTOOLS_WEBCONSOLE_OPENED_PER_USER_FLAG",
+	      timerHistogram: "DEVTOOLS_WEBCONSOLE_TIME_ACTIVE_SECONDS"
+	    },
+	    browserconsole: {
+	      histogram: "DEVTOOLS_BROWSERCONSOLE_OPENED_COUNT",
+	      userHistogram: "DEVTOOLS_BROWSERCONSOLE_OPENED_PER_USER_FLAG",
+	      timerHistogram: "DEVTOOLS_BROWSERCONSOLE_TIME_ACTIVE_SECONDS"
+	    },
+	    inspector: {
+	      histogram: "DEVTOOLS_INSPECTOR_OPENED_COUNT",
+	      userHistogram: "DEVTOOLS_INSPECTOR_OPENED_PER_USER_FLAG",
+	      timerHistogram: "DEVTOOLS_INSPECTOR_TIME_ACTIVE_SECONDS"
+	    },
+	    ruleview: {
+	      histogram: "DEVTOOLS_RULEVIEW_OPENED_COUNT",
+	      userHistogram: "DEVTOOLS_RULEVIEW_OPENED_PER_USER_FLAG",
+	      timerHistogram: "DEVTOOLS_RULEVIEW_TIME_ACTIVE_SECONDS"
+	    },
+	    computedview: {
+	      histogram: "DEVTOOLS_COMPUTEDVIEW_OPENED_COUNT",
+	      userHistogram: "DEVTOOLS_COMPUTEDVIEW_OPENED_PER_USER_FLAG",
+	      timerHistogram: "DEVTOOLS_COMPUTEDVIEW_TIME_ACTIVE_SECONDS"
+	    },
+	    fontinspector: {
+	      histogram: "DEVTOOLS_FONTINSPECTOR_OPENED_COUNT",
+	      userHistogram: "DEVTOOLS_FONTINSPECTOR_OPENED_PER_USER_FLAG",
+	      timerHistogram: "DEVTOOLS_FONTINSPECTOR_TIME_ACTIVE_SECONDS"
+	    },
+	    animationinspector: {
+	      histogram: "DEVTOOLS_ANIMATIONINSPECTOR_OPENED_COUNT",
+	      userHistogram: "DEVTOOLS_ANIMATIONINSPECTOR_OPENED_PER_USER_FLAG",
+	      timerHistogram: "DEVTOOLS_ANIMATIONINSPECTOR_TIME_ACTIVE_SECONDS"
+	    },
+	    jsdebugger: {
+	      histogram: "DEVTOOLS_JSDEBUGGER_OPENED_COUNT",
+	      userHistogram: "DEVTOOLS_JSDEBUGGER_OPENED_PER_USER_FLAG",
+	      timerHistogram: "DEVTOOLS_JSDEBUGGER_TIME_ACTIVE_SECONDS"
+	    },
+	    jsbrowserdebugger: {
+	      histogram: "DEVTOOLS_JSBROWSERDEBUGGER_OPENED_COUNT",
+	      userHistogram: "DEVTOOLS_JSBROWSERDEBUGGER_OPENED_PER_USER_FLAG",
+	      timerHistogram: "DEVTOOLS_JSBROWSERDEBUGGER_TIME_ACTIVE_SECONDS"
+	    },
+	    styleeditor: {
+	      histogram: "DEVTOOLS_STYLEEDITOR_OPENED_COUNT",
+	      userHistogram: "DEVTOOLS_STYLEEDITOR_OPENED_PER_USER_FLAG",
+	      timerHistogram: "DEVTOOLS_STYLEEDITOR_TIME_ACTIVE_SECONDS"
+	    },
+	    shadereditor: {
+	      histogram: "DEVTOOLS_SHADEREDITOR_OPENED_COUNT",
+	      userHistogram: "DEVTOOLS_SHADEREDITOR_OPENED_PER_USER_FLAG",
+	      timerHistogram: "DEVTOOLS_SHADEREDITOR_TIME_ACTIVE_SECONDS"
+	    },
+	    webaudioeditor: {
+	      histogram: "DEVTOOLS_WEBAUDIOEDITOR_OPENED_COUNT",
+	      userHistogram: "DEVTOOLS_WEBAUDIOEDITOR_OPENED_PER_USER_FLAG",
+	      timerHistogram: "DEVTOOLS_WEBAUDIOEDITOR_TIME_ACTIVE_SECONDS"
+	    },
+	    canvasdebugger: {
+	      histogram: "DEVTOOLS_CANVASDEBUGGER_OPENED_COUNT",
+	      userHistogram: "DEVTOOLS_CANVASDEBUGGER_OPENED_PER_USER_FLAG",
+	      timerHistogram: "DEVTOOLS_CANVASDEBUGGER_TIME_ACTIVE_SECONDS"
+	    },
+	    performance: {
+	      histogram: "DEVTOOLS_JSPROFILER_OPENED_COUNT",
+	      userHistogram: "DEVTOOLS_JSPROFILER_OPENED_PER_USER_FLAG",
+	      timerHistogram: "DEVTOOLS_JSPROFILER_TIME_ACTIVE_SECONDS"
+	    },
+	    memory: {
+	      histogram: "DEVTOOLS_MEMORY_OPENED_COUNT",
+	      userHistogram: "DEVTOOLS_MEMORY_OPENED_PER_USER_FLAG",
+	      timerHistogram: "DEVTOOLS_MEMORY_TIME_ACTIVE_SECONDS"
+	    },
+	    netmonitor: {
+	      histogram: "DEVTOOLS_NETMONITOR_OPENED_COUNT",
+	      userHistogram: "DEVTOOLS_NETMONITOR_OPENED_PER_USER_FLAG",
+	      timerHistogram: "DEVTOOLS_NETMONITOR_TIME_ACTIVE_SECONDS"
+	    },
+	    storage: {
+	      histogram: "DEVTOOLS_STORAGE_OPENED_COUNT",
+	      userHistogram: "DEVTOOLS_STORAGE_OPENED_PER_USER_FLAG",
+	      timerHistogram: "DEVTOOLS_STORAGE_TIME_ACTIVE_SECONDS"
+	    },
+	    paintflashing: {
+	      histogram: "DEVTOOLS_PAINTFLASHING_OPENED_COUNT",
+	      userHistogram: "DEVTOOLS_PAINTFLASHING_OPENED_PER_USER_FLAG",
+	      timerHistogram: "DEVTOOLS_PAINTFLASHING_TIME_ACTIVE_SECONDS"
+	    },
+	    scratchpad: {
+	      histogram: "DEVTOOLS_SCRATCHPAD_OPENED_COUNT",
+	      userHistogram: "DEVTOOLS_SCRATCHPAD_OPENED_PER_USER_FLAG",
+	      timerHistogram: "DEVTOOLS_SCRATCHPAD_TIME_ACTIVE_SECONDS"
+	    },
+	    "scratchpad-window": {
+	      histogram: "DEVTOOLS_SCRATCHPAD_WINDOW_OPENED_COUNT",
+	      userHistogram: "DEVTOOLS_SCRATCHPAD_WINDOW_OPENED_PER_USER_FLAG",
+	      timerHistogram: "DEVTOOLS_SCRATCHPAD_WINDOW_TIME_ACTIVE_SECONDS"
+	    },
+	    responsive: {
+	      histogram: "DEVTOOLS_RESPONSIVE_OPENED_COUNT",
+	      userHistogram: "DEVTOOLS_RESPONSIVE_OPENED_PER_USER_FLAG",
+	      timerHistogram: "DEVTOOLS_RESPONSIVE_TIME_ACTIVE_SECONDS"
+	    },
+	    eyedropper: {
+	      histogram: "DEVTOOLS_EYEDROPPER_OPENED_COUNT",
+	      userHistogram: "DEVTOOLS_EYEDROPPER_OPENED_PER_USER_FLAG"
+	    },
+	    menueyedropper: {
+	      histogram: "DEVTOOLS_MENU_EYEDROPPER_OPENED_COUNT",
+	      userHistogram: "DEVTOOLS_MENU_EYEDROPPER_OPENED_PER_USER_FLAG"
+	    },
+	    pickereyedropper: {
+	      histogram: "DEVTOOLS_PICKER_EYEDROPPER_OPENED_COUNT",
+	      userHistogram: "DEVTOOLS_PICKER_EYEDROPPER_OPENED_PER_USER_FLAG"
+	    },
+	    toolbareyedropper: {
+	      histogram: "DEVTOOLS_TOOLBAR_EYEDROPPER_OPENED_COUNT",
+	      userHistogram: "DEVTOOLS_TOOLBAR_EYEDROPPER_OPENED_PER_USER_FLAG"
+	    },
+	    developertoolbar: {
+	      histogram: "DEVTOOLS_DEVELOPERTOOLBAR_OPENED_COUNT",
+	      userHistogram: "DEVTOOLS_DEVELOPERTOOLBAR_OPENED_PER_USER_FLAG",
+	      timerHistogram: "DEVTOOLS_DEVELOPERTOOLBAR_TIME_ACTIVE_SECONDS"
+	    },
+	    aboutdebugging: {
+	      histogram: "DEVTOOLS_ABOUTDEBUGGING_OPENED_COUNT",
+	      userHistogram: "DEVTOOLS_ABOUTDEBUGGING_OPENED_PER_USER_FLAG",
+	      timerHistogram: "DEVTOOLS_ABOUTDEBUGGING_TIME_ACTIVE_SECONDS"
+	    },
+	    webide: {
+	      histogram: "DEVTOOLS_WEBIDE_OPENED_COUNT",
+	      userHistogram: "DEVTOOLS_WEBIDE_OPENED_PER_USER_FLAG",
+	      timerHistogram: "DEVTOOLS_WEBIDE_TIME_ACTIVE_SECONDS"
+	    },
+	    webideProjectEditor: {
+	      histogram: "DEVTOOLS_WEBIDE_PROJECT_EDITOR_OPENED_COUNT",
+	      userHistogram: "DEVTOOLS_WEBIDE_PROJECT_EDITOR_OPENED_PER_USER_FLAG",
+	      timerHistogram: "DEVTOOLS_WEBIDE_PROJECT_EDITOR_TIME_ACTIVE_SECONDS"
+	    },
+	    webideProjectEditorSave: {
+	      histogram: "DEVTOOLS_WEBIDE_PROJECT_EDITOR_SAVE_COUNT",
+	      userHistogram: "DEVTOOLS_WEBIDE_PROJECT_EDITOR_SAVE_PER_USER_FLAG"
+	    },
+	    webideNewProject: {
+	      histogram: "DEVTOOLS_WEBIDE_NEW_PROJECT_COUNT",
+	      userHistogram: "DEVTOOLS_WEBIDE_NEW_PROJECT_PER_USER_FLAG"
+	    },
+	    webideImportProject: {
+	      histogram: "DEVTOOLS_WEBIDE_IMPORT_PROJECT_COUNT",
+	      userHistogram: "DEVTOOLS_WEBIDE_IMPORT_PROJECT_PER_USER_FLAG"
+	    },
+	    custom: {
+	      histogram: "DEVTOOLS_CUSTOM_OPENED_COUNT",
+	      userHistogram: "DEVTOOLS_CUSTOM_OPENED_PER_USER_FLAG",
+	      timerHistogram: "DEVTOOLS_CUSTOM_TIME_ACTIVE_SECONDS"
+	    },
+	    reloadAddonInstalled: {
+	      histogram: "DEVTOOLS_RELOAD_ADDON_INSTALLED_COUNT",
+	      userHistogram: "DEVTOOLS_RELOAD_ADDON_INSTALLED_PER_USER_FLAG"
+	    },
+	    reloadAddonReload: {
+	      histogram: "DEVTOOLS_RELOAD_ADDON_RELOAD_COUNT",
+	      userHistogram: "DEVTOOLS_RELOAD_ADDON_RELOAD_PER_USER_FLAG"
+	    }
+	  },
+
+	  /**
+	   * Add an entry to a histogram.
+	   *
+	   * @param  {String} id
+	   *         Used to look up the relevant histogram ID and log true to that
+	   *         histogram.
+	   */
+	  toolOpened: function toolOpened(id) {
+	    var charts = this._histograms[id] || this._histograms.custom;
+
+	    if (charts.histogram) {
+	      this.log(charts.histogram, true);
+	    }
+	    if (charts.userHistogram) {
+	      this.logOncePerBrowserVersion(charts.userHistogram, true);
+	    }
+	    if (charts.timerHistogram) {
+	      this.startTimer(charts.timerHistogram);
+	    }
+	  },
+
+	  /**
+	   * Record that an action occurred.  Aliases to `toolOpened`, so it's just for
+	   * readability at the call site for cases where we aren't actually opening
+	   * tools.
+	   */
+	  actionOccurred: function actionOccurred(id) {
+	    this.toolOpened(id);
+	  },
+
+
+	  toolClosed: function toolClosed(id) {
+	    var charts = this._histograms[id];
+
+	    if (!charts || !charts.timerHistogram) {
+	      return;
+	    }
+
+	    this.stopTimer(charts.timerHistogram);
+	  },
+
+	  /**
+	   * Record the start time for a timing-based histogram entry.
+	   *
+	   * @param String histogramId
+	   *        Histogram in which the data is to be stored.
+	   */
+	  startTimer: function startTimer(histogramId) {
+	    this._timers.set(histogramId, new Date());
+	  },
+
+	  /**
+	   * Stop the timer and log elasped time for a timing-based histogram entry.
+	   *
+	   * @param String histogramId
+	   *        Histogram in which the data is to be stored.
+	   * @param String key [optional]
+	   *        Optional key for a keyed histogram.
+	   */
+	  stopTimer: function stopTimer(histogramId, key) {
+	    var startTime = this._timers.get(histogramId);
+	    if (startTime) {
+	      var time = (new Date() - startTime) / 1000;
+	      if (!key) {
+	        this.log(histogramId, time);
+	      } else {
+	        this.logKeyed(histogramId, key, time);
+	      }
+	      this._timers.delete(histogramId);
+	    }
+	  },
+
+	  /**
+	   * Log a value to a histogram.
+	   *
+	   * @param  {String} histogramId
+	   *         Histogram in which the data is to be stored.
+	   * @param  value
+	   *         Value to store.
+	   */
+	  log: function log(histogramId, value) {
+	    if (histogramId) {
+	      try {
+	        var histogram = Services.telemetry.getHistogramById(histogramId);
+	        histogram.add(value);
+	      } catch (e) {
+	        dump("Warning: An attempt was made to write to the " + histogramId + " histogram, which is not defined in Histograms.json\n");
+	      }
+	    }
+	  },
+
+	  /**
+	   * Log a value to a keyed histogram.
+	   *
+	   * @param  {String} histogramId
+	   *         Histogram in which the data is to be stored.
+	   * @param  {String} key
+	   *         The key within the single histogram.
+	   * @param  value
+	   *         Value to store.
+	   */
+	  logKeyed: function logKeyed(histogramId, key, value) {
+	    if (histogramId) {
+	      try {
+	        var histogram = Services.telemetry.getKeyedHistogramById(histogramId);
+	        histogram.add(key, value);
+	      } catch (e) {
+	        dump("Warning: An attempt was made to write to the " + histogramId + " histogram, which is not defined in Histograms.json\n");
+	      }
+	    }
+	  },
+
+	  /**
+	   * Log info about usage once per browser version. This allows us to discover
+	   * how many individual users are using our tools for each browser version.
+	   *
+	   * @param  {String} perUserHistogram
+	   *         Histogram in which the data is to be stored.
+	   */
+	  logOncePerBrowserVersion: function logOncePerBrowserVersion(perUserHistogram, value) {
+	    var currentVersion = Services.appinfo.version;
+	    var latest = Services.prefs.getCharPref(TOOLS_OPENED_PREF);
+	    var latestObj = JSON.parse(latest);
+
+	    var lastVersionHistogramUpdated = latestObj[perUserHistogram];
+
+	    if (typeof lastVersionHistogramUpdated == "undefined" || lastVersionHistogramUpdated !== currentVersion) {
+	      latestObj[perUserHistogram] = currentVersion;
+	      latest = JSON.stringify(latestObj);
+	      Services.prefs.setCharPref(TOOLS_OPENED_PREF, latest);
+	      this.log(perUserHistogram, value);
+	    }
+	  },
+
+	  destroy: function destroy() {
+	    var _iteratorNormalCompletion = true;
+	    var _didIteratorError = false;
+	    var _iteratorError = undefined;
+
+	    try {
+	      for (var _iterator = this._timers.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
+	        var histogramId = _step.value;
+
+	        this.stopTimer(histogramId);
+	      }
+	    } catch (err) {
+	      _didIteratorError = true;
+	      _iteratorError = err;
+	    } finally {
+	      try {
+	        if (!_iteratorNormalCompletion && _iterator.return) {
+	          _iterator.return();
+	        }
+	      } finally {
+	        if (_didIteratorError) {
+	          throw _iteratorError;
+	        }
+	      }
+	    }
+	  }
+	};
+
+/***/ },
+
+/***/ 185:
+/***/ function(module, exports, __webpack_require__) {
+
+	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
+	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+	/* This Source Code Form is subject to the terms of the Mozilla Public
+	 * License, v. 2.0. If a copy of the MPL was not distributed with this
+	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+	"use strict";
+
+	var EventEmitter = __webpack_require__(3);
+
+	/**
+	 * A partial implementation of the Menu API provided by electron:
+	 * https://github.com/electron/electron/blob/master/docs/api/menu.md.
+	 *
+	 * Extra features:
+	 *  - Emits an 'open' and 'close' event when the menu is opened/closed
+
+	 * @param String id (non standard)
+	 *        Needed so tests can confirm the XUL implementation is working
+	 */
+	function Menu() {
+	  var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
+
+	  var _ref$id = _ref.id;
+	  var id = _ref$id === undefined ? null : _ref$id;
+
+	  this.menuitems = [];
+	  this.id = id;
+
+	  Object.defineProperty(this, "items", {
+	    get: function get() {
+	      return this.menuitems;
+	    }
+	  });
+
+	  EventEmitter.decorate(this);
+	}
+
+	/**
+	 * Add an item to the end of the Menu
+	 *
+	 * @param {MenuItem} menuItem
+	 */
+	Menu.prototype.append = function (menuItem) {
+	  this.menuitems.push(menuItem);
+	};
+
+	/**
+	 * Add an item to a specified position in the menu
+	 *
+	 * @param {int} pos
+	 * @param {MenuItem} menuItem
+	 */
+	Menu.prototype.insert = function (pos, menuItem) {
+	  throw Error("Not implemented");
+	};
+
+	/**
+	 * Show the Menu at a specified location on the screen
+	 *
+	 * Missing features:
+	 *   - browserWindow - BrowserWindow (optional) - Default is null.
+	 *   - positioningItem Number - (optional) OS X
+	 *
+	 * @param {int} screenX
+	 * @param {int} screenY
+	 * @param Toolbox toolbox (non standard)
+	 *        Needed so we in which window to inject XUL
+	 */
+	Menu.prototype.popup = function (screenX, screenY, toolbox) {
+	  var _this = this;
+
+	  var doc = toolbox.doc;
+	  var popupset = doc.querySelector("popupset");
+	  // See bug 1285229, on Windows, opening the same popup multiple times in a
+	  // row ends up duplicating the popup. The newly inserted popup doesn't
+	  // dismiss the old one. So remove any previously displayed popup before
+	  // opening a new one.
+	  var popup = popupset.querySelector("menupopup[menu-api=\"true\"]");
+	  if (popup) {
+	    popup.hidePopup();
+	  }
+
+	  popup = doc.createElement("menupopup");
+	  popup.setAttribute("menu-api", "true");
+
+	  if (this.id) {
+	    popup.id = this.id;
+	  }
+	  this._createMenuItems(popup);
+
+	  // Remove the menu from the DOM once it's hidden.
+	  popup.addEventListener("popuphidden", function (e) {
+	    if (e.target === popup) {
+	      popup.remove();
+	      _this.emit("close");
+	    }
+	  });
+
+	  popup.addEventListener("popupshown", function (e) {
+	    if (e.target === popup) {
+	      _this.emit("open");
+	    }
+	  });
+
+	  popupset.appendChild(popup);
+	  popup.openPopupAtScreen(screenX, screenY, true);
+	};
+
+	Menu.prototype._createMenuItems = function (parent) {
+	  var doc = parent.ownerDocument;
+	  this.menuitems.forEach(function (item) {
+	    if (!item.visible) {
+	      return;
+	    }
+
+	    if (item.submenu) {
+	      var menupopup = doc.createElement("menupopup");
+	      item.submenu._createMenuItems(menupopup);
+
+	      var menu = doc.createElement("menu");
+	      menu.appendChild(menupopup);
+	      menu.setAttribute("label", item.label);
+	      if (item.disabled) {
+	        menu.setAttribute("disabled", "true");
+	      }
+	      if (item.accesskey) {
+	        menu.setAttribute("accesskey", item.accesskey);
+	      }
+	      if (item.id) {
+	        menu.id = item.id;
+	      }
+	      parent.appendChild(menu);
+	    } else if (item.type === "separator") {
+	      var menusep = doc.createElement("menuseparator");
+	      parent.appendChild(menusep);
+	    } else {
+	      var menuitem = doc.createElement("menuitem");
+	      menuitem.setAttribute("label", item.label);
+	      menuitem.addEventListener("command", function () {
+	        item.click();
+	      });
+
+	      if (item.type === "checkbox") {
+	        menuitem.setAttribute("type", "checkbox");
+	      }
+	      if (item.type === "radio") {
+	        menuitem.setAttribute("type", "radio");
+	      }
+	      if (item.disabled) {
+	        menuitem.setAttribute("disabled", "true");
+	      }
+	      if (item.checked) {
+	        menuitem.setAttribute("checked", "true");
+	      }
+	      if (item.accesskey) {
+	        menuitem.setAttribute("accesskey", item.accesskey);
+	      }
+	      if (item.id) {
+	        menuitem.id = item.id;
+	      }
+
+	      parent.appendChild(menuitem);
+	    }
+	  });
+	};
+
+	Menu.setApplicationMenu = function () {
+	  throw Error("Not implemented");
+	};
+
+	Menu.sendActionToFirstResponder = function () {
+	  throw Error("Not implemented");
+	};
+
+	Menu.buildFromTemplate = function () {
+	  throw Error("Not implemented");
+	};
+
+	module.exports = Menu;
+
+/***/ },
+
+/***/ 186:
+/***/ function(module, exports) {
+
+	/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
+	/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+	/* This Source Code Form is subject to the terms of the Mozilla Public
+	 * License, v. 2.0. If a copy of the MPL was not distributed with this
+	 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+	"use strict";
+
+	/**
+	 * A partial implementation of the MenuItem API provided by electron:
+	 * https://github.com/electron/electron/blob/master/docs/api/menu-item.md.
+	 *
+	 * Missing features:
+	 *   - id String - Unique within a single menu. If defined then it can be used
+	 *                 as a reference to this item by the position attribute.
+	 *   - role String - Define the action of the menu item; when specified the
+	 *                   click property will be ignored
+	 *   - sublabel String
+	 *   - accelerator Accelerator
+	 *   - icon NativeImage
+	 *   - position String - This field allows fine-grained definition of the
+	 *                       specific location within a given menu.
+	 *
+	 * Implemented features:
+	 *  @param Object options
+	 *    Function click
+	 *      Will be called with click(menuItem, browserWindow) when the menu item
+	 *       is clicked
+	 *    String type
+	 *      Can be normal, separator, submenu, checkbox or radio
+	 *    String label
+	 *    Boolean enabled
+	 *      If false, the menu item will be greyed out and unclickable.
+	 *    Boolean checked
+	 *      Should only be specified for checkbox or radio type menu items.
+	 *    Menu submenu
+	 *      Should be specified for submenu type menu items. If submenu is specified,
+	 *      the type: 'submenu' can be omitted. If the value is not a Menu then it
+	 *      will be automatically converted to one using Menu.buildFromTemplate.
+	 *    Boolean visible
+	 *      If false, the menu item will be entirely hidden.
+	 */
+
+	function MenuItem() {
+	  var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
+
+	  var _ref$accesskey = _ref.accesskey;
+	  var accesskey = _ref$accesskey === undefined ? null : _ref$accesskey;
+	  var _ref$checked = _ref.checked;
+	  var checked = _ref$checked === undefined ? false : _ref$checked;
+	  var _ref$click = _ref.click;
+	  var click = _ref$click === undefined ? function () {} : _ref$click;
+	  var _ref$disabled = _ref.disabled;
+	  var disabled = _ref$disabled === undefined ? false : _ref$disabled;
+	  var _ref$label = _ref.label;
+	  var label = _ref$label === undefined ? "" : _ref$label;
+	  var _ref$id = _ref.id;
+	  var id = _ref$id === undefined ? null : _ref$id;
+	  var _ref$submenu = _ref.submenu;
+	  var submenu = _ref$submenu === undefined ? null : _ref$submenu;
+	  var _ref$type = _ref.type;
+	  var type = _ref$type === undefined ? "normal" : _ref$type;
+	  var _ref$visible = _ref.visible;
+	  var visible = _ref$visible === undefined ? true : _ref$visible;
+
+	  this.accesskey = accesskey;
+	  this.checked = checked;
+	  this.click = click;
+	  this.disabled = disabled;
+	  this.id = id;
+	  this.label = label;
+	  this.submenu = submenu;
+	  this.type = type;
+	  this.visible = visible;
+	}
+
+	module.exports = MenuItem;
+
+/***/ }
+
+/******/ });
\ No newline at end of file
diff --git a/devtools/client/inspector/simple.js b/devtools/client/inspector/simple.js
new file mode 100644
--- /dev/null
+++ b/devtools/client/inspector/simple.js
@@ -0,0 +1,2 @@
+
+alert("hi")
\ No newline at end of file
diff --git a/devtools/client/package.json b/devtools/client/package.json
new file mode 100644
--- /dev/null
+++ b/devtools/client/package.json
@@ -0,0 +1,21 @@
+{
+  "name": "inspector",
+  "version": "1.0.0",
+  "description": "",
+  "main": "inspector-panel.js",
+  "directories": {
+    "test": "test"
+  },
+  "scripts": {
+    "test": "echo \"Error: no test specified\" && exit 1",
+    "build": "webpack"
+  },
+  "author": "",
+  "license": "ISC",
+  "devDependencies": {
+    "babel-core": "^6.11.4",
+    "babel-loader": "^6.2.4",
+    "babel-preset-es2015": "^6.9.0",
+    "webpack": "^1.13.1"
+  }
+}
diff --git a/devtools/client/webpack.config.js b/devtools/client/webpack.config.js
new file mode 100644
--- /dev/null
+++ b/devtools/client/webpack.config.js
@@ -0,0 +1,28 @@
+
+"use strict";
+
+var path = require("path");
+
+module.exports = {
+  entry: './inspector/inspector-panel.js',
+  // entry: './simple.js',
+  output: {
+    path: path.join(__dirname, "inspector"),
+    filename: 'inspector.bundle.js',
+  },
+  module: {
+    loaders: [
+      { test: /\.js$/, exclude: /node_modules/, loader: "babel-loader", query: { compact: false } }
+    ]
+  },
+  resolve: {
+    alias: {
+      devtools: path.join(__dirname, "../"),
+      // Hardcode en-US for now
+      l10n: path.join(__dirname, "client", "locales", "en-US"),
+      // sdk: path.join(__dirname, "sdk"),
+      acorn: path.join(__dirname, "shared", "acorn"),
+    },
+  },
+  externals: ["sdk", "chrome"],
+};
