# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Date 1616017242 25200
#      Wed Mar 17 14:40:42 2021 -0700
# Node ID c00ea0d2790acade7c5cd694f5ba1acc32f2934c
# Parent  fae464444619a47c479b530d7ffd1fe12b06513f
POC reference browser - ui

This is just an experiment to discover dependencies for a minimal navigator:browser window

Differential Revision: https://phabricator.services.mozilla.com/D108856

diff --git a/browser/base/content/browser.js b/browser/base/content/browser.js
--- a/browser/base/content/browser.js
+++ b/browser/base/content/browser.js
@@ -657,6 +657,8 @@ async function gLazyFindCommand(cmd, ...
   }
 }
 
+/* Start copy into reference browser (minimal-browser.js) */
+
 var gPageIcons = {
   "about:home": "chrome://branding/content/icon32.png",
   "about:newtab": "chrome://branding/content/icon32.png",
@@ -704,6 +706,8 @@ var gNavigatorBundle = {
   },
 };
 
+/* End copy into reference browser (minimal-browser.js) */
+
 function updateFxaToolbarMenu(enable, isInitialUpdate = false) {
   // We only show the Firefox Account toolbar menu if the feature is enabled and
   // if sync is enabled.
@@ -2587,6 +2591,8 @@ gBrowserInit.idleTasksFinishedPromise = 
   gBrowserInit.idleTaskPromiseResolve = resolve;
 });
 
+/* Start copy into reference browser (minimal-browser.js) */
+
 function HandleAppCommandEvent(evt) {
   switch (evt.command) {
     case "Back":
@@ -3096,6 +3102,8 @@ function readFromClipboard() {
   return url;
 }
 
+/* End copy into reference browser (minimal-browser.js) */
+
 /**
  * Open the View Source dialog.
  *
@@ -4586,6 +4594,8 @@ function BrowserDownloadsUI() {
   }
 }
 
+/* Start copy into reference browser (minimal-browser.js) */
+
 function toOpenWindowByType(inType, uri, features) {
   var topWindow = Services.wm.getMostRecentWindow(inType);
 
@@ -4706,6 +4716,8 @@ function OpenBrowserWindow(options) {
   return win;
 }
 
+/* End copy into reference browser (minimal-browser.js) */
+
 /**
  * Update the global flag that tracks whether or not any edit UI (the Edit menu,
  * edit-related items in the context menu, and edit-related toolbar buttons
@@ -5830,6 +5842,8 @@ var TabsProgressListener = {
   },
 };
 
+/* Start copy into reference browser (minimal-browser.js) */
+
 function nsBrowserAccess() {}
 
 nsBrowserAccess.prototype = {
@@ -6188,6 +6202,8 @@ nsBrowserAccess.prototype = {
   },
 };
 
+/* End copy into reference browser (minimal-browser.js) */
+
 function onViewToolbarsPopupShowing(aEvent, aInsertPoint) {
   var popup = aEvent.target;
   if (popup != aEvent.currentTarget) {
@@ -7808,6 +7824,8 @@ var WebAuthnPromptHelper = {
   },
 };
 
+/* Start copy into reference browser (minimal-browser.js) */
+
 function CanCloseWindow() {
   // Avoid redundant calls to canClose from showing multiple
   // PermitUnload dialogs.
@@ -7928,6 +7946,7 @@ function warnAboutClosingWindow() {
     gBrowser.warnAboutClosingTabs(closingTabs, gBrowser.closingTabsEnum.ALL)
   );
 }
+/* End copy into reference browser (minimal-browser.js) */
 
 var MailIntegration = {
   sendLinkForBrowser(aBrowser) {
diff --git a/browser/moz.build b/browser/moz.build
--- a/browser/moz.build
+++ b/browser/moz.build
@@ -21,6 +21,7 @@ DIRS += [
     "locales",
     "modules",
     "themes",
+    "tools/geckoreference",
     "extensions",
 ]
 
diff --git a/browser/tools/geckoreference/content/geckoreference.css b/browser/tools/geckoreference/content/geckoreference.css
new file mode 100644
--- /dev/null
+++ b/browser/tools/geckoreference/content/geckoreference.css
@@ -0,0 +1,97 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+ 
+html {
+  appearance: auto;
+  --reference-bg: rgb(255, 255, 255);
+  background: var(--reference-bg);
+  -moz-default-appearance: dialog;
+  background-color: var(--reference-bg);
+  color: black;
+}
+
+body, html {
+  height: 100vh;
+  margin: 0;
+  padding: 0;
+  overflow: hidden;
+}
+
+body {
+  --toolbar-bgcolor: #fbfbfb;
+  --toolbar-border: #b5b5b5;
+  --toolbar-hover: #ebebeb;
+  --popup-bgcolor: #fbfbfb;
+  --popup-border: #b5b5b5;
+  --font-color: #4c4c4c;
+  --icon-fill: #808080;
+  --icon-disabled-fill: #8080807F;
+  /* light colours */
+}
+
+body.dark {
+  --toolbar-bgcolor: #2a2a2d;
+  --toolbar-border: #4B4A50;
+  --toolbar-hover: #737373;
+  --popup-bgcolor: #4b4a50;
+  --popup-border: #65646a;
+  --font-color: #fff;
+  --icon-fill: #fff;
+  --icon-disabled-fill: #ffffff66;
+  /* dark colours */
+}
+
+body {
+  display: grid;
+  grid-template-rows: auto auto minmax(0, 1fr) auto;
+  padding: 3px;
+}
+
+body:not(.has-url) .when-url {
+  display: none;
+}
+body.has-url .when-no-url {
+  display: none;
+}
+
+header {
+  display: grid;
+  grid-template-columns: auto auto auto minmax(0, 1fr) auto auto;
+  height: 32px;
+  position: relative;
+}
+body button {
+  margin: 0;
+} 
+main {
+  display: grid;
+  position: relative;
+  font-weight: bold;
+  margin-top: 3px;
+}
+main label {
+  grid-area: 1 / 1;
+  align-self: center;
+  justify-self: center;
+}
+main #browser-container {
+  grid-area: 1 / 1;
+  align-self: stretch;
+  justify-self: stretch;
+}
+
+main browser {
+  width: 100%;
+  height: 100%;
+
+  /* Macos */
+  border-bottom-left-radius: 7px;
+  border-bottom-right-radius: 7px;
+}
+
+footer {
+  display: grid;
+  grid-template-columns: 1fr 1fr 1fr 1fr;
+}
diff --git a/browser/tools/geckoreference/content/geckoreference.js b/browser/tools/geckoreference/content/geckoreference.js
new file mode 100644
--- /dev/null
+++ b/browser/tools/geckoreference/content/geckoreference.js
@@ -0,0 +1,1022 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+// These come from utilityOverlay.js
+/* global BrowserWindowTracker, BrowserUtils */
+/* global gBrowser, gBrowserInit */
+
+console.log("Hello from reference");
+
+var { XPCOMUtils } = ChromeUtils.import(
+  "resource://gre/modules/XPCOMUtils.jsm"
+);
+var { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm");
+var { AppConstants } = ChromeUtils.import(
+  "resource://gre/modules/AppConstants.jsm"
+);
+
+XPCOMUtils.defineLazyModuleGetters(this, {
+  PromiseUtils: "resource://gre/modules/PromiseUtils.jsm",
+});
+
+window.gBrowser = {
+  tabContainer: document.documentElement,
+  _referenceBrowser: null,
+  _selectedTab: null,
+  mProgressListeners: [],
+  mTabsProgressListeners: [],
+  browsers: [],
+  init() {
+    this._referenceBrowser = document.createXULElement("browser");
+    // todo contextmenu="contentAreaContextMenu"
+    // todo tooltip="aHTMLTooltip"
+    // todo selectmenulist="ContentSelectDropdown remote="true" autocompletepopup="PopupAutoComplete"
+
+    this._referenceBrowser.setAttribute("maychangeremoteness", "true");
+    this._referenceBrowser.setAttribute("message", "true");
+    this._referenceBrowser.setAttribute("messagemanagergroup", "browsers");
+    this._referenceBrowser.setAttribute("type", "content");
+    // this._referenceBrowser.setAttribute("initiallyactive", "false");
+    this._referenceBrowser.setAttribute("primary", "true");
+
+    document.querySelector("#browser-container").append(this._referenceBrowser);
+
+    this._referenceTab = document.createElement("div");
+    this._referenceTab.linkedBrowser = this._referenceBrowser;
+  },
+  get selectedBrowser() {
+    return this._referenceBrowser;
+  },
+  get selectedTab() {
+    return this._referenceTab;
+  },
+  get tabs() {
+    return [this.selectedTab];
+  },
+  getTabForBrowser(browser) {
+    return this.selectedTab;
+  },
+  get currentURI() {
+    return this.selectedBrowser.currentURI;
+  },
+  get userTypedValue() {},
+  set userTypedValue(val) {},
+  removeTab() {
+    this.removeCurrentTab();
+  },
+  removeCurrentTab() {
+    window.close();
+  },
+  announceWindowCreated() {},
+  setPageInfo() {},
+
+  /**
+   * BEGIN FORWARDED BROWSER PROPERTIES.  IF YOU ADD A PROPERTY TO THE BROWSER ELEMENT
+   * MAKE SURE TO ADD IT HERE AS WELL.
+   */
+  get canGoBack() {
+    return this.selectedBrowser.canGoBack;
+  },
+
+  get canGoForward() {
+    return this.selectedBrowser.canGoForward;
+  },
+
+  goBack(requireUserInteraction) {
+    return this.selectedBrowser.goBack(requireUserInteraction);
+  },
+
+  goForward(requireUserInteraction) {
+    return this.selectedBrowser.goForward(requireUserInteraction);
+  },
+
+  reload() {
+    return this.selectedBrowser.reload();
+  },
+
+  reloadWithFlags(aFlags) {
+    return this.selectedBrowser.reloadWithFlags(aFlags);
+  },
+
+  stop() {
+    return this.selectedBrowser.stop();
+  },
+
+  addProgressListener(aListener) {
+    if (arguments.length != 1) {
+      Cu.reportError(
+        "gBrowser.addProgressListener was " +
+          "called with a second argument, " +
+          "which is not supported. See bug " +
+          "608628. Call stack: " +
+          new Error().stack
+      );
+    }
+
+    this.mProgressListeners.push(aListener);
+  },
+
+  removeProgressListener(aListener) {
+    this.mProgressListeners = this.mProgressListeners.filter(
+      l => l != aListener
+    );
+  },
+
+  addTabsProgressListener(aListener) {
+    this.mTabsProgressListeners.push(aListener);
+  },
+
+  removeTabsProgressListener(aListener) {
+    this.mTabsProgressListeners = this.mTabsProgressListeners.filter(
+      l => l != aListener
+    );
+  },
+};
+
+var TabsProgressListener = {
+  onStateChange(aBrowser, aWebProgress, aRequest, aStateFlags, aStatus) {},
+
+  onLocationChange(aBrowser, aWebProgress, aRequest, aLocationURI, aFlags) {},
+
+  onLinkIconAvailable(browser, dataURI, iconURI) {},
+};
+
+window.gBrowserInit = {
+  onLoad() {},
+  onDOMContentLoaded() {
+    window.docShell.treeOwner
+      .QueryInterface(Ci.nsIInterfaceRequestor)
+      .getInterface(Ci.nsIAppWindow).XULBrowserWindow = window.XULBrowserWindow;
+    // hook up UI through progress listener
+    // gBrowser.addProgressListener(window.XULBrowserWindow);
+    // gBrowser.addTabsProgressListener(window.TabsProgressListener);
+    gBrowser.init();
+
+    // todo browser events like securitychange
+    document.querySelector("#back").addEventListener("click", () => {
+      gBrowser.goBack();
+    });
+    document.querySelector("#forward").addEventListener("click", () => {
+      gBrowser.goForward();
+    });
+    document.querySelector("#reload").addEventListener("click", () => {
+      gBrowser.reload();
+    });
+    document.querySelector("#go").addEventListener("click", loadURI);
+    document.querySelector("#url").addEventListener("change", loadURI);
+    document.querySelector("#url").addEventListener("keydown", e => {
+      if (e.keyCode == 13) {
+        loadURI();
+      }
+    });
+  },
+  onUnload() {
+    try {
+      gBrowser.removeProgressListener(window.XULBrowserWindow);
+      gBrowser.removeTabsProgressListener(window.TabsProgressListener);
+    } catch (ex) {}
+  },
+  getTabToAdopt() {},
+};
+
+XPCOMUtils.defineLazyGetter(
+  gBrowserInit,
+  "_firstContentWindowPaintDeferred",
+  () => PromiseUtils.defer()
+);
+var XULBrowserWindow = {
+  // Stored Status, Link and Loading values
+  status: "",
+  defaultStatus: "",
+  overLink: "",
+  startTime: 0,
+  isBusy: false,
+  busyUI: false,
+
+  QueryInterface: ChromeUtils.generateQI([
+    "nsIWebProgressListener",
+    "nsIWebProgressListener2",
+    "nsISupportsWeakReference",
+    "nsIXULBrowserWindow",
+  ]),
+
+  get stopCommand() {
+    delete this.stopCommand;
+    return (this.stopCommand = document.getElementById("Browser:Stop"));
+  },
+  get reloadCommand() {
+    delete this.reloadCommand;
+    return (this.reloadCommand = document.getElementById("Browser:Reload"));
+  },
+
+  setDefaultStatus(status) {},
+
+  setOverLink(url) {},
+
+  showTooltip(x, y, tooltip, direction, browser) {},
+
+  hideTooltip() {},
+
+  getTabCount() {
+    return gBrowser.tabs.length;
+  },
+
+  // Called before links are navigated to to allow us to retarget them if needed.
+  onBeforeLinkTraversal(originalTarget, linkURI, linkNode, isAppTab) {
+    return BrowserUtils.onBeforeLinkTraversal(
+      originalTarget,
+      linkURI,
+      linkNode,
+      isAppTab
+    );
+  },
+
+  onProgressChange(
+    aWebProgress,
+    aRequest,
+    aCurSelfProgress,
+    aMaxSelfProgress,
+    aCurTotalProgress,
+    aMaxTotalProgress
+  ) {
+    // Do nothing.
+  },
+
+  onProgressChange64(
+    aWebProgress,
+    aRequest,
+    aCurSelfProgress,
+    aMaxSelfProgress,
+    aCurTotalProgress,
+    aMaxTotalProgress
+  ) {
+    return this.onProgressChange(
+      aWebProgress,
+      aRequest,
+      aCurSelfProgress,
+      aMaxSelfProgress,
+      aCurTotalProgress,
+      aMaxTotalProgress
+    );
+  },
+
+  // This function fires only for the currently selected tab.
+  onStateChange(aWebProgress, aRequest, aStateFlags, aStatus) {
+    console.trace();
+  },
+
+  /**
+   * An nsIWebProgressListener method called by tabbrowser.  The `aIsSimulated`
+   * parameter is extra and not declared in nsIWebProgressListener, however; see
+   * below.
+   *
+   * @param {nsIWebProgress} aWebProgress
+   *   The nsIWebProgress instance that fired the notification.
+   * @param {nsIRequest} aRequest
+   *   The associated nsIRequest.  This may be null in some cases.
+   * @param {nsIURI} aLocationURI
+   *   The URI of the location that is being loaded.
+   * @param {integer} aFlags
+   *   Flags that indicate the reason the location changed.  See the
+   *   nsIWebProgressListener.LOCATION_CHANGE_* values.
+   * @param {boolean} aIsSimulated
+   *   True when this is called by tabbrowser due to switching tabs and
+   *   undefined otherwise.  This parameter is not declared in
+   *   nsIWebProgressListener.onLocationChange; see bug 1478348.
+   */
+  onLocationChange(aWebProgress, aRequest, aLocationURI, aFlags, aIsSimulated) {
+    console.trace();
+  },
+
+  asyncUpdateUI() {},
+
+  onStatusChange(aWebProgress, aRequest, aStatus, aMessage) {},
+
+  // Properties used to cache security state used to update the UI
+  _state: null,
+  _lastLocation: null,
+  _event: null,
+  _lastLocationForEvent: null,
+  // _isSecureContext can change without the state/location changing, due to security
+  // error pages that intercept certain loads. For example this happens sometimes
+  // with the the HTTPS-Only Mode error page (more details in bug 1656027)
+  _isSecureContext: null,
+
+  // This is called in multiple ways:
+  //  1. Due to the nsIWebProgressListener.onContentBlockingEvent notification.
+  //  2. Called by tabbrowser.xml when updating the current browser.
+  //  3. Called directly during this object's initializations.
+  //  4. Due to the nsIWebProgressListener.onLocationChange notification.
+  // aRequest will be null always in case 2 and 3, and sometimes in case 1 (for
+  // instance, there won't be a request when STATE_BLOCKED_TRACKING_CONTENT or
+  // other blocking events are observed).
+  onContentBlockingEvent(aWebProgress, aRequest, aEvent, aIsSimulated) {},
+
+  // This is called in multiple ways:
+  //  1. Due to the nsIWebProgressListener.onSecurityChange notification.
+  //  2. Called by tabbrowser.xml when updating the current browser.
+  //  3. Called directly during this object's initializations.
+  // aRequest will be null always in case 2 and 3, and sometimes in case 1.
+  onSecurityChange(aWebProgress, aRequest, aState, aIsSimulated) {},
+
+  // simulate all change notifications after switching tabs
+  onUpdateCurrentBrowser: function XWB_onUpdateCurrentBrowser(
+    aStateFlags,
+    aStatus,
+    aMessage,
+    aTotalProgress
+  ) {},
+};
+
+function loadURI() {
+  let val = document.querySelector("#url").value;
+  gBrowser.selectedBrowser.setAttribute("src", val);
+  document.body.classList.add("has-url");
+}
+
+window.addEventListener(
+  "DOMContentLoaded",
+  () => {
+    gBrowserInit.onDOMContentLoaded();
+  },
+  { once: true }
+);
+window.onload = gBrowserInit.onLoad.bind(gBrowserInit);
+window.onunload = gBrowserInit.onUnload.bind(gBrowserInit);
+
+// TODO: Here's the API surface for gBrowser:
+
+// window.gBrowser = {
+//     init() {},
+
+//     ownerGlobal: window,
+//     ownerDocument: document,
+//     closingTabsEnum: {
+//       ALL: 0,
+//       OTHER: 1,
+//       TO_START: 2,
+//       TO_END: 3,
+//       MULTI_SELECTED: 4
+//     },
+//     _visibleTabs: null,
+//     _tabs: null,
+//     _lastRelatedTabMap: new WeakMap(),
+//     mProgressListeners: [],
+//     mTabsProgressListeners: [],
+//     _tabListeners: new Map(),
+//     _tabFilters: new Map(),
+//     _isBusy: false,
+//     arrowKeysShouldWrap: AppConstants == "macosx",
+//     _dateTimePicker: null,
+//     _previewMode: false,
+//     _lastFindValue: "",
+//     _contentWaitingCount: 0,
+//     _tabLayerCache: [],
+//     tabAnimationsInProgress: 0,
+
+//      _tabForBrowser: new WeakMap(),
+//      _browserBindingProperties: ["canGoBack", "canGoForward", "goBack", "goForward", "permitUnload", "reload", "reloadWithFlags", "stop", "loadURI", "gotoIndex", "currentURI", "documentURI", "remoteType", "preferences", "imageDocument", "isRemoteBrowser", "messageManager", "getTabBrowser", "finder", "fastFind", "sessionHistory", "contentTitle", "characterSet", "fullZoom", "textZoom", "tabHasCustomZoom", "webProgress", "addProgressListener", "removeProgressListener", "audioPlaybackStarted", "audioPlaybackStopped", "resumeMedia", "mute", "unmute", "blockedPopups", "lastURI", "purgeSessionHistory", "stopScroll", "startScroll", "userTypedValue", "userTypedClear", "didStartLoadSinceLastUserTyping", "audioMuted"],
+//      _removingTabs: [],
+//      _multiSelectedTabsSet: new WeakSet(),
+//      _lastMultiSelectedTabRef: null,
+//      _clearMultiSelectionLocked: false,
+//      _clearMultiSelectionLockedOnce: false,
+//      _multiSelectChangeStarted: false,
+//      _multiSelectChangeAdditions: new Set(),
+//      _multiSelectChangeRemovals: new Set(),
+//      _multiSelectChangeSelected: false,
+//      _windowIsClosing: false,
+//      preloadedBrowser: null,
+
+//      /**
+//       * This defines a proxy which allows us to access browsers by
+//       * index without actually creating a full array of browsers.
+//       */
+//      browsers: new Proxy([], {
+//        has: (target, name) => {},
+//        get: (target, name) => {}
+//      }),
+
+//      /**
+//       * List of browsers whose docshells must be active in order for print preview
+//       * to work.
+//       */
+//      _printPreviewBrowsers: new Set(),
+//      _switcher: null,
+//      _soundPlayingAttrRemovalTimer: 0,
+//      _hoverTabTimer: null,
+
+//      get tabContainer() {},
+
+//      get tabs() {},
+
+//      get tabbox() {},
+
+//      get tabpanels() {},
+
+//      addEventListener(...args) {},
+
+//      removeEventListener(...args) {},
+
+//      dispatchEvent(...args) {},
+
+//      get visibleTabs() {},
+
+//      get _numPinnedTabs() {},
+
+//      set selectedTab(val) {},
+
+//      get selectedTab() {},
+
+//      get selectedBrowser() {},
+
+//      _setupInitialBrowserAndTab() {},
+
+//      /**
+//       * BEGIN FORWARDED BROWSER PROPERTIES.  IF YOU ADD A PROPERTY TO THE BROWSER ELEMENT
+//       * MAKE SURE TO ADD IT HERE AS WELL.
+//       */
+//      get canGoBack() {},
+
+//      get canGoForward() {},
+
+//      goBack(requireUserInteraction) {},
+
+//      goForward(requireUserInteraction) {},
+
+//      reload() {},
+
+//      reloadWithFlags(aFlags) {},
+
+//      stop() {},
+
+//      /**
+//       * throws exception for unknown schemes
+//       */
+//      loadURI(aURI, aParams) {},
+
+//      gotoIndex(aIndex) {},
+
+//      get currentURI() {},
+
+//      get finder() {},
+
+//      get docShell() {},
+
+//      get webNavigation() {},
+
+//      get webProgress() {},
+
+//      get contentWindow() {},
+
+//      get sessionHistory() {},
+
+//      get markupDocumentViewer() {},
+
+//      get contentDocument() {},
+
+//      get contentTitle() {},
+
+//      get contentPrincipal() {},
+
+//      get securityUI() {},
+
+//      set fullZoom(val) {},
+
+//      get fullZoom() {},
+
+//      set textZoom(val) {},
+
+//      get textZoom() {},
+
+//      get isSyntheticDocument() {},
+
+//      set userTypedValue(val) {},
+
+//      get userTypedValue() {},
+
+//      _invalidateCachedTabs() {},
+
+//      _setFindbarData() {},
+
+//      isFindBarInitialized(aTab) {},
+
+//      /**
+//       * Get the already constructed findbar
+//       */
+//      getCachedFindBar(aTab = this.selectedTab) {},
+
+//      /**
+//       * Get the findbar, and create it if it doesn't exist.
+//       * @return the find bar (or null if the window or tab is closed/closing in the interim).
+//       */
+//      async getFindBar(aTab = this.selectedTab) {},
+
+//      /**
+//       * Create a findbar instance.
+//       * @param aTab the tab to create the find bar for.
+//       * @return the created findbar, or null if the window or tab is closed/closing.
+//       */
+//      async _createFindBar(aTab) {},
+
+//      _appendStatusPanel() {},
+
+//      _updateTabBarForPinnedTabs() {},
+
+//      _notifyPinnedStatus(aTab) {},
+
+//      pinTab(aTab) {},
+
+//      unpinTab(aTab) {},
+
+//      previewTab(aTab, aCallback) {},
+
+//      _getAndMaybeCreateDateTimePickerPanel() {},
+
+//      syncThrobberAnimations(aTab) {},
+
+//      getBrowserAtIndex(aIndex) {},
+
+//      getBrowserForOuterWindowID(aID) {},
+
+//      getTabForBrowser(aBrowser) {},
+
+//      getPanel(aBrowser) {},
+
+//      getBrowserContainer(aBrowser) {},
+
+//      getNotificationBox(aBrowser) {},
+
+//      getTabModalPromptBox(aBrowser) {},
+
+//      getTabDialogBox(aBrowser) {},
+
+//      getTabFromAudioEvent(aEvent) {},
+
+//      _callProgressListeners(aBrowser, aMethod, aArguments, aCallGlobalListeners = true, aCallTabsListeners = true) {},
+
+//      /**
+//       * Sets an icon for the tab if the URI is defined in FAVICON_DEFAULTS.
+//       */
+//      setDefaultIcon(aTab, aURI) {},
+
+//      setIcon(aTab, aIconURL = "", aOriginalURL = aIconURL, aLoadingPrincipal = null) {},
+
+//      getIcon(aTab) {},
+
+//      setPageInfo(aURL, aDescription, aPreviewImage) {},
+
+//      getWindowTitleForBrowser(aBrowser) {},
+
+//      updateTitlebar() {},
+
+//      updateCurrentBrowser(aForceUpdate) {},
+
+//      _adjustFocusBeforeTabSwitch(oldTab, newTab) {},
+
+//      _adjustFocusAfterTabSwitch(newTab) {},
+
+//      _tabAttrModified(aTab, aChanged) {},
+
+//      resetBrowserSharing(aBrowser) {},
+
+//      updateBrowserSharing(aBrowser, aState) {},
+
+//      getTabSharingState(aTab) {},
+
+//      setInitialTabTitle(aTab, aTitle, aOptions = {}) {},
+
+//      setTabTitle(aTab) {},
+
+//      _setTabLabel(aTab, aLabel, {
+//        beforeTabOpen,
+//        isContentTitle
+//      } = {}) {},
+
+//      loadOneTab(aURI, aReferrerInfoOrParams, aCharset, aPostData, aLoadInBackground, aAllowThirdPartyFixup) {},
+
+//      loadTabs(aURIs, {
+//        allowInheritPrincipal,
+//        allowThirdPartyFixup,
+//        inBackground,
+//        newIndex,
+//        postDatas,
+//        replace,
+//        targetTab,
+//        triggeringPrincipal,
+//        csp,
+//        userContextId,
+//        fromExternal
+//      } = {}) {},
+
+//      updateBrowserRemoteness(aBrowser, {
+//        newFrameloader,
+//        remoteType
+//      } = {}) {},
+
+//      updateBrowserRemotenessByURL(aBrowser, aURL, aOptions = {}) {},
+
+//      createBrowser({
+//        isPreloadBrowser,
+//        name,
+//        openWindowInfo,
+//        remoteType,
+//        initialBrowsingContextGroupId,
+//        uriIsAboutBlank,
+//        userContextId,
+//        skipLoad,
+//        initiallyActive
+//      } = {}) {},
+
+//      _createLazyBrowser(aTab) {},
+
+//      _insertBrowser(aTab, aInsertedOnTabCreation) {
+//        "use strict"; // If browser is already inserted or window is closed don't do anything.
+//      },
+
+//      _mayDiscardBrowser(aTab, aForceDiscard) {},
+
+//      discardBrowser(aTab, aForceDiscard) {
+//        "use strict";
+//      },
+
+//      /**
+//       * Loads a tab with a default null principal unless specified
+//       */
+//      addWebTab(aURI, params = {}) {},
+
+//      /**
+//       * Must only be used sparingly for content that came from Chrome context
+//       * If in doubt use addWebTab
+//       */
+//      addTrustedTab(aURI, params = {}) {},
+
+//      // eslint-disable-next-line complexity
+//      addTab(aURI, {
+//        allowInheritPrincipal,
+//        allowMixedContent,
+//        allowThirdPartyFixup,
+//        bulkOrderedOpen,
+//        charset,
+//        createLazyBrowser,
+//        disableTRR,
+//        eventDetail,
+//        focusUrlBar,
+//        forceNotRemote,
+//        fromExternal,
+//        index,
+//        lazyTabTitle,
+//        name,
+//        noInitialLabel,
+//        openWindowInfo,
+//        openerBrowser,
+//        originPrincipal,
+//        originStoragePrincipal,
+//        ownerTab,
+//        pinned,
+//        postData,
+//        preferredRemoteType,
+//        referrerInfo,
+//        relatedToCurrent,
+//        initialBrowsingContextGroupId,
+//        skipAnimation,
+//        skipBackgroundNotify,
+//        triggeringPrincipal,
+//        userContextId,
+//        csp,
+//        skipLoad,
+//        batchInsertingTabs
+//      } = {}) {},
+
+//      addMultipleTabs(restoreTabsLazily, selectTab, aPropertiesTabs) {},
+
+//      moveTabsToStart(contextTab) {},
+
+//      moveTabsToEnd(contextTab) {},
+
+//      warnAboutClosingTabs(tabsToClose, aCloseTabs) {},
+
+//      /**
+//       * This determines where the tab should be inserted within the tabContainer
+//       */
+//      _insertTabAtIndex(tab, {
+//        index,
+//        ownerTab,
+//        openerTab,
+//        pinned,
+//        bulkOrderedOpen
+//      } = {}) {},
+
+//      /**
+//       * Dispatch a new tab event. This should be called when things are in a
+//       * consistent state, such that listeners of this event can again open
+//       * or close tabs.
+//       */
+//      _fireTabOpen(tab, eventDetail) {},
+
+//      getTabsToTheStartFrom(aTab) {},
+
+//      getTabsToTheEndFrom(aTab) {},
+
+//      /**
+//       * In a multi-select context, the tabs (except pinned tabs) that are located to the
+//       * left of the leftmost selected tab will be removed.
+//       */
+//      removeTabsToTheStartFrom(aTab) {},
+
+//      /**
+//       * In a multi-select context, the tabs (except pinned tabs) that are located to the
+//       * right of the rightmost selected tab will be removed.
+//       */
+//      removeTabsToTheEndFrom(aTab) {},
+
+//      /**
+//       * In a multi-select context, all unpinned and unselected tabs are removed.
+//       * Otherwise all unpinned tabs except aTab are removed.
+//       */
+//      removeAllTabsBut(aTab) {},
+
+//      removeMultiSelectedTabs() {},
+
+//      removeTabs(tabs, {
+//        animate = true,
+//        suppressWarnAboutClosingWindow = false
+//      } = {}) {},
+
+//      removeCurrentTab(aParams) {},
+
+//      removeTab(aTab, {
+//        animate,
+//        byMouse,
+//        skipPermitUnload,
+//        closeWindowWithLastTab,
+//        prewarmed
+//      } = {}) {},
+
+//      _hasBeforeUnload(aTab) {},
+
+//      _beginRemoveTab(aTab, {
+//        adoptedByTab,
+//        closeWindowWithLastTab,
+//        closeWindowFastpath,
+//        skipPermitUnload,
+//        prewarmed
+//      } = {}) {},
+
+//      _endRemoveTab(aTab) {},
+
+//      /**
+//       * Finds the tab that we will blur to if we blur aTab.
+//       * @param   aTab
+//       *          The tab we would blur
+//       * @param   aExcludeTabs
+//       *          Tabs to exclude from our search (i.e., because they are being
+//       *          closed along with aTab)
+//       */
+//      _findTabToBlurTo(aTab, aExcludeTabs = []) {},
+
+//      _blurTab(aTab) {},
+
+//      /**
+//       * @returns {boolean}
+//       *   False if swapping isn't permitted, true otherwise.
+//       */
+//      swapBrowsersAndCloseOther(aOurTab, aOtherTab) {},
+
+//      swapBrowsers(aOurTab, aOtherTab) {},
+
+//      _swapBrowserDocShells(aOurTab, aOtherBrowser, aStateFlags) {},
+
+//      _swapRegisteredOpenURIs(aOurBrowser, aOtherBrowser) {},
+
+//      announceWindowCreated(browser, userContextId) {},
+
+//      reloadMultiSelectedTabs() {},
+
+//      reloadTabs(tabs) {},
+
+//      reloadTab(aTab) {},
+
+//      addProgressListener(aListener) {},
+
+//      removeProgressListener(aListener) {},
+
+//      addTabsProgressListener(aListener) {},
+
+//      removeTabsProgressListener(aListener) {},
+
+//      getBrowserForTab(aTab) {},
+
+//      showOnlyTheseTabs(aTabs) {},
+
+//      showTab(aTab) {},
+
+//      hideTab(aTab, aSource) {},
+
+//      selectTabAtIndex(aIndex, aEvent) {},
+
+//      /**
+//       * Moves a tab to a new browser window, unless it's already the only tab
+//       * in the current window, in which case this will do nothing.
+//       */
+//      replaceTabWithWindow(aTab, aOptions) {},
+
+//      /**
+//       * Move contextTab (or selected tabs in a mutli-select context)
+//       * to a new browser window, unless it is (they are) already the only tab(s)
+//       * in the current window, in which case this will do nothing.
+//       */
+//      replaceTabsWithWindow(contextTab, aOptions) {},
+
+//      _updateTabsAfterInsert() {},
+
+//      moveTabTo(aTab, aIndex, aKeepRelatedTabs) {},
+
+//      moveTabForward() {},
+
+//      /**
+//       * Adopts a tab from another browser window, and inserts it at aIndex
+//       *
+//       * @returns {object}
+//       *    The new tab in the current window, null if the tab couldn't be adopted.
+//       */
+//      adoptTab(aTab, aIndex, aSelectTab) {},
+
+//      moveTabBackward() {},
+
+//      moveTabToStart() {},
+
+//      moveTabToEnd() {},
+
+//      moveTabOver(aEvent) {},
+
+//      /**
+//       * @param   aTab
+//       *          Can be from a different window as well
+//       * @param   aRestoreTabImmediately
+//       *          Can defer loading of the tab contents
+//       * @param   aOptions
+//       *          The new index of the tab
+//       */
+//      duplicateTab(aTab, aRestoreTabImmediately, aOptions) {},
+
+//      addToMultiSelectedTabs(aTab) {},
+
+//      /**
+//       * Adds two given tabs and all tabs between them into the (multi) selected tabs collection
+//       */
+//      addRangeToMultiSelectedTabs(aTab1, aTab2) {},
+
+//      removeFromMultiSelectedTabs(aTab) {},
+
+//      clearMultiSelectedTabs() {},
+
+//      selectAllTabs() {},
+
+//      allTabsSelected() {},
+
+//      lockClearMultiSelectionOnce() {},
+
+//      unlockClearMultiSelection() {},
+
+//      /**
+//       * Remove a tab from the multiselection if it's the only one left there.
+//       *
+//       * In fact, some scenario may lead to only one single tab multi-selected,
+//       * this is something to avoid (Chrome does the same)
+//       * Consider 4 tabs A,B,C,D with A having the focus
+//       * 1. select C with Ctrl
+//       * 2. Right-click on B and "Close Tabs to The Right"
+//       *
+//       * Expected result
+//       * C and D closing
+//       * A being the only multi-selected tab, selection should be cleared
+//       *
+//       *
+//       * Single selected tab could even happen with a none-focused tab.
+//       * For exemple with the menu "Close other tabs", it could happen
+//       * with a multi-selected pinned tab.
+//       * For illustration, consider 4 tabs A,B,C,D with B active
+//       * 1. pin A and Ctrl-select it
+//       * 2. Ctrl-select C
+//       * 3. right-click on D and click "Close Other Tabs"
+//       *
+//       * Expected result
+//       * B and C closing
+//       * A[pinned] being the only multi-selected tab, selection should be cleared.
+//       */
+//      avoidSingleSelectedTab() {},
+
+//      switchToNextMultiSelectedTab() {},
+
+//      set selectedTabs(tabs) {},
+
+//      get selectedTabs() {},
+
+//      get multiSelectedTabsCount() {},
+
+//      get lastMultiSelectedTab() {},
+
+//      set lastMultiSelectedTab(aTab) {},
+
+//      _startMultiSelectChange() {},
+
+//      _endMultiSelectChange() {},
+
+//      toggleMuteAudioOnMultiSelectedTabs(aTab) {},
+
+//      pinMultiSelectedTabs() {},
+
+//      unpinMultiSelectedTabs() {},
+
+//      activateBrowserForPrintPreview(aBrowser) {},
+
+//      deactivatePrintPreviewBrowsers() {},
+
+//      /**
+//       * Returns true if a given browser's docshell should be active.
+//       */
+//      shouldActivateDocShell(aBrowser) {},
+
+//      _getSwitcher() {},
+
+//      warmupTab(aTab) {},
+
+//      /**
+//       * _maybeRequestReplyFromRemoteContent may call
+//       * aEvent.requestReplyFromRemoteContent if necessary.
+//       *
+//       * @param aEvent    The handling event.
+//       * @return          true if the handler should wait a reply event.
+//       *                  false if the handle can handle the immediately.
+//       */
+//      _maybeRequestReplyFromRemoteContent(aEvent) {},
+
+//      _handleKeyDownEvent(aEvent) {},
+
+//      toggleCaretBrowsing() {},
+
+//      _handleKeyPressEvent(aEvent) {},
+
+//      getTabTooltip(tab, includeLabel = true) {},
+
+//      createTooltip(event) {},
+
+//      handleEvent(aEvent) {},
+
+//      observe(aSubject, aTopic, aData) {},
+
+//      refreshBlocked(actor, browser, data) {},
+
+//      _generateUniquePanelID() {},
+
+//      destroy() {},
+
+//      _setupEventListeners() {},
+
+//      setSuccessor(aTab, successorTab) {},
+
+//      /**
+//       * For all tabs with aTab as a successor, set the successor to aOtherTab
+//       * instead.
+//       */
+//      replaceInSuccession(aTab, aOtherTab) {}
+
+//    };
+//    /**
+//     * A web progress listener object definition for a given tab.
+//     */
+
+//    class TabProgressListener {
+//      constructor(aTab, aBrowser, aStartsBlank, aWasPreloadedBrowser, aOrigStateFlags, aOrigRequestCount) {}
+
+//      destroy() {}
+
+//      _callProgressListeners(...args) {}
+
+//      _shouldShowProgress(aRequest) {}
+
+//      _isForInitialAboutBlank(aWebProgress, aStateFlags, aLocation) {}
+
+//      onProgressChange(aWebProgress, aRequest, aCurSelfProgress, aMaxSelfProgress, aCurTotalProgress, aMaxTotalProgress) {}
+
+//      onProgressChange64(aWebProgress, aRequest, aCurSelfProgress, aMaxSelfProgress, aCurTotalProgress, aMaxTotalProgress) {}
+//      /* eslint-disable complexity */
+
+//      onStateChange(aWebProgress, aRequest, aStateFlags, aStatus) {}
+//      /* eslint-enable complexity */
+
+//      onLocationChange(aWebProgress, aRequest, aLocation, aFlags) {}
+
+//      onStatusChange(aWebProgress, aRequest, aStatus, aMessage) {}
+
+//      onSecurityChange(aWebProgress, aRequest, aState) {}
+
+//      onContentBlockingEvent(aWebProgress, aRequest, aEvent) {}
+
+//      onRefreshAttempted(aWebProgress, aURI, aDelay, aSameURI) {}
+
+//    }
+
+//    TabProgressListener.prototype.QueryInterface = ChromeUtils.generateQI(["nsIWebProgressListener", "nsIWebProgressListener2", "nsISupportsWeakReference"]);
diff --git a/browser/tools/geckoreference/content/geckoreference.xhtml b/browser/tools/geckoreference/content/geckoreference.xhtml
new file mode 100644
--- /dev/null
+++ b/browser/tools/geckoreference/content/geckoreference.xhtml
@@ -0,0 +1,63 @@
+<?xml version="1.0"?>
+<!-- This Source Code Form is subject to the terms of the Mozilla Public
+   - License, v. 2.0. If a copy of the MPL was not distributed with this file,
+   - You can obtain one at http://mozilla.org/MPL/2.0/. -->
+
+<?xml-stylesheet href="chrome://global/skin/global.css"?>
+
+<?xml-stylesheet href="chrome://global/skin/in-content/common.css"?>
+<?xml-stylesheet href="chrome://browser/content/geckoreference/awesomebar.css"?>
+<?xml-stylesheet href="chrome://browser/skin/searchbar.css" type="text/css"?>
+<?xml-stylesheet href="chrome://browser/content/geckoreference/geckoreference.css"?>
+
+<!DOCTYPE html>
+
+<html id="reference"
+    xmlns="http://www.w3.org/1999/xhtml"
+    xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
+    width="800"
+    height="600"
+    forcedarkmode="true" 
+    windowtype="navigator:browser"
+    persist="screenX screenY width height sizemode">
+
+<head>
+    <title>Gecko Reference</title>
+    <script src="chrome://global/content/globalOverlay.js" />
+    <script src="chrome://global/content/editMenuOverlay.js" />
+    <script src="chrome://browser/content/utilityOverlay.js" />
+    <script src="chrome://browser/content/geckoreference/minimal-browser.js" />
+    <script src="chrome://browser/content/geckoreference/geckoreference.js" />
+
+    <link rel="localization" href="toolkit/global/textActions.ftl"/>
+    <link rel="localization" href="browser/browser.ftl"/>
+    <link rel="localization" href="browser/browserContext.ftl"/>
+    <link rel="localization" href="browser/browserSets.ftl"/>
+    <link rel="localization" href="browser/menubar.ftl"/>
+    <link rel="localization" href="browser/protectionsPanel.ftl"/>
+    <link rel="localization" href="browser/appmenu.ftl"/>
+</head>
+
+<body role="application">
+    <xul:box xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
+# All sets except for popupsets (commands, keys, and stringbundles)
+# *must* go into the browser-sets.inc file so that they can be shared with other
+# top level windows in macWindow.inc.xhtml.
+#include ../../../base/content/browser-sets.inc
+    </xul:box>
+    <header>
+        <button id="back">back</button>
+        <button id="forward">forward</button>
+        <button id="reload">reload</button>
+        <input id="url" />
+        <button id="go">Go</button>
+    </header>
+    <main>
+        <div id="browser-container" class="when-url">
+        </div>
+        <label id="splash" class="when-no-url">Gecko Reference</label>
+    </main>
+    <footer></footer>
+</body>
+
+</html>
\ No newline at end of file
diff --git a/browser/tools/geckoreference/content/minimal-browser.js b/browser/tools/geckoreference/content/minimal-browser.js
new file mode 100644
--- /dev/null
+++ b/browser/tools/geckoreference/content/minimal-browser.js
@@ -0,0 +1,1298 @@
+/* -*- indent-tabs-mode: nil; js-indent-level: 2 -*-
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+/* global openTrustedLinkIn, BrowserWindowTracker */
+/* global gBrowser, gBrowserInit */
+
+var { XPCOMUtils } = ChromeUtils.import(
+  "resource://gre/modules/XPCOMUtils.jsm"
+);
+var { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm");
+var { AppConstants } = ChromeUtils.import(
+  "resource://gre/modules/AppConstants.jsm"
+);
+ChromeUtils.import("resource://gre/modules/NotificationDB.jsm");
+
+// lazy module getters
+
+XPCOMUtils.defineLazyModuleGetters(this, {
+  AboutNewTab: "resource:///modules/AboutNewTab.jsm",
+  AboutReaderParent: "resource:///actors/AboutReaderParent.jsm",
+  AddonManager: "resource://gre/modules/AddonManager.jsm",
+  AMTelemetry: "resource://gre/modules/AddonManager.jsm",
+  NewTabPagePreloading: "resource:///modules/NewTabPagePreloading.jsm",
+  BrowserSearchTelemetry: "resource:///modules/BrowserSearchTelemetry.jsm",
+  BrowserUsageTelemetry: "resource:///modules/BrowserUsageTelemetry.jsm",
+  BrowserTelemetryUtils: "resource://gre/modules/BrowserTelemetryUtils.jsm",
+  BrowserUIUtils: "resource:///modules/BrowserUIUtils.jsm",
+  BrowserUtils: "resource://gre/modules/BrowserUtils.jsm",
+  BrowserWindowTracker: "resource:///modules/BrowserWindowTracker.jsm",
+  CFRPageActions: "resource://activity-stream/lib/CFRPageActions.jsm",
+  CharsetMenu: "resource://gre/modules/CharsetMenu.jsm",
+  Color: "resource://gre/modules/Color.jsm",
+  ContextualIdentityService:
+    "resource://gre/modules/ContextualIdentityService.jsm",
+  CustomizableUI: "resource:///modules/CustomizableUI.jsm",
+  Deprecated: "resource://gre/modules/Deprecated.jsm",
+  DevToolsSocketStatus:
+    "resource://devtools/shared/security/DevToolsSocketStatus.jsm",
+  DownloadsCommon: "resource:///modules/DownloadsCommon.jsm",
+  DownloadUtils: "resource://gre/modules/DownloadUtils.jsm",
+  E10SUtils: "resource://gre/modules/E10SUtils.jsm",
+  ExtensionsUI: "resource:///modules/ExtensionsUI.jsm",
+  HomePage: "resource:///modules/HomePage.jsm",
+  LightweightThemeConsumer:
+    "resource://gre/modules/LightweightThemeConsumer.jsm",
+  Log: "resource://gre/modules/Log.jsm",
+  LoginHelper: "resource://gre/modules/LoginHelper.jsm",
+  LoginManagerParent: "resource://gre/modules/LoginManagerParent.jsm",
+  MigrationUtils: "resource:///modules/MigrationUtils.jsm",
+  NetUtil: "resource://gre/modules/NetUtil.jsm",
+  NewTabUtils: "resource://gre/modules/NewTabUtils.jsm",
+  OpenInTabsUtils: "resource:///modules/OpenInTabsUtils.jsm",
+  PageActions: "resource:///modules/PageActions.jsm",
+  PageThumbs: "resource://gre/modules/PageThumbs.jsm",
+  PanelMultiView: "resource:///modules/PanelMultiView.jsm",
+  PanelView: "resource:///modules/PanelMultiView.jsm",
+  PictureInPicture: "resource://gre/modules/PictureInPicture.jsm",
+  PlacesUtils: "resource://gre/modules/PlacesUtils.jsm",
+  PlacesUIUtils: "resource:///modules/PlacesUIUtils.jsm",
+  PlacesTransactions: "resource://gre/modules/PlacesTransactions.jsm",
+  PluralForm: "resource://gre/modules/PluralForm.jsm",
+  Pocket: "chrome://pocket/content/Pocket.jsm",
+  PrivateBrowsingUtils: "resource://gre/modules/PrivateBrowsingUtils.jsm",
+  ProcessHangMonitor: "resource:///modules/ProcessHangMonitor.jsm",
+  PromiseUtils: "resource://gre/modules/PromiseUtils.jsm",
+  PromptUtils: "resource://gre/modules/SharedPromptUtils.jsm",
+  // TODO (Bug 1529552): Remove once old urlbar code goes away.
+  ReaderMode: "resource://gre/modules/ReaderMode.jsm",
+  RFPHelper: "resource://gre/modules/RFPHelper.jsm",
+  SafeBrowsing: "resource://gre/modules/SafeBrowsing.jsm",
+  Sanitizer: "resource:///modules/Sanitizer.jsm",
+  SessionStartup: "resource:///modules/sessionstore/SessionStartup.jsm",
+  SessionStore: "resource:///modules/sessionstore/SessionStore.jsm",
+  ShortcutUtils: "resource://gre/modules/ShortcutUtils.jsm",
+  SimpleServiceDiscovery: "resource://gre/modules/SimpleServiceDiscovery.jsm",
+  SiteDataManager: "resource:///modules/SiteDataManager.jsm",
+  SitePermissions: "resource:///modules/SitePermissions.jsm",
+  SubDialog: "resource://gre/modules/SubDialog.jsm",
+  SubDialogManager: "resource://gre/modules/SubDialog.jsm",
+  TabModalPrompt: "chrome://global/content/tabprompts.jsm",
+  TabCrashHandler: "resource:///modules/ContentCrashHandlers.jsm",
+  TelemetryEnvironment: "resource://gre/modules/TelemetryEnvironment.jsm",
+  Translation: "resource:///modules/translation/TranslationParent.jsm",
+  UITour: "resource:///modules/UITour.jsm",
+  UpdateUtils: "resource://gre/modules/UpdateUtils.jsm",
+  UrlbarInput: "resource:///modules/UrlbarInput.jsm",
+  UrlbarPrefs: "resource:///modules/UrlbarPrefs.jsm",
+  UrlbarProviderSearchTips: "resource:///modules/UrlbarProviderSearchTips.jsm",
+  UrlbarTokenizer: "resource:///modules/UrlbarTokenizer.jsm",
+  UrlbarUtils: "resource:///modules/UrlbarUtils.jsm",
+  UrlbarValueFormatter: "resource:///modules/UrlbarValueFormatter.jsm",
+  Weave: "resource://services-sync/main.js",
+  WebNavigationFrames: "resource://gre/modules/WebNavigationFrames.jsm",
+  fxAccounts: "resource://gre/modules/FxAccounts.jsm",
+  webrtcUI: "resource:///modules/webrtcUI.jsm",
+  WebsiteFilter: "resource:///modules/policies/WebsiteFilter.jsm",
+  ZoomUI: "resource:///modules/ZoomUI.jsm",
+});
+
+XPCOMUtils.defineLazyServiceGetters(this, {
+  ContentPrefService2: [
+    "@mozilla.org/content-pref/service;1",
+    "nsIContentPrefService2",
+  ],
+  classifierService: [
+    "@mozilla.org/url-classifier/dbservice;1",
+    "nsIURIClassifier",
+  ],
+  Favicons: ["@mozilla.org/browser/favicon-service;1", "nsIFaviconService"],
+  gDNSService: ["@mozilla.org/network/dns-service;1", "nsIDNSService"],
+  gSerializationHelper: [
+    "@mozilla.org/network/serialization-helper;1",
+    "nsISerializationHelper",
+  ],
+  Marionette: ["@mozilla.org/remote/marionette;1", "nsIMarionette"],
+  WindowsUIUtils: ["@mozilla.org/windows-ui-utils;1", "nsIWindowsUIUtils"],
+  BrowserHandler: ["@mozilla.org/browser/clh;1", "nsIBrowserHandler"],
+});
+
+/* Start copy into reference browser (minimal-browser.js) */
+
+// var gPageIcons = {
+//     "about:home": "chrome://branding/content/icon32.png",
+//     "about:newtab": "chrome://branding/content/icon32.png",
+//     "about:welcome": "chrome://branding/content/icon32.png",
+//     "about:newinstall": "chrome://branding/content/icon32.png",
+//     "about:privatebrowsing": "chrome://browser/skin/privatebrowsing/favicon.svg",
+//   };
+
+//   var gInitialPages = [
+//     "about:blank",
+//     "about:newtab",
+//     "about:home",
+//     "about:privatebrowsing",
+//     "about:welcomeback",
+//     "about:sessionrestore",
+//     "about:welcome",
+//     "about:newinstall",
+//   ];
+
+//   function isInitialPage(url) {
+//     if (!(url instanceof Ci.nsIURI)) {
+//       try {
+//         url = Services.io.newURI(url);
+//       } catch (ex) {
+//         return false;
+//       }
+//     }
+
+//     let nonQuery = url.prePath + url.filePath;
+//     return gInitialPages.includes(nonQuery) || nonQuery == BROWSER_NEW_TAB_URL;
+//   }
+
+//   function browserWindows() {
+//     return Services.wm.getEnumerator("navigator:browser");
+//   }
+
+//   // This is a stringbundle-like interface to gBrowserBundle, formerly a getter for
+//   // the "bundle_browser" element.
+//   var gNavigatorBundle = {
+//     getString(key) {
+//       return gBrowserBundle.GetStringFromName(key);
+//     },
+//     getFormattedString(key, array) {
+//       return gBrowserBundle.formatStringFromName(key, array);
+//     },
+//   };
+
+/* End copy into reference browser (minimal-browser.js) */
+
+/* Start copy into reference browser (minimal-browser.js) */
+
+function HandleAppCommandEvent(evt) {
+  switch (evt.command) {
+    case "Back":
+      BrowserBack();
+      break;
+    case "Forward":
+      BrowserForward();
+      break;
+    case "Reload":
+      BrowserReloadSkipCache();
+      break;
+    case "Stop":
+      if (XULBrowserWindow.stopCommand.getAttribute("disabled") != "true") {
+        BrowserStop();
+      }
+      break;
+    case "Search":
+      BrowserSearch.webSearch();
+      break;
+    case "Bookmarks":
+      SidebarUI.toggle("viewBookmarksSidebar");
+      break;
+    case "Home":
+      BrowserHome();
+      break;
+    case "New":
+      BrowserOpenTab();
+      break;
+    case "Close":
+      BrowserCloseTabOrWindow();
+      break;
+    case "Find":
+      gLazyFindCommand("onFindCommand");
+      break;
+    case "Help":
+      openHelpLink("firefox-help");
+      break;
+    case "Open":
+      BrowserOpenFileWindow();
+      break;
+    case "Print":
+      PrintUtils.startPrintWindow(gBrowser.selectedBrowser.browsingContext);
+      break;
+    case "Save":
+      saveBrowser(gBrowser.selectedBrowser);
+      break;
+    case "SendMail":
+      MailIntegration.sendLinkForBrowser(gBrowser.selectedBrowser);
+      break;
+    default:
+      return;
+  }
+  evt.stopPropagation();
+  evt.preventDefault();
+}
+
+function gotoHistoryIndex(aEvent) {
+  aEvent = getRootEvent(aEvent);
+
+  let index = aEvent.target.getAttribute("index");
+  if (!index) {
+    return false;
+  }
+
+  let where = whereToOpenLink(aEvent);
+
+  if (where == "current") {
+    // Normal click. Go there in the current tab and update session history.
+
+    try {
+      gBrowser.gotoIndex(index);
+    } catch (ex) {
+      return false;
+    }
+    return true;
+  }
+  // Modified click. Go there in a new tab/window.
+
+  let historyindex = aEvent.target.getAttribute("historyindex");
+  duplicateTabIn(gBrowser.selectedTab, where, Number(historyindex));
+  return true;
+}
+
+function BrowserForward(aEvent) {
+  let where = whereToOpenLink(aEvent, false, true);
+
+  if (where == "current") {
+    try {
+      gBrowser.goForward();
+    } catch (ex) {}
+  } else {
+    duplicateTabIn(gBrowser.selectedTab, where, 1);
+  }
+}
+
+function BrowserBack(aEvent) {
+  let where = whereToOpenLink(aEvent, false, true);
+
+  if (where == "current") {
+    try {
+      gBrowser.goBack();
+    } catch (ex) {}
+  } else {
+    duplicateTabIn(gBrowser.selectedTab, where, -1);
+  }
+}
+
+function BrowserHandleBackspace() {
+  switch (Services.prefs.getIntPref("browser.backspace_action")) {
+    case 0:
+      BrowserBack();
+      break;
+    case 1:
+      goDoCommand("cmd_scrollPageUp");
+      break;
+  }
+}
+
+function BrowserHandleShiftBackspace() {
+  switch (Services.prefs.getIntPref("browser.backspace_action")) {
+    case 0:
+      BrowserForward();
+      break;
+    case 1:
+      goDoCommand("cmd_scrollPageDown");
+      break;
+  }
+}
+
+function BrowserStop() {
+  gBrowser.webNavigation.stop(Ci.nsIWebNavigation.STOP_ALL);
+}
+
+function BrowserReloadOrDuplicate(aEvent) {
+  aEvent = getRootEvent(aEvent);
+  let accelKeyPressed =
+    AppConstants.platform == "macosx" ? aEvent.metaKey : aEvent.ctrlKey;
+  var backgroundTabModifier = aEvent.button == 1 || accelKeyPressed;
+
+  if (aEvent.shiftKey && !backgroundTabModifier) {
+    BrowserReloadSkipCache();
+    return;
+  }
+
+  let where = whereToOpenLink(aEvent, false, true);
+  if (where == "current") {
+    BrowserReload();
+  } else {
+    duplicateTabIn(gBrowser.selectedTab, where);
+  }
+}
+
+function BrowserReload() {
+  if (gBrowser.currentURI.schemeIs("view-source")) {
+    // Bug 1167797: For view source, we always skip the cache
+    return BrowserReloadSkipCache();
+  }
+  const reloadFlags = Ci.nsIWebNavigation.LOAD_FLAGS_NONE;
+  BrowserReloadWithFlags(reloadFlags);
+}
+
+const kSkipCacheFlags =
+  Ci.nsIWebNavigation.LOAD_FLAGS_BYPASS_PROXY |
+  Ci.nsIWebNavigation.LOAD_FLAGS_BYPASS_CACHE;
+function BrowserReloadSkipCache() {
+  // Bypass proxy and cache.
+  BrowserReloadWithFlags(kSkipCacheFlags);
+}
+
+function BrowserHome(aEvent) {
+  if (aEvent && "button" in aEvent && aEvent.button == 2) {
+    // right-click: do nothing
+    return;
+  }
+
+  var homePage = HomePage.get(window);
+  var where = whereToOpenLink(aEvent, false, true);
+  var urls;
+  var notifyObservers;
+
+  // Home page should open in a new tab when current tab is an app tab
+  if (where == "current" && gBrowser && gBrowser.selectedTab.pinned) {
+    where = "tab";
+  }
+
+  // openTrustedLinkIn in utilityOverlay.js doesn't handle loading multiple pages
+  switch (where) {
+    case "current":
+      // If we're going to load an initial page in the current tab as the
+      // home page, we set initialPageLoadedFromURLBar so that the URL
+      // bar is cleared properly (even during a remoteness flip).
+      if (isInitialPage(homePage)) {
+        gBrowser.selectedBrowser.initialPageLoadedFromUserAction = homePage;
+      }
+      loadOneOrMoreURIs(
+        homePage,
+        Services.scriptSecurityManager.getSystemPrincipal(),
+        null
+      );
+      if (isBlankPageURL(homePage)) {
+        gURLBar.select();
+      } else {
+        gBrowser.selectedBrowser.focus();
+      }
+      notifyObservers = true;
+      break;
+    case "tabshifted":
+    case "tab":
+      urls = homePage.split("|");
+      var loadInBackground = Services.prefs.getBoolPref(
+        "browser.tabs.loadBookmarksInBackground",
+        false
+      );
+      // The homepage observer event should only be triggered when the homepage opens
+      // in the foreground. This is mostly to support the homepage changed by extension
+      // doorhanger which doesn't currently support background pages. This may change in
+      // bug 1438396.
+      notifyObservers = !loadInBackground;
+      gBrowser.loadTabs(urls, {
+        inBackground: loadInBackground,
+        triggeringPrincipal: Services.scriptSecurityManager.getSystemPrincipal(),
+        csp: null,
+      });
+      break;
+    case "window":
+      // OpenBrowserWindow will trigger the observer event, so no need to do so here.
+      notifyObservers = false;
+      OpenBrowserWindow();
+      break;
+  }
+  if (notifyObservers) {
+    // A notification for when a user has triggered their homepage. This is used
+    // to display a doorhanger explaining that an extension has modified the
+    // homepage, if necessary. Observers are only notified if the homepage
+    // becomes the active page.
+    Services.obs.notifyObservers(null, "browser-open-homepage-start");
+  }
+}
+
+function loadOneOrMoreURIs(aURIString, aTriggeringPrincipal, aCsp) {
+  // we're not a browser window, pass the URI string to a new browser window
+  if (window.location.href != AppConstants.BROWSER_CHROME_URL) {
+    window.openDialog(
+      AppConstants.BROWSER_CHROME_URL,
+      "_blank",
+      "all,dialog=no",
+      aURIString
+    );
+    return;
+  }
+
+  // This function throws for certain malformed URIs, so use exception handling
+  // so that we don't disrupt startup
+  try {
+    gBrowser.loadTabs(aURIString.split("|"), {
+      inBackground: false,
+      replace: true,
+      triggeringPrincipal: aTriggeringPrincipal,
+      csp: aCsp,
+    });
+  } catch (e) {}
+}
+
+function openLocation(event) {
+  if (window.location.href == AppConstants.BROWSER_CHROME_URL) {
+    gURLBar.select();
+    gURLBar.view.autoOpen({ event });
+    return;
+  }
+
+  // If there's an open browser window, redirect the command there.
+  let win = getTopWin();
+  if (win) {
+    win.focus();
+    win.openLocation();
+    return;
+  }
+
+  // There are no open browser windows; open a new one.
+  window.openDialog(
+    AppConstants.BROWSER_CHROME_URL,
+    "_blank",
+    "chrome,all,dialog=no",
+    BROWSER_NEW_TAB_URL
+  );
+}
+
+function BrowserOpenTab(event) {
+  let where = "tab";
+  let relatedToCurrent = false;
+
+  if (event) {
+    where = whereToOpenLink(event, false, true);
+
+    switch (where) {
+      case "tab":
+      case "tabshifted":
+        // When accel-click or middle-click are used, open the new tab as
+        // related to the current tab.
+        relatedToCurrent = true;
+        break;
+      case "current":
+        where = "tab";
+        break;
+    }
+  }
+
+  // A notification intended to be useful for modular peformance tracking
+  // starting as close as is reasonably possible to the time when the user
+  // expressed the intent to open a new tab.  Since there are a lot of
+  // entry points, this won't catch every single tab created, but most
+  // initiated by the user should go through here.
+  //
+  // Note 1: This notification gets notified with a promise that resolves
+  //         with the linked browser when the tab gets created
+  // Note 2: This is also used to notify a user that an extension has changed
+  //         the New Tab page.
+  Services.obs.notifyObservers(
+    {
+      wrappedJSObject: new Promise(resolve => {
+        openTrustedLinkIn(BROWSER_NEW_TAB_URL, where, {
+          relatedToCurrent,
+          resolveOnNewTabCreated: resolve,
+        });
+      }),
+    },
+    "browser-open-newtab-start"
+  );
+}
+
+var gLastOpenDirectory = {
+  _lastDir: null,
+  get path() {
+    if (!this._lastDir || !this._lastDir.exists()) {
+      try {
+        this._lastDir = Services.prefs.getComplexValue(
+          "browser.open.lastDir",
+          Ci.nsIFile
+        );
+        if (!this._lastDir.exists()) {
+          this._lastDir = null;
+        }
+      } catch (e) {}
+    }
+    return this._lastDir;
+  },
+  set path(val) {
+    try {
+      if (!val || !val.isDirectory()) {
+        return;
+      }
+    } catch (e) {
+      return;
+    }
+    this._lastDir = val.clone();
+
+    // Don't save the last open directory pref inside the Private Browsing mode
+    if (!PrivateBrowsingUtils.isWindowPrivate(window)) {
+      Services.prefs.setComplexValue(
+        "browser.open.lastDir",
+        Ci.nsIFile,
+        this._lastDir
+      );
+    }
+  },
+  reset() {
+    this._lastDir = null;
+  },
+};
+
+function BrowserOpenFileWindow() {
+  // Get filepicker component.
+  try {
+    const nsIFilePicker = Ci.nsIFilePicker;
+    let fp = Cc["@mozilla.org/filepicker;1"].createInstance(nsIFilePicker);
+    let fpCallback = function fpCallback_done(aResult) {
+      if (aResult == nsIFilePicker.returnOK) {
+        try {
+          if (fp.file) {
+            gLastOpenDirectory.path = fp.file.parent.QueryInterface(Ci.nsIFile);
+          }
+        } catch (ex) {}
+        openTrustedLinkIn(fp.fileURL.spec, "current");
+      }
+    };
+
+    fp.init(
+      window,
+      gNavigatorBundle.getString("openFile"),
+      nsIFilePicker.modeOpen
+    );
+    fp.appendFilters(
+      nsIFilePicker.filterAll |
+        nsIFilePicker.filterText |
+        nsIFilePicker.filterImages |
+        nsIFilePicker.filterXML |
+        nsIFilePicker.filterHTML
+    );
+    fp.displayDirectory = gLastOpenDirectory.path;
+    fp.open(fpCallback);
+  } catch (ex) {}
+}
+
+function BrowserCloseTabOrWindow(event) {
+  // If we're not a browser window, just close the window.
+  if (window.location.href != AppConstants.BROWSER_CHROME_URL) {
+    closeWindow(true);
+    return;
+  }
+
+  // In a multi-select context, close all selected tabs
+  if (gBrowser.multiSelectedTabsCount) {
+    gBrowser.removeMultiSelectedTabs();
+    return;
+  }
+
+  // Keyboard shortcuts that would close a tab that is pinned select the first
+  // unpinned tab instead.
+  if (
+    event &&
+    (event.ctrlKey || event.metaKey || event.altKey) &&
+    gBrowser.selectedTab.pinned
+  ) {
+    if (gBrowser.visibleTabs.length > gBrowser._numPinnedTabs) {
+      gBrowser.tabContainer.selectedIndex = gBrowser._numPinnedTabs;
+    }
+    return;
+  }
+
+  // If the current tab is the last one, this will close the window.
+  gBrowser.removeCurrentTab({ animate: true });
+}
+
+function BrowserTryToCloseWindow() {
+  if (WindowIsClosing()) {
+    window.close();
+  } // WindowIsClosing does all the necessary checks
+}
+
+function loadURI(
+  uri,
+  referrerInfo,
+  postData,
+  allowThirdPartyFixup,
+  userContextId,
+  originPrincipal,
+  originStoragePrincipal,
+  forceAboutBlankViewerInCurrent,
+  triggeringPrincipal,
+  allowInheritPrincipal = false,
+  csp = null
+) {
+  if (!triggeringPrincipal) {
+    throw new Error("Must load with a triggering Principal");
+  }
+
+  try {
+    openLinkIn(uri, "current", {
+      referrerInfo,
+      postData,
+      allowThirdPartyFixup,
+      userContextId,
+      originPrincipal,
+      originStoragePrincipal,
+      triggeringPrincipal,
+      csp,
+      forceAboutBlankViewerInCurrent,
+      allowInheritPrincipal,
+    });
+  } catch (e) {
+    Cu.reportError(e);
+  }
+}
+
+function getLoadContext() {
+  return window.docShell.QueryInterface(Ci.nsILoadContext);
+}
+
+function readFromClipboard() {
+  var url;
+
+  try {
+    // Create transferable that will transfer the text.
+    var trans = Cc["@mozilla.org/widget/transferable;1"].createInstance(
+      Ci.nsITransferable
+    );
+    trans.init(getLoadContext());
+
+    trans.addDataFlavor("text/unicode");
+
+    // If available, use selection clipboard, otherwise global one
+    if (Services.clipboard.supportsSelectionClipboard()) {
+      Services.clipboard.getData(trans, Services.clipboard.kSelectionClipboard);
+    } else {
+      Services.clipboard.getData(trans, Services.clipboard.kGlobalClipboard);
+    }
+
+    var data = {};
+    trans.getTransferData("text/unicode", data);
+
+    if (data) {
+      data = data.value.QueryInterface(Ci.nsISupportsString);
+      url = data.data;
+    }
+  } catch (ex) {}
+
+  return url;
+}
+
+/* End copy into reference browser (minimal-browser.js) */
+
+/* Start copy into reference browser (minimal-browser.js) */
+
+function toOpenWindowByType(inType, uri, features) {
+  var topWindow = Services.wm.getMostRecentWindow(inType);
+
+  if (topWindow) {
+    topWindow.focus();
+  } else if (features) {
+    window.open(uri, "_blank", features);
+  } else {
+    window.open(
+      uri,
+      "_blank",
+      "chrome,extrachrome,menubar,resizable,scrollbars,status,toolbar"
+    );
+  }
+}
+
+/**
+ * Open a new browser window.
+ *
+ * @param {Object} options
+ *        {
+ *          private: A boolean indicating if the window should be
+ *                   private
+ *          remote:  A boolean indicating if the window should run
+ *                   remote browser tabs or not. If omitted, the window
+ *                   will choose the profile default state.
+ *          fission: A boolean indicating if the window should run
+ *                   with fission enabled or not. If omitted, the window
+ *                   will choose the profile default state.
+ *        }
+ * @return a reference to the new window.
+ */
+function OpenBrowserWindow(options) {
+  var telemetryObj = {};
+  TelemetryStopwatch.start("FX_NEW_WINDOW_MS", telemetryObj);
+
+  var defaultArgs = BrowserHandler.defaultArgs;
+  var wintype = document.documentElement.getAttribute("windowtype");
+
+  var extraFeatures = "";
+  if (options && options.private && PrivateBrowsingUtils.enabled) {
+    extraFeatures = ",private";
+    if (!PrivateBrowsingUtils.permanentPrivateBrowsing) {
+      // Force the new window to load about:privatebrowsing instead of the default home page
+      defaultArgs = "about:privatebrowsing";
+    }
+  } else {
+    extraFeatures = ",non-private";
+  }
+
+  if (options && options.remote) {
+    extraFeatures += ",remote";
+  } else if (options && options.remote === false) {
+    extraFeatures += ",non-remote";
+  }
+
+  if (options && options.fission) {
+    extraFeatures += ",fission";
+  } else if (options && options.fission === false) {
+    extraFeatures += ",non-fission";
+  }
+
+  // If the window is maximized, we want to skip the animation, since we're
+  // going to be taking up most of the screen anyways, and we want to optimize
+  // for showing the user a useful window as soon as possible.
+  if (window.windowState == window.STATE_MAXIMIZED) {
+    extraFeatures += ",suppressanimation";
+  }
+
+  // if and only if the current window is a browser window and it has a document with a character
+  // set, then extract the current charset menu setting from the current document and use it to
+  // initialize the new browser window...
+  var win;
+  if (
+    window &&
+    wintype == "navigator:browser" &&
+    window.content &&
+    window.content.document
+  ) {
+    var DocCharset = window.content.document.characterSet;
+    let charsetArg = "charset=" + DocCharset;
+
+    // we should "inherit" the charset menu setting in a new window
+    win = window.openDialog(
+      AppConstants.BROWSER_CHROME_URL,
+      "_blank",
+      "chrome,all,dialog=no" + extraFeatures,
+      defaultArgs,
+      charsetArg
+    );
+  } else {
+    // forget about the charset information.
+    win = window.openDialog(
+      AppConstants.BROWSER_CHROME_URL,
+      "_blank",
+      "chrome,all,dialog=no" + extraFeatures,
+      defaultArgs
+    );
+  }
+
+  win.addEventListener(
+    "MozAfterPaint",
+    () => {
+      TelemetryStopwatch.finish("FX_NEW_WINDOW_MS", telemetryObj);
+      if (
+        Services.prefs.getIntPref("browser.startup.page") == 1 &&
+        defaultArgs == HomePage.get()
+      ) {
+        // A notification for when a user has triggered their homepage. This is used
+        // to display a doorhanger explaining that an extension has modified the
+        // homepage, if necessary.
+        Services.obs.notifyObservers(win, "browser-open-homepage-start");
+      }
+    },
+    { once: true }
+  );
+
+  return win;
+}
+
+/* End copy into reference browser (minimal-browser.js) */
+
+/* Start copy into reference browser (minimal-browser.js) */
+
+function nsBrowserAccess() {}
+
+nsBrowserAccess.prototype = {
+  QueryInterface: ChromeUtils.generateQI(["nsIBrowserDOMWindow"]),
+
+  _openURIInNewTab(
+    aURI,
+    aReferrerInfo,
+    aIsPrivate,
+    aIsExternal,
+    aForceNotRemote = false,
+    aUserContextId = Ci.nsIScriptSecurityManager.DEFAULT_USER_CONTEXT_ID,
+    aOpenWindowInfo = null,
+    aOpenerBrowser = null,
+    aTriggeringPrincipal = null,
+    aName = "",
+    aCsp = null,
+    aSkipLoad = false
+  ) {
+    let win, needToFocusWin;
+
+    // try the current window.  if we're in a popup, fall back on the most recent browser window
+    if (window.toolbar.visible) {
+      win = window;
+    } else {
+      win = BrowserWindowTracker.getTopWindow({ private: aIsPrivate });
+      needToFocusWin = true;
+    }
+
+    if (!win) {
+      // we couldn't find a suitable window, a new one needs to be opened.
+      return null;
+    }
+
+    if (aIsExternal && (!aURI || aURI.spec == "about:blank")) {
+      win.BrowserOpenTab(); // this also focuses the location bar
+      win.focus();
+      return win.gBrowser.selectedBrowser;
+    }
+
+    let loadInBackground = Services.prefs.getBoolPref(
+      "browser.tabs.loadDivertedInBackground"
+    );
+
+    let tab = win.gBrowser.loadOneTab(aURI ? aURI.spec : "about:blank", {
+      triggeringPrincipal: aTriggeringPrincipal,
+      referrerInfo: aReferrerInfo,
+      userContextId: aUserContextId,
+      fromExternal: aIsExternal,
+      inBackground: loadInBackground,
+      forceNotRemote: aForceNotRemote,
+      openWindowInfo: aOpenWindowInfo,
+      openerBrowser: aOpenerBrowser,
+      name: aName,
+      csp: aCsp,
+      skipLoad: aSkipLoad,
+    });
+    let browser = win.gBrowser.getBrowserForTab(tab);
+
+    if (needToFocusWin || (!loadInBackground && aIsExternal)) {
+      win.focus();
+    }
+
+    return browser;
+  },
+
+  createContentWindow(
+    aURI,
+    aOpenWindowInfo,
+    aWhere,
+    aFlags,
+    aTriggeringPrincipal,
+    aCsp
+  ) {
+    return this.getContentWindowOrOpenURI(
+      null,
+      aOpenWindowInfo,
+      aWhere,
+      aFlags,
+      aTriggeringPrincipal,
+      aCsp,
+      true
+    );
+  },
+
+  openURI(aURI, aOpenWindowInfo, aWhere, aFlags, aTriggeringPrincipal, aCsp) {
+    if (!aURI) {
+      Cu.reportError("openURI should only be called with a valid URI");
+      throw Components.Exception("", Cr.NS_ERROR_FAILURE);
+    }
+    return this.getContentWindowOrOpenURI(
+      aURI,
+      aOpenWindowInfo,
+      aWhere,
+      aFlags,
+      aTriggeringPrincipal,
+      aCsp,
+      false
+    );
+  },
+
+  getContentWindowOrOpenURI(
+    aURI,
+    aOpenWindowInfo,
+    aWhere,
+    aFlags,
+    aTriggeringPrincipal,
+    aCsp,
+    aSkipLoad
+  ) {
+    var browsingContext = null;
+    var isExternal = !!(aFlags & Ci.nsIBrowserDOMWindow.OPEN_EXTERNAL);
+
+    if (aOpenWindowInfo && isExternal) {
+      Cu.reportError(
+        "nsBrowserAccess.openURI did not expect aOpenWindowInfo to be " +
+          "passed if the context is OPEN_EXTERNAL."
+      );
+      throw Components.Exception("", Cr.NS_ERROR_FAILURE);
+    }
+
+    if (isExternal && aURI && aURI.schemeIs("chrome")) {
+      dump("use --chrome command-line option to load external chrome urls\n");
+      return null;
+    }
+
+    if (aWhere == Ci.nsIBrowserDOMWindow.OPEN_DEFAULTWINDOW) {
+      if (
+        isExternal &&
+        Services.prefs.prefHasUserValue(
+          "browser.link.open_newwindow.override.external"
+        )
+      ) {
+        aWhere = Services.prefs.getIntPref(
+          "browser.link.open_newwindow.override.external"
+        );
+      } else {
+        aWhere = Services.prefs.getIntPref("browser.link.open_newwindow");
+      }
+    }
+
+    let referrerInfo;
+    if (aFlags & Ci.nsIBrowserDOMWindow.OPEN_NO_REFERRER) {
+      referrerInfo = new ReferrerInfo(Ci.nsIReferrerInfo.EMPTY, false, null);
+    } else if (
+      aOpenWindowInfo &&
+      aOpenWindowInfo.parent &&
+      aOpenWindowInfo.parent.window
+    ) {
+      referrerInfo = new ReferrerInfo(
+        aOpenWindowInfo.parent.window.document.referrerInfo.referrerPolicy,
+        true,
+        makeURI(aOpenWindowInfo.parent.window.location.href)
+      );
+    } else {
+      referrerInfo = new ReferrerInfo(Ci.nsIReferrerInfo.EMPTY, true, null);
+    }
+
+    let isPrivate = aOpenWindowInfo
+      ? aOpenWindowInfo.originAttributes.privateBrowsingId != 0
+      : PrivateBrowsingUtils.isWindowPrivate(window);
+
+    switch (aWhere) {
+      case Ci.nsIBrowserDOMWindow.OPEN_NEWWINDOW:
+        // FIXME: Bug 408379. So how come this doesn't send the
+        // referrer like the other loads do?
+        var url = aURI && aURI.spec;
+        let features = "all,dialog=no";
+        if (isPrivate) {
+          features += ",private";
+        }
+        // Pass all params to openDialog to ensure that "url" isn't passed through
+        // loadOneOrMoreURIs, which splits based on "|"
+        try {
+          openDialog(
+            AppConstants.BROWSER_CHROME_URL,
+            "_blank",
+            features,
+            // window.arguments
+            url,
+            null,
+            null,
+            null,
+            null,
+            null,
+            null,
+            null,
+            aTriggeringPrincipal,
+            null,
+            aCsp,
+            aOpenWindowInfo
+          );
+          // At this point, the new browser window is just starting to load, and
+          // hasn't created the content <browser> that we should return.
+          // If the caller of this function is originating in C++, they can pass a
+          // callback in nsOpenWindowInfo and it will be invoked when the browsing
+          // context for a newly opened window is ready.
+          browsingContext = null;
+        } catch (ex) {
+          Cu.reportError(ex);
+        }
+        break;
+      case Ci.nsIBrowserDOMWindow.OPEN_NEWTAB: {
+        // If we have an opener, that means that the caller is expecting access
+        // to the nsIDOMWindow of the opened tab right away. For e10s windows,
+        // this means forcing the newly opened browser to be non-remote so that
+        // we can hand back the nsIDOMWindow. DocumentLoadListener will do the
+        // job of shuttling off the newly opened browser to run in the right
+        // process once it starts loading a URI.
+        let forceNotRemote = aOpenWindowInfo && !aOpenWindowInfo.isRemote;
+        let userContextId = aOpenWindowInfo
+          ? aOpenWindowInfo.originAttributes.userContextId
+          : Ci.nsIScriptSecurityManager.DEFAULT_USER_CONTEXT_ID;
+        let browser = this._openURIInNewTab(
+          aURI,
+          referrerInfo,
+          isPrivate,
+          isExternal,
+          forceNotRemote,
+          userContextId,
+          aOpenWindowInfo,
+          null,
+          aTriggeringPrincipal,
+          "",
+          aCsp,
+          aSkipLoad
+        );
+        if (browser) {
+          browsingContext = browser.browsingContext;
+        }
+        break;
+      }
+      case Ci.nsIBrowserDOMWindow.OPEN_PRINT_BROWSER: {
+        let browser = PrintUtils.startPrintWindow(aOpenWindowInfo.parent, {
+          openWindowInfo: aOpenWindowInfo,
+        });
+        if (browser) {
+          browsingContext = browser.browsingContext;
+        }
+        break;
+      }
+      default:
+        // OPEN_CURRENTWINDOW or an illegal value
+        browsingContext = window.gBrowser.selectedBrowser.browsingContext;
+        if (aURI) {
+          let loadFlags = Ci.nsIWebNavigation.LOAD_FLAGS_NONE;
+          if (isExternal) {
+            loadFlags |= Ci.nsIWebNavigation.LOAD_FLAGS_FROM_EXTERNAL;
+          } else if (!aTriggeringPrincipal.isSystemPrincipal) {
+            // XXX this code must be reviewed and changed when bug 1616353
+            // lands.
+            loadFlags |= Ci.nsIWebNavigation.LOAD_FLAGS_FIRST_LOAD;
+          }
+          gBrowser.loadURI(aURI.spec, {
+            triggeringPrincipal: aTriggeringPrincipal,
+            csp: aCsp,
+            loadFlags,
+            referrerInfo,
+          });
+        }
+        if (
+          !Services.prefs.getBoolPref("browser.tabs.loadDivertedInBackground")
+        ) {
+          window.focus();
+        }
+    }
+    return browsingContext;
+  },
+
+  createContentWindowInFrame: function browser_createContentWindowInFrame(
+    aURI,
+    aParams,
+    aWhere,
+    aFlags,
+    aName
+  ) {
+    // Passing a null-URI to only create the content window,
+    // and pass true for aSkipLoad to prevent loading of
+    // about:blank
+    return this.getContentWindowOrOpenURIInFrame(
+      null,
+      aParams,
+      aWhere,
+      aFlags,
+      aName,
+      true
+    );
+  },
+
+  openURIInFrame: function browser_openURIInFrame(
+    aURI,
+    aParams,
+    aWhere,
+    aFlags,
+    aName
+  ) {
+    return this.getContentWindowOrOpenURIInFrame(
+      aURI,
+      aParams,
+      aWhere,
+      aFlags,
+      aName,
+      false
+    );
+  },
+
+  getContentWindowOrOpenURIInFrame: function browser_getContentWindowOrOpenURIInFrame(
+    aURI,
+    aParams,
+    aWhere,
+    aFlags,
+    aName,
+    aSkipLoad
+  ) {
+    if (aWhere == Ci.nsIBrowserDOMWindow.OPEN_PRINT_BROWSER) {
+      return PrintUtils.startPrintWindow(aParams.openWindowInfo.parent, {
+        openWindowInfo: aParams.openWindowInfo,
+      });
+    }
+
+    if (aWhere != Ci.nsIBrowserDOMWindow.OPEN_NEWTAB) {
+      dump("Error: openURIInFrame can only open in new tabs or print");
+      return null;
+    }
+
+    var isExternal = !!(aFlags & Ci.nsIBrowserDOMWindow.OPEN_EXTERNAL);
+
+    var userContextId =
+      aParams.openerOriginAttributes &&
+      "userContextId" in aParams.openerOriginAttributes
+        ? aParams.openerOriginAttributes.userContextId
+        : Ci.nsIScriptSecurityManager.DEFAULT_USER_CONTEXT_ID;
+
+    return this._openURIInNewTab(
+      aURI,
+      aParams.referrerInfo,
+      aParams.isPrivate,
+      isExternal,
+      false,
+      userContextId,
+      aParams.openWindowInfo,
+      aParams.openerBrowser,
+      aParams.triggeringPrincipal,
+      aName,
+      aParams.csp,
+      aSkipLoad
+    );
+  },
+
+  canClose() {
+    return CanCloseWindow();
+  },
+
+  get tabCount() {
+    return gBrowser.tabs.length;
+  },
+};
+
+/* End copy into reference browser (minimal-browser.js) */
+
+/* Start copy into reference browser (minimal-browser.js) */
+
+function CanCloseWindow() {
+  // Avoid redundant calls to canClose from showing multiple
+  // PermitUnload dialogs.
+  if (Services.startup.shuttingDown || window.skipNextCanClose) {
+    return true;
+  }
+
+  for (let browser of gBrowser.browsers) {
+    // Don't instantiate lazy browsers.
+    if (!browser.isConnected) {
+      continue;
+    }
+
+    let { permitUnload } = browser.permitUnload();
+    if (!permitUnload) {
+      return false;
+    }
+  }
+  return true;
+}
+
+function WindowIsClosing() {
+  if (!closeWindow(false, warnAboutClosingWindow)) {
+    return false;
+  }
+
+  // In theory we should exit here and the Window's internal Close
+  // method should trigger canClose on nsBrowserAccess. However, by
+  // that point it's too late to be able to show a prompt for
+  // PermitUnload. So we do it here, when we still can.
+  if (CanCloseWindow()) {
+    // This flag ensures that the later canClose call does nothing.
+    // It's only needed to make tests pass, since they detect the
+    // prompt even when it's not actually shown.
+    window.skipNextCanClose = true;
+    return true;
+  }
+
+  return false;
+}
+
+/**
+ * Checks if this is the last full *browser* window around. If it is, this will
+ * be communicated like quitting. Otherwise, we warn about closing multiple tabs.
+ * @returns true if closing can proceed, false if it got cancelled.
+ */
+function warnAboutClosingWindow() {
+  // Popups aren't considered full browser windows; we also ignore private windows.
+  let isPBWindow =
+    PrivateBrowsingUtils.isWindowPrivate(window) &&
+    !PrivateBrowsingUtils.permanentPrivateBrowsing;
+
+  let closingTabs = gBrowser.tabs.length - gBrowser._removingTabs.length;
+
+  if (!isPBWindow && !toolbar.visible) {
+    return gBrowser.warnAboutClosingTabs(
+      closingTabs,
+      gBrowser.closingTabsEnum.ALL
+    );
+  }
+
+  // Figure out if there's at least one other browser window around.
+  let otherPBWindowExists = false;
+  let otherWindowExists = false;
+  for (let win of browserWindows()) {
+    if (!win.closed && win != window) {
+      otherWindowExists = true;
+      if (isPBWindow && PrivateBrowsingUtils.isWindowPrivate(win)) {
+        otherPBWindowExists = true;
+      }
+      // If the current window is not in private browsing mode we don't need to
+      // look for other pb windows, we can leave the loop when finding the
+      // first non-popup window. If however the current window is in private
+      // browsing mode then we need at least one other pb and one non-popup
+      // window to break out early.
+      if (!isPBWindow || otherPBWindowExists) {
+        break;
+      }
+    }
+  }
+
+  if (isPBWindow && !otherPBWindowExists) {
+    let exitingCanceled = Cc["@mozilla.org/supports-PRBool;1"].createInstance(
+      Ci.nsISupportsPRBool
+    );
+    exitingCanceled.data = false;
+    Services.obs.notifyObservers(exitingCanceled, "last-pb-context-exiting");
+    if (exitingCanceled.data) {
+      return false;
+    }
+  }
+
+  if (otherWindowExists) {
+    return (
+      isPBWindow ||
+      gBrowser.warnAboutClosingTabs(closingTabs, gBrowser.closingTabsEnum.ALL)
+    );
+  }
+
+  let os = Services.obs;
+
+  let closingCanceled = Cc["@mozilla.org/supports-PRBool;1"].createInstance(
+    Ci.nsISupportsPRBool
+  );
+  os.notifyObservers(closingCanceled, "browser-lastwindow-close-requested");
+  if (closingCanceled.data) {
+    return false;
+  }
+
+  os.notifyObservers(null, "browser-lastwindow-close-granted");
+
+  // OS X doesn't quit the application when the last window is closed, but keeps
+  // the session alive. Hence don't prompt users to save tabs, but warn about
+  // closing multiple tabs.
+  return (
+    AppConstants.platform != "macosx" ||
+    isPBWindow ||
+    gBrowser.warnAboutClosingTabs(closingTabs, gBrowser.closingTabsEnum.ALL)
+  );
+}
+/* End copy into reference browser (minimal-browser.js) */
+
+// Todo: what is this used for? It seems to only be accessed in tests
+window.browserDOMWindow = new nsBrowserAccess();
+window.addEventListener("AppCommand", HandleAppCommandEvent, true);
diff --git a/browser/tools/geckoreference/jar.mn b/browser/tools/geckoreference/jar.mn
new file mode 100644
--- /dev/null
+++ b/browser/tools/geckoreference/jar.mn
@@ -0,0 +1,9 @@
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+browser.jar:
+*   content/browser/geckoreference/geckoreference.xhtml (content/geckoreference.xhtml)
+    content/browser/geckoreference/geckoreference.css (content/geckoreference.css)
+    content/browser/geckoreference/geckoreference.js (content/geckoreference.js)
+    content/browser/geckoreference/minimal-browser.js (content/minimal-browser.js)
diff --git a/browser/tools/geckoreference/moz.build b/browser/tools/geckoreference/moz.build
new file mode 100644
--- /dev/null
+++ b/browser/tools/geckoreference/moz.build
@@ -0,0 +1,7 @@
+# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+JAR_MANIFESTS += ["jar.mn"]
