# HG changeset patch
# Parent 9b1b17c33d72893cbc34dce3c03f517e31f085e1
# User Patrick Brosset <pbrosset@mozilla.com>
Bug 916443 - Highlighter is remote and pick button is at toolbox level. NO TESTS, r=paul

diff --git a/browser/base/content/highlighter.css b/browser/base/content/highlighter.css
--- a/browser/base/content/highlighter.css
+++ b/browser/base/content/highlighter.css
@@ -1,20 +1,16 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
- 
+
 .highlighter-container {
   pointer-events: none;
 }
 
-.highlighter-controls {
-  position: relative;
-}
-
 .highlighter-outline-container {
   overflow: hidden;
   position: relative;
 }
 
 .highlighter-outline {
   position: absolute;
 }
@@ -29,75 +25,65 @@
   transition-property: opacity, top, left, width, height;
   transition-duration: 0.1s;
   transition-timing-function: linear;
 }
 
 /*
  * Node Infobar
  */
+.highlighter-nodeinfobar-container {
+  position: relative;
+}
 
-.highlighter-nodeinfobar-container {
+.highlighter-nodeinfobar-positioner {
   position: absolute;
   max-width: 95%;
 }
 
-.highlighter-nodeinfobar-container[hidden] {
+.highlighter-nodeinfobar-positioner[hidden] {
   opacity: 0;
   pointer-events: none;
   display: -moz-box;
 }
 
-.highlighter-nodeinfobar-container:not([disable-transitions]),
-.highlighter-nodeinfobar-container[disable-transitions][force-transitions] {
+.highlighter-nodeinfobar-positioner:not([disable-transitions]),
+.highlighter-nodeinfobar-positioner[disable-transitions][force-transitions] {
   transition-property: transform, opacity, top, left;
   transition-duration: 0.1s;
   transition-timing-function: linear;
 }
 
 .highlighter-nodeinfobar-text {
   overflow: hidden;
   white-space: nowrap;
   text-overflow: ellipsis;
   direction: ltr;
 }
 
-.highlighter-nodeinfobar-button > .toolbarbutton-text {
-  display: none;
-}
-
-.highlighter-nodeinfobar-container:not([locked]):not(:hover) > .highlighter-nodeinfobar > .highlighter-nodeinfobar-button {
-  visibility: hidden;
-}
-
-.highlighter-nodeinfobar-container[locked] > .highlighter-nodeinfobar,
-.highlighter-nodeinfobar-container:not([locked]):hover > .highlighter-nodeinfobar {
-  pointer-events: auto;
-}
-
 html|*.highlighter-nodeinfobar-id,
 html|*.highlighter-nodeinfobar-classes,
 html|*.highlighter-nodeinfobar-pseudo-classes,
 html|*.highlighter-nodeinfobar-tagname {
   -moz-user-select: text;
   -moz-user-focus: normal;
   cursor: text;
 }
 
 .highlighter-nodeinfobar-arrow {
   display: none;
 }
 
-.highlighter-nodeinfobar-container[position="top"]:not([hide-arrow]) > .highlighter-nodeinfobar-arrow-bottom {
+.highlighter-nodeinfobar-positioner[position="top"]:not([hide-arrow]) > .highlighter-nodeinfobar-arrow-bottom {
   display: block;
 }
 
-.highlighter-nodeinfobar-container[position="bottom"]:not([hide-arrow]) > .highlighter-nodeinfobar-arrow-top {
+.highlighter-nodeinfobar-positioner[position="bottom"]:not([hide-arrow]) > .highlighter-nodeinfobar-arrow-top {
   display: block;
 }
 
-.highlighter-nodeinfobar-container[disabled] {
+.highlighter-nodeinfobar-positioner[disabled] {
   visibility: hidden;
 }
 
 html|*.highlighter-nodeinfobar-tagname {
   text-transform: lowercase;
 }
diff --git a/browser/devtools/fontinspector/font-inspector.js b/browser/devtools/fontinspector/font-inspector.js
--- a/browser/devtools/fontinspector/font-inspector.js
+++ b/browser/devtools/fontinspector/font-inspector.js
@@ -15,22 +15,18 @@ function FontInspector(inspector, window
   this.chromeDoc = window.document;
   this.init();
 }
 
 FontInspector.prototype = {
   init: function FI_init() {
     this.update = this.update.bind(this);
     this.onNewNode = this.onNewNode.bind(this);
-    this.onHighlighterLocked = this.onHighlighterLocked.bind(this);
     this.inspector.selection.on("new-node", this.onNewNode);
     this.inspector.sidebar.on("fontinspector-selected", this.onNewNode);
-    if (this.inspector.highlighter) {
-      this.inspector.highlighter.on("locked", this.onHighlighterLocked);
-    }
     this.update();
   },
 
   /**
    * Is the fontinspector visible in the sidebar?
    */
   isActive: function FI_isActive() {
     return this.inspector.sidebar &&
@@ -39,46 +35,34 @@ FontInspector.prototype = {
 
   /**
    * Remove listeners.
    */
   destroy: function FI_destroy() {
     this.chromeDoc = null;
     this.inspector.sidebar.off("layoutview-selected", this.onNewNode);
     this.inspector.selection.off("new-node", this.onNewNode);
-    if (this.inspector.highlighter) {
-      this.inspector.highlighter.off("locked", this.onHighlighterLocked);
-    }
   },
 
   /**
    * Selection 'new-node' event handler.
    */
   onNewNode: function FI_onNewNode() {
     if (this.isActive() &&
         this.inspector.selection.isLocal() &&
         this.inspector.selection.isConnected() &&
-        this.inspector.selection.isElementNode() &&
-        this.inspector.selection.reason != "highlighter") {
+        this.inspector.selection.isElementNode()) {
       this.undim();
       this.update();
     } else {
       this.dim();
     }
   },
 
   /**
-   * Highlighter 'locked' event handler
-   */
-  onHighlighterLocked: function FI_onHighlighterLocked() {
-    this.undim();
-    this.update();
-  },
-
-  /**
    * Hide the font list. No node are selected.
    */
   dim: function FI_dim() {
     this.chromeDoc.body.classList.add("dim");
     this.chromeDoc.querySelector("#all-fonts").innerHTML = "";
   },
 
   /**
@@ -205,17 +189,17 @@ FontInspector.prototype = {
    * Select the <body> to show all the fonts included in the document.
    */
   showAll: function FI_showAll() {
     if (!this.isActive() ||
         !this.inspector.selection.isConnected() ||
         !this.inspector.selection.isElementNode()) {
       return;
     }
-    let node = this.inspector.selection.node;
+    let node = this.inspector.selection.nodeFront;
     let contentDocument = node.ownerDocument;
     let root = contentDocument.documentElement;
     if (contentDocument.body) {
       root = contentDocument.body;
     }
     this.inspector.selection.setNode(root, "fontinspector");
   },
 }
diff --git a/browser/devtools/framework/selection.js b/browser/devtools/framework/selection.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/framework/selection.js
@@ -0,0 +1,296 @@
+/* -*- Mode: Javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+const {Cu, Ci} = require("chrome");
+let EventEmitter = require("devtools/shared/event-emitter");
+
+/**
+ * API
+ *
+ *   new Selection(walker=null, node=null, track={attributes,detached});
+ *   destroy()
+ *   node (readonly)
+ *   setNode(node, origin="unknown")
+ *
+ * Helpers:
+ *
+ *   window
+ *   document
+ *   isRoot()
+ *   isNode()
+ *   isHTMLNode()
+ *
+ * Check the nature of the node:
+ *
+ *   isElementNode()
+ *   isAttributeNode()
+ *   isTextNode()
+ *   isCDATANode()
+ *   isEntityRefNode()
+ *   isEntityNode()
+ *   isProcessingInstructionNode()
+ *   isCommentNode()
+ *   isDocumentNode()
+ *   isDocumentTypeNode()
+ *   isDocumentFragmentNode()
+ *   isNotationNode()
+ *
+ * Events:
+ *   "new-node" when the inner node changed
+ *   "before-new-node" when the inner node is set to change
+ *   "attribute-changed" when an attribute is changed (only if tracked)
+ *   "detached" when the node (or one of its parents) is removed from the document (only if tracked)
+ *   "reparented" when the node (or one of its parents) is moved under a different node (only if tracked)
+ */
+
+/**
+ * A Selection object. Hold a reference to a node.
+ * Includes some helpers, fire some helpful events.
+ *
+ * @param node Inner node.
+ *    Can be null. Can be (un)set in the future via the "node" property;
+ * @param trackAttribute Tell if events should be fired when the attributes of
+ *    the node change.
+ *
+ */
+function Selection(walker, node=null, track={attributes:true,detached:true}) {
+  EventEmitter.decorate(this);
+
+  this._onMutations = this._onMutations.bind(this);
+  this.track = track;
+  this.setWalker(walker);
+  this.setNode(node);
+}
+
+exports.Selection = Selection;
+
+Selection.prototype = {
+  _walker: null,
+  _node: null,
+
+  _onMutations: function(mutations) {
+    let attributeChange = false;
+    let pseudoChange = false;
+    let detached = false;
+    let parentNode = null;
+
+    for (let m of mutations) {
+      if (!attributeChange && m.type == "attributes") {
+        attributeChange = true;
+      }
+      if (m.type == "childList") {
+        if (!detached && !this.isConnected()) {
+          if (this.isNode()) {
+            parentNode = m.target;
+          }
+          detached = true;
+        }
+      }
+      if (m.type == "pseudoClassLock") {
+        pseudoChange = true;
+      }
+    }
+
+    // Fire our events depending on what changed in the mutations array
+    if (attributeChange) {
+      this.emit("attribute-changed");
+    }
+    if (pseudoChange) {
+      this.emit("pseudoclass");
+    }
+    if (detached) {
+      let rawNode = null;
+      if (parentNode && parentNode.isLocal_toBeDeprecated()) {
+        rawNode = parentNode.rawNode();
+      }
+
+      this.emit("detached", rawNode, null);
+      this.emit("detached-front", parentNode);
+    }
+  },
+
+  destroy: function() {
+    this.setNode(null);
+    this.setWalker(null);
+  },
+
+  setWalker: function(walker) {
+    if (this._walker) {
+      this._walker.off("mutations", this._onMutations);
+    }
+    this._walker = walker;
+    if (this._walker) {
+      this._walker.on("mutations", this._onMutations);
+    }
+  },
+
+  // Not remote-safe
+  setNode: function(value, reason="unknown") {
+    if (value) {
+      value = this._walker.frontForRawNode(value);
+    }
+    this.setNodeFront(value, reason);
+  },
+
+  // Not remote-safe
+  get node() {
+    return this._node;
+  },
+
+  // Not remote-safe
+  get window() {
+    if (this.isNode()) {
+      return this.node.ownerDocument.defaultView;
+    }
+    return null;
+  },
+
+  // Not remote-safe
+  get document() {
+    if (this.isNode()) {
+      return this.node.ownerDocument;
+    }
+    return null;
+  },
+
+  setNodeFront: function(value, reason="unknown") {
+    this.reason = reason;
+    if (value !== this._nodeFront) {
+      let rawValue = null;
+      if (value && value.isLocal_toBeDeprecated()) {
+        rawValue = value.rawNode();
+      }
+      this.emit("before-new-node", rawValue, reason);
+      this.emit("before-new-node-front", value, reason);
+      let previousNode = this._node;
+      let previousFront = this._nodeFront;
+      this._node = rawValue;
+      this._nodeFront = value;
+      this.emit("new-node", previousNode, this.reason);
+      this.emit("new-node-front", value, this.reason);
+    }
+  },
+
+  get documentFront() {
+    return this._walker.document(this._nodeFront);
+  },
+
+  get nodeFront() {
+    return this._nodeFront;
+  },
+
+  isRoot: function() {
+    return this.isNode() &&
+           this.isConnected() &&
+           this._nodeFront.isDocumentElement;
+  },
+
+  isNode: function() {
+    if (!this._nodeFront) {
+      return false;
+    }
+
+    // As long as tools are still accessing node.rawNode(),
+    // this needs to stay here.
+    if (this._node && Cu.isDeadWrapper(this._node)) {
+      return false;
+    }
+
+    return true;
+  },
+
+  isLocal: function() {
+    return !!this._node;
+  },
+
+  isConnected: function() {
+    let node = this._nodeFront;
+    if (!node || !node.actorID) {
+      return false;
+    }
+
+    // As long as there are still tools going around
+    // accessing node.rawNode, this needs to stay.
+    let rawNode = null;
+    if (node.isLocal_toBeDeprecated()) {
+      rawNode = node.rawNode();
+    }
+    if (rawNode) {
+      try {
+        let doc = this.document;
+        return (doc && doc.defaultView && doc.documentElement.contains(rawNode));
+      } catch (e) {
+        // "can't access dead object" error
+        return false;
+      }
+    }
+
+    while(node) {
+      if (node === this._walker.rootNode) {
+        return true;
+      }
+      node = node.parentNode();
+    };
+    return false;
+  },
+
+  isHTMLNode: function() {
+    let xhtml_ns = "http://www.w3.org/1999/xhtml";
+    return this.isNode() && this.node.namespaceURI == xhtml_ns;
+  },
+
+  // Node type
+
+  isElementNode: function() {
+    return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.ELEMENT_NODE;
+  },
+
+  isAttributeNode: function() {
+    return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.ATTRIBUTE_NODE;
+  },
+
+  isTextNode: function() {
+    return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.TEXT_NODE;
+  },
+
+  isCDATANode: function() {
+    return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.CDATA_SECTION_NODE;
+  },
+
+  isEntityRefNode: function() {
+    return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.ENTITY_REFERENCE_NODE;
+  },
+
+  isEntityNode: function() {
+    return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.ENTITY_NODE;
+  },
+
+  isProcessingInstructionNode: function() {
+    return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.PROCESSING_INSTRUCTION_NODE;
+  },
+
+  isCommentNode: function() {
+    return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.PROCESSING_INSTRUCTION_NODE;
+  },
+
+  isDocumentNode: function() {
+    return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.DOCUMENT_NODE;
+  },
+
+  isDocumentTypeNode: function() {
+    return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.DOCUMENT_TYPE_NODE;
+  },
+
+  isDocumentFragmentNode: function() {
+    return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.DOCUMENT_FRAGMENT_NODE;
+  },
+
+  isNotationNode: function() {
+    return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.NOTATION_NODE;
+  },
+};
diff --git a/browser/devtools/framework/toolbox.js b/browser/devtools/framework/toolbox.js
--- a/browser/devtools/framework/toolbox.js
+++ b/browser/devtools/framework/toolbox.js
@@ -3,16 +3,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 "use strict";
 
 const MAX_ORDINAL = 99;
 const ZOOM_PREF = "devtools.toolbox.zoomValue";
 const MIN_ZOOM = 0.5;
 const MAX_ZOOM = 2;
+const HIGHLIGHTER_PICKED_TIMER = 1000;
 
 let {Cc, Ci, Cu} = require("chrome");
 let promise = require("sdk/core/promise");
 let EventEmitter = require("devtools/shared/event-emitter");
 let Telemetry = require("devtools/shared/telemetry");
 let HUDService = require("devtools/webconsole/hudservice");
 
 Cu.import("resource://gre/modules/XPCOMUtils.jsm");
@@ -40,16 +41,19 @@ loader.lazyGetter(this, "toolboxStrings"
 });
 
 loader.lazyGetter(this, "Requisition", () => {
   let {require} = Cu.import("resource://gre/modules/devtools/Require.jsm", {});
   Cu.import("resource://gre/modules/devtools/gcli.jsm", {});
   return require("gcli/cli").Requisition;
 });
 
+loader.lazyGetter(this, "Selection", () => require("devtools/framework/selection").Selection);
+loader.lazyGetter(this, "InspectorFront", () => require("devtools/server/actors/inspector").InspectorFront);
+
 /**
  * A "Toolbox" is the component that holds all the tools for one specific
  * target. Visually, it's a document that includes the tools tabs and all
  * the iframes where the tool panels will be living in.
  *
  * @param {object} target
  *        The object the toolbox is debugging.
  * @param {string} selectedTool
@@ -178,16 +182,52 @@ Toolbox.prototype = {
   /**
    * Get current zoom level of toolbox
    */
   get zoomValue() {
     return parseFloat(Services.prefs.getCharPref(ZOOM_PREF));
   },
 
   /**
+   * Get the toolbox highlighter front. Note that it may not always have been
+   * initialized first. Use `initInspector()` if needed.
+   */
+  get highlighter() {
+    if (this.isRemoteHighlightable) {
+      return this._highlighter;
+    } else {
+      return null;
+    }
+  },
+
+  /**
+   * Get the toolbox's inspector front. Note that it may not always have been
+   * initialized first. Use `initInspector()` if needed.
+   */
+  get inspector() {
+    return this._inspector;
+  },
+
+  /**
+   * Get the toolbox's walker front. Note that it may not always have been
+   * initialized first. Use `initInspector()` if needed.
+   */
+  get walker() {
+    return this._walker;
+  },
+
+  /**
+   * Get the toolbox's node selection. Note that it may not always have been
+   * initialized first. Use `initInspector()` if needed.
+   */
+  get selection() {
+    return this._selection;
+  },
+
+  /**
    * Get the toggled state of the split console
    */
   get splitConsole() {
     return this._splitConsole;
   },
 
   /**
    * Open the toolbox
@@ -208,21 +248,24 @@ Toolbox.prototype = {
         this._buildOptions();
         this._buildTabs();
         this._buildButtons();
         this._addKeysToWindow();
         this._addToolSwitchingKeys();
         this._addZoomKeys();
         this._loadInitialZoom();
 
-        this._telemetry.toolOpened("toolbox");
+        // Load the toolbox-level actor fronts and utilities now
+        this._target.makeRemote().then(() => {
+          this._telemetry.toolOpened("toolbox");
 
-        this.selectTool(this._defaultToolId).then(panel => {
-          this.emit("ready");
-          deferred.resolve();
+          this.selectTool(this._defaultToolId).then(panel => {
+            this.emit("ready");
+            deferred.resolve();
+          });
         });
       };
 
       iframe.setAttribute("src", this._URL);
 
       let domHelper = new DOMHelpers(iframe.contentWindow);
       domHelper.onceDOMReady(domReady);
 
@@ -409,17 +452,16 @@ Toolbox.prototype = {
       key.setAttribute("oncommand", "void(0)"); // needed. See bug 371900
       key.addEventListener("command", () => {
         HUDService.toggleBrowserConsole();
       }, true);
       doc.getElementById("toolbox-keyset").appendChild(key);
     }
   },
 
-
   /**
    * Handle any custom key events.  Returns true if there was a custom key binding run
    * @param {string} toolId
    *        Which tool to run the command on (skip if not current)
    */
   fireCustomKey: function(toolId) {
     let toolDefinition = gDevTools.getToolDefinition(toolId);
 
@@ -478,33 +520,52 @@ Toolbox.prototype = {
    */
   _buildTabs: function() {
     for (let definition of gDevTools.getToolDefinitionArray()) {
       this._buildTabForTool(definition);
     }
   },
 
   /**
-   * Add buttons to the UI as specified in the devtools.window.toolbarSpec pref
+   * Add buttons to the UI as specified in the devtools.toolbox.toolbarSpec pref
    */
   _buildButtons: function() {
+    this._buildPickerButton();
+
     if (!this.target.isLocalTab) {
       return;
     }
 
     let spec = CommandUtils.getCommandbarSpec("devtools.toolbox.toolbarSpec");
     let env = CommandUtils.createEnvironment(this.target.tab.ownerDocument,
                                              this.target.window.document);
     let req = new Requisition(env);
     let buttons = CommandUtils.createButtons(spec, this._target, this.doc, req);
     let container = this.doc.getElementById("toolbox-buttons");
     buttons.forEach(container.appendChild.bind(container));
   },
 
   /**
+   * Adding the element picker button is done here unlike the other buttons
+   * since we want it to work for remote targets too
+   */
+  _buildPickerButton: function() {
+    this._pickerButton = this.doc.createElement("toolbarbutton");
+    this._pickerButton.id = "command-button-pick";
+    this._pickerButton.className = "command-button";
+    this._pickerButton.setAttribute("tooltiptext", toolboxStrings("pickButton.tooltip"));
+
+    let container = this.doc.querySelector("#toolbox-buttons");
+    container.appendChild(this._pickerButton);
+
+    this.togglePicker = this.togglePicker.bind(this);
+    this._pickerButton.addEventListener("command", this.togglePicker, false);
+  },
+
+  /**
    * Build a tab for one tool definition and add to the toolbox
    *
    * @param {string} toolDefinition
    *        Tool definition of the tool to build a tab for.
    */
   _buildTabForTool: function(toolDefinition) {
     if (!toolDefinition.isTargetSupported(this._target)) {
       return;
@@ -593,16 +654,22 @@ Toolbox.prototype = {
 
   /**
    * Ensure the tool with the given id is loaded.
    *
    * @param {string} id
    *        The id of the tool to load.
    */
   loadTool: function(id) {
+    if (id === "inspector" && !this._inspector) {
+      return this.initInspector().then(() => {
+        return this.loadTool(id);
+      });
+    }
+
     let deferred = promise.defer();
     let iframe = this.doc.getElementById("toolbox-panel-iframe-" + id);
 
     if (iframe) {
       let panel = this._toolPanels.get(id);
       if (panel) {
         deferred.resolve(panel);
       } else {
@@ -951,16 +1018,156 @@ Toolbox.prototype = {
       let key = doc.getElementById("key_" + toolId);
       if (key) {
         key.parentNode.removeChild(key);
       }
     }
   },
 
   /**
+   * Initialize the inspector/walker/selection/highlighter fronts.
+   * Returns a promise that resolves when the fronts are initialized
+   */
+  initInspector: function() {
+    let deferred = promise.defer();
+
+    if (!this._inspector) {
+      this._inspector = InspectorFront(this._target.client, this._target.form);
+      this._inspector.getWalker().then(walker => {
+        this._walker = walker;
+        this._selection = new Selection(this._walker);
+        this._inspector.getHighlighter().then(highlighter => {
+          this._highlighter = highlighter;
+          deferred.resolve();
+        });
+      });
+    } else {
+      deferred.resolve();
+    }
+
+    return deferred.promise;
+  },
+
+  /**
+   * Destroy the inspector/walker/selection fronts
+   * Returns a promise that resolves when the fronts are destroyed
+   */
+  destroyInspector: function() {
+    let deferred = promise.defer();
+
+    if (this._inspector) {
+      this._selection.destroy();
+      this._selection = null;
+      this._walker.release().then(() => {
+        this._inspector.destroy();
+        this._highlighter.destroy();
+      }).then(() => {
+        this._inspector = null;
+        this._walker = null;
+        deferred.resolve();
+      });
+    } else {
+      deferred.resolve();
+    }
+
+    return deferred.promise;
+  },
+
+  /**
+   * Start/stop the element picker on the debuggee target.
+   */
+  togglePicker: function() {
+    if (this._isPicking) {
+      return this.stopPicker();
+    } else {
+      return this.startPicker();
+    }
+  },
+
+  /**
+   * Start the element picker on the debuggee target.
+   * This will request the inspector actor to start listening for mouse/touch
+   * events on the target to highlight the hovered/picked element.
+   * Depending on the server-side capabilities, this may fire events when nodes
+   * are hovered.
+   * @return A promise that resolves when the picker has started
+   */
+  startPicker: function() {
+    let deferred = promise.defer();
+
+    let done = () => {
+      this.emit("picker-started");
+      deferred.resolve();
+    };
+
+    this.initInspector().then(() => {
+      this._isPicking = true;
+      this._pickerButton.setAttribute("checked", "true");
+
+      if (this.isRemoteHighlightable) {
+        this.walker.pick2().then(done);
+        this._onPickerNodeHovered = res => {
+          this.highlighter.showBoxModel(res.node).then(() => {
+            this.emit("picker-node-hovered", res.node);
+          });
+        };
+        this.walker.on("picker-node-hovered", this._onPickerNodeHovered);
+        this._onPickerNodePicked = res => {
+          this.selection.setNodeFront(res.node, "picker-node-picked");
+          this.stopPicker();
+        };
+        this.walker.on("picker-node-picked", this._onPickerNodePicked);
+      } else {
+        this.walker.pick().then(node => {
+          this.selection.setNodeFront(node, "picker-node-picked");
+          this.stopPicker();
+        });
+        done();
+      }
+    });
+
+    return deferred.promise;
+  },
+
+  get isRemoteHighlightable() {
+    return this._target.client.traits.highlightable;
+  },
+
+  /**
+   * Stop the element picker
+   * @return A promise that resolves when the picker has stopped
+   */
+  stopPicker: function() {
+    let deferred = promise.defer();
+
+    let done = () => {
+      this.emit("picker-stopped");
+      deferred.resolve();
+    };
+
+    this.initInspector().then(() => {
+      this._isPicking = false;
+      this._pickerButton.removeAttribute("checked");
+      if (this.isRemoteHighlightable) {
+        this.walker.cancelPick2().then(() => {
+          this.doc.defaultView.setTimeout(() => {
+            this.highlighter.hideBoxModel().then(done);
+          }, HIGHLIGHTER_PICKED_TIMER);
+        });
+        this.walker.off("picker-node-hovered", this._onPickerNodeHovered);
+        this.walker.off("picker-node-picked", this._onPickerNodePicked);
+      } else {
+        this.walker.cancelPick().then(done);
+      }
+    });
+
+    return deferred.promise;
+  },
+
+  /**
    * Get the toolbox's notification box
    *
    * @return The notification box element.
    */
   getNotificationBox: function() {
     return this.doc.getElementById("toolbox-notificationbox");
   },
 
@@ -997,25 +1204,38 @@ Toolbox.prototype = {
     if (typeof this._origAllowJavascript != "undefined") {
       let docShell = this._host.hostTab.linkedBrowser.docShell;
       docShell.allowJavascript = this._origAllowJavascript;
       this._origAllowJavascript = undefined;
     }
 
     let outstanding = [];
 
+    // Destroying each panel
     for (let [id, panel] of this._toolPanels) {
       try {
         outstanding.push(panel.destroy());
       } catch (e) {
         // We don't want to stop here if any panel fail to close.
         console.error(e);
       }
     }
 
+    // Destroying the walker and inspector fronts
+    outstanding.push(this.destroyInspector());
+
+    // Destroying the highlighter. Note that if the server connection has
+    // already been cut (closing browser), this will send a noSuchActor message
+    // but we don't want this to prevent the rest of the destroy process to be
+    // carried out
+    // this.highlighter.finalize();
+
+    // Removing buttons
+    this._pickerButton.removeEventListener("command", this.togglePicker, false);
+    this._pickerButton = null;
     let container = this.doc.getElementById("toolbox-buttons");
     while (container.firstChild) {
       container.removeChild(container.firstChild);
     }
 
     outstanding.push(this.destroyHost());
 
     this._telemetry.destroy();
diff --git a/browser/devtools/inspector/highlighter.js b/browser/devtools/inspector/highlighter.js
deleted file mode 100644
--- a/browser/devtools/inspector/highlighter.js
+++ /dev/null
@@ -1,877 +0,0 @@
-/* -*- Mode: Javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-const {Cu, Cc, Ci} = require("chrome");
-
-Cu.import("resource://gre/modules/Services.jsm");
-Cu.import("resource://gre/modules/devtools/LayoutHelpers.jsm");
-Cu.import("resource://gre/modules/XPCOMUtils.jsm");
-
-let EventEmitter = require("devtools/shared/event-emitter");
-
-const PSEUDO_CLASSES = [":hover", ":active", ":focus"];
-  // add ":visited" and ":link" after bug 713106 is fixed
-
-exports._forceBasic = {value: false};
-
-exports.Highlighter = function Highlighter(aTarget, aInspector, aToolbox) {
-  if (aTarget.isLocalTab && !exports._forceBasic.value) {
-    return new LocalHighlighter(aTarget, aInspector, aToolbox);
-  } else {
-    return new BasicHighlighter(aTarget, aInspector, aToolbox);
-  }
-}
-
-exports.LocalHighlighter = LocalHighlighter;
-exports.BasicHighlighter = BasicHighlighter;
-
-/**
- * A highlighter mechanism.
- *
- * The highlighter is built dynamically into the browser element.
- * The caller is in charge of destroying the highlighter (ie, the highlighter
- * won't be destroyed if a new tab is selected for example).
- *
- * API:
- *
- *   // Constructor and destructor.
- *   Highlighter(aTab, aInspector)
- *   void destroy();
- *
- *   // Show and hide the highlighter
- *   void show();
- *   void hide();
- *   boolean isHidden();
- *
- *   // Redraw the highlighter if the visible portion of the node has changed.
- *   void invalidateSize(aScroll);
- *
- * Events:
- *
- *   "closed" - Highlighter is closing
- *   "highlighting" - Highlighter is highlighting
- *   "locked" - The selected node has been locked
- *   "unlocked" - The selected ndoe has been unlocked
- *
- * Structure:
- *  <stack class="highlighter-container">
- *    <box class="highlighter-outline-container">
- *      <box class="highlighter-outline" locked="true/false"/>
- *    </box>
- *    <box class="highlighter-controls">
- *      <box class="highlighter-nodeinfobar-container" position="top/bottom" locked="true/false">
- *        <box class="highlighter-nodeinfobar-arrow highlighter-nodeinfobar-arrow-top"/>
- *        <hbox class="highlighter-nodeinfobar">
- *          <toolbarbutton class="highlighter-nodeinfobar-inspectbutton highlighter-nodeinfobar-button"/>
- *          <hbox class="highlighter-nodeinfobar-text">tagname#id.class1.class2</hbox>
- *          <toolbarbutton class="highlighter-nodeinfobar-menu highlighter-nodeinfobar-button">â€¦</toolbarbutton>
- *        </hbox>
- *        <box class="highlighter-nodeinfobar-arrow highlighter-nodeinfobar-arrow-bottom"/>
- *      </box>
- *    </box>
- *  </stack>
- *
- */
-
-
-/**
- * Constructor.
- *
- * @param aTarget The inspection target.
- * @param aInspector Inspector panel.
- * @param aToolbox The toolbox holding the inspector.
- */
-function LocalHighlighter(aTarget, aInspector, aToolbox)
-{
-  this.target = aTarget;
-  this.tab = aTarget.tab;
-  this.toolbox = aToolbox;
-  this.browser = this.tab.linkedBrowser;
-  this.chromeDoc = this.tab.ownerDocument;
-  this.chromeWin = this.chromeDoc.defaultView;
-  this.inspector = aInspector
-  this.layoutHelpers = new LayoutHelpers(this.browser.contentWindow);
-
-  EventEmitter.decorate(this);
-
-  this._init();
-}
-
-LocalHighlighter.prototype = {
-  get selection() {
-    return this.inspector.selection;
-  },
-
-  _init: function LocalHighlighter__init()
-  {
-    this.toggleLockState = this.toggleLockState.bind(this);
-    this.unlockAndFocus = this.unlockAndFocus.bind(this);
-    this.updateInfobar = this.updateInfobar.bind(this);
-    this.highlight = this.highlight.bind(this);
-
-    let stack = this.browser.parentNode;
-    this.win = this.browser.contentWindow;
-    this._highlighting = false;
-
-    this.highlighterContainer = this.chromeDoc.createElement("stack");
-    this.highlighterContainer.className = "highlighter-container";
-
-    this.outline = this.chromeDoc.createElement("box");
-    this.outline.className = "highlighter-outline";
-
-    let outlineContainer = this.chromeDoc.createElement("box");
-    outlineContainer.appendChild(this.outline);
-    outlineContainer.className = "highlighter-outline-container";
-
-    // The controlsBox will host the different interactive
-    // elements of the highlighter (buttons, toolbars, ...).
-    let controlsBox = this.chromeDoc.createElement("box");
-    controlsBox.className = "highlighter-controls";
-    this.highlighterContainer.appendChild(outlineContainer);
-    this.highlighterContainer.appendChild(controlsBox);
-
-    // Insert the highlighter right after the browser
-    stack.insertBefore(this.highlighterContainer, stack.childNodes[1]);
-
-    this.buildInfobar(controlsBox);
-
-    this.transitionDisabler = null;
-    this.pageEventsMuter = null;
-
-    this.selection.on("new-node", this.highlight);
-    this.selection.on("new-node", this.updateInfobar);
-    this.selection.on("pseudoclass", this.updateInfobar);
-    this.selection.on("attribute-changed", this.updateInfobar);
-
-    this.onToolSelected = function(event, id) {
-      if (id != "inspector") {
-        this.chromeWin.clearTimeout(this.pageEventsMuter);
-        this.detachMouseListeners();
-        this.disabled = true;
-        this.hide();
-      } else {
-        if (!this.locked) {
-          this.attachMouseListeners();
-        }
-        this.disabled = false;
-        this.show();
-      }
-    }.bind(this);
-    this.toolbox.on("select", this.onToolSelected);
-
-    this.hidden = true;
-    this.highlight();
-  },
-
-  /**
-   * Destroy the nodes. Remove listeners.
-   */
-  destroy: function LocalHighlighter_destroy()
-  {
-    this.inspectButton.removeEventListener("command", this.unlockAndFocus);
-    this.inspectButton = null;
-
-    this.toolbox.off("select", this.onToolSelected);
-    this.toolbox = null;
-
-    this.selection.off("new-node", this.highlight);
-    this.selection.off("new-node", this.updateInfobar);
-    this.selection.off("pseudoclass", this.updateInfobar);
-    this.selection.off("attribute-changed", this.updateInfobar);
-
-    this.detachMouseListeners();
-    this.detachPageListeners();
-
-    this.chromeWin.clearTimeout(this.transitionDisabler);
-    this.chromeWin.clearTimeout(this.pageEventsMuter);
-    this.boundCloseEventHandler = null;
-    this._contentRect = null;
-    this._highlightRect = null;
-    this._highlighting = false;
-    this.outline = null;
-    this.nodeInfo = null;
-    this.highlighterContainer.parentNode.removeChild(this.highlighterContainer);
-    this.highlighterContainer = null;
-    this.win = null
-    this.browser = null;
-    this.chromeDoc = null;
-    this.chromeWin = null;
-    this.tabbrowser = null;
-
-    this.emit("closed");
-  },
-
-  /**
-   * Show the outline, and select a node.
-   */
-  highlight: function LocalHighlighter_highlight()
-  {
-    if (this.selection.reason != "highlighter") {
-      this.lock();
-    }
-
-    let canHighlightNode = this.selection.isNode() &&
-                          this.selection.isConnected() &&
-                          this.selection.isElementNode();
-
-    if (canHighlightNode) {
-      if (this.selection.reason != "navigateaway") {
-        this.disabled = false;
-      }
-      this.show();
-      this.updateInfobar();
-      this.invalidateSize();
-      if (!this._highlighting &&
-          this.selection.reason != "highlighter") {
-        this.layoutHelpers.scrollIntoViewIfNeeded(this.selection.node);
-      }
-    } else {
-      this.disabled = true;
-      this.hide();
-    }
-  },
-
-  /**
-   * Update the highlighter size and position.
-   */
-  invalidateSize: function LocalHighlighter_invalidateSize()
-  {
-    let canHiglightNode = this.selection.isNode() &&
-                          this.selection.isConnected() &&
-                          this.selection.isElementNode();
-
-    if (!canHiglightNode)
-      return;
-
-    // The highlighter runs locally while the selection runs remotely,
-    // so we can't quite trust the selection's isConnected to protect us
-    // here, do the check manually.
-    if (!this.selection.node ||
-        !this.selection.node.ownerDocument ||
-        !this.selection.node.ownerDocument.defaultView) {
-      return;
-    }
-
-    let clientRect = this.selection.node.getBoundingClientRect();
-    let rect = this.layoutHelpers.getDirtyRect(this.selection.node);
-    this.highlightRectangle(rect);
-
-    this.moveInfobar();
-
-    if (this._highlighting) {
-      this.showOutline();
-      this.emit("highlighting");
-    }
-  },
-
-  /**
-   * Show the highlighter if it has been hidden.
-   */
-  show: function() {
-    if (!this.hidden || this.disabled) return;
-    this.showOutline();
-    this.showInfobar();
-    this.computeZoomFactor();
-    this.attachPageListeners();
-    this.invalidateSize();
-    this.hidden = false;
-  },
-
-  /**
-   * Hide the highlighter, the outline and the infobar.
-   */
-  hide: function() {
-    if (this.hidden) return;
-    this.hideOutline();
-    this.hideInfobar();
-    this.detachPageListeners();
-    this.hidden = true;
-  },
-
-  /**
-   * Is the highlighter visible?
-   *
-   * @return boolean
-   */
-  isHidden: function() {
-    return this.hidden;
-  },
-
-  /**
-   * Lock a node. Stops the inspection.
-   */
-  lock: function() {
-    if (this.locked === true) return;
-    this.outline.setAttribute("locked", "true");
-    this.nodeInfo.container.setAttribute("locked", "true");
-    this.detachMouseListeners();
-    this.locked = true;
-    this.emit("locked");
-  },
-
-  /**
-   * Start inspecting.
-   * Unlock the current node (if any), and select any node being hovered.
-   */
-  unlock: function() {
-    if (this.locked === false) return;
-    this.outline.removeAttribute("locked");
-    this.nodeInfo.container.removeAttribute("locked");
-    this.attachMouseListeners();
-    this.locked = false;
-    if (this.selection.isElementNode() &&
-        this.selection.isConnected()) {
-      this.showOutline();
-    }
-    this.emit("unlocked");
-  },
-
-  /**
-   * Toggle between locked and unlocked
-   */
-  toggleLockState: function() {
-    if (this.locked) {
-      this.startNode = this.selection.node;
-      this.unlockAndFocus();
-    } else {
-      this.selection.setNode(this.startNode);
-      this.lock();
-    }
-  },
-
-  /**
-   * Focus the browser before unlocking.
-   */
-  unlockAndFocus: function LocalHighlighter_unlockAndFocus() {
-    if (this.locked === false) return;
-    this.chromeWin.focus();
-    this.unlock();
-  },
-
-  /**
-   * Hide the infobar
-   */
-   hideInfobar: function LocalHighlighter_hideInfobar() {
-     this.nodeInfo.container.setAttribute("force-transitions", "true");
-     this.nodeInfo.container.setAttribute("hidden", "true");
-   },
-
-  /**
-   * Show the infobar
-   */
-   showInfobar: function LocalHighlighter_showInfobar() {
-     this.nodeInfo.container.removeAttribute("hidden");
-     this.moveInfobar();
-     this.nodeInfo.container.removeAttribute("force-transitions");
-   },
-
-  /**
-   * Hide the outline
-   */
-   hideOutline: function LocalHighlighter_hideOutline() {
-     this.outline.setAttribute("hidden", "true");
-   },
-
-  /**
-   * Show the outline
-   */
-   showOutline: function LocalHighlighter_showOutline() {
-     if (this._highlighting)
-       this.outline.removeAttribute("hidden");
-   },
-
-  /**
-   * Build the node Infobar.
-   *
-   * <box class="highlighter-nodeinfobar-container">
-   *   <box class="highlighter-nodeinfobar-arrow-top"/>
-   *   <hbox class="highlighter-nodeinfobar">
-   *     <toolbarbutton class="highlighter-nodeinfobar-button highlighter-nodeinfobar-inspectbutton"/>
-   *     <hbox class="highlighter-nodeinfobar-text">
-   *       <xhtml:span class="highlighter-nodeinfobar-tagname"/>
-   *       <xhtml:span class="highlighter-nodeinfobar-id"/>
-   *       <xhtml:span class="highlighter-nodeinfobar-classes"/>
-   *       <xhtml:span class="highlighter-nodeinfobar-pseudo-classes"/>
-   *     </hbox>
-   *     <toolbarbutton class="highlighter-nodeinfobar-button highlighter-nodeinfobar-menu"/>
-   *   </hbox>
-   *   <box class="highlighter-nodeinfobar-arrow-bottom"/>
-   * </box>
-   *
-   * @param nsIDOMElement aParent
-   *        The container of the infobar.
-   */
-  buildInfobar: function LocalHighlighter_buildInfobar(aParent)
-  {
-    let container = this.chromeDoc.createElement("box");
-    container.className = "highlighter-nodeinfobar-container";
-    container.setAttribute("position", "top");
-    container.setAttribute("disabled", "true");
-
-    let nodeInfobar = this.chromeDoc.createElement("hbox");
-    nodeInfobar.className = "highlighter-nodeinfobar";
-
-    let arrowBoxTop = this.chromeDoc.createElement("box");
-    arrowBoxTop.className = "highlighter-nodeinfobar-arrow highlighter-nodeinfobar-arrow-top";
-
-    let arrowBoxBottom = this.chromeDoc.createElement("box");
-    arrowBoxBottom.className = "highlighter-nodeinfobar-arrow highlighter-nodeinfobar-arrow-bottom";
-
-    let tagNameLabel = this.chromeDoc.createElementNS("http://www.w3.org/1999/xhtml", "span");
-    tagNameLabel.className = "highlighter-nodeinfobar-tagname";
-
-    let idLabel = this.chromeDoc.createElementNS("http://www.w3.org/1999/xhtml", "span");
-    idLabel.className = "highlighter-nodeinfobar-id";
-
-    let classesBox = this.chromeDoc.createElementNS("http://www.w3.org/1999/xhtml", "span");
-    classesBox.className = "highlighter-nodeinfobar-classes";
-
-    let pseudoClassesBox = this.chromeDoc.createElementNS("http://www.w3.org/1999/xhtml", "span");
-    pseudoClassesBox.className = "highlighter-nodeinfobar-pseudo-classes";
-
-    // Add some content to force a better boundingClientRect down below.
-    pseudoClassesBox.textContent = "&nbsp;";
-
-    // Create buttons
-
-    this.inspectButton = this.chromeDoc.createElement("toolbarbutton");
-    this.inspectButton.className = "highlighter-nodeinfobar-button highlighter-nodeinfobar-inspectbutton"
-    let toolbarInspectButton = this.inspector.panelDoc.getElementById("inspector-inspect-toolbutton");
-    this.inspectButton.setAttribute("tooltiptext", toolbarInspectButton.getAttribute("tooltiptext"));
-    this.inspectButton.addEventListener("command", this.toggleLockState);
-
-    let nodemenu = this.chromeDoc.createElement("toolbarbutton");
-    nodemenu.setAttribute("type", "menu");
-    nodemenu.className = "highlighter-nodeinfobar-button highlighter-nodeinfobar-menu"
-    nodemenu.setAttribute("tooltiptext",
-                          this.strings.GetStringFromName("nodeMenu.tooltiptext"));
-
-    nodemenu.onclick = function() {
-      this.inspector.showNodeMenu(nodemenu, "after_start");
-    }.bind(this);
-
-    // <hbox class="highlighter-nodeinfobar-text"/>
-    let texthbox = this.chromeDoc.createElement("hbox");
-    texthbox.className = "highlighter-nodeinfobar-text";
-    texthbox.setAttribute("align", "center");
-    texthbox.setAttribute("flex", "1");
-
-    texthbox.addEventListener("mousedown", function(aEvent) {
-      // On click, show the node:
-      if (this.selection.isElementNode()) {
-        this.layoutHelpers.scrollIntoViewIfNeeded(this.selection.node);
-      }
-    }.bind(this), true);
-
-    texthbox.appendChild(tagNameLabel);
-    texthbox.appendChild(idLabel);
-    texthbox.appendChild(classesBox);
-    texthbox.appendChild(pseudoClassesBox);
-
-    nodeInfobar.appendChild(this.inspectButton);
-    nodeInfobar.appendChild(texthbox);
-    nodeInfobar.appendChild(nodemenu);
-
-    container.appendChild(arrowBoxTop);
-    container.appendChild(nodeInfobar);
-    container.appendChild(arrowBoxBottom);
-
-    aParent.appendChild(container);
-
-    let barHeight = container.getBoundingClientRect().height;
-
-    this.nodeInfo = {
-      tagNameLabel: tagNameLabel,
-      idLabel: idLabel,
-      classesBox: classesBox,
-      pseudoClassesBox: pseudoClassesBox,
-      container: container,
-      barHeight: barHeight,
-    };
-  },
-
-  /**
-   * Highlight a rectangular region.
-   *
-   * @param object aRect
-   *        The rectangle region to highlight.
-   * @returns boolean
-   *          True if the rectangle was highlighted, false otherwise.
-   */
-  highlightRectangle: function LocalHighlighter_highlightRectangle(aRect)
-  {
-    if (!aRect) {
-      this.unhighlight();
-      return;
-    }
-
-    let oldRect = this._contentRect;
-
-    if (oldRect && aRect.top == oldRect.top && aRect.left == oldRect.left &&
-        aRect.width == oldRect.width && aRect.height == oldRect.height) {
-      return; // same rectangle
-    }
-
-    let aRectScaled = this.layoutHelpers.getZoomedRect(this.win, aRect);
-
-    if (aRectScaled.left >= 0 && aRectScaled.top >= 0 &&
-        aRectScaled.width > 0 && aRectScaled.height > 0) {
-
-      this.showOutline();
-
-      // The bottom div and the right div are flexibles (flex=1).
-      // We don't need to resize them.
-      let top = "top:" + aRectScaled.top + "px;";
-      let left = "left:" + aRectScaled.left + "px;";
-      let width = "width:" + aRectScaled.width + "px;";
-      let height = "height:" + aRectScaled.height + "px;";
-      this.outline.setAttribute("style", top + left + width + height);
-
-      this._highlighting = true;
-    } else {
-      this.unhighlight();
-    }
-
-    this._contentRect = aRect; // save orig (non-scaled) rect
-    this._highlightRect = aRectScaled; // and save the scaled rect.
-
-    return;
-  },
-
-  /**
-   * Clear the highlighter surface.
-   */
-  unhighlight: function LocalHighlighter_unhighlight()
-  {
-    this._highlighting = false;
-    this.hideOutline();
-  },
-
-  /**
-   * Update node information (tagName#id.class)
-   */
-  updateInfobar: function LocalHighlighter_updateInfobar()
-  {
-    if (!this.selection.isElementNode()) {
-      this.nodeInfo.tagNameLabel.textContent = "";
-      this.nodeInfo.idLabel.textContent = "";
-      this.nodeInfo.classesBox.textContent = "";
-      this.nodeInfo.pseudoClassesBox.textContent = "";
-      return;
-    }
-
-    let node = this.selection.node;
-
-    // Tag name
-    this.nodeInfo.tagNameLabel.textContent = node.tagName;
-
-    // ID
-    this.nodeInfo.idLabel.textContent = node.id ? "#" + node.id : "";
-
-    // Classes
-    let classes = this.nodeInfo.classesBox;
-
-    classes.textContent = node.classList.length ?
-                            "." + Array.join(node.classList, ".") : "";
-
-    // Pseudo-classes
-    let pseudos = PSEUDO_CLASSES.filter(function(pseudo) {
-      return DOMUtils.hasPseudoClassLock(node, pseudo);
-    }, this);
-
-    let pseudoBox = this.nodeInfo.pseudoClassesBox;
-    pseudoBox.textContent = pseudos.join("");
-  },
-
-  /**
-   * Move the Infobar to the right place in the highlighter.
-   */
-  moveInfobar: function LocalHighlighter_moveInfobar()
-  {
-    if (this._highlightRect) {
-      let winHeight = this.win.innerHeight * this.zoom;
-      let winWidth = this.win.innerWidth * this.zoom;
-
-      let rect = {top: this._highlightRect.top,
-                  left: this._highlightRect.left,
-                  width: this._highlightRect.width,
-                  height: this._highlightRect.height};
-
-      rect.top = Math.max(rect.top, 0);
-      rect.left = Math.max(rect.left, 0);
-      rect.width = Math.max(rect.width, 0);
-      rect.height = Math.max(rect.height, 0);
-
-      rect.top = Math.min(rect.top, winHeight);
-      rect.left = Math.min(rect.left, winWidth);
-
-      this.nodeInfo.container.removeAttribute("disabled");
-      // Can the bar be above the node?
-      if (rect.top < this.nodeInfo.barHeight) {
-        // No. Can we move the toolbar under the node?
-        if (rect.top + rect.height +
-            this.nodeInfo.barHeight > winHeight) {
-          // No. Let's move it inside.
-          this.nodeInfo.container.style.top = rect.top + "px";
-          this.nodeInfo.container.setAttribute("position", "overlap");
-        } else {
-          // Yes. Let's move it under the node.
-          this.nodeInfo.container.style.top = rect.top + rect.height + "px";
-          this.nodeInfo.container.setAttribute("position", "bottom");
-        }
-      } else {
-        // Yes. Let's move it on top of the node.
-        this.nodeInfo.container.style.top =
-          rect.top - this.nodeInfo.barHeight + "px";
-        this.nodeInfo.container.setAttribute("position", "top");
-      }
-
-      let barWidth = this.nodeInfo.container.getBoundingClientRect().width;
-      let left = rect.left + rect.width / 2 - barWidth / 2;
-
-      // Make sure the whole infobar is visible
-      if (left < 0) {
-        left = 0;
-        this.nodeInfo.container.setAttribute("hide-arrow", "true");
-      } else {
-        if (left + barWidth > winWidth) {
-          left = winWidth - barWidth;
-          this.nodeInfo.container.setAttribute("hide-arrow", "true");
-        } else {
-          this.nodeInfo.container.removeAttribute("hide-arrow");
-        }
-      }
-      this.nodeInfo.container.style.left = left + "px";
-    } else {
-      this.nodeInfo.container.style.left = "0";
-      this.nodeInfo.container.style.top = "0";
-      this.nodeInfo.container.setAttribute("position", "top");
-      this.nodeInfo.container.setAttribute("hide-arrow", "true");
-    }
-  },
-
-  /**
-   * Store page zoom factor.
-   */
-  computeZoomFactor: function LocalHighlighter_computeZoomFactor() {
-    this.zoom =
-      this.win.QueryInterface(Ci.nsIInterfaceRequestor)
-      .getInterface(Ci.nsIDOMWindowUtils)
-      .fullZoom;
-  },
-
-  /////////////////////////////////////////////////////////////////////////
-  //// Event Handling
-
-  attachMouseListeners: function LocalHighlighter_attachMouseListeners()
-  {
-    this.browser.addEventListener("mousemove", this, true);
-    this.browser.addEventListener("click", this, true);
-    this.browser.addEventListener("dblclick", this, true);
-    this.browser.addEventListener("mousedown", this, true);
-    this.browser.addEventListener("mouseup", this, true);
-  },
-
-  detachMouseListeners: function LocalHighlighter_detachMouseListeners()
-  {
-    this.browser.removeEventListener("mousemove", this, true);
-    this.browser.removeEventListener("click", this, true);
-    this.browser.removeEventListener("dblclick", this, true);
-    this.browser.removeEventListener("mousedown", this, true);
-    this.browser.removeEventListener("mouseup", this, true);
-  },
-
-  attachPageListeners: function LocalHighlighter_attachPageListeners()
-  {
-    this.browser.addEventListener("resize", this, true);
-    this.browser.addEventListener("scroll", this, true);
-    this.browser.addEventListener("MozAfterPaint", this, true);
-  },
-
-  detachPageListeners: function LocalHighlighter_detachPageListeners()
-  {
-    this.browser.removeEventListener("resize", this, true);
-    this.browser.removeEventListener("scroll", this, true);
-    this.browser.removeEventListener("MozAfterPaint", this, true);
-  },
-
-  /**
-   * Generic event handler.
-   *
-   * @param nsIDOMEvent aEvent
-   *        The DOM event object.
-   */
-  handleEvent: function LocalHighlighter_handleEvent(aEvent)
-  {
-    switch (aEvent.type) {
-      case "click":
-        this.handleClick(aEvent);
-        break;
-      case "mousemove":
-        this.brieflyIgnorePageEvents();
-        this.handleMouseMove(aEvent);
-        break;
-      case "resize":
-        this.computeZoomFactor();
-        break;
-      case "MozAfterPaint":
-      case "scroll":
-        this.brieflyDisableTransitions();
-        this.invalidateSize();
-        break;
-      case "dblclick":
-      case "mousedown":
-      case "mouseup":
-        aEvent.stopPropagation();
-        aEvent.preventDefault();
-        break;
-    }
-  },
-
-  /**
-   * Disable the CSS transitions for a short time to avoid laggy animations
-   * during scrolling or resizing.
-   */
-  brieflyDisableTransitions: function LocalHighlighter_brieflyDisableTransitions()
-  {
-    if (this.transitionDisabler) {
-      this.chromeWin.clearTimeout(this.transitionDisabler);
-    } else {
-      this.outline.setAttribute("disable-transitions", "true");
-      this.nodeInfo.container.setAttribute("disable-transitions", "true");
-    }
-    this.transitionDisabler =
-      this.chromeWin.setTimeout(function() {
-        this.outline.removeAttribute("disable-transitions");
-        this.nodeInfo.container.removeAttribute("disable-transitions");
-        this.transitionDisabler = null;
-      }.bind(this), 500);
-  },
-
-  /**
-   * Don't listen to page events while inspecting with the mouse.
-   */
-  brieflyIgnorePageEvents: function LocalHighlighter_brieflyIgnorePageEvents()
-  {
-    // The goal is to keep smooth animations while inspecting.
-    // CSS Transitions might be interrupted because of a MozAfterPaint
-    // event that would triger an invalidateSize() call.
-    // So we don't listen to events that would trigger an invalidateSize()
-    // call.
-    //
-    // Side effect, zoom levels are not updated during this short period.
-    // It's very unlikely this would happen, but just in case, we call
-    // computeZoomFactor() when reattaching the events.
-    if (this.pageEventsMuter) {
-      this.chromeWin.clearTimeout(this.pageEventsMuter);
-    } else {
-      this.detachPageListeners();
-    }
-    this.pageEventsMuter =
-      this.chromeWin.setTimeout(function() {
-        this.attachPageListeners();
-        // Just in case the zoom level changed while ignoring the paint events
-        this.computeZoomFactor();
-        this.pageEventsMuter = null;
-      }.bind(this), 500);
-  },
-
-  /**
-   * Handle clicks.
-   *
-   * @param nsIDOMEvent aEvent
-   *        The DOM event.
-   */
-  handleClick: function LocalHighlighter_handleClick(aEvent)
-  {
-    // Stop inspection when the user clicks on a node.
-    if (aEvent.button == 0) {
-      this.lock();
-      let node = this.selection.node;
-      this.selection.setNode(node, "highlighter-lock");
-      aEvent.preventDefault();
-      aEvent.stopPropagation();
-    }
-  },
-
-  /**
-   * Handle mousemoves in panel.
-   *
-   * @param nsiDOMEvent aEvent
-   *        The MouseEvent triggering the method.
-   */
-  handleMouseMove: function LocalHighlighter_handleMouseMove(aEvent)
-  {
-    let doc = aEvent.target.ownerDocument;
-
-    // This should never happen, but just in case, we don't let the
-    // highlighter highlight browser nodes.
-    if (doc && doc != this.chromeDoc) {
-      let element = this.layoutHelpers.getElementFromPoint(aEvent.target.ownerDocument,
-        aEvent.clientX, aEvent.clientY);
-      if (element && element != this.selection.node) {
-        this.selection.setNode(element, "highlighter");
-      }
-    }
-  },
-};
-
-// BasicHighlighter. Doesn't implement any fancy features. Just change
-// the outline of the selected node. Works with remote target.
-
-function BasicHighlighter(aTarget, aInspector)
-{
-  this.walker = aInspector.walker;
-  this.selection = aInspector.selection;
-  this.highlight = this.highlight.bind(this);
-  this.selection.on("new-node-front", this.highlight);
-  EventEmitter.decorate(this);
-  this.locked = true;
-}
-
-BasicHighlighter.prototype = {
-  destroy: function() {
-    this.walker.highlight(null);
-    this.selection.off("new-node-front", this.highlight);
-    this.walker = null;
-    this.selection = null;
-  },
-  toggleLockState: function() {
-    this.locked = !this.locked;
-    if (this.locked) {
-      this.walker.cancelPick();
-    } else {
-      this.emit("unlocked");
-      this.walker.pick().then(
-        (node) => this._onPick(node),
-        () => this._onPick(null)
-      );
-    }
-  },
-  highlight: function() {
-    this.walker.highlight(this.selection.nodeFront);
-  },
-  _onPick: function(node) {
-    if (node) {
-      this.selection.setNodeFront(node);
-    }
-    this.locked = true;
-    this.emit("locked");
-  },
-  hide: function() {},
-  show: function() {},
-}
-
-///////////////////////////////////////////////////////////////////////////
-
-XPCOMUtils.defineLazyGetter(this, "DOMUtils", function () {
-  return Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils)
-});
-
-XPCOMUtils.defineLazyGetter(LocalHighlighter.prototype, "strings", function () {
-    return Services.strings.createBundle(
-            "chrome://browser/locale/devtools/inspector.properties");
-});
diff --git a/browser/devtools/inspector/inspector-panel.js b/browser/devtools/inspector/inspector-panel.js
--- a/browser/devtools/inspector/inspector-panel.js
+++ b/browser/devtools/inspector/inspector-panel.js
@@ -8,30 +8,26 @@ const {Cc, Ci, Cu, Cr} = require("chrome
 
 Cu.import("resource://gre/modules/Services.jsm");
 
 let promise = require("sdk/core/promise");
 let EventEmitter = require("devtools/shared/event-emitter");
 let {CssLogic} = require("devtools/styleinspector/css-logic");
 
 loader.lazyGetter(this, "MarkupView", () => require("devtools/markupview/markup-view").MarkupView);
-loader.lazyGetter(this, "Selection", () => require("devtools/inspector/selection").Selection);
 loader.lazyGetter(this, "HTMLBreadcrumbs", () => require("devtools/inspector/breadcrumbs").HTMLBreadcrumbs);
-loader.lazyGetter(this, "Highlighter", () => require("devtools/inspector/highlighter").Highlighter);
 loader.lazyGetter(this, "ToolSidebar", () => require("devtools/framework/sidebar").ToolSidebar);
 loader.lazyGetter(this, "SelectorSearch", () => require("devtools/inspector/selector-search").SelectorSearch);
-loader.lazyGetter(this, "InspectorFront", () => require("devtools/server/actors/inspector").InspectorFront);
 
 const LAYOUT_CHANGE_TIMER = 250;
 
 /**
  * Represents an open instance of the Inspector for a tab.
- * The inspector controls the highlighter, the breadcrumbs,
- * the markup view, and the sidebar (computed view, rule view
- * and layout view).
+ * The inspector controls the breadcrumbs, the markup view, and the sidebar
+ * (computed view, rule view, font view and layout view).
  *
  * Events:
  * - ready
  *      Fired when the inspector panel is opened for the first time and ready to
  *      use
  * - new-root
  *      Fired after a new root (navigation to a new page) event was fired by
  *      the walker, and taken into account by the inspector (after the markup
@@ -72,51 +68,57 @@ function InspectorPanel(iframeWindow, to
 exports.InspectorPanel = InspectorPanel;
 
 InspectorPanel.prototype = {
   /**
    * open is effectively an asynchronous constructor
    */
   open: function InspectorPanel_open() {
     return this.target.makeRemote().then(() => {
-      return this._getWalker();
+      return this._getPageStyle();
     }).then(() => {
       return this._getDefaultNodeForSelection();
     }).then(defaultSelection => {
       return this._deferredOpen(defaultSelection);
     }).then(null, console.error);
   },
 
+  get toolbox() {
+    return this._toolbox;
+  },
+
   get inspector() {
-    if (!this._target.form) {
-      throw new Error("Target.inspector requires an initialized remote actor.");
-    }
-    if (!this._inspector) {
-      this._inspector = InspectorFront(this._target.client, this._target.form);
-    }
-    return this._inspector;
+    return this._toolbox.inspector;
+  },
+
+  get walker() {
+    return this._toolbox.walker;
+  },
+
+  get selection() {
+    return this._toolbox.selection;
+  },
+
+  get isOuterHTMLEditable() {
+    return this._target.client.traits.editOuterHTML;
   },
 
   _deferredOpen: function(defaultSelection) {
     let deferred = promise.defer();
 
-    this.outerHTMLEditable = this._target.client.traits.editOuterHTML;
-
     this.onNewRoot = this.onNewRoot.bind(this);
     this.walker.on("new-root", this.onNewRoot);
 
     this.nodemenu = this.panelDoc.getElementById("inspector-node-popup");
     this.lastNodemenuItem = this.nodemenu.lastChild;
     this._setupNodeMenu = this._setupNodeMenu.bind(this);
     this._resetNodeMenu = this._resetNodeMenu.bind(this);
     this.nodemenu.addEventListener("popupshowing", this._setupNodeMenu, true);
     this.nodemenu.addEventListener("popuphiding", this._resetNodeMenu, true);
 
-    // Create an empty selection
-    this._selection = new Selection(this.walker);
     this.onNewSelection = this.onNewSelection.bind(this);
     this.selection.on("new-node-front", this.onNewSelection);
     this.onBeforeNewSelection = this.onBeforeNewSelection.bind(this);
     this.selection.on("before-new-node-front", this.onBeforeNewSelection);
     this.onDetached = this.onDetached.bind(this);
     this.selection.on("detached-front", this.onDetached);
 
     this.breadcrumbs = new HTMLBreadcrumbs(this);
@@ -149,37 +151,24 @@ InspectorPanel.prototype = {
 
       }.bind(this);
       this.target.on("thread-paused", this.updateDebuggerPausedWarning);
       this.target.on("thread-resumed", this.updateDebuggerPausedWarning);
       this._toolbox.on("select", this.updateDebuggerPausedWarning);
       this.updateDebuggerPausedWarning();
     }
 
-    this.highlighter = new Highlighter(this.target, this, this._toolbox);
-    let button = this.panelDoc.getElementById("inspector-inspect-toolbutton");
-    this.onLockStateChanged = function() {
-      if (this.highlighter.locked) {
-        button.removeAttribute("checked");
-        this._toolbox.raise();
-      } else {
-        button.setAttribute("checked", "true");
-      }
-    }.bind(this);
-    this.highlighter.on("locked", this.onLockStateChanged);
-    this.highlighter.on("unlocked", this.onLockStateChanged);
-
     this._initMarkup();
     this.isReady = false;
 
     this.once("markuploaded", function() {
       this.isReady = true;
 
       // All the components are initialized. Let's select a node.
-      this._selection.setNodeFront(defaultSelection);
+      this.selection.setNodeFront(defaultSelection, "inspector-open");
 
       this.markup.expandNode(this.selection.nodeFront);
 
       this.emit("ready");
       deferred.resolve(this);
     }.bind(this));
 
     this.setupSearchBox();
@@ -190,21 +179,18 @@ InspectorPanel.prototype = {
 
   _onBeforeNavigate: function() {
     this._defaultNode = null;
     this.selection.setNodeFront(null);
     this._destroyMarkup();
     this.isDirty = false;
   },
 
-  _getWalker: function() {
-    return this.inspector.getWalker().then(walker => {
-      this.walker = walker;
-      return this.inspector.getPageStyle();
-    }).then(pageStyle => {
+  _getPageStyle: function() {
+    return this._toolbox.inspector.getPageStyle().then(pageStyle => {
       this.pageStyle = pageStyle;
     });
   },
 
   /**
    * Return a promise that will resolve to the default node for selection.
    */
   _getDefaultNodeForSelection: function() {
@@ -234,23 +220,16 @@ InspectorPanel.prototype = {
         promise.reject(null);
       }
       this._defaultNode = node;
       return node;
     });
   },
 
   /**
-   * Selection object (read only)
-   */
-  get selection() {
-    return this._selection;
-  },
-
-  /**
    * Target getter.
    */
   get target() {
     return this._target;
   },
 
   /**
    * Target setter.
@@ -309,17 +288,16 @@ InspectorPanel.prototype = {
 
     let defaultTab = Services.prefs.getCharPref("devtools.inspector.activeSidebar");
 
     this._setDefaultSidebar = function(event, toolId) {
       Services.prefs.setCharPref("devtools.inspector.activeSidebar", toolId);
     }.bind(this);
 
     this.sidebar.on("select", this._setDefaultSidebar);
-    this.toggleHighlighter = this.toggleHighlighter.bind(this);
 
     this.sidebar.addTab("ruleview",
                         "chrome://browser/content/devtools/cssruleview.xhtml",
                         "ruleview" == defaultTab);
 
     this.sidebar.addTab("computedview",
                         "chrome://browser/content/devtools/computedview.xhtml",
                         "computedview" == defaultTab);
@@ -330,40 +308,35 @@ InspectorPanel.prototype = {
                           "fontinspector" == defaultTab);
     }
 
     this.sidebar.addTab("layoutview",
                         "chrome://browser/content/devtools/layoutview/view.xhtml",
                         "layoutview" == defaultTab);
 
     let ruleViewTab = this.sidebar.getTab("ruleview");
-    ruleViewTab.addEventListener("mouseover", this.toggleHighlighter, false);
-    ruleViewTab.addEventListener("mouseout", this.toggleHighlighter, false);
 
     this.sidebar.show();
   },
 
   /**
    * Reset the inspector on new root mutation.
    */
   onNewRoot: function InspectorPanel_onNewRoot() {
     this._defaultNode = null;
     this.selection.setNodeFront(null);
     this._destroyMarkup();
     this.isDirty = false;
 
     this._getDefaultNodeForSelection().then(defaultNode => {
-      if (this._destroyPromise) {
-        return;
-      }
       this.selection.setNodeFront(defaultNode, "navigateaway");
 
       this._initMarkup();
       this.once("markuploaded", () => {
-        if (this._destroyPromise) {
+        if (!this.markup) {
           return;
         }
         this.markup.expandNode(this.selection.nodeFront);
         this.setupSearchBox();
         this.emit("new-root");
       });
     });
   },
@@ -394,16 +367,20 @@ InspectorPanel.prototype = {
       return null;
     }
   },
 
   /**
    * When a new node is selected.
    */
   onNewSelection: function InspectorPanel_onNewSelection(event, value, reason) {
+    if (reason === "selection-destroy") {
+      return;
+    }
+
     this.cancelLayoutChange();
 
     // Wait for all the known tools to finish updating and then let the
     // client know.
     let selection = this.selection.nodeFront;
 
     // On any new selection made by the user, store the unique css selector
     // of the selected node so it can be restored after reload of the same page
@@ -495,85 +472,70 @@ InspectorPanel.prototype = {
     this.breadcrumbs.cutAfter(this.breadcrumbs.indexOf(parentNode));
     this.selection.setNodeFront(parentNode ? parentNode : this._defaultNode, "detached");
   },
 
   /**
    * Destroy the inspector.
    */
   destroy: function InspectorPanel__destroy() {
-    if (this._destroyPromise) {
-      return this._destroyPromise;
+    if (this._panelDestroyer) {
+      return this._panelDestroyer.promise;
     }
 
-    if (this.highlighter) {
-      this.highlighter.off("locked", this.onLockStateChanged);
-      this.highlighter.off("unlocked", this.onLockStateChanged);
-      this.highlighter.destroy();
-    }
+    this._panelDestroyer = promise.defer();
 
-    delete this.onLockStateChanged;
+    this.onLockStateChanged = null;
 
     if (this.walker) {
       this.walker.off("new-root", this.onNewRoot);
-      this._destroyPromise = this.walker.release()
-        .then(() => this._inspector.destroy())
-        .then(() => {
-          this._inspector = null;
-        }, console.error);
-
-      delete this.walker;
-      delete this.pageStyle;
-    } else {
-      this._destroyPromise = promise.resolve(null);
+      this.pageStyle = null;
     }
 
     this.cancelUpdate();
     this.cancelLayoutChange();
 
     if (this.browser) {
       this.browser.removeEventListener("resize", this.scheduleLayoutChange, true);
       this.browser = null;
     }
 
     this.target.off("will-navigate", this._onBeforeNavigate);
 
     this.target.off("thread-paused", this.updateDebuggerPausedWarning);
     this.target.off("thread-resumed", this.updateDebuggerPausedWarning);
     this._toolbox.off("select", this.updateDebuggerPausedWarning);
 
-    this._toolbox = null;
-
     this.sidebar.off("select", this._setDefaultSidebar);
     this.sidebar.destroy();
     this.sidebar = null;
 
     this.nodemenu.removeEventListener("popupshowing", this._setupNodeMenu, true);
     this.nodemenu.removeEventListener("popuphiding", this._resetNodeMenu, true);
     this.breadcrumbs.destroy();
     this.searchSuggestions.destroy();
-    delete this.searchBox;
+    this.searchBox = null;
     this.selection.off("new-node-front", this.onNewSelection);
     this.selection.off("before-new-node", this.onBeforeNewSelection);
     this.selection.off("before-new-node-front", this.onBeforeNewSelection);
     this.selection.off("detached-front", this.onDetached);
     this._destroyMarkup();
-    this._selection.destroy();
-    this._selection = null;
     this.panelWin.inspector = null;
     this.target = null;
     this.panelDoc = null;
     this.panelWin = null;
     this.breadcrumbs = null;
     this.searchSuggestions = null;
     this.lastNodemenuItem = null;
     this.nodemenu = null;
-    this.highlighter = null;
+    this._toolbox = null;
 
-    return this._destroyPromise;
+    this._panelDestroyer.resolve(null);
+
+    return this._panelDestroyer.promise;
   },
 
   /**
    * Show the node menu.
    */
   showNodeMenu: function InspectorPanel_showNodeMenu(aButton, aPosition, aExtraItems) {
     if (aExtraItems) {
       for (let item of aExtraItems) {
@@ -624,17 +586,17 @@ InspectorPanel.prototype = {
       copyOuterHTML.removeAttribute("disabled");
     } else {
       unique.setAttribute("disabled", "true");
       copyInnerHTML.setAttribute("disabled", "true");
       copyOuterHTML.setAttribute("disabled", "true");
     }
 
     let editHTML = this.panelDoc.getElementById("node-menu-edithtml");
-    if (this.outerHTMLEditable && selectionIsElement) {
+    if (this.isOuterHTMLEditable && selectionIsElement) {
       editHTML.removeAttribute("disabled");
     } else {
       editHTML.setAttribute("disabled", "true");
     }
   },
 
   _resetNodeMenu: function InspectorPanel_resetNodeMenu() {
     // Remove any extra items
@@ -677,74 +639,58 @@ InspectorPanel.prototype = {
     this.markup = new MarkupView(this, this._markupFrame, controllerWindow);
 
     this.emit("markuploaded");
   },
 
   _destroyMarkup: function InspectorPanel__destroyMarkup() {
     if (this._boundMarkupFrameLoad) {
       this._markupFrame.removeEventListener("load", this._boundMarkupFrameLoad, true);
-      delete this._boundMarkupFrameLoad;
+      this._boundMarkupFrameLoad = null;
     }
 
     if (this.markup) {
       this.markup.destroy();
-      delete this.markup;
+      this.markup = null;
     }
 
     if (this._markupFrame) {
       this._markupFrame.parentNode.removeChild(this._markupFrame);
-      delete this._markupFrame;
+      this._markupFrame = null;
     }
 
     this._markupBox = null;
   },
 
   /**
    * Toggle a pseudo class.
    */
   togglePseudoClass: function InspectorPanel_togglePseudoClass(aPseudo) {
     if (this.selection.isElementNode()) {
       let node = this.selection.nodeFront;
       if (node.hasPseudoClassLock(aPseudo)) {
-        return this.walker.removePseudoClassLock(node, aPseudo, { parents: true });
+        return this.walker.removePseudoClassLock(node, aPseudo, {parents: true});
       }
 
       let hierarchical = aPseudo == ":hover" || aPseudo == ":active";
-      return this.walker.addPseudoClassLock(node, aPseudo, { parents: hierarchical });
+      return this.walker.addPseudoClassLock(node, aPseudo, {parents: hierarchical});
     }
   },
 
   /**
    * Clear any pseudo-class locks applied to the current hierarchy.
    */
   clearPseudoClasses: function InspectorPanel_clearPseudoClasses() {
     if (!this.walker) {
       return;
     }
     return this.walker.clearPseudoClassLocks().then(null, console.error);
   },
 
   /**
-   * Toggle the highlighter when ruleview is hovered.
-   */
-  toggleHighlighter: function InspectorPanel_toggleHighlighter(event)
-  {
-    if (!this.highlighter) {
-      return;
-    }
-    if (event.type == "mouseover") {
-      this.highlighter.hide();
-    }
-    else if (event.type == "mouseout") {
-      this.highlighter.show();
-    }
-  },
-
-  /**
    * Edit the outerHTML of the selected Node.
    */
   editHTML: function InspectorPanel_editHTML()
   {
     if (!this.selection.isNode()) {
       return;
     }
     if (this.markup) {
diff --git a/browser/devtools/inspector/inspector.xul b/browser/devtools/inspector/inspector.xul
--- a/browser/devtools/inspector/inspector.xul
+++ b/browser/devtools/inspector/inspector.xul
@@ -70,20 +70,16 @@
     </menupopup>
   </popupset>
 
   <box flex="1" class="devtools-responsive-container theme-body">
     <vbox flex="1">
       <toolbar id="inspector-toolbar"
         class="devtools-toolbar"
         nowindowdrag="true">
-        <toolbarbutton id="inspector-inspect-toolbutton"
-          tooltiptext="&inspector.selectButton.tooltip;"
-          class="devtools-toolbarbutton"
-          oncommand="inspector.highlighter.toggleLockState()"/>
         <arrowscrollbox id="inspector-breadcrumbs"
           class="breadcrumbs-widget-container"
           flex="1" orient="horizontal"
           clicktoscroll="true"/>
         <textbox id="inspector-searchbox"
           type="search"
           timeout="50"
           class="devtools-searchinput"
diff --git a/browser/devtools/inspector/selection.js b/browser/devtools/inspector/selection.js
deleted file mode 100644
--- a/browser/devtools/inspector/selection.js
+++ /dev/null
@@ -1,296 +0,0 @@
-/* -*- Mode: Javascript; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ft=javascript ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-"use strict";
-
-const {Cu, Ci} = require("chrome");
-let EventEmitter = require("devtools/shared/event-emitter");
-
-/**
- * API
- *
- *   new Selection(walker=null, node=null, track={attributes,detached});
- *   destroy()
- *   node (readonly)
- *   setNode(node, origin="unknown")
- *
- * Helpers:
- *
- *   window
- *   document
- *   isRoot()
- *   isNode()
- *   isHTMLNode()
- *
- * Check the nature of the node:
- *
- *   isElementNode()
- *   isAttributeNode()
- *   isTextNode()
- *   isCDATANode()
- *   isEntityRefNode()
- *   isEntityNode()
- *   isProcessingInstructionNode()
- *   isCommentNode()
- *   isDocumentNode()
- *   isDocumentTypeNode()
- *   isDocumentFragmentNode()
- *   isNotationNode()
- *
- * Events:
- *   "new-node" when the inner node changed
- *   "before-new-node" when the inner node is set to change
- *   "attribute-changed" when an attribute is changed (only if tracked)
- *   "detached" when the node (or one of its parents) is removed from the document (only if tracked)
- *   "reparented" when the node (or one of its parents) is moved under a different node (only if tracked)
- */
-
-/**
- * A Selection object. Hold a reference to a node.
- * Includes some helpers, fire some helpful events.
- *
- * @param node Inner node.
- *    Can be null. Can be (un)set in the future via the "node" property;
- * @param trackAttribute Tell if events should be fired when the attributes of
- *    the node change.
- *
- */
-function Selection(walker, node=null, track={attributes:true,detached:true}) {
-  EventEmitter.decorate(this);
-
-  this._onMutations = this._onMutations.bind(this);
-  this.track = track;
-  this.setWalker(walker);
-  this.setNode(node);
-}
-
-exports.Selection = Selection;
-
-Selection.prototype = {
-  _walker: null,
-  _node: null,
-
-  _onMutations: function(mutations) {
-    let attributeChange = false;
-    let pseudoChange = false;
-    let detached = false;
-    let parentNode = null;
-
-    for (let m of mutations) {
-      if (!attributeChange && m.type == "attributes") {
-        attributeChange = true;
-      }
-      if (m.type == "childList") {
-        if (!detached && !this.isConnected()) {
-          if (this.isNode()) {
-            parentNode = m.target;
-          }
-          detached = true;
-        }
-      }
-      if (m.type == "pseudoClassLock") {
-        pseudoChange = true;
-      }
-    }
-
-    // Fire our events depending on what changed in the mutations array
-    if (attributeChange) {
-      this.emit("attribute-changed");
-    }
-    if (pseudoChange) {
-      this.emit("pseudoclass");
-    }
-    if (detached) {
-      let rawNode = null;
-      if (parentNode && parentNode.isLocal_toBeDeprecated()) {
-        rawNode = parentNode.rawNode();
-      }
-
-      this.emit("detached", rawNode, null);
-      this.emit("detached-front", parentNode);
-    }
-  },
-
-  destroy: function() {
-    this.setNode(null);
-    this.setWalker(null);
-  },
-
-  setWalker: function(walker) {
-    if (this._walker) {
-      this._walker.off("mutations", this._onMutations);
-    }
-    this._walker = walker;
-    if (this._walker) {
-      this._walker.on("mutations", this._onMutations);
-    }
-  },
-
-  // Not remote-safe
-  setNode: function(value, reason="unknown") {
-    if (value) {
-      value = this._walker.frontForRawNode(value);
-    }
-    this.setNodeFront(value, reason);
-  },
-
-  // Not remote-safe
-  get node() {
-    return this._node;
-  },
-
-  // Not remote-safe
-  get window() {
-    if (this.isNode()) {
-      return this.node.ownerDocument.defaultView;
-    }
-    return null;
-  },
-
-  // Not remote-safe
-  get document() {
-    if (this.isNode()) {
-      return this.node.ownerDocument;
-    }
-    return null;
-  },
-
-  setNodeFront: function(value, reason="unknown") {
-    this.reason = reason;
-    if (value !== this._nodeFront) {
-      let rawValue = null;
-      if (value && value.isLocal_toBeDeprecated()) {
-        rawValue = value.rawNode();
-      }
-      this.emit("before-new-node", rawValue, reason);
-      this.emit("before-new-node-front", value, reason);
-      let previousNode = this._node;
-      let previousFront = this._nodeFront;
-      this._node = rawValue;
-      this._nodeFront = value;
-      this.emit("new-node", previousNode, this.reason);
-      this.emit("new-node-front", value, this.reason);
-    }
-  },
-
-  get documentFront() {
-    return this._walker.document(this._nodeFront);
-  },
-
-  get nodeFront() {
-    return this._nodeFront;
-  },
-
-  isRoot: function() {
-    return this.isNode() &&
-           this.isConnected() &&
-           this._nodeFront.isDocumentElement;
-  },
-
-  isNode: function() {
-    if (!this._nodeFront) {
-      return false;
-    }
-
-    // As long as tools are still accessing node.rawNode(),
-    // this needs to stay here.
-    if (this._node && Cu.isDeadWrapper(this._node)) {
-      return false;
-    }
-
-    return true;
-  },
-
-  isLocal: function() {
-    return !!this._node;
-  },
-
-  isConnected: function() {
-    let node = this._nodeFront;
-    if (!node || !node.actorID) {
-      return false;
-    }
-
-    // As long as there are still tools going around
-    // accessing node.rawNode, this needs to stay.
-    let rawNode = null;
-    if (node.isLocal_toBeDeprecated()) {
-      rawNode = node.rawNode();
-    }
-    if (rawNode) {
-      try {
-        let doc = this.document;
-        return (doc && doc.defaultView && doc.documentElement.contains(rawNode));
-      } catch (e) {
-        // "can't access dead object" error
-        return false;
-      }
-    }
-
-    while(node) {
-      if (node === this._walker.rootNode) {
-        return true;
-      }
-      node = node.parentNode();
-    };
-    return false;
-  },
-
-  isHTMLNode: function() {
-    let xhtml_ns = "http://www.w3.org/1999/xhtml";
-    return this.isNode() && this.node.namespaceURI == xhtml_ns;
-  },
-
-  // Node type
-
-  isElementNode: function() {
-    return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.ELEMENT_NODE;
-  },
-
-  isAttributeNode: function() {
-    return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.ATTRIBUTE_NODE;
-  },
-
-  isTextNode: function() {
-    return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.TEXT_NODE;
-  },
-
-  isCDATANode: function() {
-    return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.CDATA_SECTION_NODE;
-  },
-
-  isEntityRefNode: function() {
-    return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.ENTITY_REFERENCE_NODE;
-  },
-
-  isEntityNode: function() {
-    return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.ENTITY_NODE;
-  },
-
-  isProcessingInstructionNode: function() {
-    return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.PROCESSING_INSTRUCTION_NODE;
-  },
-
-  isCommentNode: function() {
-    return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.PROCESSING_INSTRUCTION_NODE;
-  },
-
-  isDocumentNode: function() {
-    return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.DOCUMENT_NODE;
-  },
-
-  isDocumentTypeNode: function() {
-    return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.DOCUMENT_TYPE_NODE;
-  },
-
-  isDocumentFragmentNode: function() {
-    return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.DOCUMENT_FRAGMENT_NODE;
-  },
-
-  isNotationNode: function() {
-    return this.isNode() && this.nodeFront.nodeType == Ci.nsIDOMNode.NOTATION_NODE;
-  },
-};
diff --git a/browser/devtools/layoutview/view.js b/browser/devtools/layoutview/view.js
--- a/browser/devtools/layoutview/view.js
+++ b/browser/devtools/layoutview/view.js
@@ -29,22 +29,18 @@ function LayoutView(aInspector, aWindow)
   this.init();
 }
 
 LayoutView.prototype = {
   init: function LV_init() {
     this.update = this.update.bind(this);
     this.onNewNode = this.onNewNode.bind(this);
     this.onNewSelection = this.onNewSelection.bind(this);
-    this.onHighlighterLocked = this.onHighlighterLocked.bind(this);
     this.inspector.selection.on("new-node-front", this.onNewSelection);
     this.inspector.sidebar.on("layoutview-selected", this.onNewNode);
-    if (this.inspector.highlighter) {
-      this.inspector.highlighter.on("locked", this.onHighlighterLocked);
-    }
 
     // Store for the different dimensions of the node.
     // 'selector' refers to the element that holds the value in view.xhtml;
     // 'property' is what we are measuring;
     // 'value' is the computed dimension, computed in update().
     this.map = {
       position: {selector: "#element-position",
                  property: "position",
@@ -101,19 +97,16 @@ LayoutView.prototype = {
    * Destroy the nodes. Remove listeners.
    */
   destroy: function LV_destroy() {
     this.inspector.sidebar.off("layoutview-selected", this.onNewNode);
     this.inspector.selection.off("new-node-front", this.onNewSelection);
     if (this.browser) {
       this.browser.removeEventListener("MozAfterPaint", this.update, true);
     }
-    if (this.inspector.highlighter) {
-      this.inspector.highlighter.off("locked", this.onHighlighterLocked);
-    }
     this.sizeHeadingLabel = null;
     this.sizeLabel = null;
     this.inspector = null;
     this.doc = null;
   },
 
   /**
    * Selection 'new-node-front' event handler.
@@ -121,34 +114,25 @@ LayoutView.prototype = {
   onNewSelection: function() {
     let done = this.inspector.updating("layoutview");
     this.onNewNode().then(done, (err) => { console.error(err); done() });
   },
 
   onNewNode: function LV_onNewNode() {
     if (this.isActive() &&
         this.inspector.selection.isConnected() &&
-        this.inspector.selection.isElementNode() &&
-        this.inspector.selection.reason != "highlighter") {
+        this.inspector.selection.isElementNode()) {
       this.undim();
     } else {
       this.dim();
     }
     return this.update();
   },
 
   /**
-   * Highlighter 'locked' event handler
-   */
-  onHighlighterLocked: function LV_onHighlighterLocked() {
-    this.undim();
-    this.update();
-  },
-
-  /**
    * Hide the layout boxes. No node are selected.
    */
   dim: function LV_dim() {
     if (this.browser) {
       this.browser.removeEventListener("MozAfterPaint", this.update, true);
     }
     this.trackingPaint = false;
     this.doc.body.classList.add("dim");
diff --git a/browser/devtools/main.js b/browser/devtools/main.js
--- a/browser/devtools/main.js
+++ b/browser/devtools/main.js
@@ -104,19 +104,17 @@ Tools.inspector = {
   icon: "chrome://browser/skin/devtools/tool-inspector.png",
   url: "chrome://browser/content/devtools/inspector/inspector.xul",
   label: l10n("inspector.label", inspectorStrings),
   tooltip: l10n("inspector.tooltip", inspectorStrings),
   inMenu: true,
 
   preventClosingOnKey: true,
   onkey: function(panel) {
-    if (panel.highlighter) {
-      panel.highlighter.toggleLockState();
-    }
+    panel.toolbox.togglePicker();
   },
 
   isTargetSupported: function(target) {
     return true;
   },
 
   build: function(iframeWindow, toolbox) {
     let panel = new InspectorPanel(iframeWindow, toolbox);
diff --git a/browser/devtools/markupview/markup-view.css b/browser/devtools/markupview/markup-view.css
--- a/browser/devtools/markupview/markup-view.css
+++ b/browser/devtools/markupview/markup-view.css
@@ -65,17 +65,17 @@
 .html-editor-container {
   position: relative;
   min-height: 200px;
 }
 
 /* This extra element placed in each tag is positioned absolutely to cover the
  * whole tag line and is used for background styling (when a selection is made
  * or when the tag is flashing) */
-.tag-line .highlighter {
+.tag-line .tag-state {
   position: absolute;
   left: -1000em;
   right: 0;
   height: 100%;
   z-index: -1;
 }
 
 .expander {
@@ -115,17 +115,17 @@
   margin-right: -1em;
   padding: 1px 0;
 }
 
 .newattr:focus {
   margin-right: 0;
 }
 
-.highlighter.flash-out {
+.tag-state.flash-out {
   transition: background .5s;
 }
 
 /* Preview */
 
 #previewbar {
   position: fixed;
   top: 0;
diff --git a/browser/devtools/markupview/markup-view.js b/browser/devtools/markupview/markup-view.js
--- a/browser/devtools/markupview/markup-view.js
+++ b/browser/devtools/markupview/markup-view.js
@@ -10,24 +10,26 @@ const {Cc, Cu, Ci} = require("chrome");
 const PAGE_SIZE = 10;
 const PREVIEW_AREA = 700;
 const DEFAULT_MAX_CHILDREN = 100;
 const COLLAPSE_ATTRIBUTE_LENGTH = 120;
 const COLLAPSE_DATA_URL_REGEX = /^data.+base64/;
 const COLLAPSE_DATA_URL_LENGTH = 60;
 const CONTAINER_FLASHING_DURATION = 500;
 const IMAGE_PREVIEW_MAX_DIM = 400;
+const NEW_SELECTION_HIGHLIGHTER_TIMER = 1000;
 
 const {UndoStack} = require("devtools/shared/undo");
 const {editableField, InplaceEditor} = require("devtools/shared/inplace-editor");
 const {gDevTools} = Cu.import("resource:///modules/devtools/gDevTools.jsm", {});
 const {HTMLEditor} = require("devtools/markupview/html-editor");
 const {OutputParser} = require("devtools/output-parser");
 const promise = require("sdk/core/promise");
 const {Tooltip} = require("devtools/shared/widgets/Tooltip");
+const EventEmitter = require("devtools/shared/event-emitter");
 
 Cu.import("resource://gre/modules/devtools/LayoutHelpers.jsm");
 Cu.import("resource://gre/modules/devtools/Templater.jsm");
 Cu.import("resource://gre/modules/Services.jsm");
 
 loader.lazyGetter(this, "DOMParser", function() {
  return Cc["@mozilla.org/xmlextras/domparser;1"].createInstance(Ci.nsIDOMParser);
 });
@@ -47,16 +49,20 @@ loader.lazyGetter(this, "AutocompletePop
 /**
  * The markup tree.  Manages the mapping of nodes to MarkupContainers,
  * updating based on mutations, and the undo/redo bindings.
  *
  * @param Inspector aInspector
  *        The inspector we're watching.
  * @param iframe aFrame
  *        An iframe in which the caller has kindly loaded markup-view.xhtml.
+ *
+ * Fires the following events:
+ * - node-highlight: When a node in the markup-view is hovered and the
+ *   corresponding node in the content gets highlighted
  */
 function MarkupView(aInspector, aFrame, aControllerWindow) {
   this._inspector = aInspector;
   this.walker = this._inspector.walker;
   this._frame = aFrame;
   this.doc = this._frame.contentDocument;
   this._elt = this.doc.querySelector("#root");
   this._outputParser = new OutputParser();
@@ -95,27 +101,138 @@ function MarkupView(aInspector, aFrame, 
 
   this._boundFocus = this._onFocus.bind(this);
   this._frame.addEventListener("focus", this._boundFocus, false);
 
   this._handlePrefChange = this._handlePrefChange.bind(this);
   gDevTools.on("pref-changed", this._handlePrefChange);
 
   this._initPreview();
+  this._initTooltips();
+  this._initHighlighter();
 
-  this.tooltip = new Tooltip(this._inspector.panelDoc);
-  this.tooltip.startTogglingOnHover(this._elt,
-    this._buildTooltipContent.bind(this));
+  EventEmitter.decorate(this);
 }
 
 exports.MarkupView = MarkupView;
 
 MarkupView.prototype = {
   _selectedContainer: null,
 
+  _initTooltips: function() {
+    this.tooltip = new Tooltip(this._inspector.panelDoc);
+    this.tooltip.startTogglingOnHover(this._elt,
+      this._buildTooltipContent.bind(this));
+  },
+
+  _initHighlighter: function() {
+    // Show the box model on markup-view mousemove
+    this._onMouseMove = this._onMouseMove.bind(this);
+    this._elt.addEventListener("mousemove", this._onMouseMove, false);
+    this._onMouseLeave = this._onMouseLeave.bind(this);
+    this._elt.addEventListener("mouseleave", this._onMouseLeave, false);
+
+    // Show markup-containers as hovered on toolbox "picker-node-hovered" event
+    // which happens when the "pick" button is pressed
+    this._onToolboxPickerHover = (event, nodeFront) => {
+      this.showNode(nodeFront, true).then(() => {
+        this._showContainerAsHovered(nodeFront);
+      });
+    }
+    this._inspector.toolbox.on("picker-node-hovered", this._onToolboxPickerHover);
+  },
+
+  _onMouseMove: function(event) {
+    let target = event.target;
+
+    // Search target for a markupContainer reference, if not found, walk up
+    while (!target.container) {
+      if (target.tagName.toLowerCase() === "body") {
+        return;
+      }
+      target = target.parentNode;
+    }
+
+    let container = target.container;
+    if (this._hoveredNode !== container.node) {
+      if (container.node.nodeType !== Ci.nsIDOMNode.TEXT_NODE) {
+        this._showBoxModel(container.node);
+      } else {
+        this._hideBoxModel();
+      }
+    }
+    this._showContainerAsHovered(container.node);
+  },
+
+  _hoveredNode: null,
+  _showContainerAsHovered: function(nodeFront) {
+    if (this._hoveredNode !== nodeFront) {
+      if (this._hoveredNode) {
+        this._containers.get(this._hoveredNode).hovered = false;
+      }
+      this._containers.get(nodeFront).hovered = true;
+
+      this._hoveredNode = nodeFront;
+    }
+  },
+
+  _onMouseLeave: function() {
+    this._hideBoxModel();
+  },
+
+  _showBoxModel: function(nodeFront, options={}) {
+    let toolbox = this._inspector.toolbox;
+
+    // If the remote highlighter exists on the target, use it
+    if (toolbox.isRemoteHighlightable) {
+      toolbox.highlighter.showBoxModel(nodeFront, options).then(() => {
+        this.emit("node-highlight", nodeFront);
+      });
+    }
+    // Else, revert to the "older" version of the highlighter in the walker
+    // actor
+    else {
+      this.walker.highlight(nodeFront).then(() => {
+        this.emit("node-highlight", nodeFront);
+      });
+    }
+  },
+
+  _hideBoxModel: function() {
+    let deferred = promise.defer();
+    let toolbox = this._inspector.toolbox;
+
+    // If the remote highlighter exists on the target, use it
+    if (toolbox.isRemoteHighlightable) {
+      toolbox.highlighter.hideBoxModel().then(deferred.resolve);
+    } else {
+      deferred.resolve();
+    }
+    // If not, no need to unhighlight as the older highlight method uses a
+    // setTimeout to hide itself
+
+    return deferred.promise;
+  },
+
+  _briefBoxModelTimer: null,
+  _brieflyShowBoxModel: function(nodeFront, options) {
+    let win = this._frame.contentWindow;
+
+    if (this._briefBoxModelTimer) {
+      win.clearTimeout(this._briefBoxModelTimer);
+      this._briefBoxModelTimer = null;
+    }
+
+    this._showBoxModel(nodeFront, options);
+
+    this._briefBoxModelTimer = this._frame.contentWindow.setTimeout(() => {
+      this._hideBoxModel();
+    }, NEW_SELECTION_HIGHLIGHTER_TIMER);
+  },
+
   template: function(aName, aDest, aOptions={stack: "markup-view.xhtml"}) {
     let node = this.doc.getElementById("template-" + aName).cloneNode(true);
     node.removeAttribute("id");
     template(node, aDest, aOptions);
     return node;
   },
 
   /**
@@ -171,21 +288,32 @@ MarkupView.prototype = {
       return container._buildTooltipContent(target, this.tooltip);
     }
   },
 
   /**
    * Highlight the inspector selected node.
    */
   _onNewSelection: function() {
+    let selection = this._inspector.selection;
+
     this.htmlEditor.hide();
     let done = this._inspector.updating("markup-view");
-    if (this._inspector.selection.isNode()) {
-      this.showNode(this._inspector.selection.nodeFront, true).then(() => {
-        this.markNodeAsSelected(this._inspector.selection.nodeFront);
+    if (selection.isNode()) {
+      let reason = selection.reason;
+      if (reason && reason !== "inspector-open" && reason !== "navigateaway") {
+        this._brieflyShowBoxModel(selection.nodeFront, {
+          scrollIntoView: true
+        });
+      }
+
+      this.showNode(selection.nodeFront, true).then(() => {
+        if (selection.reason !== "treepanel") {
+          this.markNodeAsSelected(selection.nodeFront);
+        }
         done();
       });
     } else {
       this.unmarkSelectedNode();
       done();
     }
   },
 
@@ -365,21 +493,16 @@ MarkupView.prototype = {
   navigate: function(aContainer, aIgnoreFocus) {
     if (!aContainer) {
       return;
     }
 
     let node = aContainer.node;
     this.markNodeAsSelected(node, "treepanel");
 
-    // This event won't be fired if the node is the same. But the highlighter
-    // need to lock the node if it wasn't.
-    this._inspector.selection.emit("new-node");
-    this._inspector.selection.emit("new-node-front");
-
     if (!aIgnoreFocus) {
       aContainer.focus();
     }
   },
 
   /**
    * Make sure a node is included in the markup tool.
    *
@@ -935,65 +1058,74 @@ MarkupView.prototype = {
   },
 
   /**
    * Tear down the markup panel.
    */
   destroy: function() {
     gDevTools.off("pref-changed", this._handlePrefChange);
 
-    delete this._outputParser;
+    // Note that if the toolbox is closed, this will work fine, but will fail
+    // in case the browser is closed and will trigger a noSuchActor message.
+    this._hideBoxModel();
+
+    this._hoveredNode = null;
+    this._inspector.toolbox.off("picker-node-hovered", this._onToolboxPickerHover);
+
+    this._outputParser = null;
 
     this.htmlEditor.destroy();
-    delete this.htmlEditor;
+    this.htmlEditor = null;
 
     this.undo.destroy();
-    delete this.undo;
+    this.undo = null;
 
     this.popup.destroy();
-    delete this.popup;
+    this.popup = null;
 
     this._frame.removeEventListener("focus", this._boundFocus, false);
-    delete this._boundFocus;
+    this._boundFocus = null;
 
     if (this._boundUpdatePreview) {
       this._frame.contentWindow.removeEventListener("scroll",
         this._boundUpdatePreview, true);
-      delete this._boundUpdatePreview;
+      this._boundUpdatePreview = null;
     }
 
     if (this._boundResizePreview) {
       this._frame.contentWindow.removeEventListener("resize",
         this._boundResizePreview, true);
       this._frame.contentWindow.removeEventListener("overflow",
         this._boundResizePreview, true);
       this._frame.contentWindow.removeEventListener("underflow",
         this._boundResizePreview, true);
-      delete this._boundResizePreview;
+      this._boundResizePreview = null;
     }
 
     this._frame.contentWindow.removeEventListener("keydown",
       this._boundKeyDown, false);
-    delete this._boundKeyDown;
+    this._boundKeyDown = null;
 
     this._inspector.selection.off("new-node-front", this._boundOnNewSelection);
-    delete this._boundOnNewSelection;
+    this._boundOnNewSelection = null;
 
     this.walker.off("mutations", this._boundMutationObserver)
-    delete this._boundMutationObserver;
+    this._boundMutationObserver = null;
 
-    delete this._elt;
+    this._elt.removeEventListener("mousemove", this._onMouseMove, false);
+    this._elt.removeEventListener("mouseleave", this._onMouseLeave, false);
+    this._elt = null;
 
     for (let [key, container] of this._containers) {
       container.destroy();
     }
-    delete this._containers;
+    this._containers = null;
 
     this.tooltip.destroy();
-    delete this.tooltip;
+    this.tooltip = null;
   },
 
   /**
    * Initialize the preview panel.
    */
   _initPreview: function() {
     this._previewEnabled = Services.prefs.getBoolPref("devtools.inspector.markupPreview");
     if (!this._previewEnabled) {
@@ -1109,37 +1241,28 @@ function MarkupContainer(aMarkupView, aN
     this.editor = new DoctypeEditor(this, aNode);
   } else {
     this.editor = new GenericEditor(this, aNode);
   }
 
   // The template will fill the following properties
   this.elt = null;
   this.expander = null;
-  this.highlighter = null;
+  this.tagState = null;
   this.tagLine = null;
   this.children = null;
   this.markup.template("container", this);
   this.elt.container = this;
   this.children.container = this;
 
   // Expanding/collapsing the node on dblclick of the whole tag-line element
   this._onToggle = this._onToggle.bind(this);
   this.elt.addEventListener("dblclick", this._onToggle, false);
   this.expander.addEventListener("click", this._onToggle, false);
 
-  // Dealing with the highlighting of the row via javascript rather than :hover
-  // This is to allow highlighting the closing tag-line as well as reusing the
-  // theme css classes (which wouldn't have been possible with a :hover pseudo)
-  this._onMouseOver = this._onMouseOver.bind(this);
-  this.elt.addEventListener("mouseover", this._onMouseOver, false);
-
-  this._onMouseOut = this._onMouseOut.bind(this);
-  this.elt.addEventListener("mouseout", this._onMouseOut, false);
-
   // Appending the editor element and attaching event listeners
   this.tagLine.appendChild(this.editor.elt);
 
   this._onMouseDown = this._onMouseDown.bind(this);
   this.elt.addEventListener("mousedown", this._onMouseDown, false);
 
   this._onClick = this._onClick.bind(this);
   this.elt.addEventListener("click", this._onClick, false);
@@ -1230,32 +1353,30 @@ MarkupContainer.prototype = {
       // tag-line that the user can interact with and showing the children.
       if (this.editor instanceof ElementEditor) {
         let closingTag = this.elt.querySelector(".close");
         if (closingTag) {
           if (!this.closeTagLine) {
             let line = this.markup.doc.createElement("div");
             line.classList.add("tag-line");
 
-            let highlighter = this.markup.doc.createElement("div");
-            highlighter.classList.add("highlighter");
-            line.appendChild(highlighter);
+            let tagState = this.markup.doc.createElement("div");
+            tagState.classList.add("tag-state");
+            line.appendChild(tagState);
 
             line.appendChild(closingTag.cloneNode(true));
-            line.addEventListener("mouseover", this._onMouseOver, false);
-            line.addEventListener("mouseout", this._onMouseOut, false);
 
             this.closeTagLine = line;
           }
           this.elt.appendChild(this.closeTagLine);
         }
       }
       this.elt.classList.remove("collapsed");
       this.expander.setAttribute("open", "");
-      this.highlighted = false;
+      this.hovered = false;
     } else if (!aValue) {
       if (this.editor instanceof ElementEditor && this.closeTagLine) {
         this.elt.removeChild(this.closeTagLine);
       }
       this.elt.classList.add("collapsed");
       this.expander.removeAttribute("open");
     }
   },
@@ -1263,29 +1384,19 @@ MarkupContainer.prototype = {
   _onToggle: function(event) {
     this.markup.navigate(this);
     if(this.hasChildren) {
       this.markup.setNodeExpanded(this.node, !this.expanded);
     }
     event.stopPropagation();
   },
 
-  _onMouseOver: function(event) {
-    this.highlighted = true;
-    event.stopPropagation();
-  },
-
-  _onMouseOut: function(event) {
-    this.highlighted = false;
-    event.stopPropagation();
-  },
-
   _onMouseDown: function(event) {
     if (event.target.nodeName !== "a") {
-      this.highlighted = false;
+      this.hovered = false;
       this.markup.navigate(this);
       event.stopPropagation();
     }
   },
 
   _onClick: function(event) {
     let target = event.target;
 
@@ -1314,64 +1425,64 @@ MarkupContainer.prototype = {
         this.flashed = false;
       }, CONTAINER_FLASHING_DURATION);
     }
   },
 
   set flashed(aValue) {
     if (aValue) {
       // Make sure the animation class is not here
-      this.highlighter.classList.remove("flash-out");
+      this.tagState.classList.remove("flash-out");
 
       // Change the background
-      this.highlighter.classList.add("theme-bg-contrast");
+      this.tagState.classList.add("theme-bg-contrast");
 
       // Change the text color
       this.editor.elt.classList.add("theme-fg-contrast");
       [].forEach.call(
         this.editor.elt.querySelectorAll("[class*=theme-fg-color]"),
         span => span.classList.add("theme-fg-contrast")
       );
     } else {
       // Add the animation class to smoothly remove the background
-      this.highlighter.classList.add("flash-out");
+      this.tagState.classList.add("flash-out");
 
       // Remove the background
-      this.highlighter.classList.remove("theme-bg-contrast");
+      this.tagState.classList.remove("theme-bg-contrast");
 
       // Remove the text color
       this.editor.elt.classList.remove("theme-fg-contrast");
       [].forEach.call(
         this.editor.elt.querySelectorAll("[class*=theme-fg-color]"),
         span => span.classList.remove("theme-fg-contrast")
       );
     }
   },
 
-  _highlighted: false,
+  _hovered: false,
 
   /**
    * Highlight the currently hovered tag + its closing tag if necessary
    * (that is if the tag is expanded)
    */
-  set highlighted(aValue) {
-    this.highlighter.classList.remove("flash-out");
-    this._highlighted = aValue;
+  set hovered(aValue) {
+    this.tagState.classList.remove("flash-out");
+    this._hovered = aValue;
     if (aValue) {
       if (!this.selected) {
-        this.highlighter.classList.add("theme-bg-darker");
+        this.tagState.classList.add("theme-bg-darker");
       }
       if (this.closeTagLine) {
-        this.closeTagLine.querySelector(".highlighter").classList.add(
+        this.closeTagLine.querySelector(".tag-state").classList.add(
           "theme-bg-darker");
       }
     } else {
-      this.highlighter.classList.remove("theme-bg-darker");
+      this.tagState.classList.remove("theme-bg-darker");
       if (this.closeTagLine) {
-        this.closeTagLine.querySelector(".highlighter").classList.remove(
+        this.closeTagLine.querySelector(".tag-state").classList.remove(
           "theme-bg-darker");
       }
     }
   },
 
   /**
    * True if the container is visible in the markup tree.
    */
@@ -1384,25 +1495,25 @@ MarkupContainer.prototype = {
    */
   _selected: false,
 
   get selected() {
     return this._selected;
   },
 
   set selected(aValue) {
-    this.highlighter.classList.remove("flash-out");
+    this.tagState.classList.remove("flash-out");
     this._selected = aValue;
     this.editor.selected = aValue;
     if (this._selected) {
       this.tagLine.setAttribute("selected", "");
-      this.highlighter.classList.add("theme-selected");
+      this.tagState.classList.add("theme-selected");
     } else {
       this.tagLine.removeAttribute("selected");
-      this.highlighter.classList.remove("theme-selected");
+      this.tagState.classList.remove("theme-selected");
     }
   },
 
   /**
    * Update the container's editor to the current state of the
    * viewed node.
    */
   update: function() {
diff --git a/browser/devtools/markupview/markup-view.xhtml b/browser/devtools/markupview/markup-view.xhtml
--- a/browser/devtools/markupview/markup-view.xhtml
+++ b/browser/devtools/markupview/markup-view.xhtml
@@ -18,17 +18,17 @@
 <body class="theme-body devtools-monospace" role="application">
   <div id="root-wrapper">
     <div id="root"></div>
   </div>
   <div id="templates" style="display:none">
 
     <ul class="children">
       <li id="template-container" save="${elt}" class="child collapsed">
-        <div save="${tagLine}" class="tag-line"><span save="${highlighter}" class="highlighter"></span><span save="${expander}" class="theme-twisty expander"></span></div>
+        <div save="${tagLine}" class="tag-line"><span save="${tagState}" class="tag-state"></span><span save="${expander}" class="theme-twisty expander"></span></div>
         <ul save="${children}" class="children"></ul>
       </li>
 
       <li id="template-more-nodes" class="more-nodes devtools-class-comment" save="${elt}"><span>${showing}</span> <button href="#" onclick="${allButtonClick}">${showAll}</button></li>
     </ul>
 
     <span id="template-element" save="${elt}" class="editor"><span class="open">&lt;<span save="${tag}" class="tag theme-fg-color3" tabindex="0"></span><span save="${attrList}"></span><span save="${newAttr}" class="newattr" tabindex="0"></span><span class="closing-bracket">&gt;</span></span><span class="close">&lt;/<span save="${closeTag}" class="tag theme-fg-color3"></span>&gt;</span></span>
 
diff --git a/browser/devtools/styleinspector/computed-view.js b/browser/devtools/styleinspector/computed-view.js
--- a/browser/devtools/styleinspector/computed-view.js
+++ b/browser/devtools/styleinspector/computed-view.js
@@ -386,19 +386,16 @@ CssHtmlTree.prototype = {
       // Reset zebra striping.
       this._darkStripe = true;
 
       let deferred = promise.defer();
       this._refreshProcess = new UpdateProcess(this.styleWindow, this.propertyViews, {
         onItem: (aPropView) => {
           aPropView.refresh();
         },
-        onCancel: () => {
-          deferred.reject("refresh cancelled");
-        },
         onDone: () => {
           this._refreshProcess = null;
           this.noResults.hidden = this.numVisibleProperties > 0;
           this.styleInspector.inspector.emit("computed-view-refreshed");
           deferred.resolve(undefined);
         }
       });
       this._refreshProcess.schedule();
diff --git a/browser/devtools/styleinspector/rule-view.js b/browser/devtools/styleinspector/rule-view.js
--- a/browser/devtools/styleinspector/rule-view.js
+++ b/browser/devtools/styleinspector/rule-view.js
@@ -1379,17 +1379,17 @@ CssRuleView.prototype = {
     // Repopulate the element style.
     this._populate();
   },
 
   _populate: function() {
     let elementStyle = this._elementStyle;
     return this._elementStyle.populate().then(() => {
       if (this._elementStyle != elementStyle) {
-        return promise.reject("element changed");
+        return;
       }
       this._createEditors();
 
       // Notify anyone that cares that we refreshed.
       var evt = this.doc.createEvent("Events");
       evt.initEvent("CssRuleViewRefreshed", true, false);
       this.element.dispatchEvent(evt);
       return undefined;
diff --git a/browser/devtools/styleinspector/style-inspector.js b/browser/devtools/styleinspector/style-inspector.js
--- a/browser/devtools/styleinspector/style-inspector.js
+++ b/browser/devtools/styleinspector/style-inspector.js
@@ -76,19 +76,16 @@ function RuleViewTool(aInspector, aWindo
 
   this._onSelect = this.onSelect.bind(this);
   this.inspector.selection.on("detached", this._onSelect);
   this.inspector.selection.on("new-node-front", this._onSelect);
   this.refresh = this.refresh.bind(this);
   this.inspector.on("layout-change", this.refresh);
 
   this.inspector.selection.on("pseudoclass", this.refresh);
-  if (this.inspector.highlighter) {
-    this.inspector.highlighter.on("locked", this._onSelect);
-  }
 
   this.onSelect();
 }
 
 exports.RuleViewTool = RuleViewTool;
 
 RuleViewTool.prototype = {
   onSelect: function RVT_onSelect(aEvent) {
@@ -96,41 +93,29 @@ RuleViewTool.prototype = {
 
     if (!this.inspector.selection.isConnected() ||
         !this.inspector.selection.isElementNode()) {
       this.view.highlight(null);
       return;
     }
 
     if (!aEvent || aEvent == "new-node-front") {
-      if (this.inspector.selection.reason == "highlighter") {
-        this.view.highlight(null);
-      } else {
-        let done = this.inspector.updating("rule-view");
-        this.view.highlight(this.inspector.selection.nodeFront).then(done, done);
-      }
-    }
-
-    if (aEvent == "locked") {
       let done = this.inspector.updating("rule-view");
       this.view.highlight(this.inspector.selection.nodeFront).then(done, done);
     }
   },
 
   refresh: function RVT_refresh() {
     this.view.nodeChanged();
   },
 
   destroy: function RVT_destroy() {
     this.inspector.off("layout-change", this.refresh);
     this.inspector.selection.off("pseudoclass", this.refresh);
     this.inspector.selection.off("new-node-front", this._onSelect);
-    if (this.inspector.highlighter) {
-      this.inspector.highlighter.off("locked", this._onSelect);
-    }
 
     this.view.element.removeEventListener("CssRuleViewCSSLinkClicked",
       this._cssLinkHandler);
 
     this.view.element.removeEventListener("CssRuleViewChanged",
       this._changeHandler);
 
     this.view.element.removeEventListener("CssRuleViewRefreshed",
@@ -153,19 +138,16 @@ function ComputedViewTool(aInspector, aW
   this.window = aWindow;
   this.document = aWindow.document;
   this.outerIFrame = aIFrame;
   this.view = new ComputedView.CssHtmlTree(this, aInspector.pageStyle);
 
   this._onSelect = this.onSelect.bind(this);
   this.inspector.selection.on("detached", this._onSelect);
   this.inspector.selection.on("new-node-front", this._onSelect);
-  if (this.inspector.highlighter) {
-    this.inspector.highlighter.on("locked", this._onSelect);
-  }
   this.refresh = this.refresh.bind(this);
   this.inspector.on("layout-change", this.refresh);
   this.inspector.selection.on("pseudoclass", this.refresh);
 
   this.view.highlight(null);
 
   this.onSelect();
 }
@@ -179,27 +161,16 @@ ComputedViewTool.prototype = {
 
     if (!this.inspector.selection.isConnected() ||
         !this.inspector.selection.isElementNode()) {
       this.view.highlight(null);
       return;
     }
 
     if (!aEvent || aEvent == "new-node-front") {
-      if (this.inspector.selection.reason == "highlighter") {
-        // FIXME: We should hide view's content
-      } else {
-        let done = this.inspector.updating("computed-view");
-        this.view.highlight(this.inspector.selection.nodeFront).then(() => {
-          done();
-        });
-      }
-    }
-
-    if (aEvent == "locked" && this.inspector.selection.nodeFront != this.view.viewedElement) {
       let done = this.inspector.updating("computed-view");
       this.view.highlight(this.inspector.selection.nodeFront).then(() => {
         done();
       });
     }
   },
 
   refresh: function CVT_refresh() {
@@ -207,19 +178,16 @@ ComputedViewTool.prototype = {
   },
 
   destroy: function CVT_destroy(aContext)
   {
     this.inspector.off("layout-change", this.refresh);
     this.inspector.sidebar.off("computedview-selected", this.refresh);
     this.inspector.selection.off("pseudoclass", this.refresh);
     this.inspector.selection.off("new-node-front", this._onSelect);
-    if (this.inspector.highlighter) {
-      this.inspector.highlighter.off("locked", this._onSelect);
-    }
 
     this.view.destroy();
     delete this.view;
 
     delete this.outerIFrame;
     delete this.cssLogic;
     delete this.cssHtmlTree;
     delete this.window;
diff --git a/browser/devtools/tilt/tilt-visualizer.js b/browser/devtools/tilt/tilt-visualizer.js
--- a/browser/devtools/tilt/tilt-visualizer.js
+++ b/browser/devtools/tilt/tilt-visualizer.js
@@ -267,20 +267,21 @@ TiltVisualizer.prototype = {
    */
   onNewNodeFromTilt: function TV_onNewNodeFromTilt()
   {
     if (!this.inspector) {
       return;
     }
     let nodeIndex = this.presenter._currentSelection;
     if (nodeIndex < 0) {
-      this.inspector.selection.setNode(null, "tilt");
+      this.inspector.selection.setNodeFront(null, "tilt");
     }
     let node = this.presenter._traverseData.nodes[nodeIndex];
-    this.inspector.selection.setNode(node, "tilt");
+    node = this.inspector.walker.frontForRawNode(node);
+    this.inspector.selection.setNodeFront(node, "tilt");
   },
 };
 
 /**
  * This object manages the visualization logic and drawing loop.
  *
  * @param {HTMLCanvasElement} aCanvas
  *                            the canvas element used for rendering
diff --git a/browser/locales/en-US/chrome/browser/devtools/toolbox.properties b/browser/locales/en-US/chrome/browser/devtools/toolbox.properties
--- a/browser/locales/en-US/chrome/browser/devtools/toolbox.properties
+++ b/browser/locales/en-US/chrome/browser/devtools/toolbox.properties
@@ -49,8 +49,12 @@ options.toolNotSupportedMarker=%1$S *
 # Used for opening scratchpad from the detached toolbox window
 # Needs to match scratchpad.keycode from browser.dtd
 scratchpad.keycode=VK_F4
 
 # LOCALIZATION NOTE (browserConsoleCmd.commandkey)
 # Used for toggling the browser console from the detached toolbox window
 # Needs to match browserConsoleCmd.commandkey from browser.dtd
 browserConsoleCmd.commandkey=j
+
+# LOCALIZATION NOTE (pickButton.tooltip)
+# This is the tooltip of the pick button in the toolbox toolbar
+pickButton.tooltip=Pick an element from the page
diff --git a/browser/themes/linux/jar.mn b/browser/themes/linux/jar.mn
--- a/browser/themes/linux/jar.mn
+++ b/browser/themes/linux/jar.mn
@@ -151,16 +151,17 @@ browser.jar:
 * skin/classic/browser/devtools/light-theme.css       (../shared/devtools/light-theme.css)
   skin/classic/browser/devtools/controls.png          (../shared/devtools/controls.png)
 * skin/classic/browser/devtools/widgets.css           (devtools/widgets.css)
   skin/classic/browser/devtools/commandline-icon.png  (devtools/commandline-icon.png)
   skin/classic/browser/devtools/command-paintflashing.png  (devtools/command-paintflashing.png)
   skin/classic/browser/devtools/command-responsivemode.png (devtools/command-responsivemode.png)
   skin/classic/browser/devtools/command-scratchpad.png (devtools/command-scratchpad.png)
   skin/classic/browser/devtools/command-tilt.png      (devtools/command-tilt.png)
+  skin/classic/browser/devtools/command-pick.png      (../shared/devtools/command-pick.png)
   skin/classic/browser/devtools/command-console.png   (devtools/command-console.png)
   skin/classic/browser/devtools/alerticon-warning.png (devtools/alerticon-warning.png)
   skin/classic/browser/devtools/ruleview.css          (devtools/ruleview.css)
 * skin/classic/browser/devtools/webconsole.css                  (devtools/webconsole.css)
   skin/classic/browser/devtools/webconsole_networkpanel.css     (devtools/webconsole_networkpanel.css)
   skin/classic/browser/devtools/webconsole.png                  (devtools/webconsole.png)
   skin/classic/browser/devtools/commandline.css              (devtools/commandline.css)
   skin/classic/browser/devtools/markup-view.css       (../shared/devtools/markup-view.css)
diff --git a/browser/themes/osx/jar.mn b/browser/themes/osx/jar.mn
--- a/browser/themes/osx/jar.mn
+++ b/browser/themes/osx/jar.mn
@@ -253,16 +253,17 @@ browser.jar:
 * skin/classic/browser/devtools/light-theme.css             (../shared/devtools/light-theme.css)
   skin/classic/browser/devtools/controls.png                (../shared/devtools/controls.png)
 * skin/classic/browser/devtools/widgets.css                 (devtools/widgets.css)
   skin/classic/browser/devtools/commandline-icon.png        (devtools/commandline-icon.png)
   skin/classic/browser/devtools/command-paintflashing.png   (devtools/command-paintflashing.png)
   skin/classic/browser/devtools/command-responsivemode.png  (devtools/command-responsivemode.png)
   skin/classic/browser/devtools/command-scratchpad.png      (devtools/command-scratchpad.png)
   skin/classic/browser/devtools/command-tilt.png            (devtools/command-tilt.png)
+  skin/classic/browser/devtools/command-pick.png            (../shared/devtools/command-pick.png)
   skin/classic/browser/devtools/command-console.png         (devtools/command-console.png)
   skin/classic/browser/devtools/alerticon-warning.png       (devtools/alerticon-warning.png)
   skin/classic/browser/devtools/ruleview.css                (devtools/ruleview.css)
   skin/classic/browser/devtools/commandline.css             (devtools/commandline.css)
   skin/classic/browser/devtools/markup-view.css             (../shared/devtools/markup-view.css)
   skin/classic/browser/devtools/editor-error.png             (devtools/editor-error.png)
   skin/classic/browser/devtools/editor-breakpoint.png        (devtools/editor-breakpoint.png)
   skin/classic/browser/devtools/editor-debug-location.png    (devtools/editor-debug-location.png)
diff --git a/browser/themes/shared/devtools/command-pick.png b/browser/themes/shared/devtools/command-pick.png
new file mode 100644
index 0000000000000000000000000000000000000000..fbd9775607cee6dca06768fa608ad9c1f5a786c7
GIT binary patch
literal 1780
zc$@+B1`GL#P)<h;3K|Lk000e1NJLTq002M$000mO1^@s6rssJn0000PbVXQnQ*UN;
zcVTj606}DLVr3vnZDD6+Qe|Oed2z{QJOBU&mPtfGRCwCdS8GfZR}|iPEc;~H<*~|3
z1Z#mlh()v&YSfChMQz$>TN{5^YtpD`G%>9TMzlYy)YqQ|Y@(8wv{ajFiK%Z36^f0D
zfL1_+3PR+uEbNn+*`1x4p1aJ@*=2!k`^!nbJu~;-@6J8vp6}dQOb`UcvwWq$|Ly<c
zljujKGd$Blm|1X8hYTPUpa)=+3`aZe0Q?2$CZ$$~-L?V@LPQwvqyeX+jHWsne<K(K
zbr^g%;4tvd%lMyz`2wH`gYN|F0{(YW3{<Jp%gI>7Tm_C1Q?hy9#}3%9db<a=k+Npw
zJPz=Mu>d8{^KXN#leHn|l>jabz6PYX0ql8M+YXeB;tox9MFM|2SSbK$LX<YgO?&Wg
zG6usiGQyx;0=F~d0YGUZ*lf0{s;cTc;NZB0D3v6hpP#>2uh-8PgB2_%!R2yQ+`4u9
zQYb!268M4z3)X5hngU6F^6AmujEszwHa0e%7D5y!0w&0QC3}-vt@<b^Q*|De^{<ET
zw+wlEIv?{aLkD^de5F>eOr13gkBN@*az6BaJsG48MQ?9!{U;kYc25+&#)iAMAprA2
z>=ciFEEda^)oa$YPsDF+X}$yjcuN`|%pV#W`f0_=RV@?oAGNjps8*Xl4B}%LFFxAr
z^}O4;lcgOaN==kb;8>QWY!t^*K5g9W1jVrZ8_Z;!ui*USF*0}o2?+^4=^k{M1EvqO
z_EZ{VHk(<oUkFiLP`{kN3`{5RJETD-lgT?ln){^_6BEPA`0s&f1O8Y*3{eJ;IF<|2
z^=Ou<v^_d=Mi&~YN{-#exfzGg=DrTkXpSB%0`C@he!esw4+=nlV;sl545knjI6(a9
zdw5oSd8i%a1J}gA4(1ea_XE<zHt)aSF9-80aE}AhN5d>g0SF8t&yC`r%gkfknusJ*
zk!F^;f-q=`p)E(?cxrU4|5YA*vIVfLzaFBWEHM!49S#R`<Hn6r(CWjf9Ps&knAo;R
z48&gGQ4I|ZpV2gZD?|nacmNw9&08P_qLiX2cXM;|yNt(E6(DhNXjBG*RL@k9{Sh=p
zV?Gj#SI>yvqDhTAhH=<*wyonaZ?_M^n1OK;fC`BRrM29tImyY%b3i5yb#--Bp)?G9
zViNvRkjNXcv9VY0-MjZgC<&kn9W<vrD62psD?mn-EiEl&<1)bSIi4&i_~+r)C}oAu
zi{Qneh9+vCo1PHiGW0tiJ*-k`;;q5X3I>B=HAFfe5G%FGfEMJ1)YRqX=BB`yaT%o5
zYPUiAIzWOfD|neR4Dd}^Sy?Xz@%<S91#%y>Zw92uIC3y>KtyL|X6C>cDcC#)jv}b1
z8D3MzM;;@z5z8@wS4iy$oY$+M-EIZvW3`bfX&kO3e56coP8`SefJAsq@_M~}A$Cwv
zTU%Sca@9NCqBO?(U{S-cdnVv#z+(oa|6_S^l&+?xrou&wm$Zi94*)+Ffa*>b@Y_OU
zfTFpjWkYUmUX#d|`m6%z6(b0eB@|JlmdwW7jK_bF@`0ts`=sv))!Tl79kE_9&dha;
z?Ld9~-7|28H-X0f1l%7Uwz;I8^LRX+5Fk{1_`JNlWe|A=l?eI7Ev>Czfv&3<##4jf
zbUJMk9}c4X;2=7edD!`nL-E_&JGRpda~|Gx1#sEzc3Y(Y0RJ}dN6>v{M#k0<{C2vd
z?I!1NIa!<2MOlZPK6=FBcOG`0AE7ANb{^eFro<Z!N!iz9(wAQ&RC)?S-y7n80Ydy3
zk-nq71O5GL1%cOX+Pvk=;X?=K#l^)f75mS^(R3&HJ0+MuXc;Jk`Hh7|Mf;2Q>?trB
zjqAn!Bf!5r72i5&ISBliefz%LzH8Uc4?vz<#lAhjKP&q$pd9Y_?IqsFEW!zuj^{j{
z$iz7oT}r|s4&+LA_0*`Qndg$x1~Wn63Y<~=!dU4~(GgEhR)t+IXJ^sw-47}&E1g!W
z_4mr3&%HnpL?mPiJHa^~z=w>uUsCdQ&B>GH_MxHSbLA&bEJQMac278bhGFWD96fru
zw5-hbw72&Z@ZSW9#X@_)S6<h}9cVp`2oQ|1xOnZ>MpxIP2Rd_R8U3_-onAY8w~xR{
z!9{^M)T2dPmH{EZ`9-bybzD*LeR6emHFf;>2}ij98RYzn7cb1Nt*Lb!C@C5KFZ}D*
zu4Uf*<EE{+c&~LLzAONmzJ`id4M}sGbmnvi&(evMz5M{kP#9>k!j!fUonp-20t^7_
W)~_S{&ugv#0000<MNUMnLSTYQXH3-q

diff --git a/browser/themes/shared/devtools/highlighter.inc.css b/browser/themes/shared/devtools/highlighter.inc.css
--- a/browser/themes/shared/devtools/highlighter.inc.css
+++ b/browser/themes/shared/devtools/highlighter.inc.css
@@ -7,32 +7,32 @@
 /* Highlighter */
 
 .highlighter-outline {
   box-shadow: 0 0 0 1px black;
   outline: 1px dashed white;
   outline-offset: -1px;
 }
 
-.highlighter-outline[locked]  {
-  box-shadow: 0 0 0 1px rgba(0,0,0,0.3);
-  outline-color: rgba(255,255,255,0.7);
-}
-
 /* Highlighter - Node Infobar */
 
 .highlighter-nodeinfobar {
   color: hsl(216,33%,97%);
   border-radius: 3px;
   background: hsl(214,13%,24%) no-repeat padding-box;
+  padding: 5px;
+  /* Avoid cases where the infobar is smaller than the arrow, when the text is
+  short */
+  min-width: 75px;
 }
 
 /* Highlighter - Node Infobar - text */
 
 .highlighter-nodeinfobar-text {
+  text-align: center;
   /* 100% - size of the buttons and margins */
   max-width: calc(100% - 2 * (26px + 6px));
   padding-bottom: 1px;
 }
 
 html|*.highlighter-nodeinfobar-tagname {
   color: hsl(285,100%,75%);
 }
@@ -41,53 +41,16 @@ html|*.highlighter-nodeinfobar-id {
   color: hsl(103,46%,54%);
 }
 
 html|*.highlighter-nodeinfobar-classes,
 html|*.highlighter-nodeinfobar-pseudo-classes {
   color: hsl(200,74%,57%);
 }
 
-/* Highlighter - Node Infobar - buttons */
-
-.highlighter-nodeinfobar-button {
-  -moz-appearance: none;
-  border-width: 0;
-  padding: 0;
-  width: 26px;
-  min-height: 26px;
-%if !defined(MOZ_WIDGET_GTK) && !defined(MOZ_WIDGET_QT)
-  background-color: transparent;
-%endif
-}
-
-.highlighter-nodeinfobar-inspectbutton {
-  -moz-border-end: 1px solid #5a6169;
-  -moz-margin-end: 12px;
-  list-style-image: url("chrome://browser/skin/devtools/inspect-button.png");
-  -moz-image-region: rect(0px 16px 16px 0px);
-}
-
-.highlighter-nodeinfobar-inspectbutton:active:hover,
-.highlighter-nodeinfobar-container:not([locked]) >  .highlighter-nodeinfobar >  .highlighter-nodeinfobar-inspectbutton {
-  -moz-image-region: rect(0px 32px 16px 16px);
-}
-
-.highlighter-nodeinfobar-menu {
-  -moz-border-start: 1px solid #5a6169;
-  -moz-margin-start: 12px;
-}
-
-.highlighter-nodeinfobar-menu > .toolbarbutton-menu-dropmarker {
-  -moz-appearance: none !important;
-  list-style-image: url("chrome://browser/skin/devtools/dropmarker.png");
-  -moz-box-align: center;
-  -moz-margin-start: -1px;
-}
-
 /* Highlighter - Node Infobar - box & arrow */
 
 .highlighter-nodeinfobar-arrow {
   width: 14px;
   height: 14px;
   -moz-margin-start: calc(50% - 7px);
   transform: rotate(-45deg);
   background-clip: padding-box;
diff --git a/browser/themes/shared/devtools/toolbars.inc.css b/browser/themes/shared/devtools/toolbars.inc.css
--- a/browser/themes/shared/devtools/toolbars.inc.css
+++ b/browser/themes/shared/devtools/toolbars.inc.css
@@ -463,16 +463,33 @@
 #command-button-splitconsole:hover:active {
   -moz-image-region: rect(0px, 48px, 16px, 32px);
 }
 
 #command-button-splitconsole[checked=true] {
   -moz-image-region: rect(0px, 64px, 16px, 48px);
 }
 
+#command-button-pick {
+  list-style-image: url("chrome://browser/skin/devtools/command-pick.png");
+  -moz-image-region: rect(0px, 16px, 16px, 0px);
+}
+
+#command-button-pick:hover {
+  -moz-image-region: rect(0px, 32px, 16px, 16px);
+}
+
+#command-button-pick:hover:active {
+  -moz-image-region: rect(0px, 48px, 16px, 32px);
+}
+
+#command-button-pick[checked=true] {
+  -moz-image-region: rect(0px, 64px, 16px, 48px);
+}
+
 /* Tabs */
 
 .devtools-tabbar {
   -moz-appearance: none;
   background: #252c33;
   border-color: #434a51;
   border-style: solid;
   border-width: 1px 0;
diff --git a/browser/themes/windows/jar.mn b/browser/themes/windows/jar.mn
--- a/browser/themes/windows/jar.mn
+++ b/browser/themes/windows/jar.mn
@@ -181,16 +181,17 @@ browser.jar:
         skin/classic/browser/devtools/commandline-icon.png          (devtools/commandline-icon.png)
         skin/classic/browser/devtools/alerticon-warning.png         (devtools/alerticon-warning.png)
         skin/classic/browser/devtools/ruleview.css                  (devtools/ruleview.css)
         skin/classic/browser/devtools/commandline.css               (devtools/commandline.css)
         skin/classic/browser/devtools/command-paintflashing.png     (devtools/command-paintflashing.png)
         skin/classic/browser/devtools/command-responsivemode.png    (devtools/command-responsivemode.png)
         skin/classic/browser/devtools/command-scratchpad.png        (devtools/command-scratchpad.png)
         skin/classic/browser/devtools/command-tilt.png              (devtools/command-tilt.png)
+        skin/classic/browser/devtools/command-pick.png              (../shared/devtools/command-pick.png)
         skin/classic/browser/devtools/command-console.png           (devtools/command-console.png)
         skin/classic/browser/devtools/markup-view.css               (../shared/devtools/markup-view.css)
         skin/classic/browser/devtools/editor-error.png               (devtools/editor-error.png)
         skin/classic/browser/devtools/editor-breakpoint.png          (devtools/editor-breakpoint.png)
         skin/classic/browser/devtools/editor-debug-location.png      (devtools/editor-debug-location.png)
 *       skin/classic/browser/devtools/webconsole.css                  (devtools/webconsole.css)
         skin/classic/browser/devtools/webconsole_networkpanel.css     (devtools/webconsole_networkpanel.css)
         skin/classic/browser/devtools/webconsole.png                  (devtools/webconsole.png)
@@ -484,16 +485,17 @@ browser.jar:
 *       skin/classic/aero/browser/devtools/light-theme.css           (../shared/devtools/light-theme.css)
         skin/classic/aero/browser/devtools/controls.png              (../shared/devtools/controls.png)
 *       skin/classic/aero/browser/devtools/widgets.css               (devtools/widgets.css)
         skin/classic/aero/browser/devtools/commandline-icon.png      (devtools/commandline-icon.png)
         skin/classic/aero/browser/devtools/command-paintflashing.png  (devtools/command-paintflashing.png)
         skin/classic/aero/browser/devtools/command-responsivemode.png (devtools/command-responsivemode.png)
         skin/classic/aero/browser/devtools/command-scratchpad.png    (devtools/command-scratchpad.png)
         skin/classic/aero/browser/devtools/command-tilt.png          (devtools/command-tilt.png)
+        skin/classic/aero/browser/devtools/command-pick.png          (../shared/devtools/command-pick.png)
         skin/classic/aero/browser/devtools/command-console.png       (devtools/command-console.png)
         skin/classic/aero/browser/devtools/alerticon-warning.png     (devtools/alerticon-warning.png)
         skin/classic/aero/browser/devtools/ruleview.css              (devtools/ruleview.css)
         skin/classic/aero/browser/devtools/commandline.css           (devtools/commandline.css)
         skin/classic/aero/browser/devtools/markup-view.css           (../shared/devtools/markup-view.css)
         skin/classic/aero/browser/devtools/editor-error.png           (devtools/editor-error.png)
         skin/classic/aero/browser/devtools/editor-breakpoint.png      (devtools/editor-breakpoint.png)
         skin/classic/aero/browser/devtools/editor-debug-location.png  (devtools/editor-debug-location.png)
diff --git a/toolkit/devtools/server/actors/highlighter.js b/toolkit/devtools/server/actors/highlighter.js
new file mode 100644
--- /dev/null
+++ b/toolkit/devtools/server/actors/highlighter.js
@@ -0,0 +1,666 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+const {Cu, Cc, Ci} = require("chrome");
+const protocol = require("devtools/server/protocol");
+const {Arg, Option, method, RetVal, types} = protocol;
+const events = require("sdk/event/core");
+// Make sure the domnode type is known here
+require("devtools/server/actors/inspector");
+
+Cu.import("resource://gre/modules/devtools/LayoutHelpers.jsm");
+Cu.import("resource://gre/modules/XPCOMUtils.jsm");
+
+// FIXME: add ":visited" and ":link" after bug 713106 is fixed
+const PSEUDO_CLASSES = [":hover", ":active", ":focus"];
+const HIGHLIGHTED_PSEUDO_CLASS = ":-moz-devtools-highlighted";
+let HELPER_SHEET = ".__fx-devtools-hide-shortcut__ { visibility: hidden !important } ";
+HELPER_SHEET += ":-moz-devtools-highlighted { outline: 2px dashed #F06!important; outline-offset: -2px!important } ";
+const XHTML_NS = "http://www.w3.org/1999/xhtml";
+
+/**
+ * The HighlighterActor is the server-side entry points for any tool that wishes
+ * to highlight elements in the content document.
+ *
+ * The highlighter can be retrieved via the inspector's getHighlighter method.
+ */
+
+/**
+ * The HighlighterActor class
+ */
+let HighlighterActor = protocol.ActorClass({
+  typeName: "highlighter",
+
+  initialize: function(inspector) {
+    protocol.Actor.prototype.initialize.call(this, null);
+
+    this._inspector = inspector;
+    this._walker = this._inspector.walker;
+    this._browser = this._inspector.tabActor.browser;
+    this._layoutHelpers = new LayoutHelpers(this._browser.contentWindow);
+
+    if (this._supportsBoxModelHighlighter()) {
+      this._boxModelHighlighter = new BoxModelHighlighter(this._browser);
+    } else {
+      this._boxModelHighlighter = new SimpleOutlineHighlighter(this._browser);
+    }
+  },
+
+  get conn() this._inspector.conn,
+
+  /**
+   * Can the host support the box model highlighter which requires a parent
+   * XUL node to attach itself.
+   */
+  _supportsBoxModelHighlighter: function() {
+    return !!this._browser.parentNode;
+  },
+
+  finalize: method(function() {
+    this._destroy();
+  }, {
+    request: {}
+  }),
+
+  destroy: function() {
+    this._destroy();
+    protocol.Actor.prototype.destroy.call(this);
+  },
+
+  _destroy: function() {
+    if (this._boxModelHighlighter) {
+      this._boxModelHighlighter.destroy();
+      this._boxModelHighlighter = null;
+    }
+    this._inspector = null;
+    this._walker = null;
+    this._browser = null;
+  },
+
+  /**
+   * Display the box model highlighting on a given NodeActor.
+   * There is only one instance of the box model highlighter, so calling this
+   * method several times won't display several highlighters, it will just move
+   * the highlighter instance to these nodes.
+   */
+  showBoxModel: method(function(node, options={}) {
+    if (this._isNodeValidForHighlighting(node.rawNode)) {
+      this._boxModelHighlighter.show(node.rawNode);
+      if (options.scrollIntoView) {
+        this._layoutHelpers.scrollIntoViewIfNeeded(node.rawNode);
+      }
+    }
+  }, {
+    request: {
+      node: Arg(0, "domnode"),
+      scrollIntoView: Option(1)
+    }
+  }),
+
+  _isNodeValidForHighlighting: function(node) {
+    // Is it null or dead?
+    let isNotDead = node && !Cu.isDeadWrapper(node);
+
+    // Is it connected to the document?
+    let isConnected = false;
+    try {
+      let doc = node.ownerDocument;
+      isConnected = (doc && doc.defaultView && doc.documentElement.contains(node));
+    } catch (e) {
+      // "can't access dead object" error
+    }
+
+    // Is it an element node
+    let isElementNode = node.nodeType === Ci.nsIDOMNode.ELEMENT_NODE;
+
+    return isNotDead && isConnected && isElementNode;
+  },
+
+  /**
+   * Hide the box model highlighting if it was shown before
+   */
+  hideBoxModel: method(function() {
+    this._boxModelHighlighter.hide();
+  }, {
+    request: {}
+  })
+});
+
+exports.HighlighterActor = HighlighterActor;
+
+/**
+ * The HighlighterFront class
+ */
+let HighlighterFront = protocol.FrontClass(HighlighterActor, {});
+
+/**
+ * The BoxModelHighlighter is the class that actually draws the the box model
+ * regions on top of a node.
+ * It is used by the HighlighterActor.
+ *
+ * Usage example:
+ *
+ * let h = new BoxModelHighlighter(browser);
+ * h.show(node);
+ * h.hide();
+ * h.destroy();
+ *
+ * Structure:
+ *  <stack class="highlighter-container">
+ *    <box class="highlighter-outline-container">
+ *      <box class="highlighter-outline" />
+ *    </box>
+ *    <box class="highlighter-nodeinfobar-container">
+ *      <box class="highlighter-nodeinfobar-positioner" position="top/bottom">
+ *        <box class="highlighter-nodeinfobar-arrow highlighter-nodeinfobar-arrow-top"/>
+ *        <hbox class="highlighter-nodeinfobar">
+ *          <hbox class="highlighter-nodeinfobar-text">tagname#id.class1.class2</hbox>
+ *        </hbox>
+ *        <box class="highlighter-nodeinfobar-arrow highlighter-nodeinfobar-arrow-bottom"/>
+ *      </box>
+ *    </box>
+ *  </stack>
+ */
+function BoxModelHighlighter(tab) {
+  this.tab = tab;
+
+  this.browser = this.tab;
+  this.win = this.browser.contentWindow;
+  this.chromeDoc = this.tab.ownerDocument;
+  this.chromeWin = this.chromeDoc.defaultView;
+  this.layoutHelpers = new LayoutHelpers(this.tab.contentWindow);
+
+  this.transitionDisabler = null;
+  this.pageEventsMuter = null;
+  this._update = this._update.bind(this);
+  this.currentNode = null;
+
+  this._initMarkup();
+}
+
+BoxModelHighlighter.prototype = {
+  _initMarkup: function() {
+    let stack = this.browser.parentNode;
+
+    this.highlighterContainer = this.chromeDoc.createElement("stack");
+    this.highlighterContainer.className = "highlighter-container";
+
+    this.outline = this.chromeDoc.createElement("box");
+    this.outline.className = "highlighter-outline";
+
+    let outlineContainer = this.chromeDoc.createElement("box");
+    outlineContainer.appendChild(this.outline);
+    outlineContainer.className = "highlighter-outline-container";
+    this.highlighterContainer.appendChild(outlineContainer);
+
+    let infobarContainer = this.chromeDoc.createElement("box");
+    infobarContainer.className = "highlighter-nodeinfobar-container";
+    this.highlighterContainer.appendChild(infobarContainer);
+
+    // Insert the highlighter right after the browser
+    stack.insertBefore(this.highlighterContainer, stack.childNodes[1]);
+
+    // Building the infobar
+    let infobarPositioner = this.chromeDoc.createElement("box");
+    infobarPositioner.className = "highlighter-nodeinfobar-positioner";
+    infobarPositioner.setAttribute("position", "top");
+    infobarPositioner.setAttribute("disabled", "true");
+
+    let nodeInfobar = this.chromeDoc.createElement("hbox");
+    nodeInfobar.className = "highlighter-nodeinfobar";
+
+    let arrowBoxTop = this.chromeDoc.createElement("box");
+    arrowBoxTop.className = "highlighter-nodeinfobar-arrow highlighter-nodeinfobar-arrow-top";
+
+    let arrowBoxBottom = this.chromeDoc.createElement("box");
+    arrowBoxBottom.className = "highlighter-nodeinfobar-arrow highlighter-nodeinfobar-arrow-bottom";
+
+    let tagNameLabel = this.chromeDoc.createElementNS(XHTML_NS, "span");
+    tagNameLabel.className = "highlighter-nodeinfobar-tagname";
+
+    let idLabel = this.chromeDoc.createElementNS(XHTML_NS, "span");
+    idLabel.className = "highlighter-nodeinfobar-id";
+
+    let classesBox = this.chromeDoc.createElementNS(XHTML_NS, "span");
+    classesBox.className = "highlighter-nodeinfobar-classes";
+
+    let pseudoClassesBox = this.chromeDoc.createElementNS(XHTML_NS, "span");
+    pseudoClassesBox.className = "highlighter-nodeinfobar-pseudo-classes";
+
+    // Add some content to force a better boundingClientRect
+    pseudoClassesBox.textContent = "&nbsp;";
+
+    // <hbox class="highlighter-nodeinfobar-text"/>
+    let texthbox = this.chromeDoc.createElement("hbox");
+    texthbox.className = "highlighter-nodeinfobar-text";
+    texthbox.setAttribute("align", "center");
+    texthbox.setAttribute("flex", "1");
+
+    texthbox.appendChild(tagNameLabel);
+    texthbox.appendChild(idLabel);
+    texthbox.appendChild(classesBox);
+    texthbox.appendChild(pseudoClassesBox);
+
+    nodeInfobar.appendChild(texthbox);
+
+    infobarPositioner.appendChild(arrowBoxTop);
+    infobarPositioner.appendChild(nodeInfobar);
+    infobarPositioner.appendChild(arrowBoxBottom);
+
+    infobarContainer.appendChild(infobarPositioner);
+
+    let barHeight = infobarPositioner.getBoundingClientRect().height;
+
+    this.nodeInfo = {
+      tagNameLabel: tagNameLabel,
+      idLabel: idLabel,
+      classesBox: classesBox,
+      pseudoClassesBox: pseudoClassesBox,
+      positioner: infobarPositioner,
+      barHeight: barHeight,
+    };
+  },
+
+  /**
+   * Destroy the nodes. Remove listeners.
+   */
+  destroy: function() {
+    this.hide();
+
+    this.chromeWin.clearTimeout(this.transitionDisabler);
+    this.chromeWin.clearTimeout(this.pageEventsMuter);
+
+    this._contentRect = null;
+    this._highlightRect = null;
+    this.outline = null;
+    this.nodeInfo = null;
+
+    this.highlighterContainer.remove();
+    this.highlighterContainer = null;
+
+    this.win = null
+    this.browser = null;
+    this.chromeDoc = null;
+    this.chromeWin = null;
+    this.currentNode = null;
+  },
+
+  /**
+   * Show the highlighter on a given node
+   *
+   * @param {DOMNode} node
+   */
+  show: function(node) {
+    if (!this.currentNode || node !== this.currentNode) {
+      // Store the currentNode
+      this.currentNode = node;
+
+      // Show the highlighter
+      this._showInfobar();
+      this._computeZoomFactor();
+      this._detachPageListeners();
+      this._attachPageListeners();
+      this._update();
+
+      // Listen for attributes mutations on the element
+      this.currentNodeObserver = node.ownerDocument.defaultView.MutationObserver(this._update);
+      this.currentNodeObserver.observe(node, {attributes: true});
+    }
+  },
+
+  /**
+   * Update the highlighter on the current highlighted node (the one that was
+   * passed as an argument to show(node)).
+   * Should be called whenever node size or attributes change
+   * @param {Boolean} brieflyDisableTransitions
+   *        In case _update is called during scrolling or repaint, set this
+   *        to true to avoid transitions
+   */
+  _update: function(brieflyDisableTransitions) {
+    if (this.currentNode) {
+      let rect = this.layoutHelpers.getDirtyRect(this.currentNode);
+
+      if (this._highlightRectangle(rect, brieflyDisableTransitions)) {
+        this._moveInfobar();
+        this._updateInfobar();
+      } else {
+        // Nothing to highlight (0px rectangle like a <script> tag for instance)
+        this.hide();
+      }
+    }
+  },
+
+  /**
+   * Hide the highlighter, the outline and the infobar.
+   */
+  hide: function() {
+    if (this.currentNode) {
+      if (this.currentNodeObserver) {
+        this.currentNodeObserver.disconnect();
+        this.currentNodeObserver = null;
+      }
+
+      this.currentNode = null;
+      this._hideOutline();
+      this._hideInfobar();
+      this._detachPageListeners();
+      this.chromeWin.focus();
+    }
+  },
+
+  /**
+   * Hide the infobar
+   */
+  _hideInfobar: function() {
+    this.nodeInfo.positioner.setAttribute("force-transitions", "true");
+    this.nodeInfo.positioner.setAttribute("hidden", "true");
+  },
+
+  /**
+   * Show the infobar
+   */
+  _showInfobar: function() {
+    this.nodeInfo.positioner.removeAttribute("hidden");
+    this._moveInfobar();
+    this.nodeInfo.positioner.removeAttribute("force-transitions");
+  },
+
+  /**
+   * Hide the outline
+   */
+  _hideOutline: function() {
+    this.outline.setAttribute("hidden", "true");
+  },
+
+  /**
+   * Show the outline
+   */
+  _showOutline: function() {
+    this.outline.removeAttribute("hidden");
+  },
+
+  /**
+   * Highlight a rectangular region.
+   *
+   * @param {object} aRect
+   *        The rectangle region to highlight.
+   * @param {boolean} brieflyDisableTransitions
+   *        Set to true to avoid transitions during the highlighting
+   * @return {boolean}
+   *         True if the rectangle was highlighted, false otherwise.
+   */
+  _highlightRectangle: function(aRect, brieflyDisableTransitions) {
+    if (!aRect) {
+      return false;
+    }
+
+    let oldRect = this._contentRect;
+
+    if (oldRect && aRect.top == oldRect.top && aRect.left == oldRect.left &&
+        aRect.width == oldRect.width && aRect.height == oldRect.height) {
+      return true; // same rectangle
+    }
+
+    let aRectScaled = this.layoutHelpers.getZoomedRect(this.win, aRect);
+    let isShown = false;
+
+    if (aRectScaled.left >= 0 && aRectScaled.top >= 0 &&
+        aRectScaled.width > 0 && aRectScaled.height > 0) {
+
+      // The bottom div and the right div are flexibles (flex=1).
+      // We don't need to resize them.
+      let top = "top:" + aRectScaled.top + "px;";
+      let left = "left:" + aRectScaled.left + "px;";
+      let width = "width:" + aRectScaled.width + "px;";
+      let height = "height:" + aRectScaled.height + "px;";
+
+      if (brieflyDisableTransitions) {
+        this._brieflyDisableTransitions();
+      }
+
+      this.outline.setAttribute("style", top + left + width + height);
+
+      isShown = true;
+      this._showOutline();
+    } else {
+      // Only return false if the element really is invisible.
+      // A height of 0 and a non-0 width corresponds to a visible element that
+      // is below the fold for instance
+      if (aRectScaled.width > 0 || aRectScaled.height > 0) {
+        isShown = true;
+        this._hideOutline();
+      }
+    }
+
+    this._contentRect = aRect; // save orig (non-scaled) rect
+    this._highlightRect = aRectScaled; // and save the scaled rect.
+
+    return isShown;
+  },
+
+  /**
+   * Update node information (tagName#id.class)
+   */
+  _updateInfobar: function() {
+    if (this.currentNode) {
+      // Tag name
+      this.nodeInfo.tagNameLabel.textContent = this.currentNode.tagName;
+
+      // ID
+      this.nodeInfo.idLabel.textContent = this.currentNode.id ? "#" + this.currentNode.id : "";
+
+      // Classes
+      let classes = this.nodeInfo.classesBox;
+
+      classes.textContent = this.currentNode.classList.length ?
+                              "." + Array.join(this.currentNode.classList, ".") : "";
+
+      // Pseudo-classes
+      let pseudos = PSEUDO_CLASSES.filter(pseudo => {
+        return DOMUtils.hasPseudoClassLock(this.currentNode, pseudo);
+      }, this);
+
+      let pseudoBox = this.nodeInfo.pseudoClassesBox;
+      pseudoBox.textContent = pseudos.join("");
+    }
+  },
+
+  /**
+   * Move the Infobar to the right place in the highlighter.
+   */
+  _moveInfobar: function() {
+    if (this._highlightRect) {
+      let winHeight = this.win.innerHeight * this.zoom;
+      let winWidth = this.win.innerWidth * this.zoom;
+
+      let rect = {top: this._highlightRect.top,
+                  left: this._highlightRect.left,
+                  width: this._highlightRect.width,
+                  height: this._highlightRect.height};
+
+      rect.top = Math.max(rect.top, 0);
+      rect.left = Math.max(rect.left, 0);
+      rect.width = Math.max(rect.width, 0);
+      rect.height = Math.max(rect.height, 0);
+
+      rect.top = Math.min(rect.top, winHeight);
+      rect.left = Math.min(rect.left, winWidth);
+
+      this.nodeInfo.positioner.removeAttribute("disabled");
+      // Can the bar be above the node?
+      if (rect.top < this.nodeInfo.barHeight) {
+        // No. Can we move the toolbar under the node?
+        if (rect.top + rect.height +
+            this.nodeInfo.barHeight > winHeight) {
+          // No. Let's move it inside.
+          this.nodeInfo.positioner.style.top = rect.top + "px";
+          this.nodeInfo.positioner.setAttribute("position", "overlap");
+        } else {
+          // Yes. Let's move it under the node.
+          this.nodeInfo.positioner.style.top = rect.top + rect.height + "px";
+          this.nodeInfo.positioner.setAttribute("position", "bottom");
+        }
+      } else {
+        // Yes. Let's move it on top of the node.
+        this.nodeInfo.positioner.style.top =
+          rect.top - this.nodeInfo.barHeight + "px";
+        this.nodeInfo.positioner.setAttribute("position", "top");
+      }
+
+      let barWidth = this.nodeInfo.positioner.getBoundingClientRect().width;
+      let left = rect.left + rect.width / 2 - barWidth / 2;
+
+      // Make sure the whole infobar is visible
+      if (left < 0) {
+        left = 0;
+        this.nodeInfo.positioner.setAttribute("hide-arrow", "true");
+      } else {
+        if (left + barWidth > winWidth) {
+          left = winWidth - barWidth;
+          this.nodeInfo.positioner.setAttribute("hide-arrow", "true");
+        } else {
+          this.nodeInfo.positioner.removeAttribute("hide-arrow");
+        }
+      }
+      this.nodeInfo.positioner.style.left = left + "px";
+    } else {
+      this.nodeInfo.positioner.style.left = "0";
+      this.nodeInfo.positioner.style.top = "0";
+      this.nodeInfo.positioner.setAttribute("position", "top");
+      this.nodeInfo.positioner.setAttribute("hide-arrow", "true");
+    }
+  },
+
+  /**
+   * Store page zoom factor.
+   */
+  _computeZoomFactor: function() {
+    this.zoom =
+      this.win.QueryInterface(Ci.nsIInterfaceRequestor)
+      .getInterface(Ci.nsIDOMWindowUtils)
+      .fullZoom;
+  },
+
+  _attachPageListeners: function() {
+    this.browser.addEventListener("resize", this, true);
+    this.browser.addEventListener("scroll", this, true);
+    this.browser.addEventListener("MozAfterPaint", this, true);
+  },
+
+  _detachPageListeners: function() {
+    this.browser.removeEventListener("resize", this, true);
+    this.browser.removeEventListener("scroll", this, true);
+    this.browser.removeEventListener("MozAfterPaint", this, true);
+  },
+
+  /**
+   * Generic event handler.
+   *
+   * @param nsIDOMEvent aEvent
+   *        The DOM event object.
+   */
+  handleEvent: function(event) {
+    switch (event.type) {
+      case "resize":
+        this._computeZoomFactor();
+        break;
+      case "MozAfterPaint":
+      case "scroll":
+        this._update(true);
+        break;
+    }
+  },
+
+  /**
+   * Disable the CSS transitions for a short time to avoid laggy animations
+   * during scrolling or resizing.
+   */
+  _brieflyDisableTransitions: function() {
+    if (this.transitionDisabler) {
+      this.chromeWin.clearTimeout(this.transitionDisabler);
+    } else {
+      this.outline.setAttribute("disable-transitions", "true");
+      this.nodeInfo.positioner.setAttribute("disable-transitions", "true");
+    }
+    this.transitionDisabler =
+      this.chromeWin.setTimeout(() => {
+        this.outline.removeAttribute("disable-transitions");
+        this.nodeInfo.positioner.removeAttribute("disable-transitions");
+        this.transitionDisabler = null;
+      }, 500);
+  }
+};
+
+/**
+ * The SimpleOutlineHighlighter is the class that has the same API as the
+ * BoxModelHighlighter, but adds a pseudo-class on the target element itself
+ * to draw a simple outline.
+ * It is used by the HighlighterActor too, but in case the more complex
+ * BoxModelHighlighter can't be attached (which is the case for FirefoxOS and
+ * Fennec targets for instance).
+ */
+function SimpleOutlineHighlighter(tab) {
+  this.tab = tab;
+
+  this.browser = this.tab;
+  this.chromeDoc = this.tab.ownerDocument;
+  this.chromeWin = this.chromeDoc.defaultView;
+}
+
+SimpleOutlineHighlighter.prototype = {
+  /**
+   * Destroy the nodes. Remove listeners.
+   */
+  destroy: function() {
+    this.hide();
+  },
+
+  _installHelperSheet: function(node) {
+    if (!this.installedHelpers) {
+      this.installedHelpers = new WeakMap;
+    }
+    let win = node.ownerDocument.defaultView;
+    if (!this.installedHelpers.has(win)) {
+      let { Style } = require("sdk/stylesheet/style");
+      let { attach } = require("sdk/content/mod");
+      let style = Style({source: HELPER_SHEET, type: "agent" });
+      attach(style, win);
+      this.installedHelpers.set(win, style);
+    }
+  },
+
+  /**
+   * Show the highlighter on a given node
+   *
+   * @param {DOMNode} node
+   */
+  show: function(node) {
+    if (!this.currentNode || node !== this.currentNode) {
+      // Store the currentNode
+      this.currentNode = node;
+
+      this._installHelperSheet(node);
+      DOMUtils.addPseudoClassLock(node, HIGHLIGHTED_PSEUDO_CLASS);
+    }
+  },
+
+  /**
+   * Hide the highlighter, the outline and the infobar.
+   */
+  hide: function() {
+    if (this.currentNode) {
+      this.currentNode = null;
+      let nodes = this.chromeDoc.querySelectorAll(HIGHLIGHTED_PSEUDO_CLASS);
+      for (let node of nodes) {
+        DOMUtils.removePseudoClassLock(node, HIGHLIGHTED_PSEUDO_CLASS);
+      }
+    }
+  }
+};
+
+XPCOMUtils.defineLazyGetter(this, "DOMUtils", function () {
+  return Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils)
+});
diff --git a/toolkit/devtools/server/actors/inspector.js b/toolkit/devtools/server/actors/inspector.js
--- a/toolkit/devtools/server/actors/inspector.js
+++ b/toolkit/devtools/server/actors/inspector.js
@@ -57,32 +57,29 @@ const {Arg, Option, method, RetVal, type
 const {LongStringActor, ShortLongString} = require("devtools/server/actors/string");
 const promise = require("sdk/core/promise");
 const object = require("sdk/util/object");
 const events = require("sdk/event/core");
 const {setTimeout, clearTimeout} = require('sdk/timers');
 const { Unknown } = require("sdk/platform/xpcom");
 const { Class } = require("sdk/core/heritage");
 const {PageStyleActor} = require("devtools/server/actors/styles");
+const {HighlighterActor} = require("devtools/server/actors/highlighter");
 
 const PSEUDO_CLASSES = [":hover", ":active", ":focus"];
-
 const HIDDEN_CLASS = "__fx-devtools-hide-shortcut__";
 
-const HIGHLIGHTED_PSEUDO_CLASS = ":-moz-devtools-highlighted";
-const HIGHLIGHTED_TIMEOUT = 2000;
-
 let HELPER_SHEET = ".__fx-devtools-hide-shortcut__ { visibility: hidden !important } ";
 HELPER_SHEET += ":-moz-devtools-highlighted { outline: 2px dashed #F06!important; outline-offset: -2px!important } ";
 
 Cu.import("resource://gre/modules/Services.jsm");
 Cu.import("resource://gre/modules/devtools/LayoutHelpers.jsm");
 
 loader.lazyGetter(this, "DOMParser", function() {
- return Cc["@mozilla.org/xmlextras/domparser;1"].createInstance(Ci.nsIDOMParser);
+  return Cc["@mozilla.org/xmlextras/domparser;1"].createInstance(Ci.nsIDOMParser);
 });
 
 exports.register = function(handle) {
   handle.addGlobalActor(InspectorActor, "inspectorActor");
   handle.addTabActor(InspectorActor, "inspectorActor");
 };
 
 exports.unregister = function(handle) {
@@ -132,17 +129,17 @@ exports.getValueSummaryLength = function
 
 exports.setValueSummaryLength = function(val) {
   gValueSummaryLength = val;
 };
 
 /**
  * Server side of the node actor.
  */
-var NodeActor = protocol.ActorClass({
+var NodeActor = exports.NodeActor = protocol.ActorClass({
   typeName: "domnode",
 
   initialize: function(walker, node) {
     protocol.Actor.prototype.initialize.call(this, null);
     this.walker = walker;
     this.rawNode = node;
   },
 
@@ -382,18 +379,18 @@ let NodeFront = protocol.FrontClass(Node
   /**
    * Destroy a node front.  The node must have been removed from the
    * ownership tree before this is called, unless the whole walker front
    * is being destroyed.
    */
   destroy: function() {
     // If an observer was added on this node, shut it down.
     if (this.observer) {
-      this._observer.disconnect();
-      this._observer = null;
+      this.observer.disconnect();
+      this.observer = null;
     }
 
     protocol.Front.prototype.destroy.call(this);
   },
 
   // Update the object given a form representation off the wire.
   form: function(form, detail, ctx) {
     if (detail === "actorid") {
@@ -844,26 +841,35 @@ var ProgressListener = Class({
  * Server side of the DOM walker.
  */
 var WalkerActor = protocol.ActorClass({
   typeName: "domwalker",
 
   events: {
     "new-mutations" : {
       type: "newMutations"
+    },
+    "picker-node-picked" : {
+      type: "pickerNodePicked",
+      node: Arg(0, "disconnectedNode")
+    },
+    "picker-node-hovered" : {
+      type: "pickerNodeHovered",
+      node: Arg(0, "disconnectedNode")
     }
   },
 
   /**
    * Create the WalkerActor
    * @param DebuggerServerConnection conn
    *    The server connection.
    */
   initialize: function(conn, tabActor, options) {
     protocol.Actor.prototype.initialize.call(this, conn);
+    this.tabActor = tabActor;
     this.rootWin = tabActor.window;
     this.rootDoc = this.rootWin.document;
     this._refMap = new Map();
     this._pendingMutations = [];
     this._activePseudoClassLocks = new Set();
 
     this.layoutHelpers = new LayoutHelpers(this.rootWin);
 
@@ -899,16 +905,17 @@ var WalkerActor = protocol.ActorClass({
     }
   },
 
   toString: function() {
     return "[WalkerActor " + this.actorID + "]";
   },
 
   destroy: function() {
+    this._hoveredNode = null;
     this.clearPseudoClassLocks();
     this._activePseudoClassLocks = null;
     this.progressListener.destroy();
     this.rootDoc = null;
     events.emit(this, "destroyed");
     protocol.Actor.prototype.destroy.call(this);
   },
 
@@ -938,103 +945,124 @@ var WalkerActor = protocol.ActorClass({
 
     if (node.nodeType === Ci.nsIDOMNode.DOCUMENT_NODE) {
       this._watchDocument(actor);
     }
     return actor;
   },
 
   /**
+   * This is kept for backward-compatibility reasons with older remote targets.
+   * Targets prior to bug 916443.
+   *
+   * pick/cancelPick are used to pick a node on click on the content
+   * document. But in their implementation prior to bug 916443, they don't allow
+   * highlighting on hover.
+   * The client-side now uses pick2 and cancelPick2 instead to benefit from
+   * fired events used to highlight the hovered nodes. The client-side uses the
+   * the highlightable trait found in the root actor to determine which version
+   * of pick to use.
+   *
+   * As for highlight, there is now a new highlighter actor that is used instead
+   * of the older walker one here. Same here though, the client-side uses the
+   * highlightable trait to dertermine which to use.
+   *
+   * Keeping these actor methods for now allows newer client-side debuggers to
+   * inspect fxos 1.2 remote targets or older firefox desktop remote targets.
+   */
+  pick: method(function() {}, {request: {}, response: RetVal("disconnectedNode")}),
+  cancelPick: method(function() {}),
+  highlight: method(function(node) {}, {request: {node: Arg(0, "nullable:domnode")}}),
+
+  /**
    * Pick a node on click.
+   *
+   * This method doesn't respond anything interesting, however, it starts
+   * mousemove, and click listeners on the content document to fire
+   * events and let connected clients know when nodes are hovered over or
+   * clicked.
+   *
+   * Once a node is picked, events will cease, and listeners will be removed.
    */
-  _pickDeferred: null,
-  pick: method(function() {
-    if (this._pickDeferred) {
-      return this._pickDeferred.promise;
+  _isPicking: false,
+  _hoveredNode: null,
+  pick2: method(function() {
+    if (this._isPicking) {
+      return null;
     }
+    this._isPicking = true;
 
-    this._pickDeferred = promise.defer();
+    this._preventContentEvent = event => {
+      event.stopPropagation();
+      event.preventDefault();
+    };
 
-    let window = this.rootDoc.defaultView;
-    let isTouch = 'ontouchstart' in window;
-    let event = isTouch ? 'touchstart' : 'click';
+    this._onPick = event => {
+      this._preventContentEvent(event);
+      this._stopPickerListeners();
+      this._isPicking = false;
+      events.emit(this, "picker-node-picked", this._findAndAttachElement(event));
+    };
 
-    this._onPick = function(e) {
-      e.stopImmediatePropagation();
-      e.preventDefault();
-      window.removeEventListener(event, this._onPick, true);
-      let u = window.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils);
+    this._onHovered = event => {
+      this._preventContentEvent(event);
+      let res = this._findAndAttachElement(event);
+      if (this._hoveredNode !== res.node) {
+        events.emit(this, "picker-node-hovered", res);
+        this._hoveredNode = res.node;
+      }
+    };
 
-      let x, y;
-      if (isTouch) {
-        x = e.touches[0].clientX;
-        y = e.touches[0].clientY;
-      } else {
-        x = e.clientX;
-        y = e.clientY;
-      }
+    this._startPickerListeners();
 
-      let node = u.elementFromPoint(x, y, false, false);
-      node = this._ref(node);
-      let newParents = this.ensurePathToRoot(node);
+    return null;
+  }),
 
-      this._pickDeferred.resolve({
-        node: node,
-        newParents: [parent for (parent of newParents)]
-      });
-      this._pickDeferred = null;
+  _findAndAttachElement: function(event) {
+    let doc = event.target.ownerDocument;
 
-    }.bind(this);
+    let x = event.clientX;
+    let y = event.clientY;
 
-    window.addEventListener(event, this._onPick, true);
+    let node = doc.elementFromPoint(x, y);
+    node = this._ref(node);
+    let newParents = this.ensurePathToRoot(node);
 
-    return this._pickDeferred.promise;
-  }, { request: { }, response: RetVal("disconnectedNode") }),
+    return {
+      node: node,
+      newParents: [parent for (parent of newParents)]
+    };
+  },
 
-  cancelPick: method(function() {
-    if (this._pickDeferred) {
-      let window = this.rootDoc.defaultView;
-      let isTouch = 'ontouchstart' in window;
-      let event = isTouch ? 'touchstart' : 'click';
-      window.removeEventListener(event, this._onPick, true);
-      this._pickDeferred.resolve(null);
-      this._pickDeferred = null;
+  _startPickerListeners: function() {
+    let browser = this.tabActor.browser;
+    browser.addEventListener("mousemove", this._onHovered, true);
+    browser.addEventListener("click", this._onPick, true);
+    browser.addEventListener("mousedown", this._preventContentEvent, true);
+    browser.addEventListener("mouseup", this._preventContentEvent, true);
+    browser.addEventListener("dblclick", this._preventContentEvent, true);
+  },
+
+  _stopPickerListeners: function() {
+    let browser = this.tabActor.browser;
+    browser.removeEventListener("mousemove", this._onHovered, true);
+    browser.removeEventListener("click", this._onPick, true);
+    browser.removeEventListener("mousedown", this._preventContentEvent, true);
+    browser.removeEventListener("mouseup", this._preventContentEvent, true);
+    browser.removeEventListener("dblclick", this._preventContentEvent, true);
+  },
+
+  cancelPick2: method(function() {
+    if (this._isPicking) {
+      this._stopPickerListeners();
+      this._isPicking = false;
     }
   }),
 
   /**
-   * Simple highlight mechanism.
-   */
-  _unhighlight: function() {
-    clearTimeout(this._highlightTimeout);
-    if (!this.rootDoc) {
-      return;
-    }
-    let nodes = this.rootDoc.querySelectorAll(HIGHLIGHTED_PSEUDO_CLASS);
-    for (let node of nodes) {
-      DOMUtils.removePseudoClassLock(node, HIGHLIGHTED_PSEUDO_CLASS);
-    }
-  },
-
-  highlight: method(function(node) {
-    this._unhighlight();
-
-    if (!node ||
-        !node.rawNode ||
-         node.rawNode.nodeType !== Ci.nsIDOMNode.ELEMENT_NODE) {
-      return;
-    }
-
-    this._installHelperSheet(node);
-    DOMUtils.addPseudoClassLock(node.rawNode, HIGHLIGHTED_PSEUDO_CLASS);
-    this._highlightTimeout = setTimeout(this._unhighlight.bind(this), HIGHLIGHTED_TIMEOUT);
-
-  }, { request: { node: Arg(0, "nullable:domnode") }}),
-
-  /**
    * Watch the given document node for mutations using the DOM observer
    * API.
    */
   _watchDocument: function(actor) {
     let node = actor.rawNode;
     // Create the observer on the node's actor.  The node will make sure
     // the observer is cleaned up when the actor is released.
     actor.observer = actor.rawNode.defaultView.MutationObserver(this.onMutations);
@@ -1984,23 +2012,25 @@ var WalkerActor = protocol.ActorClass({
 
 /**
  * Client side of the DOM walker.
  */
 var WalkerFront = exports.WalkerFront = protocol.FrontClass(WalkerActor, {
   // Set to true if cleanup should be requested after every mutation list.
   autoCleanup: true,
 
+  /**
+   * This is kept for backward-compatibility reasons with older remote target.
+   * Targets previous to bug 916443
+   */
   pick: protocol.custom(function() {
     return this._pick().then(response => {
       return response.node;
     });
-  }, {
-    impl: "_pick"
-  }),
+  }, {impl: "_pick"}),
 
   initialize: function(client, form) {
     this._createRootNodePromise();
     protocol.Front.prototype.initialize.call(this, client, form);
     this._orphaned = new Set();
     this._retainedOrphans = new Set();
   },
 
@@ -2385,17 +2415,35 @@ var InspectorActor = protocol.ActorClass
     }
 
     this._pageStylePromise = this.getWalker().then(walker => {
       return PageStyleActor(this);
     });
     return this._pageStylePromise;
   }, {
     request: {},
-    response: { pageStyle: RetVal("pagestyle") }
+    response: {
+      pageStyle: RetVal("pagestyle")
+    }
+  }),
+
+  getHighlighter: method(function () {
+    if (this._highlighterPromise) {
+      return this._highlighterPromise;
+    }
+
+    this._highlighterPromise = this.getWalker().then(walker => {
+      return HighlighterActor(this);
+    });
+    return this._highlighterPromise;
+  }, {
+    request: {},
+    response: {
+      highligter: RetVal("highlighter")
+    }
   })
 });
 
 /**
  * Client side of the inspector actor, which is used to create
  * inspector-related actors, including the walker.
  */
 var InspectorFront = exports.InspectorFront = protocol.FrontClass(InspectorActor, {
diff --git a/toolkit/devtools/server/actors/root.js b/toolkit/devtools/server/actors/root.js
--- a/toolkit/devtools/server/actors/root.js
+++ b/toolkit/devtools/server/actors/root.js
@@ -171,17 +171,20 @@ RootActor.prototype = {
   sayHello: function() {
     return {
       from: this.actorID,
       applicationType: this.applicationType,
       /* This is not in the spec, but it's used by tests. */
       testConnectionPrefix: this.conn.prefix,
       traits: {
         sources: true,
-        editOuterHTML: true
+        editOuterHTML: true,
+        // Wether the server-side highlighter actor exists and can be used to
+        // remotely highlight nodes (see server/actors/highlighter.js)
+        highlightable: true
       }
     };
   },
 
   /**
    * This is true for the root actor only, used by some child actors
    */
   get isRootActor() true,
diff --git a/toolkit/devtools/server/protocol.js b/toolkit/devtools/server/protocol.js
--- a/toolkit/devtools/server/protocol.js
+++ b/toolkit/devtools/server/protocol.js
@@ -243,16 +243,17 @@ types.addDictType = function(name, speci
  */
 types.addActorType = function(name) {
   let type = types.addType(name, {
     _actor: true,
     read: (v, ctx, detail) => {
       // If we're reading a request on the server side, just
       // find the actor registered with this actorID.
       if (ctx instanceof Actor) {
+        if (!ctx.conn) debugger;
         return ctx.conn.getActor(v);
       }
 
       // Reading a response on the client side, check for an
       // existing front on the connection, and create the front
       // if it isn't found.
       let actorID = typeof(v) === "string" ? v : v.actor;
       let front = ctx.conn.getActor(actorID);
diff --git a/toolkit/devtools/webconsole/utils.js b/toolkit/devtools/webconsole/utils.js
--- a/toolkit/devtools/webconsole/utils.js
+++ b/toolkit/devtools/webconsole/utils.js
@@ -1430,18 +1430,17 @@ function JSTermHelpers(aOwner)
         // Console every time when she evaluates any string.
       }
 
       if (!target) {
         return null;
       }
 
       let toolbox = gDevTools.getToolbox(target);
-      let panel = toolbox ? toolbox.getPanel("inspector") : null;
-      let node = panel ? panel.selection.node : null;
+      let node = toolbox && toolbox.selection ? toolbox.selection.node : null;
 
       return node ? aOwner.makeDebuggeeValue(node) : null;
     },
     enumerable: true,
     configurable: false
   });
 
   /**
