# HG changeset patch
# Parent  a72096bff057d469bf02132d723af1091f19f728

diff --git a/browser/base/content/browser-box.inc.xhtml b/browser/base/content/browser-box.inc.xhtml
--- a/browser/base/content/browser-box.inc.xhtml
+++ b/browser/base/content/browser-box.inc.xhtml
@@ -3,6 +3,12 @@
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 <hbox flex="1" id="browser">
+  <hbox id="containerui-sidebar">
+    <vbox>
+      <vbox class="containerui-list-container">
+      </vbox>
+    </vbox>
+  </hbox>
   <vbox id="sidebar-box" hidden="true" class="chromeclass-extrachrome">
     <box id="sidebar-header" align="center">
       <toolbarbutton id="sidebar-switcher-target" flex="1" class="tabbable">
diff --git a/browser/base/content/browser-containerui.js b/browser/base/content/browser-containerui.js
new file mode 100644
--- /dev/null
+++ b/browser/base/content/browser-containerui.js
@@ -0,0 +1,169 @@
+var ContainerUI = {
+  setSizes() {
+    let marginTop =
+      document.querySelector("#navigator-toolbox").scrollHeight -
+      document.querySelector("#titlebar").scrollHeight;
+    document.querySelector(
+      "#containerui-sidebar"
+    ).style.marginTop = `-${marginTop}px`;
+
+    // Todo: also set margin-inline-start / css variable for relevant titlebar children
+  },
+  init() {
+    let tabParent = document.querySelector(".containerui-list-container");
+    this.setSizes();
+    document.documentElement.setAttribute("containerui", "true");
+    // document.documentElement.classList.add("containerui-visible");
+    let iconForUserContext = new Map();
+
+    // Todo brand new PB window doesn't have container ui for first tab
+    // Todo group by container
+
+    function selectUserContextId(userContextId) {
+      let reselect = false;
+      for (let t of gBrowser.tabs) {
+        if (t.userContextId !== userContextId) {
+          if (t == gBrowser.selectedTab) {
+            reselect = true;
+          }
+          gBrowser.hideTab(t);
+        } else {
+          gBrowser.showTab(t);
+        }
+      }
+
+      if (reselect) {
+        for (let t of gBrowser.tabs) {
+          if (t.userContextId === userContextId) {
+            let oldTab = gBrowser.selectedTab;
+            gBrowser.selectedTab = t;
+            gBrowser.hideTab(oldTab);
+            break;
+          }
+        }
+      }
+
+      // Needed when showing the normal tabbrowser to reset pinned area size
+      gBrowser.tabContainer._positionPinnedTabs();
+    }
+
+    function createContainerIcon(userContextId) {
+      if (iconForUserContext.has(userContextId)) {
+        return iconForUserContext.get(userContextId);
+      }
+      let identity = ContextualIdentityService.getPublicIdentityFromId(
+        userContextId
+      );
+      let li = document.createElement("li");
+      li.classList.add("userContext-icon");
+
+      if (identity) {
+        li.classList.add(`identity-color-${identity.color}`);
+        li.classList.add(`identity-icon-${identity.icon}`);
+
+        let label = ContextualIdentityService.getUserContextLabel(
+          userContextId
+        );
+        li.setAttribute("title", label);
+        // let name = identity.l10nID
+        //   ? gNavigatorBundle.getString(identity.l10nID)
+        //   : identity.name;
+
+        // let labelContainer = document.createElement("label");
+        // let label = ContextualIdentityService.getUserContextLabel(userContextId);
+        // labelContainer.append(label);
+        // li.append(labelContainer);
+      } else {
+        li.classList.add(`default-container`);
+      }
+
+      li.onclick = () => {
+        selectUserContextId(userContextId);
+      };
+
+      iconForUserContext.set(userContextId, li);
+      return li;
+    }
+
+    function renderAll() {
+      let userContextToTabs = new Map();
+      let selectedUserContextId = gBrowser.selectedTab.userContextId;
+      let identity = ContextualIdentityService.getPublicIdentityFromId(
+        selectedUserContextId
+      );
+      // console.log(`Tabs# ${gBrowser.tabs.length}`);
+      for (let t of gBrowser.tabs) {
+        let { userContextId } = t;
+        if (!userContextToTabs.has(userContextId)) {
+          userContextToTabs.set(userContextId, []);
+        }
+        userContextToTabs.get(userContextId).push(t);
+      }
+
+      let list = document.createElement("ul");
+      let li = createContainerIcon(0);
+      list.append(li);
+      if (selectedUserContextId == 0) {
+        li.setAttribute("selected", "true");
+      } else {
+        li.removeAttribute("selected");
+      }
+
+      for (let userContextId of userContextToTabs.keys()) {
+        if (userContextId == 0) {
+          // Todo sort this instead of duplicating the code above
+          continue;
+        }
+
+        //       if (!identity) {
+        //         replaceContainerClass("color", hbox, "");
+        //         hbox.hidden = true;
+        //         return;
+        //       }
+
+        // replaceContainerClass("color", hbox, identity.color);
+
+        // let label = ContextualIdentityService.getUserContextLabel(userContextId);
+        // document.getElementById("userContext-label").setAttribute("value", label);
+        // // Also set the container label as the tooltip so we can only show the icon
+        // // in small windows.
+        // hbox.setAttribute("tooltiptext", label);
+
+        // let indicator = document.getElementById("userContext-indicator");
+        // replaceContainerClass("icon", indicator, identity.icon);
+
+        let li = createContainerIcon(userContextId);
+
+        if (userContextId == selectedUserContextId) {
+          li.setAttribute("selected", "true");
+        } else {
+          li.removeAttribute("selected");
+        }
+
+        list.append(li);
+      }
+
+      let addLi = document.createElement("li");
+      addLi.classList.add("add-container");
+      addLi.textContent = "+";
+      list.append(addLi);
+
+      tabParent.textContent = "";
+      tabParent.append(list);
+
+      // make sure to switch in case a tab gets reopneed from a different container
+      selectUserContextId(selectedUserContextId);
+    }
+
+    // if (gBrowser.selectedBrowser.currentURI.spec == "about:sessionrestore") {
+    //   // document.documentElement.classList.add("containerui-visible");
+    // }
+    renderAll();
+    document.addEventListener("TabOpen", e => {
+      renderAll();
+    });
+    document.addEventListener("TabAttrModified", e => {
+      renderAll();
+    });
+  },
+};
diff --git a/browser/base/content/browser.css b/browser/base/content/browser.css
--- a/browser/base/content/browser.css
+++ b/browser/base/content/browser.css
@@ -44,6 +44,77 @@ body {
   -moz-box-flex: 1;
 }
 
+.tabbrowser-tab[pinned][hidden] {
+  display: none !important;
+}
+
+:root:not([containerui="true"]) #containerui-sidebar {
+  display: none;
+}
+
+:root[containerui="true"] #nav-bar,
+:root[containerui="true"] #PersonalToolbar {
+  /* Todo: set this dynamically */
+  margin-inline-start: 56px;
+}
+
+#container-overlay {
+  -moz-box-flex: 1;
+}
+
+#containerui-sidebar {
+  background: var(--toolbar-bgcolor);
+  color: var(--toolbar-color);
+}
+
+#containerui-sidebar .containerui-list-container {
+  -moz-box-flex: 1;
+}
+#containerui-sidebar tab {
+  height: 15px !important;
+}
+#containerui-sidebar ul,
+#containerui-sidebar li {
+  list-style: none;
+  padding: 0;
+  margin: 0;
+}
+#containerui-sidebar li {
+  width: 48px;
+  height: 32px;
+  margin: 16px 3px 16px 3px;
+  /* margin-bottom: 16px; */
+  /* margin: 16px 0; */
+  border-left: solid 2px transparent;
+}
+#containerui-sidebar li.default-container {
+  --identity-icon: url("chrome://browser/skin/fxa/avatar-empty.svg");
+  --identity-tab-color: #ccc;
+  --identity-icon-color: #ccc;
+}
+
+#containerui-sidebar li.add-container {
+  text-align: center;
+  font-weight: 900;
+  font-size: 24px;
+}
+#containerui-sidebar li.add-container:hover {
+  background: rgba(0, 0, 0, .5);
+}
+/* #containerui-sidebar li label {
+  position: relative;
+  background: orange;
+  top: 32px;
+  text-align: center;
+  display: block;
+} */
+#containerui-sidebar li[selected] {
+  border-left: solid 2px var(--identity-icon-color);
+}
+
+
+/* Set additional backgrounds alignment relative to toolbox */
+
 #navigator-toolbox:-moz-lwtheme {
   background-image: var(--lwt-additional-images);
   background-repeat: var(--lwt-background-tiling);
diff --git a/browser/base/content/browser.js b/browser/base/content/browser.js
--- a/browser/base/content/browser.js
+++ b/browser/base/content/browser.js
@@ -12,6 +12,8 @@ var { AppConstants } = ChromeUtils.impor
 );
 ChromeUtils.import("resource://gre/modules/NotificationDB.jsm");
 
+window.ENABLE_CONTAINER_UI = true;
+
 // lazy module getters
 
 XPCOMUtils.defineLazyModuleGetters(this, {
@@ -1689,6 +1691,10 @@ var gBrowserInit = {
     delete window._gBrowser;
     gBrowser.init();
 
+    if (window.ENABLE_CONTAINER_UI) {
+      ContainerUI.init();
+    }
+
     BrowserWindowTracker.track(window);
 
     gNavToolbox.palette = document.getElementById(
@@ -6304,6 +6310,14 @@ nsBrowserAccess.prototype = {
         let userContextId = aOpenWindowInfo
           ? aOpenWindowInfo.originAttributes.userContextId
           : Ci.nsIScriptSecurityManager.DEFAULT_USER_CONTEXT_ID;
+
+        if (
+          window.ENABLE_CONTAINER_UI &&
+          userContextId == Ci.nsIScriptSecurityManager.DEFAULT_USER_CONTEXT_ID
+        ) {
+          userContextId = gBrowser.guessUserContextId(aURI);
+        }
+
         let browser = this._openURIInNewTab(
           aURI,
           referrerInfo,
@@ -6704,6 +6718,10 @@ function setToolbarVisibility(
     Services.xulStore.persist(toolbar, hidingAttribute);
   }
 
+  if (window.ENABLE_CONTAINER_UI) {
+    ContainerUI.setSizes();
+  }
+
   let eventParams = {
     detail: {
       visible: isVisible,
diff --git a/browser/base/content/browser.xhtml b/browser/base/content/browser.xhtml
--- a/browser/base/content/browser.xhtml
+++ b/browser/base/content/browser.xhtml
@@ -93,6 +93,7 @@
   /* eslint-env mozilla/browser-window */
   Services.scriptloader.loadSubScript("chrome://global/content/contentAreaUtils.js", this);
   Services.scriptloader.loadSubScript("chrome://browser/content/browser-captivePortal.js", this);
+  Services.scriptloader.loadSubScript("chrome://browser/content/browser-containerui.js", this);
   if (AppConstants.MOZ_DATA_REPORTING) {
     Services.scriptloader.loadSubScript("chrome://browser/content/browser-data-submission-info-bar.js", this);
   }
@@ -154,7 +155,6 @@
 #include ../../components/customizableui/content/customizeMode.inc.xhtml
     ]]></box>
   </html:template>
-
 #include fullscreen-and-pointerlock.inc.xhtml
 
   <vbox id="browser-bottombox" layer="true">
diff --git a/browser/base/content/tabbrowser-tabs.js b/browser/base/content/tabbrowser-tabs.js
--- a/browser/base/content/tabbrowser-tabs.js
+++ b/browser/base/content/tabbrowser-tabs.js
@@ -1347,7 +1347,7 @@
       let numPinned = gBrowser._numPinnedTabs;
       let doPosition =
         this.getAttribute("overflow") == "true" &&
-        tabs.length > numPinned &&
+        this._getVisibleTabs().length > numPinned &&
         numPinned > 0;
 
       this.toggleAttribute("haspinnedtabs", !!numPinned);
diff --git a/browser/base/content/tabbrowser.js b/browser/base/content/tabbrowser.js
--- a/browser/base/content/tabbrowser.js
+++ b/browser/base/content/tabbrowser.js
@@ -246,6 +246,52 @@
 
     _hoverTabTimer: null,
 
+    // Proof of concept of https://bugzilla.mozilla.org/show_bug.cgi?id=1692124
+    guessUserContextId(aURI) {
+      let userContextId =
+        gBrowser.selectedTab?.userContextId ||
+        Ci.nsIScriptSecurityManager.DEFAULT_USER_CONTEXT_ID;
+      console.log(`Got open request from container UI ${aURI}`);
+
+      let matchingContainers = new Map();
+      for (let tab of gBrowser.tabs) {
+        if (!tab.linkedBrowser) {
+          // Todo can we get url from the tab and not the browser (i.e. if we did a session restore)
+          continue;
+        }
+        let currentURIHost = null;
+        try {
+          currentURIHost = tab.linkedBrowser.currentURI.host;
+        } catch (e) {}
+        if (currentURIHost == aURI.host) {
+          if (!matchingContainers.has(userContextId)) {
+            matchingContainers.set(userContextId, 0);
+          }
+          matchingContainers.set(
+            userContextId,
+            matchingContainers.get(userContextId) + 1
+          );
+          userContextId = tab.userContextId;
+        }
+      }
+
+      let maxUserContext = [...matchingContainers.entries()].reduce((a, e) =>
+        e[1] > a[1] ? e : a
+      );
+      console.log(matchingContainers.entries(), maxUserContext);
+      if (maxUserContext) {
+        userContextId = maxUserContext[0];
+      }
+
+      // Actively focused container if we don't have a strong signal from existing tabs?
+      if (!userContextId) {
+        console.log("Just use current container");
+        userContextId = gBrowser.selectedTab.userContextId;
+      }
+
+      return userContextId;
+    },
+
     get tabContainer() {
       delete this.tabContainer;
       return (this.tabContainer = document.getElementById("tabbrowser-tabs"));
@@ -291,8 +337,10 @@
     },
 
     get _numPinnedTabs() {
-      for (var i = 0; i < this.tabs.length; i++) {
-        if (!this.tabs[i].pinned) {
+      // XXX: We allow hidden pinned within container
+      let tabs = this.visibleTabs;
+      for (var i = 0; i < tabs.length; i++) {
+        if (!tabs[i].pinned) {
           break;
         }
       }
@@ -2648,6 +2696,12 @@
         userContextId = openerTab.getAttribute("usercontextid") || 0;
       }
 
+      // Make a new tab inherit the currently selected tab's container.
+      // Todo: Maybe make this read some global state on which container is selected instead?
+      if (window.ENABLE_CONTAINER_UI && userContextId == null && !openerTab) {
+        userContextId = gBrowser.selectedTab.userContextId;
+      }
+
       if (!noInitialLabel) {
         if (isBlankPageURL(aURI)) {
           t.setAttribute("label", this.tabContainer.emptyTabTitle);
@@ -4487,7 +4541,7 @@
     hideTab(aTab, aSource) {
       if (
         aTab.hidden ||
-        aTab.pinned ||
+        (!window.ENABLE_CONTAINER_UI && aTab.pinned) ||
         aTab.selected ||
         aTab.closing ||
         // Tabs that are sharing the screen, microphone or camera cannot be hidden.
diff --git a/browser/base/jar.mn b/browser/base/jar.mn
--- a/browser/base/jar.mn
+++ b/browser/base/jar.mn
@@ -42,6 +42,7 @@ browser.jar:
         content/browser/browser-allTabsMenu.js        (content/browser-allTabsMenu.js)
         content/browser/browser-captivePortal.js      (content/browser-captivePortal.js)
         content/browser/browser-ctrlTab.js            (content/browser-ctrlTab.js)
+        content/browser/browser-containerui.js        (content/browser-containerui.js)
         content/browser/browser-customization.js      (content/browser-customization.js)
         content/browser/browser-data-submission-info-bar.js (content/browser-data-submission-info-bar.js)
 #ifndef MOZILLA_OFFICIAL
