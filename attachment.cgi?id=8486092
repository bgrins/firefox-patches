# HG changeset patch
# User Mihai Sucan <mihai.sucan@gmail.com>
# Date 1407604820 -10800
#      Sat Aug 09 20:20:20 2014 +0300
# Node ID 56225651f72dbb589e2ab5ad63983692a51d61ed
# Parent 46dfee14106aa8e64b5844093875d579d4f75dfa
Bug 1042253 - Enable devtools/webconsole tests with e10s; r=robcee

diff --git a/browser/devtools/webconsole/test/browser.ini b/browser/devtools/webconsole/test/browser.ini
--- a/browser/devtools/webconsole/test/browser.ini
+++ b/browser/devtools/webconsole/test/browser.ini
@@ -1,10 +1,9 @@
 [DEFAULT]
-skip-if = e10s # Bug ?????? - devtools tests disabled with e10s
 subsuite = devtools
 support-files =
   head.js
   test-bug-585956-console-trace.html
   test-bug-593003-iframe-wrong-hud-iframe.html
   test-bug-593003-iframe-wrong-hud.html
   test-bug-595934-canvas-css.html
   test-bug-595934-canvas-css.js
@@ -123,194 +122,235 @@ support-files =
 [browser_bug_862916_console_dir_and_filter_off.js]
 [browser_bug_865288_repeat_different_objects.js]
 [browser_bug_865871_variables_view_close_on_esc_key.js]
 [browser_bug_869003_inspect_cross_domain_object.js]
 [browser_bug_871156_ctrlw_close_tab.js]
 [browser_cached_messages.js]
 skip-if = buildapp == 'mulet'
 [browser_console.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_console_addonsdk_loader_exception.js]
+skip-if = e10s # Bug 1049103 - e10s: closing the Browser Console breaks the toolbox
 [browser_console_clear_on_reload.js]
 [browser_console_click_focus.js]
 [browser_console_consolejsm_output.js]
 [browser_console_dead_objects.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_console_error_source_click.js]
-skip-if = buildapp == 'mulet'
+skip-if = buildapp == 'mulet' || e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_console_filters.js]
 [browser_console_iframe_messages.js]
 skip-if = buildapp == 'mulet'
 [browser_console_keyboard_accessibility.js]
 [browser_console_log_inspectable_object.js]
 [browser_console_native_getters.js]
 [browser_console_navigation_marker.js]
 [browser_console_nsiconsolemessage.js]
 skip-if = buildapp == 'mulet'
 [browser_console_optimized_out_vars.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_console_private_browsing.js]
-skip-if = buildapp == 'mulet'
+skip-if = buildapp == 'mulet' || e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_console_variables_view.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_console_variables_view_dom_nodes.js]
 [browser_console_variables_view_dont_sort_non_sortable_classes_properties.js]
 skip-if = buildapp == 'mulet'
 [browser_console_variables_view_while_debugging.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_console_variables_view_while_debugging_and_inspecting.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_eval_in_debugger_stackframe.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_jsterm_inspect.js]
 [browser_longstring_hang.js]
 [browser_netpanel_longstring_expand.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_output_breaks_after_console_dir_uninspectable.js]
 [browser_output_longstring_expand.js]
 [browser_repeated_messages_accuracy.js]
 skip-if = buildapp == 'mulet'
 [browser_result_format_as_string.js]
 [browser_warn_user_about_replaced_api.js]
 [browser_webconsole_abbreviate_source_url.js]
 [browser_webconsole_allow_mixedcontent_securityerrors.js]
 skip-if = buildapp == 'mulet'
 [browser_webconsole_assert.js]
 [browser_webconsole_basic_net_logging.js]
 [browser_webconsole_block_mixedcontent_securityerrors.js]
 skip-if = buildapp == 'mulet'
 [browser_webconsole_bug_579412_input_focus.js]
 [browser_webconsole_bug_580001_closing_after_completion.js]
 [browser_webconsole_bug_580030_errors_after_page_reload.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_webconsole_bug_580454_timestamp_l10n.js]
 [browser_webconsole_bug_582201_duplicate_errors.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_webconsole_bug_583816_No_input_and_Tab_key_pressed.js]
 [browser_webconsole_bug_585237_line_limit.js]
 [browser_webconsole_bug_585956_console_trace.js]
 [browser_webconsole_bug_585991_autocomplete_keys.js]
 [browser_webconsole_bug_585991_autocomplete_popup.js]
 [browser_webconsole_bug_586388_select_all.js]
 [browser_webconsole_bug_587617_output_copy.js]
 [browser_webconsole_bug_588342_document_focus.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_webconsole_bug_588730_text_node_insertion.js]
 [browser_webconsole_bug_588967_input_expansion.js]
 [browser_webconsole_bug_589162_css_filter.js]
 [browser_webconsole_bug_592442_closing_brackets.js]
 [browser_webconsole_bug_593003_iframe_wrong_hud.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_webconsole_bug_594477_clickable_output.js]
 [browser_webconsole_bug_594497_history_arrow_keys.js]
 [browser_webconsole_bug_595223_file_uri.js]
 [browser_webconsole_bug_595350_multiple_windows_and_tabs.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_webconsole_bug_595934_message_categories.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_webconsole_bug_597103_deactivateHUDForContext_unfocused_window.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_webconsole_bug_597136_external_script_errors.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_webconsole_bug_597136_network_requests_from_chrome.js]
 [browser_webconsole_bug_597460_filter_scroll.js]
 [browser_webconsole_bug_597756_reopen_closed_tab.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_webconsole_bug_599725_response_headers.js]
 [browser_webconsole_bug_600183_charset.js]
 [browser_webconsole_bug_601177_log_levels.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_webconsole_bug_601352_scroll.js]
 [browser_webconsole_bug_601667_filter_buttons.js]
 [browser_webconsole_bug_602572_log_bodies_checkbox.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s - attempt: https://pastebin.mozilla.org/6153491
 [browser_webconsole_bug_603750_websocket.js]
 [browser_webconsole_bug_611795.js]
 [browser_webconsole_bug_613013_console_api_iframe.js]
 [browser_webconsole_bug_613280_jsterm_copy.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_webconsole_bug_613642_maintain_scroll.js]
 [browser_webconsole_bug_613642_prune_scroll.js]
 [browser_webconsole_bug_614793_jsterm_scroll.js]
 [browser_webconsole_bug_618078_network_exceptions.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_webconsole_bug_618311_close_panels.js]
 [browser_webconsole_bug_621644_jsterm_dollar.js]
 [browser_webconsole_bug_622303_persistent_filters.js]
 [browser_webconsole_bug_623749_ctrl_a_select_all_winnt.js]
 run-if = os == "win"
 [browser_webconsole_bug_630733_response_redirect_headers.js]
 [browser_webconsole_bug_632275_getters_document_width.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_webconsole_bug_632347_iterators_generators.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_webconsole_bug_632817.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_webconsole_bug_642108_pruneTest.js]
 [browser_webconsole_autocomplete_and_selfxss.js]
 [browser_webconsole_bug_644419_log_limits.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_webconsole_bug_646025_console_file_location.js]
 [browser_webconsole_bug_651501_document_body_autocomplete.js]
 [browser_webconsole_bug_653531_highlighter_console_helper.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_webconsole_bug_658368_time_methods.js]
 [browser_webconsole_bug_659907_console_dir.js]
 [browser_webconsole_bug_660806_history_nav.js]
 [browser_webconsole_bug_664131_console_group.js]
 [browser_webconsole_bug_686937_autocomplete_JSTerm_helpers.js]
 [browser_webconsole_bug_704295.js]
 [browser_webconsole_bug_734061_No_input_change_and_Tab_key_pressed.js]
 [browser_webconsole_bug_737873_mixedcontent.js]
 [browser_webconsole_bug_762593_insecure_passwords_about_blank_web_console_warning.js]
 skip-if = buildapp == 'mulet'
 [browser_webconsole_bug_762593_insecure_passwords_web_console_warning.js]
 skip-if = buildapp == 'mulet'
 [browser_webconsole_bug_764572_output_open_url.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_webconsole_bug_766001_JS_Console_in_Debugger.js]
-skip-if = buildapp == 'mulet'
+skip-if = buildapp == 'mulet' || e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_webconsole_bug_770099_violation.js]
 [browser_webconsole_bug_782653_CSS_links_in_Style_Editor.js]
 skip-if = buildapp == 'mulet'
 [browser_webconsole_bug_804845_ctrl_key_nav.js]
 run-if = os == "mac"
 [browser_webconsole_bug_817834_add_edited_input_to_history.js]
 [browser_webconsole_bug_837351_securityerrors.js]
 skip-if = buildapp == 'mulet'
 [browser_webconsole_bug_846918_hsts_invalid-headers.js]
-skip-if = buildapp == 'mulet'
+skip-if = buildapp == 'mulet' || e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_webconsole_bug_915141_toggle_response_logging_with_keyboard.js]
 [browser_webconsole_bug_1006027_message_timestamps_incorrect.js]
 [browser_webconsole_bug_1010953_cspro.js]
 [browser_webconsole_cached_autocomplete.js]
 [browser_webconsole_change_font_size.js]
 [browser_webconsole_chrome.js]
 [browser_webconsole_clickable_urls.js]
 [browser_webconsole_closure_inspection.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_webconsole_completion.js]
 [browser_webconsole_console_extras.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_webconsole_console_logging_api.js]
 [browser_webconsole_count.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_webconsole_dont_navigate_on_doubleclick.js]
 [browser_webconsole_execution_scope.js]
 [browser_webconsole_for_of.js]
 [browser_webconsole_history.js]
 [browser_webconsole_input_field_focus_on_panel_select.js]
 [browser_webconsole_inspect-parsed-documents.js]
 [browser_webconsole_js_input_expansion.js]
 [browser_webconsole_jsterm.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_webconsole_live_filtering_of_message_types.js]
 [browser_webconsole_live_filtering_on_search_strings.js]
 [browser_webconsole_message_node_id.js]
 [browser_webconsole_netlogging.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_webconsole_network_panel.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_webconsole_notifications.js]
 [browser_webconsole_open-links-without-callback.js]
 [browser_webconsole_output_copy_newlines.js]
 [browser_webconsole_output_order.js]
 [browser_webconsole_property_provider.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_webconsole_scratchpad_panel_link.js]
 [browser_webconsole_split.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_webconsole_split_escape_key.js]
 [browser_webconsole_split_focus.js]
 [browser_webconsole_split_persist.js]
 [browser_webconsole_view_source.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_webconsole_reflow.js]
 [browser_webconsole_log_file_filter.js]
 [browser_webconsole_expandable_timestamps.js]
 [browser_webconsole_autocomplete_in_debugger_stackframe.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s -> tried https://pastebin.mozilla.org/6061236 but got stuck with debugger stack frame errors
 [browser_webconsole_autocomplete_popup_close_on_tab_switch.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s -> is successful when running alone, but fails with mach mochitest-devtools --e10s browser/devtools/webconsole/test/ --end-at=browser_webconsole_cd_iframe.js
 [browser_webconsole_autocomplete-properties-with-non-alphanumeric-names.js]
 [browser_console_hide_jsterm_when_devtools_chrome_enabled_false.js]
 [browser_webconsole_output_01.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_webconsole_output_02.js]
 [browser_webconsole_output_03.js]
 [browser_webconsole_output_04.js]
 [browser_webconsole_output_05.js]
 [browser_webconsole_output_06.js]
 [browser_webconsole_output_dom_elements_01.js]
 [browser_webconsole_output_dom_elements_02.js]
 [browser_webconsole_output_dom_elements_03.js]
 [browser_webconsole_output_dom_elements_04.js]
 [browser_webconsole_output_events.js]
 [browser_webconsole_output_table.js]
 [browser_console_variables_view_highlighter.js]
 [browser_webconsole_start_netmon_first.js]
+skip-if = e10s # Bug 1042253 - webconsole tests disabled with e10s
 [browser_webconsole_console_trace_duplicates.js]
 [browser_webconsole_cd_iframe.js]
 [browser_webconsole_autocomplete_crossdomain_iframe.js]
 [browser_webconsole_console_custom_styles.js]
 [browser_webconsole_console_api_stackframe.js]
diff --git a/browser/devtools/webconsole/test/browser_bug1045902_console_csp_ignore_reflected_xss_message.js b/browser/devtools/webconsole/test/browser_bug1045902_console_csp_ignore_reflected_xss_message.js
--- a/browser/devtools/webconsole/test/browser_bug1045902_console_csp_ignore_reflected_xss_message.js
+++ b/browser/devtools/webconsole/test/browser_bug1045902_console_csp_ignore_reflected_xss_message.js
@@ -11,43 +11,47 @@
  */
 
 const EXPECTED_RESULT = "Not supporting directive 'reflected-xss'. Directive and values will be ignored.";
 const TEST_FILE = "http://example.com/browser/browser/devtools/webconsole/test/" +
                   "test_bug1045902_console_csp_ignore_reflected_xss_message.html";
 
 let hud = undefined;
 
-function test() {
-  addTab("data:text/html;charset=utf8,Web Console CSP ignoring reflected XSS (bug 1045902)");
-  browser.addEventListener("load", function _onLoad() {
-    browser.removeEventListener("load", _onLoad, true);
-    openConsole(null, loadDocument);
+let TEST_URI = "data:text/html;charset=utf8,Web Console CSP ignoring reflected XSS (bug 1045902)";
+
+let test = asyncTest(function* () {
+  let { browser } = yield loadTab(TEST_URI);
+
+  hud = yield openConsole();
+
+  yield loadDocument(browser);
+  yield testViolationMessage();
+});
+
+
+function loadDocument(browser) {
+  let deferred = promise.defer();
+
+  hud.jsterm.clearOutput()
+  browser.addEventListener("load", function onLoad() {
+    browser.removeEventListener("load", onLoad, true);
+    deferred.resolve();
   }, true);
-}
+  content.location = TEST_FILE;
 
-function loadDocument(theHud) {
-  hud = theHud;
-  hud.jsterm.clearOutput()
-  browser.addEventListener("load", onLoad, true);
-  content.location = TEST_FILE;
-}
-
-function onLoad(aEvent) {
-  browser.removeEventListener("load", onLoad, true);
-  testViolationMessage();
+  return deferred.promise;
 }
 
 function testViolationMessage() {
+  let deferred = promise.defer();
   let aOutputNode = hud.outputNode;
 
-  waitForSuccess({
+  return waitForSuccess({
       name: "Confirming that CSP logs messages to the console when 'reflected-xss' directive is used!",
-      validatorFn: function() {
+      validator: function() {
         console.log(hud.outputNode.textContent);
         let success = false;
         success = hud.outputNode.textContent.indexOf(EXPECTED_RESULT) > -1;
         return success;
-      },
-      successFn: finishTest,
-      failureFn: finishTest,
+      }
     });
 }
diff --git a/browser/devtools/webconsole/test/browser_bug664688_sandbox_update_after_navigation.js b/browser/devtools/webconsole/test/browser_bug664688_sandbox_update_after_navigation.js
--- a/browser/devtools/webconsole/test/browser_bug664688_sandbox_update_after_navigation.js
+++ b/browser/devtools/webconsole/test/browser_bug664688_sandbox_update_after_navigation.js
@@ -2,112 +2,90 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Tests if the JSTerm sandbox is updated when the user navigates from one
 // domain to another, in order to avoid permission denied errors with a sandbox
 // created for a different origin.
 
-function test()
-{
+"use strict";
+
+let test = asyncTest(function* () {
   const TEST_URI1 = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
   const TEST_URI2 = "http://example.org/browser/browser/devtools/webconsole/test/test-console.html";
 
-  let hud;
-  let msgForLocation1;
+  yield loadTab(TEST_URI1);
+  let hud = yield openConsole();
 
-  waitForExplicitFinish();
+  hud.jsterm.clearOutput();
+  hud.jsterm.execute("window.location.href");
 
-  gBrowser.selectedTab = gBrowser.addTab(TEST_URI1);
-  gBrowser.selectedBrowser.addEventListener("load", function onLoad() {
-    gBrowser.selectedBrowser.removeEventListener("load", onLoad, true);
-    openConsole(gBrowser.selectedTab, pageLoad1);
-  }, true);
+  info("wait for window.location.href");
 
-  function pageLoad1(aHud)
-  {
-    hud = aHud;
+  let msgForLocation1 = {
+    webconsole: hud,
+    messages: [
+      {
+        name: "window.location.href jsterm input",
+        text: "window.location.href",
+        category: CATEGORY_INPUT,
+      },
+      {
+        name: "window.location.href result is displayed",
+        text: TEST_URI1,
+        category: CATEGORY_OUTPUT,
+      },
+    ],
+  };
 
-    hud.jsterm.clearOutput();
-    hud.jsterm.execute("window.location.href");
+  yield waitForMessages(msgForLocation1);
 
-    info("wait for window.location.href");
+  // load second url
+  content.location = TEST_URI2;
+  yield loadBrowser(gBrowser.selectedBrowser);
 
-    msgForLocation1 = {
-      webconsole: hud,
-      messages: [
-        {
-          name: "window.location.href jsterm input",
-          text: "window.location.href",
-          category: CATEGORY_INPUT,
-        },
-        {
-          name: "window.location.href result is displayed",
-          text: TEST_URI1,
-          category: CATEGORY_OUTPUT,
-        },
-      ]
-    };
+  is(hud.outputNode.textContent.indexOf("Permission denied"), -1,
+     "no permission denied errors");
 
-    waitForMessages(msgForLocation1).then(() => {
-      gBrowser.selectedBrowser.addEventListener("load", onPageLoad2, true);
-      content.location = TEST_URI2;
-    });
-  }
+  hud.jsterm.clearOutput();
+  hud.jsterm.execute("window.location.href");
 
-  function onPageLoad2() {
-    gBrowser.selectedBrowser.removeEventListener("load", onPageLoad2, true);
+  info("wait for window.location.href after page navigation");
 
-    is(hud.outputNode.textContent.indexOf("Permission denied"), -1,
-       "no permission denied errors");
+  yield waitForMessages({
+    webconsole: hud,
+    messages: [
+      {
+        name: "window.location.href jsterm input",
+        text: "window.location.href",
+        category: CATEGORY_INPUT,
+      },
+      {
+        name: "window.location.href result is displayed",
+        text: TEST_URI2,
+        category: CATEGORY_OUTPUT,
+      },
+    ],
+  });
 
-    hud.jsterm.clearOutput();
-    hud.jsterm.execute("window.location.href");
+  is(hud.outputNode.textContent.indexOf("Permission denied"), -1,
+     "no permission denied errors");
 
-    info("wait for window.location.href after page navigation");
+  gBrowser.goBack();
 
-    waitForMessages({
-      webconsole: hud,
-      messages: [
-        {
-          name: "window.location.href jsterm input",
-          text: "window.location.href",
-          category: CATEGORY_INPUT,
-        },
-        {
-          name: "window.location.href result is displayed",
-          text: TEST_URI2,
-          category: CATEGORY_OUTPUT,
-        },
-      ]
-    }).then(() => {
-      is(hud.outputNode.textContent.indexOf("Permission denied"), -1,
-         "no permission denied errors");
-
-      gBrowser.goBack();
-      waitForSuccess(waitForBack);
-    });
-  }
-
-  let waitForBack = {
+  yield waitForSuccess({
     name: "go back",
-    validatorFn: function()
-    {
+    validator: function() {
       return content.location.href == TEST_URI1;
     },
-    successFn: function()
-    {
-      hud.jsterm.clearOutput();
-      executeSoon(() => {
-        hud.jsterm.execute("window.location.href");
-      });
+  });
 
-      info("wait for window.location.href after goBack()");
-      waitForMessages(msgForLocation1).then(() => executeSoon(() => {
-        is(hud.outputNode.textContent.indexOf("Permission denied"), -1,
-           "no permission denied errors");
-        finishTest();
-      }));
-    },
-    failureFn: finishTest,
-  };
-}
+  hud.jsterm.clearOutput();
+  executeSoon(() => {
+    hud.jsterm.execute("window.location.href");
+  });
+
+  info("wait for window.location.href after goBack()");
+  yield waitForMessages(msgForLocation1);
+  is(hud.outputNode.textContent.indexOf("Permission denied"), -1,
+     "no permission denied errors");
+});
diff --git a/browser/devtools/webconsole/test/browser_bug_638949_copy_link_location.js b/browser/devtools/webconsole/test/browser_bug_638949_copy_link_location.js
--- a/browser/devtools/webconsole/test/browser_bug_638949_copy_link_location.js
+++ b/browser/devtools/webconsole/test/browser_bug_638949_copy_link_location.js
@@ -1,118 +1,105 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/" +
-  "test/test-console.html?_date=" + Date.now();
-const COMMAND_NAME = "consoleCmd_copyURL";
-const CONTEXT_MENU_ID = "#menu_copyURL";
+// Test for the "Copy link location" context menu item shown when you right
+// click network requests in the output.
 
-let HUD = null;
-let output = null;
-let menu = null;
+"use strict";
 
-function test() {
-  let originalNetPref = Services.prefs.getBoolPref("devtools.webconsole.filter.networkinfo");
+let test = asyncTest(function* () {
+  const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/" +
+    "test/test-console.html?_date=" + Date.now();
+  const COMMAND_NAME = "consoleCmd_copyURL";
+  const CONTEXT_MENU_ID = "#menu_copyURL";
+
   registerCleanupFunction(() => {
-    Services.prefs.setBoolPref("devtools.webconsole.filter.networkinfo", originalNetPref);
-    HUD = output = menu = null;
+    Services.prefs.clearUserPref("devtools.webconsole.filter.networkinfo");
   });
 
   Services.prefs.setBoolPref("devtools.webconsole.filter.networkinfo", true);
 
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
+  let output = hud.outputNode;
+  let menu = hud.iframeWindow.document.getElementById("output-contextmenu");
 
-    openConsole(null, function (aHud) {
-      HUD = aHud;
-      output = aHud.outputNode;
-      menu = HUD.iframeWindow.document.getElementById("output-contextmenu");
-
-      executeSoon(testWithoutNetActivity);
-    });
-  }, true);
-}
-
-// Return whether "Copy Link Location" command is enabled or not.
-function isEnabled() {
-  let controller = top.document.commandDispatcher
-                   .getControllerForCommand(COMMAND_NAME);
-  return controller && controller.isCommandEnabled(COMMAND_NAME);
-}
-
-function testWithoutNetActivity() {
-  HUD.jsterm.clearOutput();
+  hud.jsterm.clearOutput();
   content.console.log("bug 638949");
 
   // Test that the "Copy Link Location" command is disabled for non-network
   // messages.
-  waitForMessages({
-    webconsole: HUD,
+  let [result] = yield waitForMessages({
+    webconsole: hud,
     messages: [{
       text: "bug 638949",
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG,
     }],
-  }).then(onConsoleMessage);
-}
+  });
 
-function onConsoleMessage(aResults) {
   output.focus();
-  let message = [...aResults[0].matched][0];
+  let message = [...result.matched][0];
 
   goUpdateCommand(COMMAND_NAME);
-  ok(!isEnabled(), COMMAND_NAME + "is disabled");
+  ok(!isEnabled(), COMMAND_NAME + " is disabled");
 
   // Test that the "Copy Link Location" menu item is hidden for non-network
   // messages.
   message.scrollIntoView();
-  waitForContextMenu(menu, message, () => {
+
+  yield waitForContextMenu(menu, message, () => {
     let isHidden = menu.querySelector(CONTEXT_MENU_ID).hidden;
     ok(isHidden, CONTEXT_MENU_ID + " is hidden");
-  }, testWithNetActivity);
-}
+  });
 
-function testWithNetActivity() {
-  HUD.jsterm.clearOutput();
+  hud.jsterm.clearOutput();
   content.location.reload(); // Reloading will produce network logging
 
   // Test that the "Copy Link Location" command is enabled and works
   // as expected for any network-related message.
   // This command should copy only the URL.
-  waitForMessages({
-    webconsole: HUD,
+  [result] = yield waitForMessages({
+    webconsole: hud,
     messages: [{
       text: "test-console.html",
       category: CATEGORY_NETWORK,
       severity: SEVERITY_LOG,
     }],
-  }).then(onNetworkMessage);
-}
+  });
 
-function onNetworkMessage(aResults) {
   output.focus();
-  let message = [...aResults[0].matched][0];
-  HUD.ui.output.selectMessage(message);
+  message = [...result.matched][0];
+  hud.ui.output.selectMessage(message);
 
   goUpdateCommand(COMMAND_NAME);
   ok(isEnabled(), COMMAND_NAME + " is enabled");
 
   info("expected clipboard value: " + message.url);
 
+  let deferred = promise.defer();
+
   waitForClipboard((aData) => { return aData.trim() == message.url; },
-    () => { goDoCommand(COMMAND_NAME) },
-    testMenuWithNetActivity, testMenuWithNetActivity);
+    () => { goDoCommand(COMMAND_NAME); },
+    () => { deferred.resolve(null); },
+    () => { deferred.reject(null); });
 
-  function testMenuWithNetActivity() {
-    // Test that the "Copy Link Location" menu item is visible for network-related
-    // messages.
-    message.scrollIntoView();
-    waitForContextMenu(menu, message, () => {
-      let isVisible = !menu.querySelector(CONTEXT_MENU_ID).hidden;
-      ok(isVisible, CONTEXT_MENU_ID + " is visible");
-    }, finishTest);
+  yield deferred.promise;
+
+  // Test that the "Copy Link Location" menu item is visible for network-related
+  // messages.
+  message.scrollIntoView();
+
+  yield waitForContextMenu(menu, message, () => {
+    let isVisible = !menu.querySelector(CONTEXT_MENU_ID).hidden;
+    ok(isVisible, CONTEXT_MENU_ID + " is visible");
+  });
+
+  // Return whether "Copy Link Location" command is enabled or not.
+  function isEnabled() {
+    let controller = top.document.commandDispatcher
+                     .getControllerForCommand(COMMAND_NAME);
+    return controller && controller.isCommandEnabled(COMMAND_NAME);
   }
-}
-
+});
diff --git a/browser/devtools/webconsole/test/browser_bug_862916_console_dir_and_filter_off.js b/browser/devtools/webconsole/test/browser_bug_862916_console_dir_and_filter_off.js
--- a/browser/devtools/webconsole/test/browser_bug_862916_console_dir_and_filter_off.js
+++ b/browser/devtools/webconsole/test/browser_bug_862916_console_dir_and_filter_off.js
@@ -1,34 +1,31 @@
 /*
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // Check that the output for console.dir() works even if Logging filter is off.
 
+"use strict";
+
 const TEST_URI = "data:text/html;charset=utf8,<p>test for bug 862916";
 
-function test()
-{
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
 
-function consoleOpened(hud)
-{
   ok(hud, "web console opened");
 
   hud.setFilterState("log", false);
   registerCleanupFunction(() => hud.setFilterState("log", true));
 
-  content.wrappedJSObject.fooBarz = "bug862916";
-  hud.jsterm.execute("console.dir(window)");
-  hud.jsterm.once("variablesview-fetched", (aEvent, aVar) => {
-    ok(aVar, "variables view object");
-    findVariableViewProperties(aVar, [
-      { name: "fooBarz", value: "bug862916" },
-    ], { webconsole: hud }).then(finishTest);
-  });
-}
+  hud.jsterm.execute("window.fooBarz = 'bug862916'; " +
+                     "console.dir(window)");
+
+  let varView = yield hud.jsterm.once("variablesview-fetched");
+  ok(varView, "variables view object");
+
+  yield findVariableViewProperties(varView, [
+    { name: "fooBarz", value: "bug862916" },
+  ], { webconsole: hud });
+});
+
diff --git a/browser/devtools/webconsole/test/browser_bug_865288_repeat_different_objects.js b/browser/devtools/webconsole/test/browser_bug_865288_repeat_different_objects.js
--- a/browser/devtools/webconsole/test/browser_bug_865288_repeat_different_objects.js
+++ b/browser/devtools/webconsole/test/browser_bug_865288_repeat_different_objects.js
@@ -1,81 +1,63 @@
 /*
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // Test that makes sure messages are not considered repeated when console.log()
 // is invoked with different objects, see bug 865288.
 
+"use strict";
+
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-repeated-messages.html";
 
-let hud = null;
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
-
-function consoleOpened(aHud) {
-  hud = aHud;
-
-  // Check that css warnings are not coalesced if they come from different lines.
   info("waiting for 3 console.log objects");
 
   hud.jsterm.clearOutput(true);
-  content.wrappedJSObject.testConsoleObjects();
+  hud.jsterm.execute("window.testConsoleObjects()");
 
-  waitForMessages({
+  let [result] = yield waitForMessages({
     webconsole: hud,
     messages: [{
       name: "3 console.log messages",
       text: "abba",
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG,
       count: 3,
       repeats: 1,
       objects: true,
     }],
-  }).then(checkMessages);
-}
+  });
 
-function checkMessages([result])
-{
   let msgs = [...result.matched];
   is(msgs.length, 3, "3 message elements");
-  let m = -1;
 
-  function nextMessage()
-  {
-    let msg = msgs[++m];
-    if (msg) {
-      ok(msg, "message element #" + m);
+  for (let i = 0; i < msgs.length; i++) {
+    info("test message element #" + i);
 
-      let clickable = msg.querySelector(".message-body a");
-      ok(clickable, "clickable object #" + m);
+    let msg = msgs[i];
+    let clickable = msg.querySelector(".message-body a");
+    ok(clickable, "clickable object #" + i);
 
-      msg.scrollIntoView(false);
-      clickObject(clickable);
-    }
-    else {
-      finishTest();
-    }
+    msg.scrollIntoView(false);
+    yield clickObject(clickable, i);
   }
 
-  nextMessage();
+  function* clickObject(obj, i)
+  {
+    executeSoon(() => {
+      EventUtils.synthesizeMouse(obj, 2, 2, {}, hud.iframeWindow);
+    });
 
-  function clickObject(aObject)
-  {
-    hud.jsterm.once("variablesview-fetched", onObjectFetch);
-    EventUtils.synthesizeMouse(aObject, 2, 2, {}, hud.iframeWindow);
+    let varView = yield hud.jsterm.once("variablesview-fetched");
+    ok(varView, "variables view fetched #" + i);
+
+    yield findVariableViewProperties(varView, [
+      { name: "id", value: "abba" + i },
+    ], { webconsole: hud });
   }
+});
 
-  function onObjectFetch(aEvent, aVar)
-  {
-    findVariableViewProperties(aVar, [
-      { name: "id", value: "abba" + m },
-    ], { webconsole: hud }).then(nextMessage);
-  }
-}
diff --git a/browser/devtools/webconsole/test/browser_bug_865871_variables_view_close_on_esc_key.js b/browser/devtools/webconsole/test/browser_bug_865871_variables_view_close_on_esc_key.js
--- a/browser/devtools/webconsole/test/browser_bug_865871_variables_view_close_on_esc_key.js
+++ b/browser/devtools/webconsole/test/browser_bug_865871_variables_view_close_on_esc_key.js
@@ -1,16 +1,18 @@
 /*
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // Check that the variables view sidebar can be closed by pressing Escape in the
 // web console.
 
+"use strict";
+
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-eval-in-stackframe.html";
 
 function test()
 {
   let hud;
 
   Task.spawn(runner).then(finishTest);
 
@@ -39,19 +41,16 @@ function test()
 
     let [result] = yield findVariableViewProperties(vviewVar, [
       { name: "testProp", value: "testValue" },
     ], { webconsole: hud });
 
     let prop = result.matchedProp;
     ok(prop, "matched the |testProp| property in the variables view");
 
-    is(content.wrappedJSObject.fooObj.testProp, result.value,
-       "|fooObj.testProp| value is correct");
-
     vview.window.focus();
 
     executeSoon(() => {
       EventUtils.synthesizeKey("VK_ESCAPE", {});
     });
     yield jsterm.once("sidebar-closed");
 
     jsterm.clearOutput();
diff --git a/browser/devtools/webconsole/test/browser_bug_869003_inspect_cross_domain_object.js b/browser/devtools/webconsole/test/browser_bug_869003_inspect_cross_domain_object.js
--- a/browser/devtools/webconsole/test/browser_bug_869003_inspect_cross_domain_object.js
+++ b/browser/devtools/webconsole/test/browser_bug_869003_inspect_cross_domain_object.js
@@ -1,99 +1,76 @@
 /*
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // Check that users can inspect objects logged from cross-domain iframes -
 // bug 869003.
 
+"use strict";
+
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-bug-869003-top-window.html";
 
-let gWebConsole, gJSTerm, gVariablesView;
-
-function test()
-{
+let test = asyncTest(function* () {
   // This test is slightly more involved: it opens the web console, then the
   // variables view for a given object, it updates a property in the view and
   // checks the result. We can get a timeout with debug builds on slower machines.
   requestLongerTimeout(2);
 
-  addTab("data:text/html;charset=utf8,<p>hello");
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
+  yield loadTab("data:text/html;charset=utf8,<p>hello");
+  let hud = yield openConsole();
 
-function consoleOpened(hud)
-{
-  gWebConsole = hud;
-  gJSTerm = hud.jsterm;
   content.location = TEST_URI;
 
-  waitForMessages({
+  let [result] = yield waitForMessages({
     webconsole: hud,
     messages: [{
       name: "console.log message",
       text: "foobar",
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG,
       objects: true,
     }],
-  }).then(onConsoleMessage);
-}
+  });
 
-function onConsoleMessage(aResults)
-{
-  let msg = [...aResults[0].matched][0];
+  let msg = [...result.matched][0];
   ok(msg, "message element");
 
   let body = msg.querySelector(".message-body");
   ok(body, "message body");
 
-  let clickable = aResults[0].clickableElements[0];
+  let clickable = result.clickableElements[0];
   ok(clickable, "clickable object found");
   ok(body.textContent.contains('{ hello: "world!",'), "message text check");
 
-  gJSTerm.once("variablesview-fetched", onObjFetch);
+  executeSoon(() => {
+    EventUtils.synthesizeMouse(clickable, 2, 2, {}, hud.iframeWindow)
+  });
 
-  EventUtils.synthesizeMouse(clickable, 2, 2, {}, gWebConsole.iframeWindow)
-}
+  let aVar = yield hud.jsterm.once("variablesview-fetched");
+  ok(aVar, "variables view fetched");
+  ok(aVar._variablesView, "variables view object");
 
-function onObjFetch(aEvent, aVar)
-{
-  gVariablesView = aVar._variablesView;
-  ok(gVariablesView, "variables view object");
-
-  findVariableViewProperties(aVar, [
+  [result] = yield findVariableViewProperties(aVar, [
     { name: "hello", value: "world!" },
     { name: "bug", value: 869003 },
-  ], { webconsole: gWebConsole }).then(onPropFound);
-}
+  ], { webconsole: hud });
 
-function onPropFound(aResults)
-{
-  let prop = aResults[0].matchedProp;
+  let prop = result.matchedProp;
   ok(prop, "matched the |hello| property in the variables view");
 
   // Check that property value updates work.
-  updateVariablesViewProperty({
+  aVar = yield updateVariablesViewProperty({
     property: prop,
     field: "value",
     string: "'omgtest'",
-    webconsole: gWebConsole,
-    callback: onFetchAfterUpdate,
+    webconsole: hud,
   });
-}
 
-function onFetchAfterUpdate(aEvent, aVar)
-{
   info("onFetchAfterUpdate");
 
-  findVariableViewProperties(aVar, [
+  yield findVariableViewProperties(aVar, [
     { name: "hello", value: "omgtest" },
     { name: "bug", value: 869003 },
-  ], { webconsole: gWebConsole }).then(() => {
-    gWebConsole = gJSTerm = gVariablesView = null;
-    finishTest();
-  });
-}
+  ], { webconsole: hud });
+});
+
diff --git a/browser/devtools/webconsole/test/browser_bug_871156_ctrlw_close_tab.js b/browser/devtools/webconsole/test/browser_bug_871156_ctrlw_close_tab.js
--- a/browser/devtools/webconsole/test/browser_bug_871156_ctrlw_close_tab.js
+++ b/browser/devtools/webconsole/test/browser_bug_871156_ctrlw_close_tab.js
@@ -1,83 +1,79 @@
 /*
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // Check that Ctrl-W closes the Browser Console and that Ctrl-W closes the
 // current tab when using the Web Console - bug 871156.
 
-function test()
-{
+"use strict";
+
+let test = asyncTest(function* () {
   const TEST_URI = "data:text/html;charset=utf8,<title>bug871156</title>\n" +
                    "<p>hello world";
   let firstTab = gBrowser.selectedTab;
+
   Services.prefs.setBoolPref("browser.tabs.animate", false);
+  registerCleanupFunction(() => {
+    Services.prefs.clearUserPref("browser.tabs.animate");
+  });
 
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
+  yield loadTab(TEST_URI);
 
-  function consoleOpened(hud)
-  {
-    ok(hud, "Web Console opened");
+  let hud = yield openConsole();
+  ok(hud, "Web Console opened");
 
-    let tabClosed = promise.defer();
-    let toolboxDestroyed = promise.defer();
-    let tabSelected = promise.defer();
+  let tabClosed = promise.defer();
+  let toolboxDestroyed = promise.defer();
+  let tabSelected = promise.defer();
 
-    let pageWindow = firstTab.linkedBrowser.contentWindow;
-    let toolbox = gDevTools.getToolbox(hud.target);
+  let target = TargetFactory.forTab(gBrowser.selectedTab);
+  let toolbox = gDevTools.getToolbox(target);
 
-    gBrowser.tabContainer.addEventListener("TabClose", function onTabClose() {
-      gBrowser.tabContainer.removeEventListener("TabClose", onTabClose);
-      info("tab closed");
-      tabClosed.resolve(null);
-    });
+  gBrowser.tabContainer.addEventListener("TabClose", function onTabClose() {
+    gBrowser.tabContainer.removeEventListener("TabClose", onTabClose);
+    info("tab closed");
+    tabClosed.resolve(null);
+  });
 
-    gBrowser.tabContainer.addEventListener("TabSelect", function onTabSelect() {
-      gBrowser.tabContainer.removeEventListener("TabSelect", onTabSelect);
-      if (gBrowser.selectedTab == firstTab) {
-        info("tab selected");
-        tabSelected.resolve(null);
-      }
-    });
+  gBrowser.tabContainer.addEventListener("TabSelect", function onTabSelect() {
+    gBrowser.tabContainer.removeEventListener("TabSelect", onTabSelect);
+    if (gBrowser.selectedTab == firstTab) {
+      info("tab selected");
+      tabSelected.resolve(null);
+    }
+  });
 
-    toolbox.once("destroyed", () => {
-      info("toolbox destroyed");
-      toolboxDestroyed.resolve(null);
-    });
+  toolbox.once("destroyed", () => {
+    info("toolbox destroyed");
+    toolboxDestroyed.resolve(null);
+  });
 
-    promise.all([tabClosed.promise, toolboxDestroyed.promise, tabSelected.promise ]).then(() => {
-      info("promise.all resolved");
-      waitForFocus(testBrowserConsole, pageWindow, true);
-    });
+  // Get out of the web console initialization.
+  executeSoon(() => {
+    EventUtils.synthesizeKey("w", { accelKey: true });
+  });
 
-    // Get out of the web console initialization.
-    executeSoon(() => {
-      EventUtils.synthesizeKey("w", { accelKey: true });
-    });
-  }
 
-  function testBrowserConsole()
-  {
-    info("test the Browser Console");
+  yield promise.all([tabClosed.promise, toolboxDestroyed.promise,
+                     tabSelected.promise]);
+  info("promise.all resolved. start testing the Browser Console");
 
-    HUDService.toggleBrowserConsole().then((hud) => {
-      ok(hud, "Browser Console opened");
+  hud = yield HUDService.toggleBrowserConsole();
+  ok(hud, "Browser Console opened");
 
-      Services.obs.addObserver(function onDestroy() {
-        Services.obs.removeObserver(onDestroy, "web-console-destroyed");
-        ok(true, "the Browser Console closed");
+  let deferred = promise.defer();
 
-        Services.prefs.clearUserPref("browser.tabs.animate");
-        waitForFocus(finish, content, true);
-      }, "web-console-destroyed", false);
+  Services.obs.addObserver(function onDestroy() {
+    Services.obs.removeObserver(onDestroy, "web-console-destroyed");
+    ok(true, "the Browser Console closed");
 
-      waitForFocus(() => {
-        EventUtils.synthesizeKey("w", { accelKey: true }, hud.iframeWindow);
-      }, hud.iframeWindow);
-    });
-  }
-}
+    deferred.resolve(null);
+  }, "web-console-destroyed", false);
+
+  waitForFocus(() => {
+    EventUtils.synthesizeKey("w", { accelKey: true }, hud.iframeWindow);
+  }, hud.iframeWindow);
+
+  yield deferred.promise;
+});
diff --git a/browser/devtools/webconsole/test/browser_console.js b/browser/devtools/webconsole/test/browser_console.js
--- a/browser/devtools/webconsole/test/browser_console.js
+++ b/browser/devtools/webconsole/test/browser_console.js
@@ -2,40 +2,38 @@
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // Test the basic features of the Browser Console, bug 587757.
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html?" + Date.now();
 
-function test()
-{
-  Services.obs.addObserver(function observer(aSubject) {
-    Services.obs.removeObserver(observer, "web-console-created");
-    aSubject.QueryInterface(Ci.nsISupportsString);
+"use strict";
 
-    let hud = HUDService.getBrowserConsole();
-    ok(hud, "browser console is open");
-    is(aSubject.data, hud.hudId, "notification hudId is correct");
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
 
-    executeSoon(() => consoleOpened(hud));
-  }, "web-console-created", false);
+  let opened = waitForConsole();
 
   let hud = HUDService.getBrowserConsole();
   ok(!hud, "browser console is not open");
   info("wait for the browser console to open with ctrl-shift-j");
   EventUtils.synthesizeKey("j", { accelKey: true, shiftKey: true }, window);
-}
+
+  hud = yield opened;
+  ok(hud, "browser console opened");
+
+  yield consoleOpened(hud);
+});
 
 function consoleOpened(hud)
 {
   hud.jsterm.clearOutput(true);
 
-  expectUncaughtException();
   executeSoon(() => {
     foobarExceptionBug587757();
   });
 
   // Add a message from a chrome window.
   hud.iframeWindow.console.log("bug587757a");
 
   // Add a message from a content window.
@@ -45,17 +43,17 @@ function consoleOpened(hud)
   hud.jsterm.execute("document.location.href");
 
   // Check for network requests.
   let xhr = new XMLHttpRequest();
   xhr.onload = () => console.log("xhr loaded, status is: " + xhr.status);
   xhr.open("get", TEST_URI, true);
   xhr.send();
 
-  waitForMessages({
+  return waitForMessages({
     webconsole: hud,
     messages: [
       {
         name: "chrome window console.log() is displayed",
         text: "bug587757a",
         category: CATEGORY_WEBDEV,
         severity: SEVERITY_LOG,
       },
@@ -79,10 +77,27 @@ function consoleOpened(hud)
       },
       {
         name: "network message",
         text: "test-console.html",
         category: CATEGORY_NETWORK,
         severity: SEVERITY_LOG,
       },
     ],
-  }).then(finishTest);
+  });
 }
+
+function waitForConsole() {
+  let deferred = promise.defer();
+
+  Services.obs.addObserver(function observer(aSubject) {
+    Services.obs.removeObserver(observer, "web-console-created");
+    aSubject.QueryInterface(Ci.nsISupportsString);
+
+    let hud = HUDService.getBrowserConsole();
+    ok(hud, "browser console is open");
+    is(aSubject.data, hud.hudId, "notification hudId is correct");
+
+    executeSoon(() => deferred.resolve(hud));
+  }, "web-console-created", false);
+
+  return deferred.promise;
+}
diff --git a/browser/devtools/webconsole/test/browser_console_addonsdk_loader_exception.js b/browser/devtools/webconsole/test/browser_console_addonsdk_loader_exception.js
--- a/browser/devtools/webconsole/test/browser_console_addonsdk_loader_exception.js
+++ b/browser/devtools/webconsole/test/browser_console_addonsdk_loader_exception.js
@@ -2,16 +2,18 @@
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // Check that exceptions from scripts loaded with the addon-sdk loader are
 // opened correctly in View Source from the Browser Console.
 // See bug 866950.
 
+"use strict";
+
 const TEST_URI = "data:text/html;charset=utf8,<p>hello world from bug 866950";
 
 function test()
 {
   requestLongerTimeout(2);
 
   let webconsole, browserconsole;
 
@@ -40,19 +42,20 @@ function test()
       executeSoon(fixToolbox);
       expectUncaughtException();
       toolbox.getToolPanels();
     });
 
     let [result] = yield waitForMessages({
       webconsole: browserconsole,
       messages: [{
-        text: "TypeError: can't convert null to object",
+        text: "can't convert null to object",
         category: CATEGORY_JS,
         severity: SEVERITY_ERROR,
+        source: { url: /\btoolbox\.js\b/ }
       }],
     });
 
     fixToolbox();
 
     let msg = [...result.matched][0];
     ok(msg, "message element found");
     let locationNode = msg.querySelector(".message-location");
diff --git a/browser/devtools/webconsole/test/browser_console_clear_on_reload.js b/browser/devtools/webconsole/test/browser_console_clear_on_reload.js
--- a/browser/devtools/webconsole/test/browser_console_clear_on_reload.js
+++ b/browser/devtools/webconsole/test/browser_console_clear_on_reload.js
@@ -1,73 +1,54 @@
 /*
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // Check that clear output on page reload works - bug 705921.
 
-function test()
-{
+"use strict";
+
+let test = asyncTest(function*() {
   const PREF = "devtools.webconsole.persistlog";
   const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
-  let hud = null;
 
   Services.prefs.setBoolPref(PREF, false);
   registerCleanupFunction(() => Services.prefs.clearUserPref(PREF));
 
-  addTab(TEST_URI);
+  yield loadTab(TEST_URI);
 
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
+  let hud = yield openConsole();
+  ok(hud, "Web Console opened");
 
-  function consoleOpened(aHud)
-  {
-    hud = aHud;
-    ok(hud, "Web Console opened");
+  hud.jsterm.clearOutput();
+  hud.jsterm.execute("console.log('foobarz1')");
 
-    hud.jsterm.clearOutput();
-    content.console.log("foobarz1");
-    waitForMessages({
-      webconsole: hud,
-      messages: [{
-        text: "foobarz1",
-        category: CATEGORY_WEBDEV,
-        severity: SEVERITY_LOG,
-      }],
-    }).then(onConsoleMessage);
-  }
+  yield waitForMessages({
+    webconsole: hud,
+    messages: [{
+      text: "foobarz1",
+      category: CATEGORY_WEBDEV,
+      severity: SEVERITY_LOG,
+    }],
+  });
 
-  function onConsoleMessage()
-  {
-    browser.addEventListener("load", onReload, true);
-    content.location.reload();
-  }
+  BrowserReload();
+  yield loadBrowser(gBrowser.selectedBrowser);
 
-  function onReload()
-  {
-    browser.removeEventListener("load", onReload, true);
+  hud.jsterm.execute("console.log('foobarz2')");
 
-    content.console.log("foobarz2");
+  yield waitForMessages({
+    webconsole: hud,
+    messages: [{
+      text: "test-console.html",
+      category: CATEGORY_NETWORK,
+    },
+    {
+      text: "foobarz2",
+      category: CATEGORY_WEBDEV,
+      severity: SEVERITY_LOG,
+    }],
+  });
 
-    waitForMessages({
-      webconsole: hud,
-      messages: [{
-        text: "test-console.html",
-        category: CATEGORY_NETWORK,
-      },
-      {
-        text: "foobarz2",
-        category: CATEGORY_WEBDEV,
-        severity: SEVERITY_LOG,
-      }],
-    }).then(onConsoleMessageAfterReload);
-  }
-
-  function onConsoleMessageAfterReload()
-  {
-    is(hud.outputNode.textContent.indexOf("foobarz1"), -1,
-       "foobarz1 has been removed from output");
-    finishTest();
-  }
-}
+  is(hud.outputNode.textContent.indexOf("foobarz1"), -1,
+     "foobarz1 has been removed from output");
+});
diff --git a/browser/devtools/webconsole/test/browser_console_click_focus.js b/browser/devtools/webconsole/test/browser_console_click_focus.js
--- a/browser/devtools/webconsole/test/browser_console_click_focus.js
+++ b/browser/devtools/webconsole/test/browser_console_click_focus.js
@@ -1,60 +1,55 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Tests that the input field is focused when the console is opened.
 
+"use strict";
+
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("DOMContentLoaded", testInputFocus, false);
-}
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
 
-function testInputFocus() {
-  browser.removeEventListener("DOMContentLoaded", testInputFocus, false);
+  let [result] = yield waitForMessages({
+    webconsole: hud,
+    messages: [{
+      text: "Dolske Digs Bacon",
+      category: CATEGORY_WEBDEV,
+      severity: SEVERITY_LOG,
+    }],
+  });
 
-  openConsole().then((hud) => {
-    waitForMessages({
-      webconsole: hud,
-      messages: [{
-        text: "Dolske Digs Bacon",
-        category: CATEGORY_WEBDEV,
-        severity: SEVERITY_LOG,
-      }],
-    }).then(([result]) => {
-      let msg = [...result.matched][0];
-      let outputItem = msg.querySelector(".message-body");
-      ok(outputItem, "found a logged message");
-      let inputNode = hud.jsterm.inputNode;
-      ok(inputNode.getAttribute("focused"), "input node is focused, first");
+  let msg = [...result.matched][0];
+  let outputItem = msg.querySelector(".message-body");
+  ok(outputItem, "found a logged message");
 
-      let lostFocus = () => {
-        inputNode.removeEventListener("blur", lostFocus);
-        info("input node lost focus");
-      }
+  let inputNode = hud.jsterm.inputNode;
+  ok(inputNode.getAttribute("focused"), "input node is focused, first");
 
-      inputNode.addEventListener("blur", lostFocus);
+  let lostFocus = () => {
+    inputNode.removeEventListener("blur", lostFocus);
+    info("input node lost focus");
+  }
 
-      browser.ownerDocument.getElementById("urlbar").click();
+  inputNode.addEventListener("blur", lostFocus);
 
-      ok(!inputNode.getAttribute("focused"), "input node is not focused");
+  document.getElementById("urlbar").click();
 
-      EventUtils.sendMouseEvent({type: "click"}, hud.outputNode);
+  ok(!inputNode.getAttribute("focused"), "input node is not focused");
 
-      ok(inputNode.getAttribute("focused"), "input node is focused, second time")
+  EventUtils.sendMouseEvent({type: "click"}, hud.outputNode);
 
-      // test click-drags are not focusing the input element.
-      EventUtils.sendMouseEvent({type: "mousedown", clientX: 3, clientY: 4},
-        outputItem);
-      EventUtils.sendMouseEvent({type: "click", clientX: 15, clientY: 5},
-        outputItem);
+  ok(inputNode.getAttribute("focused"), "input node is focused, second time")
 
-      executeSoon(() => {
-        todo(!inputNode.getAttribute("focused"), "input node is not focused after drag");
-        finishTest();
-      });
-    });
-  });
-}
+  // test click-drags are not focusing the input element.
+  EventUtils.sendMouseEvent({type: "mousedown", clientX: 3, clientY: 4},
+    outputItem);
+  EventUtils.sendMouseEvent({type: "click", clientX: 15, clientY: 5},
+    outputItem);
+
+  todo(!inputNode.getAttribute("focused"), "input node is not focused after drag");
+});
+
diff --git a/browser/devtools/webconsole/test/browser_console_consolejsm_output.js b/browser/devtools/webconsole/test/browser_console_consolejsm_output.js
--- a/browser/devtools/webconsole/test/browser_console_consolejsm_output.js
+++ b/browser/devtools/webconsole/test/browser_console_consolejsm_output.js
@@ -1,135 +1,137 @@
 /*
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // Test that Console.jsm outputs messages to the Browser Console, bug 851231.
 
-function test()
-{
+"use strict";
+
+let test = asyncTest(function*() {
   let storage = Cc["@mozilla.org/consoleAPI-storage;1"].getService(Ci.nsIConsoleAPIStorage);
   storage.clearEvents();
 
   let console = Cu.import("resource://gre/modules/devtools/Console.jsm", {}).console;
   console.log("bug861338-log-cached");
 
-  HUDService.toggleBrowserConsole().then(consoleOpened);
-  let hud = null;
+  let hud = yield HUDService.toggleBrowserConsole();
 
-  function consoleOpened(aHud)
-  {
-    hud = aHud;
-    waitForMessages({
-      webconsole: hud,
-      messages: [{
-        name: "cached console.log message",
-        text: "bug861338-log-cached",
+  yield waitForMessages({
+    webconsole: hud,
+    messages: [{
+      name: "cached console.log message",
+      text: "bug861338-log-cached",
+      category: CATEGORY_WEBDEV,
+      severity: SEVERITY_LOG,
+    }],
+  });
+
+  hud.jsterm.clearOutput(true);
+
+  function testTrace() {
+    console.trace();
+  }
+
+  console.time("foobarTimer");
+  let foobar = { bug851231prop: "bug851231value" };
+
+  console.log("bug851231-log");
+  console.info("bug851231-info");
+  console.warn("bug851231-warn");
+  console.error("bug851231-error", foobar);
+  console.debug("bug851231-debug");
+  console.dir(document);
+  testTrace();
+  console.timeEnd("foobarTimer");
+
+  info("wait for the Console.jsm messages");
+
+  let results = yield waitForMessages({
+    webconsole: hud,
+    messages: [
+      {
+        name: "console.log output",
+        text: "bug851231-log",
         category: CATEGORY_WEBDEV,
         severity: SEVERITY_LOG,
-      }],
-    }).then(onCachedMessage);
-  }
+      },
+      {
+        name: "console.info output",
+        text: "bug851231-info",
+        category: CATEGORY_WEBDEV,
+        severity: SEVERITY_INFO,
+      },
+      {
+        name: "console.warn output",
+        text: "bug851231-warn",
+        category: CATEGORY_WEBDEV,
+        severity: SEVERITY_WARNING,
+      },
+      {
+        name: "console.error output",
+        text: /\bbug851231-error\b.+\{\s*bug851231prop:\s"bug851231value"\s*\}/,
+        category: CATEGORY_WEBDEV,
+        severity: SEVERITY_ERROR,
+        objects: true,
+      },
+      {
+        name: "console.debug output",
+        text: "bug851231-debug",
+        category: CATEGORY_WEBDEV,
+        severity: SEVERITY_LOG,
+      },
+      {
+        name: "console.trace output",
+        consoleTrace: {
+          file: "browser_console_consolejsm_output.js",
+          fn: "testTrace",
+        },
+      },
+      {
+        name: "console.dir output",
+        consoleDir: /XULDocument\s+.+\s+chrome:\/\/.+\/browser\.xul/,
+      },
+      {
+        name: "console.time output",
+        consoleTime: "foobarTimer",
+      },
+      {
+        name: "console.timeEnd output",
+        consoleTimeEnd: "foobarTimer",
+      },
+    ],
+  });
 
-  function onCachedMessage()
-  {
-    hud.jsterm.clearOutput(true);
+  let consoleErrorMsg = results[3];
+  ok(consoleErrorMsg, "console.error message element found");
+  let clickable = consoleErrorMsg.clickableElements[0];
+  ok(clickable, "clickable object found for console.error");
 
-    console.time("foobarTimer");
-    let foobar = { bug851231prop: "bug851231value" };
+  let deferred = promise.defer();
 
-    console.log("bug851231-log");
-    console.info("bug851231-info");
-    console.warn("bug851231-warn");
-    console.error("bug851231-error", foobar);
-    console.debug("bug851231-debug");
-    console.trace();
-    console.dir(document);
-    console.timeEnd("foobarTimer");
+  let onFetch = (aEvent, aVar) => {
+    // Skip the notification from console.dir variablesview-fetched.
+    if (aVar._variablesView != hud.jsterm._variablesView) {
+      return;
+    }
+    hud.jsterm.off("variablesview-fetched", onFetch);
 
-    info("wait for the Console.jsm messages");
+    deferred.resolve(aVar);
+  };
 
-    waitForMessages({
-      webconsole: hud,
-      messages: [
-        {
-          name: "console.log output",
-          text: "bug851231-log",
-          category: CATEGORY_WEBDEV,
-          severity: SEVERITY_LOG,
-        },
-        {
-          name: "console.info output",
-          text: "bug851231-info",
-          category: CATEGORY_WEBDEV,
-          severity: SEVERITY_INFO,
-        },
-        {
-          name: "console.warn output",
-          text: "bug851231-warn",
-          category: CATEGORY_WEBDEV,
-          severity: SEVERITY_WARNING,
-        },
-        {
-          name: "console.error output",
-          text: /\bbug851231-error\b.+\{\s*bug851231prop:\s"bug851231value"\s*\}/,
-          category: CATEGORY_WEBDEV,
-          severity: SEVERITY_ERROR,
-          objects: true,
-        },
-        {
-          name: "console.debug output",
-          text: "bug851231-debug",
-          category: CATEGORY_WEBDEV,
-          severity: SEVERITY_LOG,
-        },
-        {
-          name: "console.trace output",
-          consoleTrace: {
-            file: "browser_console_consolejsm_output.js",
-            fn: "onCachedMessage",
-          },
-        },
-        {
-          name: "console.dir output",
-          consoleDir: /XULDocument\s+.+\s+chrome:\/\/.+\/browser\.xul/,
-        },
-        {
-          name: "console.time output",
-          consoleTime: "foobarTimer",
-        },
-        {
-          name: "console.timeEnd output",
-          consoleTimeEnd: "foobarTimer",
-        },
-      ],
-    }).then((aResults) => {
-      let consoleErrorMsg = aResults[3];
-      ok(consoleErrorMsg, "console.error message element found");
-      let clickable = consoleErrorMsg.clickableElements[0];
-      ok(clickable, "clickable object found for console.error");
+  hud.jsterm.on("variablesview-fetched", onFetch);
 
-      let onFetch = (aEvent, aVar) => {
-        // Skip the notification from console.dir variablesview-fetched.
-        if (aVar._variablesView != hud.jsterm._variablesView) {
-          return;
-        }
-        hud.jsterm.off("variablesview-fetched", onFetch);
+  clickable.scrollIntoView(false);
 
-        ok(aVar, "object inspector opened on click");
+  info("wait for variablesview-fetched");
+  executeSoon(() =>
+    EventUtils.synthesizeMouse(clickable, 2, 2, {}, hud.iframeWindow));
 
-        findVariableViewProperties(aVar, [{
-          name: "bug851231prop",
-          value: "bug851231value",
-        }], { webconsole: hud }).then(finishTest);
-      };
+  let varView = yield deferred.promise;
+  ok(varView, "object inspector opened on click");
 
-      hud.jsterm.on("variablesview-fetched", onFetch);
-
-      clickable.scrollIntoView(false);
-
-      info("wait for variablesview-fetched");
-      executeSoon(() =>
-        EventUtils.synthesizeMouse(clickable, 2, 2, {}, hud.iframeWindow));
-    });
-  }
-}
+  yield findVariableViewProperties(varView, [{
+    name: "bug851231prop",
+    value: "bug851231value",
+  }], { webconsole: hud });
+});
diff --git a/browser/devtools/webconsole/test/browser_console_dead_objects.js b/browser/devtools/webconsole/test/browser_console_dead_objects.js
--- a/browser/devtools/webconsole/test/browser_console_dead_objects.js
+++ b/browser/devtools/webconsole/test/browser_console_dead_objects.js
@@ -7,16 +7,18 @@
 // This test does:
 // - opens a new tab,
 // - opens the Browser Console,
 // - stores a reference to the content document of the tab on the chrome window object,
 // - closes the tab,
 // - tries to use the object that was pointing to the now-defunct content
 // document. This is the dead object.
 
+"use strict";
+
 const TEST_URI = "data:text/html;charset=utf8,<p>dead objects!";
 
 function test()
 {
   let hud = null;
 
   registerCleanupFunction(() => {
     Services.prefs.clearUserPref("devtools.chrome.enabled");
@@ -32,21 +34,17 @@ function test()
 
     hud = yield HUDService.toggleBrowserConsole();
     ok(hud, "browser console opened");
 
     hud.jsterm.clearOutput();
 
     // Add the reference to the content document.
 
-    yield execute("Cu = Components.utils;" +
-                  "Cu.import('resource://gre/modules/Services.jsm');" +
-                  "chromeWindow = Services.wm.getMostRecentWindow('navigator:browser');" +
-                  "foobarzTezt = chromeWindow.content.document;" +
-                  "delete chromeWindow");
+    yield execute("foobarzTezt = content.document.documentElement");
 
     gBrowser.removeCurrentTab();
 
     let msg = yield execute("foobarzTezt");
 
     isnot(hud.outputNode.textContent.indexOf("[object DeadObject]"), -1,
           "dead object found");
 
@@ -56,16 +54,18 @@ function test()
       EventUtils.synthesizeKey(c, {}, hud.iframeWindow);
     }
 
     yield execute();
 
     isnot(hud.outputNode.textContent.indexOf("can't access dead object"), -1,
           "'cannot access dead object' message found");
 
+    yield promise.defer().promise;
+
     // Click the second execute output.
     let clickable = msg.querySelector("a");
     ok(clickable, "clickable object found");
     isnot(clickable.textContent.indexOf("[object DeadObject]"), -1,
           "message text check");
 
     msg.scrollIntoView();
 
diff --git a/browser/devtools/webconsole/test/browser_console_filters.js b/browser/devtools/webconsole/test/browser_console_filters.js
--- a/browser/devtools/webconsole/test/browser_console_filters.js
+++ b/browser/devtools/webconsole/test/browser_console_filters.js
@@ -1,32 +1,27 @@
 /*
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // Check that the Browser Console does not use the same filter prefs as the Web
 // Console. See bug 878186.
 
+"use strict";
+
 const TEST_URI = "data:text/html;charset=utf8,<p>browser console filters";
 const WEB_CONSOLE_PREFIX = "devtools.webconsole.filter.";
 const BROWSER_CONSOLE_PREFIX = "devtools.browserconsole.filter.";
 
-function test()
-{
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    info("open the web console");
-    openConsole(null, consoleOpened);
-  }, true);
-}
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
 
-function consoleOpened(hud)
-{
+  info("open the web console");
+  let hud = yield openConsole();
   ok(hud, "web console opened");
 
   is(Services.prefs.getBoolPref(BROWSER_CONSOLE_PREFIX + "exception"), true,
      "'exception' filter is enabled (browser console)");
   is(Services.prefs.getBoolPref(WEB_CONSOLE_PREFIX + "exception"), true,
      "'exception' filter is enabled (web console)");
 
   info("toggle 'exception' filter");
@@ -34,38 +29,32 @@ function consoleOpened(hud)
 
   is(Services.prefs.getBoolPref(BROWSER_CONSOLE_PREFIX + "exception"), true,
      "'exception' filter is enabled (browser console)");
   is(Services.prefs.getBoolPref(WEB_CONSOLE_PREFIX + "exception"), false,
      "'exception' filter is disabled (web console)");
 
   hud.setFilterState("exception", true);
 
-  executeSoon(() => closeConsole(null, onWebConsoleClose));
-}
+  // We need to let the console opening event loop to finish.
+  let deferred = promise.defer();
+  executeSoon(() => closeConsole().then(() => deferred.resolve(null)));
+  yield deferred.promise;
 
-function onWebConsoleClose()
-{
   info("web console closed");
-  HUDService.toggleBrowserConsole().then(onBrowserConsoleOpen);
-}
-
-function onBrowserConsoleOpen(hud)
-{
+  hud = yield HUDService.toggleBrowserConsole();
   ok(hud, "browser console opened");
 
   is(Services.prefs.getBoolPref(BROWSER_CONSOLE_PREFIX + "exception"), true,
      "'exception' filter is enabled (browser console)");
   is(Services.prefs.getBoolPref(WEB_CONSOLE_PREFIX + "exception"), true,
      "'exception' filter is enabled (web console)");
 
   info("toggle 'exception' filter");
   hud.setFilterState("exception", false);
 
   is(Services.prefs.getBoolPref(BROWSER_CONSOLE_PREFIX + "exception"), false,
      "'exception' filter is disabled (browser console)");
   is(Services.prefs.getBoolPref(WEB_CONSOLE_PREFIX + "exception"), true,
      "'exception' filter is enabled (web console)");
 
   hud.setFilterState("exception", true);
-
-  executeSoon(finishTest);
-}
+});
diff --git a/browser/devtools/webconsole/test/browser_console_keyboard_accessibility.js b/browser/devtools/webconsole/test/browser_console_keyboard_accessibility.js
--- a/browser/devtools/webconsole/test/browser_console_keyboard_accessibility.js
+++ b/browser/devtools/webconsole/test/browser_console_keyboard_accessibility.js
@@ -1,90 +1,79 @@
 /*
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // Check that basic keyboard shortcuts work in the web console.
 
-function test()
-{
+"use strict";
+
+let test = asyncTest(function*() {
   const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
-  let hud = null;
 
-  addTab(TEST_URI);
+  yield loadTab(TEST_URI);
 
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
+  let hud = yield openConsole();
+  ok(hud, "Web Console opened");
 
-  function consoleOpened(aHud)
-  {
-    hud = aHud;
-    ok(hud, "Web Console opened");
+  info("dump some spew into the console for scrolling");
+  hud.jsterm.execute("(function() { for (var i = 0; i < 100; i++) { " +
+                     "console.log('foobarz' + i);" +
+                     "}})();");
 
-    info("dump some spew into the console for scrolling");
-    for (let i = 0; i < 100; i++)
-      content.console.log("foobarz" + i);
-    waitForMessages({
-      webconsole: hud,
-      messages: [{
-        text: "foobarz99",
-        category: CATEGORY_WEBDEV,
-        severity: SEVERITY_LOG,
-      }],
-    }).then(onConsoleMessage);
+  yield waitForMessages({
+    webconsole: hud,
+    messages: [{
+      text: "foobarz99",
+      category: CATEGORY_WEBDEV,
+      severity: SEVERITY_LOG,
+    }],
+  });
+
+  let currentPosition = hud.outputNode.parentNode.scrollTop;
+  let bottom = currentPosition;
+
+  EventUtils.synthesizeKey("VK_PAGE_UP", {});
+  isnot(hud.outputNode.parentNode.scrollTop, currentPosition, "scroll position changed after page up");
+
+  currentPosition = hud.outputNode.parentNode.scrollTop;
+  EventUtils.synthesizeKey("VK_PAGE_DOWN", {});
+  ok(hud.outputNode.parentNode.scrollTop > currentPosition, "scroll position now at bottom");
+
+  EventUtils.synthesizeKey("VK_HOME", {});
+  is(hud.outputNode.parentNode.scrollTop, 0, "scroll position now at top");
+
+  EventUtils.synthesizeKey("VK_END", {});
+
+  let scrollTop = hud.outputNode.parentNode.scrollTop;
+  ok(scrollTop > 0 && Math.abs(scrollTop - bottom) <= 5,
+     "scroll position now at bottom");
+
+  info("try ctrl-l to clear output");
+  executeSoon(() => { EventUtils.synthesizeKey("l", { ctrlKey: true }); });
+  yield hud.jsterm.once("messages-cleared");
+
+  is(hud.outputNode.textContent.indexOf("foobarz1"), -1, "output cleared");
+  is(hud.jsterm.inputNode.getAttribute("focused"), "true",
+     "jsterm input is focused");
+
+  info("try ctrl-f to focus filter");
+  EventUtils.synthesizeKey("F", { accelKey: true });
+  ok(!hud.jsterm.inputNode.getAttribute("focused"),
+     "jsterm input is not focused");
+  is(hud.ui.filterBox.getAttribute("focused"), "true",
+     "filter input is focused");
+
+  if (Services.appinfo.OS == "Darwin") {
+    ok(hud.ui.getFilterState("network"), "network category is enabled");
+    EventUtils.synthesizeKey("t", { ctrlKey: true });
+    ok(!hud.ui.getFilterState("network"), "accesskey for Network works");
+    EventUtils.synthesizeKey("t", { ctrlKey: true });
+    ok(hud.ui.getFilterState("network"), "accesskey for Network works (again)");
   }
-
-  function onConsoleMessage()
-  {
-    let currentPosition = hud.outputNode.parentNode.scrollTop;
-    let bottom = currentPosition;
-
-    EventUtils.synthesizeKey("VK_PAGE_UP", {});
-    isnot(hud.outputNode.parentNode.scrollTop, currentPosition, "scroll position changed after page up");
-
-    currentPosition = hud.outputNode.parentNode.scrollTop;
-    EventUtils.synthesizeKey("VK_PAGE_DOWN", {});
-    ok(hud.outputNode.parentNode.scrollTop > currentPosition, "scroll position now at bottom");
-
-    EventUtils.synthesizeKey("VK_HOME", {});
-    is(hud.outputNode.parentNode.scrollTop, 0, "scroll position now at top");
-
-    EventUtils.synthesizeKey("VK_END", {});
-    is(hud.outputNode.parentNode.scrollTop, bottom, "scroll position now at bottom");
-
-    hud.jsterm.once("messages-cleared", onClear);
-    info("try ctrl-l to clear output");
-    EventUtils.synthesizeKey("l", { ctrlKey: true });
+  else {
+    EventUtils.synthesizeKey("N", { altKey: true });
+    let net = hud.ui.document.querySelector("toolbarbutton[category=net]");
+    is(hud.ui.document.activeElement, net,
+       "accesskey for Network category focuses the Net button");
   }
-
-  function onClear()
-  {
-    is(hud.outputNode.textContent.indexOf("foobarz1"), -1, "output cleared");
-    is(hud.jsterm.inputNode.getAttribute("focused"), "true",
-       "jsterm input is focused");
-
-    info("try ctrl-f to focus filter");
-    EventUtils.synthesizeKey("F", { accelKey: true });
-    ok(!hud.jsterm.inputNode.getAttribute("focused"),
-       "jsterm input is not focused");
-    is(hud.ui.filterBox.getAttribute("focused"), "true",
-       "filter input is focused");
-
-    if (Services.appinfo.OS == "Darwin") {
-      ok(hud.ui.getFilterState("network"), "network category is enabled");
-      EventUtils.synthesizeKey("t", { ctrlKey: true });
-      ok(!hud.ui.getFilterState("network"), "accesskey for Network works");
-      EventUtils.synthesizeKey("t", { ctrlKey: true });
-      ok(hud.ui.getFilterState("network"), "accesskey for Network works (again)");
-    }
-    else {
-      EventUtils.synthesizeKey("N", { altKey: true });
-      let net = hud.ui.document.querySelector("toolbarbutton[category=net]");
-      is(hud.ui.document.activeElement, net,
-         "accesskey for Network category focuses the Net button");
-    }
-
-    finishTest();
-  }
-}
+});
diff --git a/browser/devtools/webconsole/test/browser_console_log_inspectable_object.js b/browser/devtools/webconsole/test/browser_console_log_inspectable_object.js
--- a/browser/devtools/webconsole/test/browser_console_log_inspectable_object.js
+++ b/browser/devtools/webconsole/test/browser_console_log_inspectable_object.js
@@ -1,58 +1,50 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 // Test that objects given to console.log() are inspectable.
 
-function test()
-{
-  waitForExplicitFinish();
+"use strict";
 
-  addTab("data:text/html;charset=utf8,test for bug 676722 - inspectable objects for window.console");
+let test = asyncTest(function*() {
+  yield loadTab("data:text/html;charset=utf8,test for bug 676722 - inspectable objects for window.console");
 
-  gBrowser.selectedBrowser.addEventListener("load", function onLoad() {
-    gBrowser.selectedBrowser.removeEventListener("load", onLoad, true);
-    openConsole(null, performTest);
-  }, true);
-}
-
-function performTest(hud)
-{
+  let hud = yield openConsole();
   hud.jsterm.clearOutput(true);
 
   hud.jsterm.execute("myObj = {abba: 'omgBug676722'}");
   hud.jsterm.execute("console.log('fooBug676722', myObj)");
 
-  waitForMessages({
+  let [result] = yield waitForMessages({
     webconsole: hud,
     messages: [{
       text: "fooBug676722",
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG,
       objects: true,
     }],
-  }).then(([result]) => {
-    let msg = [...result.matched][0];
-    ok(msg, "message element");
-    let body = msg.querySelector(".message-body");
-    ok(body, "message body");
-    let clickable = result.clickableElements[0];
-    ok(clickable, "the console.log() object anchor was found");
-    ok(body.textContent.contains('{ abba: "omgBug676722" }'),
-       "clickable node content is correct");
+  });
 
-    hud.jsterm.once("variablesview-fetched",
-      (aEvent, aVar) => {
-        ok(aVar, "object inspector opened on click");
+  let msg = [...result.matched][0];
+  ok(msg, "message element");
 
-        findVariableViewProperties(aVar, [{
-          name: "abba",
-          value: "omgBug676722",
-        }], { webconsole: hud }).then(finishTest);
-      });
+  let body = msg.querySelector(".message-body");
+  ok(body, "message body");
 
-    executeSoon(function() {
-      EventUtils.synthesizeMouse(clickable, 2, 2, {}, hud.iframeWindow);
-    });
+  let clickable = result.clickableElements[0];
+  ok(clickable, "the console.log() object anchor was found");
+  ok(body.textContent.contains('{ abba: "omgBug676722" }'),
+     "clickable node content is correct");
+
+  executeSoon(() => {
+    EventUtils.synthesizeMouse(clickable, 2, 2, {}, hud.iframeWindow);
   });
-}
+
+  let varView = yield hud.jsterm.once("variablesview-fetched");
+  ok(varView, "object inspector opened on click");
+
+  yield findVariableViewProperties(varView, [{
+    name: "abba",
+    value: "omgBug676722",
+  }], { webconsole: hud });
+});
diff --git a/browser/devtools/webconsole/test/browser_console_native_getters.js b/browser/devtools/webconsole/test/browser_console_native_getters.js
--- a/browser/devtools/webconsole/test/browser_console_native_getters.js
+++ b/browser/devtools/webconsole/test/browser_console_native_getters.js
@@ -1,121 +1,99 @@
 /*
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // Check that native getters and setters for DOM elements work as expected in
 // variables view - bug 870220.
 
+"use strict";
+
 const TEST_URI = "data:text/html;charset=utf8,<title>bug870220</title>\n" +
                  "<p>hello world\n<p>native getters!";
 
-let gWebConsole, gJSTerm, gVariablesView;
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
+  let jsterm = hud.jsterm;
 
-function test()
-{
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
+  jsterm.execute("document");
 
-function consoleOpened(hud)
-{
-  gWebConsole = hud;
-  gJSTerm = hud.jsterm;
-
-  gJSTerm.execute("document");
-
-  waitForMessages({
+  let [result] = yield waitForMessages({
     webconsole: hud,
     messages: [{
       text: "HTMLDocument \u2192 data:text/html;charset=utf8",
       category: CATEGORY_OUTPUT,
       objects: true,
     }],
-  }).then(onEvalResult);
-}
+  });
 
-function onEvalResult(aResults)
-{
-  let clickable = aResults[0].clickableElements[0];
+  let clickable = result.clickableElements[0];
   ok(clickable, "clickable object found");
 
-  gJSTerm.once("variablesview-fetched", onDocumentFetch);
-  EventUtils.synthesizeMouse(clickable, 2, 2, {}, gWebConsole.iframeWindow)
-}
+  executeSoon(() => {
+    EventUtils.synthesizeMouse(clickable, 2, 2, {}, hud.iframeWindow);
+  });
 
-function onDocumentFetch(aEvent, aVar)
-{
-  gVariablesView = aVar._variablesView;
-  ok(gVariablesView, "variables view object");
+  let fetchedVar = yield jsterm.once("variablesview-fetched");
 
-  findVariableViewProperties(aVar, [
+  let variablesView = fetchedVar._variablesView;
+  ok(variablesView, "variables view object");
+
+  let results = yield findVariableViewProperties(fetchedVar, [
     { name: "title", value: "bug870220" },
     { name: "bgColor" },
-  ], { webconsole: gWebConsole }).then(onDocumentPropsFound);
-}
+  ], { webconsole: hud });
 
-function onDocumentPropsFound(aResults)
-{
-  let prop = aResults[1].matchedProp;
+  let prop = results[1].matchedProp;
   ok(prop, "matched the |bgColor| property in the variables view");
 
   // Check that property value updates work.
-  updateVariablesViewProperty({
+  let updatedVar = yield updateVariablesViewProperty({
     property: prop,
     field: "value",
     string: "'red'",
-    webconsole: gWebConsole,
-    callback: onFetchAfterBackgroundUpdate,
+    webconsole: hud,
   });
-}
 
-function onFetchAfterBackgroundUpdate(aEvent, aVar)
-{
-  info("onFetchAfterBackgroundUpdate");
+  info("on fetch after background update");
 
-  is(content.document.bgColor, "red", "document background color changed");
+  jsterm.clearOutput(true);
+  jsterm.execute("document.bgColor");
 
-  findVariableViewProperties(aVar, [
+  [result] = yield waitForMessages({
+    webconsole: hud,
+    messages: [{
+      text: "red",
+      category: CATEGORY_OUTPUT,
+    }],
+  });
+
+  yield findVariableViewProperties(updatedVar, [
     { name: "bgColor", value: "red" },
-  ], { webconsole: gWebConsole }).then(testParagraphs);
-}
+  ], { webconsole: hud });
 
-function testParagraphs()
-{
-  gJSTerm.execute("$$('p')");
+  jsterm.execute("$$('p')");
 
-  waitForMessages({
-    webconsole: gWebConsole,
+  [result] = yield waitForMessages({
+    webconsole: hud,
     messages: [{
       text: "NodeList [",
       category: CATEGORY_OUTPUT,
       objects: true,
     }],
-  }).then(onEvalNodeList);
-}
+  });
 
-function onEvalNodeList(aResults)
-{
-  let clickable = aResults[0].clickableElements[0];
+  clickable = result.clickableElements[0];
   ok(clickable, "clickable object found");
 
-  gJSTerm.once("variablesview-fetched", onNodeListFetch);
-  EventUtils.synthesizeMouse(clickable, 2, 2, {}, gWebConsole.iframeWindow)
-}
+  executeSoon(() => {
+    EventUtils.synthesizeMouse(clickable, 2, 2, {}, hud.iframeWindow);
+  });
 
-function onNodeListFetch(aEvent, aVar)
-{
-  gVariablesView = aVar._variablesView;
-  ok(gVariablesView, "variables view object");
+  fetchedVar = yield jsterm.once("variablesview-fetched");
 
-  findVariableViewProperties(aVar, [
+  yield findVariableViewProperties(fetchedVar, [
     { name: "0.textContent", value: /hello world/ },
     { name: "1.textContent", value: /native getters/ },
-  ], { webconsole: gWebConsole }).then(() => {
-    gWebConsole = gJSTerm = gVariablesView = null;
-    finishTest();
-  });
-}
+  ], { webconsole: hud });
+});
diff --git a/browser/devtools/webconsole/test/browser_console_navigation_marker.js b/browser/devtools/webconsole/test/browser_console_navigation_marker.js
--- a/browser/devtools/webconsole/test/browser_console_navigation_marker.js
+++ b/browser/devtools/webconsole/test/browser_console_navigation_marker.js
@@ -1,81 +1,73 @@
 /*
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // Check that the navigation marker shows on page reload - bug 793996.
 
-function test()
+const PREF = "devtools.webconsole.persistlog";
+const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
+
+let hud;
+
+let test = asyncTest(function* () {
+  Services.prefs.setBoolPref(PREF, true);
+
+  let { browser } = yield loadTab(TEST_URI);
+  hud = yield openConsole();
+
+  yield consoleOpened();
+
+  let loaded = loadBrowser(browser);
+  BrowserReload();
+  yield loaded;
+
+  yield onReload();
+
+  isnot(hud.outputNode.textContent.indexOf("foobarz1"), -1,
+        "foobarz1 is still in the output");
+
+  Services.prefs.clearUserPref(PREF);
+});
+
+function consoleOpened()
 {
-  const PREF = "devtools.webconsole.persistlog";
-  const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
-  let hud = null;
-  let Messages = require("devtools/webconsole/console-output").Messages;
+  ok(hud, "Web Console opened");
 
-  Services.prefs.setBoolPref(PREF, true);
-  registerCleanupFunction(() => Services.prefs.clearUserPref(PREF));
+  hud.jsterm.clearOutput();
+  content.console.log("foobarz1");
+  return waitForMessages({
+    webconsole: hud,
+    messages: [{
+      text: "foobarz1",
+      category: CATEGORY_WEBDEV,
+      severity: SEVERITY_LOG,
+    }],
+  });
+}
 
-  addTab(TEST_URI);
+function onReload()
+{
+  content.console.log("foobarz2");
 
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
+  return waitForMessages({
+    webconsole: hud,
+    messages: [{
+      name: "page reload",
+      text: "test-console.html",
+      category: CATEGORY_NETWORK,
+      severity: SEVERITY_LOG,
+    },
+    {
+      text: "foobarz2",
+      category: CATEGORY_WEBDEV,
+      severity: SEVERITY_LOG,
+    },
+    {
+      name: "navigation marker",
+      text: "test-console.html",
+      type: Messages.NavigationMarker,
+    }],
+  });
+}
 
-  function consoleOpened(aHud)
-  {
-    hud = aHud;
-    ok(hud, "Web Console opened");
-
-    hud.jsterm.clearOutput();
-    content.console.log("foobarz1");
-    waitForMessages({
-      webconsole: hud,
-      messages: [{
-        text: "foobarz1",
-        category: CATEGORY_WEBDEV,
-        severity: SEVERITY_LOG,
-      }],
-    }).then(onConsoleMessage);
-  }
-
-  function onConsoleMessage()
-  {
-    browser.addEventListener("load", onReload, true);
-    content.location.reload();
-  }
-
-  function onReload()
-  {
-    browser.removeEventListener("load", onReload, true);
-
-    content.console.log("foobarz2");
-
-    waitForMessages({
-      webconsole: hud,
-      messages: [{
-        name: "page reload",
-        text: "test-console.html",
-        category: CATEGORY_NETWORK,
-        severity: SEVERITY_LOG,
-      },
-      {
-        text: "foobarz2",
-        category: CATEGORY_WEBDEV,
-        severity: SEVERITY_LOG,
-      },
-      {
-        name: "navigation marker",
-        text: "test-console.html",
-        type: Messages.NavigationMarker,
-      }],
-    }).then(onConsoleMessageAfterReload);
-  }
-
-  function onConsoleMessageAfterReload()
-  {
-    isnot(hud.outputNode.textContent.indexOf("foobarz1"), -1,
-          "foobarz1 is still in the output");
-    finishTest();
-  }
-}
diff --git a/browser/devtools/webconsole/test/browser_console_variables_view.js b/browser/devtools/webconsole/test/browser_console_variables_view.js
--- a/browser/devtools/webconsole/test/browser_console_variables_view.js
+++ b/browser/devtools/webconsole/test/browser_console_variables_view.js
@@ -4,180 +4,194 @@
  */
 
 // Check that variables view works as expected in the web console.
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-eval-in-stackframe.html";
 
 let gWebConsole, gJSTerm, gVariablesView;
 
-function test()
-{
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
+let hud;
 
-function consoleOpened(hud)
-{
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+
+  hud = yield openConsole();
+
   gWebConsole = hud;
   gJSTerm = hud.jsterm;
-  gJSTerm.execute("fooObj", onExecuteFooObj);
-}
+  let msg = yield execute(hud, "fooObj");
 
-function onExecuteFooObj(msg)
-{
   ok(msg, "output message found");
   ok(msg.textContent.contains('{ testProp: "testValue" }'), "message text check");
 
   let anchor = msg.querySelector("a");
   ok(anchor, "object link found");
 
-  gJSTerm.once("variablesview-fetched", onFooObjFetch);
+  let fetched = gJSTerm.once("variablesview-fetched");
 
-  executeSoon(() =>
-    EventUtils.synthesizeMouse(anchor, 2, 2, {}, gWebConsole.iframeWindow)
-  );
-}
+  // executeSoon
+  EventUtils.synthesizeMouse(anchor, 2, 2, {}, gWebConsole.iframeWindow);
 
-function onFooObjFetch(aEvent, aVar)
+  let view = yield fetched;
+
+  let results = yield onFooObjFetch(view);
+
+  let vView = yield onTestPropFound(results);
+  let results2 = yield onFooObjFetchAfterUpdate(vView);
+
+  let vView2 = yield onUpdatedTestPropFound(results2);
+  let results3 = yield onFooObjFetchAfterPropRename(vView2);
+
+  let vView3 = yield onRenamedTestPropFound(results3);
+  let results4 = yield onPropUpdateError(vView3);
+
+  let vView4 = yield onRenamedTestPropFoundAgain(results4);
+  let results5 = yield onPropUpdateError(vView4);
+
+  let vView5 = yield onRenamedTestPropFoundAgain(results5);
+
+  let prop = results5[0].matchedProp;
+  yield testPropDelete(prop);
+});
+
+function onFooObjFetch(aVar)
 {
   gVariablesView = aVar._variablesView;
   ok(gVariablesView, "variables view object");
 
-  findVariableViewProperties(aVar, [
+  return findVariableViewProperties(aVar, [
     { name: "testProp", value: "testValue" },
-  ], { webconsole: gWebConsole }).then(onTestPropFound);
+  ], { webconsole: gWebConsole });
 }
 
 function onTestPropFound(aResults)
 {
   let prop = aResults[0].matchedProp;
   ok(prop, "matched the |testProp| property in the variables view");
 
-  is(content.wrappedJSObject.fooObj.testProp, aResults[0].value,
+  is("testValue", aResults[0].value,
      "|fooObj.testProp| value is correct");
 
   // Check that property value updates work and that jsterm functions can be
   // used.
-  updateVariablesViewProperty({
+  return updateVariablesViewProperty({
     property: prop,
     field: "value",
     string: "document.title + window.location + $('p')",
-    webconsole: gWebConsole,
-    callback: onFooObjFetchAfterUpdate,
+    webconsole: gWebConsole
   });
 }
 
-function onFooObjFetchAfterUpdate(aEvent, aVar)
+function onFooObjFetchAfterUpdate(aVar)
 {
   info("onFooObjFetchAfterUpdate");
-  let para = content.wrappedJSObject.document.querySelector("p");
-  let expectedValue = content.document.title + content.location + para;
+  let expectedValue = content.document.title + content.location
+                      + '[object HTMLParagraphElement]';
 
-  findVariableViewProperties(aVar, [
+  return findVariableViewProperties(aVar, [
     { name: "testProp", value: expectedValue },
-  ], { webconsole: gWebConsole }).then(onUpdatedTestPropFound);
+  ], { webconsole: gWebConsole });
 }
 
 function onUpdatedTestPropFound(aResults)
 {
   let prop = aResults[0].matchedProp;
   ok(prop, "matched the updated |testProp| property value");
 
   is(content.wrappedJSObject.fooObj.testProp, aResults[0].value,
      "|fooObj.testProp| value has been updated");
 
   // Check that property name updates work.
-  updateVariablesViewProperty({
+  return updateVariablesViewProperty({
     property: prop,
     field: "name",
     string: "testUpdatedProp",
-    webconsole: gWebConsole,
-    callback: onFooObjFetchAfterPropRename,
+    webconsole: gWebConsole
   });
 }
 
-function onFooObjFetchAfterPropRename(aEvent, aVar)
+function onFooObjFetchAfterPropRename(aVar)
 {
   info("onFooObjFetchAfterPropRename");
 
   let para = content.wrappedJSObject.document.querySelector("p");
   let expectedValue = content.document.title + content.location + para;
 
   // Check that the new value is in the variables view.
-  findVariableViewProperties(aVar, [
+  return findVariableViewProperties(aVar, [
     { name: "testUpdatedProp", value: expectedValue },
-  ], { webconsole: gWebConsole }).then(onRenamedTestPropFound);
+  ], { webconsole: gWebConsole });
 }
 
 function onRenamedTestPropFound(aResults)
 {
   let prop = aResults[0].matchedProp;
   ok(prop, "matched the renamed |testProp| property");
 
   ok(!content.wrappedJSObject.fooObj.testProp,
      "|fooObj.testProp| has been deleted");
   is(content.wrappedJSObject.fooObj.testUpdatedProp, aResults[0].value,
      "|fooObj.testUpdatedProp| is correct");
 
   // Check that property value updates that cause exceptions are reported in
   // the web console output.
-  updateVariablesViewProperty({
+  return updateVariablesViewProperty({
     property: prop,
     field: "value",
     string: "foobarzFailure()",
-    webconsole: gWebConsole,
-    callback: onPropUpdateError,
+    webconsole: gWebConsole
   });
 }
 
-function onPropUpdateError(aEvent, aVar)
+function onPropUpdateError(aVar)
 {
   info("onPropUpdateError");
 
   let para = content.wrappedJSObject.document.querySelector("p");
   let expectedValue = content.document.title + content.location + para;
 
   // Make sure the property did not change.
-  findVariableViewProperties(aVar, [
+  return findVariableViewProperties(aVar, [
     { name: "testUpdatedProp", value: expectedValue },
-  ], { webconsole: gWebConsole }).then(onRenamedTestPropFoundAgain);
+  ], { webconsole: gWebConsole });
 }
 
 function onRenamedTestPropFoundAgain(aResults)
 {
   let prop = aResults[0].matchedProp;
   ok(prop, "matched the renamed |testProp| property again");
 
   let outputNode = gWebConsole.outputNode;
 
-  waitForMessages({
+  return waitForMessages({
     webconsole: gWebConsole,
     messages: [{
       name: "exception in property update reported in the web console output",
       text: "foobarzFailure",
       category: CATEGORY_OUTPUT,
       severity: SEVERITY_ERROR,
     }],
-  }).then(testPropDelete.bind(null, prop));
+  });
 }
 
 function testPropDelete(aProp)
 {
   gVariablesView.window.focus();
   aProp.focus();
 
   executeSoon(() => {
     EventUtils.synthesizeKey("VK_DELETE", {}, gVariablesView.window);
     gWebConsole = gJSTerm = gVariablesView = null;
   });
 
-  waitForSuccess({
+  return waitForSuccess({
     name: "property deleted",
     timeout: 60000,
-    validatorFn: () => !("testUpdatedProp" in content.wrappedJSObject.fooObj),
-    successFn: finishTest,
-    failureFn: finishTest,
+    validator: () => !("testUpdatedProp" in content.wrappedJSObject.fooObj)
   });
 }
+
+function execute(hud, str) {
+  let deferred = promise.defer();
+  hud.jsterm.execute(str, deferred.resolve);
+  return deferred.promise;
+}
diff --git a/browser/devtools/webconsole/test/browser_console_variables_view_highlighter.js b/browser/devtools/webconsole/test/browser_console_variables_view_highlighter.js
--- a/browser/devtools/webconsole/test/browser_console_variables_view_highlighter.js
+++ b/browser/devtools/webconsole/test/browser_console_variables_view_highlighter.js
@@ -7,21 +7,21 @@
 // selecting DOM nodes
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-bug-952277-highlight-nodes-in-vview.html";
 
 let gWebConsole, gJSTerm, gVariablesView, gToolbox;
 
 function test()
 {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
+  loadTab(TEST_URI).then(() => {
+    openConsole().then(hud => {
+      consoleOpened(hud);
+    })
+  });
 }
 
 function consoleOpened(hud)
 {
   gWebConsole = hud;
   gJSTerm = hud.jsterm;
   gToolbox = gDevTools.getToolbox(hud.target);
   gJSTerm.execute("document.querySelectorAll('p')", onQSAexecuted);
diff --git a/browser/devtools/webconsole/test/browser_jsterm_inspect.js b/browser/devtools/webconsole/test/browser_jsterm_inspect.js
--- a/browser/devtools/webconsole/test/browser_jsterm_inspect.js
+++ b/browser/devtools/webconsole/test/browser_jsterm_inspect.js
@@ -1,35 +1,28 @@
 /*
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // Check that the inspect() jsterm helper function works.
 
-function test()
-{
-  const TEST_URI = "data:text/html;charset=utf8,<p>hello bug 869981";
+const TEST_URI = "data:text/html;charset=utf8,<p>hello bug 869981";
 
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
 
-  function consoleOpened(hud)
-  {
-    content.wrappedJSObject.testProp = "testValue";
+  let hud = yield openConsole();
+  let jsterm = hud.jsterm;
 
-    hud.jsterm.once("variablesview-fetched", onObjFetch);
-    hud.jsterm.execute("inspect(window)");
-  }
+  jsterm.execute("testProp = 'testValue'");
 
-  function onObjFetch(aEvent, aVar)
-  {
-    ok(aVar._variablesView, "variables view object");
+  let fetched = jsterm.once("variablesview-fetched");
+  jsterm.execute("inspect(window)");
+  let variable = yield fetched;
 
-    findVariableViewProperties(aVar, [
-      { name: "testProp", value: "testValue" },
-      { name: "document", value: /HTMLDocument \u2192 data:/ },
-    ], { webconsole: hud }).then(finishTest);
-  }
-}
+  ok(variable._variablesView, "variables view object");
+
+  yield findVariableViewProperties(variable, [
+    { name: "testProp", value: "testValue" },
+    { name: "document", value: /HTMLDocument \u2192 data:/ },
+  ], { webconsole: hud });
+});
diff --git a/browser/devtools/webconsole/test/browser_longstring_hang.js b/browser/devtools/webconsole/test/browser_longstring_hang.js
--- a/browser/devtools/webconsole/test/browser_longstring_hang.js
+++ b/browser/devtools/webconsole/test/browser_longstring_hang.js
@@ -1,64 +1,53 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 // Test that very long strings do not hang the browser.
 
-function test()
-{
-  addTab("http://example.com/browser/browser/devtools/webconsole/test/test-bug-859170-longstring-hang.html");
+const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-bug-859170-longstring-hang.html";
 
-  let hud = null;
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
 
-  gBrowser.selectedBrowser.addEventListener("load", function onLoad() {
-    gBrowser.selectedBrowser.removeEventListener("load", onLoad, true);
-    openConsole(null, performTest);
-  }, true);
+  let hud = yield openConsole();
 
-  function performTest(aHud)
-  {
-    hud = aHud;
-    info("wait for the initial long string");
+  info("wait for the initial long string");
 
-    waitForMessages({
-      webconsole: hud,
-      messages: [
-        {
-          name: "find 'foobar', no 'foobaz', in long string output",
-          text: "foobar",
-          noText: "foobaz",
-          category: CATEGORY_WEBDEV,
-          longString: true,
-        },
-      ],
-    }).then(onInitialString);
-  }
+  let results = yield waitForMessages({
+    webconsole: hud,
+    messages: [
+      {
+        name: "find 'foobar', no 'foobaz', in long string output",
+        text: "foobar",
+        noText: "foobaz",
+        category: CATEGORY_WEBDEV,
+        longString: true,
+      },
+    ],
+  });
 
-  function onInitialString(aResults)
-  {
-    let clickable = aResults[0].longStrings[0];
-    ok(clickable, "long string ellipsis is shown");
-    clickable.scrollIntoView(false);
+  let clickable = results[0].longStrings[0];
+  ok(clickable, "long string ellipsis is shown");
+  clickable.scrollIntoView(false);
 
-    EventUtils.synthesizeMouse(clickable, 2, 2, {}, hud.iframeWindow);
+  EventUtils.synthesizeMouse(clickable, 2, 2, {}, hud.iframeWindow);
 
-    info("wait for long string expansion");
+  info("wait for long string expansion");
 
-    waitForMessages({
-      webconsole: hud,
-      messages: [
-        {
-          name: "find 'foobaz' after expand, but no 'boom!' at the end",
-          text: "foobaz",
-          noText: "boom!",
-          category: CATEGORY_WEBDEV,
-          longString: false,
-        },
-        {
-          text: "too long to be displayed",
-          longString: false,
-        },
-      ],
-    }).then(finishTest);
-  }
-}
+  yield waitForMessages({
+    webconsole: hud,
+    messages: [
+      {
+        name: "find 'foobaz' after expand, but no 'boom!' at the end",
+        text: "foobaz",
+        noText: "boom!",
+        category: CATEGORY_WEBDEV,
+        longString: false,
+      },
+      {
+        text: "too long to be displayed",
+        longString: false,
+      },
+    ],
+  });
+});
diff --git a/browser/devtools/webconsole/test/browser_output_breaks_after_console_dir_uninspectable.js b/browser/devtools/webconsole/test/browser_output_breaks_after_console_dir_uninspectable.js
--- a/browser/devtools/webconsole/test/browser_output_breaks_after_console_dir_uninspectable.js
+++ b/browser/devtools/webconsole/test/browser_output_breaks_after_console_dir_uninspectable.js
@@ -1,50 +1,44 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 // Make sure that the Web Console output does not break after we try to call
 // console.dir() for objects that are not inspectable.
 
-function test()
-{
-  waitForExplicitFinish();
+const TEST_URI = "data:text/html;charset=utf8,test for bug 773466";
 
-  addTab("data:text/html;charset=utf8,test for bug 773466");
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
 
-  gBrowser.selectedBrowser.addEventListener("load", function onLoad() {
-    gBrowser.selectedBrowser.removeEventListener("load", onLoad, true);
-    openConsole(null, performTest);
-  }, true);
-}
+  let hud = yield openConsole();
 
-function performTest(hud)
-{
   hud.jsterm.clearOutput(true);
 
   hud.jsterm.execute("console.log('fooBug773466a')");
   hud.jsterm.execute("myObj = Object.create(null)");
   hud.jsterm.execute("console.dir(myObj)");
 
-  waitForMessages({
+  yield waitForMessages({
     webconsole: hud,
     messages: [{
       text: "fooBug773466a",
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG,
     },
     {
       name: "console.dir output",
       consoleDir: "[object Object]",
     }],
-  }).then(() => {
-    content.console.log("fooBug773466b");
-    waitForMessages({
-      webconsole: hud,
-      messages: [{
-        text: "fooBug773466b",
-        category: CATEGORY_WEBDEV,
-        severity: SEVERITY_LOG,
-      }],
-    }).then(finishTest);
+  })
+
+  content.console.log("fooBug773466b");
+
+  yield waitForMessages({
+    webconsole: hud,
+    messages: [{
+      text: "fooBug773466b",
+      category: CATEGORY_WEBDEV,
+      severity: SEVERITY_LOG,
+    }],
   });
-}
+});
diff --git a/browser/devtools/webconsole/test/browser_output_longstring_expand.js b/browser/devtools/webconsole/test/browser_output_longstring_expand.js
--- a/browser/devtools/webconsole/test/browser_output_longstring_expand.js
+++ b/browser/devtools/webconsole/test/browser_output_longstring_expand.js
@@ -1,93 +1,83 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 // Test that long strings can be expanded in the console output.
 
-function test()
-{
-  waitForExplicitFinish();
+const TEST_URI = "data:text/html;charset=utf8,test for bug 787981 - check that long strings can be expanded in the output.";
 
+let test = asyncTest(function* () {
   let tempScope = {};
   Cu.import("resource://gre/modules/devtools/dbg-server.jsm", tempScope);
   let DebuggerServer = tempScope.DebuggerServer;
 
   let longString = (new Array(DebuggerServer.LONG_STRING_LENGTH + 4)).join("a") +
                    "foobar";
   let initialString =
     longString.substring(0, DebuggerServer.LONG_STRING_INITIAL_LENGTH);
 
-  addTab("data:text/html;charset=utf8,test for bug 787981 - check that long strings can be expanded in the output.");
+  yield loadTab(TEST_URI);
 
-  let hud = null;
+  let hud = yield openConsole();
 
-  gBrowser.selectedBrowser.addEventListener("load", function onLoad() {
-    gBrowser.selectedBrowser.removeEventListener("load", onLoad, true);
-    openConsole(null, performTest);
-  }, true);
+  hud.jsterm.clearOutput(true);
+  hud.jsterm.execute("console.log('bazbaz', '" + longString +"', 'boom')");
 
-  function performTest(aHud)
-  {
-    hud = aHud;
-    hud.jsterm.clearOutput(true);
-    hud.jsterm.execute("console.log('bazbaz', '" + longString +"', 'boom')");
+  let [result] = yield waitForMessages({
+    webconsole: hud,
+    messages: [{
+      name: "console.log output",
+      text: ["bazbaz", "boom", initialString],
+      noText: "foobar",
+      longString: true,
+    }],
+  });
 
-    waitForMessages({
-      webconsole: hud,
-      messages: [{
-        name: "console.log output",
-        text: ["bazbaz", "boom", initialString],
-        noText: "foobar",
-        longString: true,
-      }],
-    }).then(onConsoleMessage);
-  }
+  let clickable = result.longStrings[0];
+  ok(clickable, "long string ellipsis is shown");
 
-  function onConsoleMessage([result])
-  {
-    let clickable = result.longStrings[0];
-    ok(clickable, "long string ellipsis is shown");
+  clickable.scrollIntoView(false);
 
-    clickable.scrollIntoView(false);
+  EventUtils.synthesizeMouse(clickable, 2, 2, {}, hud.iframeWindow);
 
-    EventUtils.synthesizeMouse(clickable, 2, 2, {}, hud.iframeWindow);
+  yield waitForMessages({
+    webconsole: hud,
+    messages: [{
+      name: "full string",
+      text: ["bazbaz", "boom", longString],
+      category: CATEGORY_WEBDEV,
+      longString: false,
+    }],
+  });
 
-    waitForMessages({
-      webconsole: hud,
-      messages: [{
-        name: "full string",
-        text: ["bazbaz", "boom", longString],
-        category: CATEGORY_WEBDEV,
-        longString: false,
-      }],
-    }).then(() => {
-      hud.jsterm.clearOutput(true);
-      hud.jsterm.execute("'" + longString +"'", onExecute);
-    });
-  }
+  hud.jsterm.clearOutput(true);
+  let msg = yield execute(hud, "'" + longString +"'");
 
-  function onExecute(msg)
-  {
-    isnot(msg.textContent.indexOf(initialString), -1,
-        "initial string is shown");
-    is(msg.textContent.indexOf(longString), -1,
-        "full string is not shown");
+  isnot(msg.textContent.indexOf(initialString), -1,
+      "initial string is shown");
+  is(msg.textContent.indexOf(longString), -1,
+      "full string is not shown");
 
-    let clickable = msg.querySelector(".longStringEllipsis");
-    ok(clickable, "long string ellipsis is shown");
+  let clickable = msg.querySelector(".longStringEllipsis");
+  ok(clickable, "long string ellipsis is shown");
 
-    clickable.scrollIntoView(false);
+  clickable.scrollIntoView(false);
 
-    EventUtils.synthesizeMouse(clickable, 3, 4, {}, hud.iframeWindow);
+  EventUtils.synthesizeMouse(clickable, 3, 4, {}, hud.iframeWindow);
 
-    waitForMessages({
-      webconsole: hud,
-      messages: [{
-        name: "full string",
-        text: longString,
-        category: CATEGORY_OUTPUT,
-        longString: false,
-      }],
-    }).then(finishTest);
-  }
+  yield waitForMessages({
+    webconsole: hud,
+    messages: [{
+      name: "full string",
+      text: longString,
+      category: CATEGORY_OUTPUT,
+      longString: false,
+    }],
+  })
+});
+
+function execute(hud, str) {
+  let deferred = promise.defer();
+  hud.jsterm.execute(str, deferred.resolve);
+  return deferred.promise;
 }
diff --git a/browser/devtools/webconsole/test/browser_repeated_messages_accuracy.js b/browser/devtools/webconsole/test/browser_repeated_messages_accuracy.js
--- a/browser/devtools/webconsole/test/browser_repeated_messages_accuracy.js
+++ b/browser/devtools/webconsole/test/browser_repeated_messages_accuracy.js
@@ -3,71 +3,77 @@
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // Test that makes sure messages are not considered repeated when coming from
 // different lines of code, or from different severities, etc.
 // See bugs 720180 and 800510.
 
+"use strict";
+
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-repeated-messages.html";
+const PREF = "devtools.webconsole.persistlog";
 
-function test() {
-  const PREF = "devtools.webconsole.persistlog";
+let test = asyncTest(function* () {
   Services.prefs.setBoolPref(PREF, true);
-  registerCleanupFunction(() => Services.prefs.clearUserPref(PREF));
 
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
+  let { browser } = yield loadTab(TEST_URI);
+
+  let hud = yield openConsole();
+
+  yield consoleOpened(hud);
+
+  let loaded = loadBrowser(browser);
+  BrowserReload();
+  yield loaded;
+
+  yield testCSSRepeats(hud);
+  yield testCSSRepeatsAfterReload(hud);
+  yield testConsoleRepeats(hud);
+
+  Services.prefs.clearUserPref(PREF);
+});
 
 function consoleOpened(hud) {
   // Check that css warnings are not coalesced if they come from different lines.
   info("waiting for 2 css warnings");
 
-  waitForMessages({
+  return waitForMessages({
     webconsole: hud,
     messages: [{
       name: "two css warnings",
       category: CATEGORY_CSS,
       count: 2,
       repeats: 1,
     }],
-  }).then(testCSSRepeats.bind(null, hud));
+  });
 }
 
 function testCSSRepeats(hud) {
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
+  info("wait for repeats after page reload");
 
-    info("wait for repeats after page reload");
-
-    waitForMessages({
-      webconsole: hud,
-      messages: [{
-        name: "two css warnings, repeated twice",
-        category: CATEGORY_CSS,
-        repeats: 2,
-        count: 2,
-      }],
-    }).then(testCSSRepeatsAfterReload.bind(null, hud));
-  }, true);
-  content.location.reload();
+  return waitForMessages({
+    webconsole: hud,
+    messages: [{
+      name: "two css warnings, repeated twice",
+      category: CATEGORY_CSS,
+      repeats: 2,
+      count: 2,
+    }],
+  });
 }
 
 function testCSSRepeatsAfterReload(hud) {
   hud.jsterm.clearOutput(true);
-  content.wrappedJSObject.testConsole();
+  hud.jsterm.execute("testConsole()");
 
   info("wait for repeats with the console API");
 
-  waitForMessages({
+  return waitForMessages({
     webconsole: hud,
     messages: [
       {
         name: "console.log 'foo repeat' repeated twice",
         category: CATEGORY_WEBDEV,
         severity: SEVERITY_LOG,
         repeats: 2,
       },
@@ -79,27 +85,28 @@ function testCSSRepeatsAfterReload(hud) 
       },
       {
         name: "console.error 'foo repeat' repeated once",
         category: CATEGORY_WEBDEV,
         severity: SEVERITY_ERROR,
         repeats: 1,
       },
     ],
-  }).then(testConsoleRepeats.bind(null, hud));
+  })
 }
 
 function testConsoleRepeats(hud) {
   hud.jsterm.clearOutput(true);
   hud.jsterm.execute("undefined");
+
   content.console.log("undefined");
 
   info("make sure console API messages are not coalesced with jsterm output");
 
-  waitForMessages({
+  return waitForMessages({
     webconsole: hud,
     messages: [
       {
         name: "'undefined' jsterm input message",
         text: "undefined",
         category: CATEGORY_INPUT,
       },
       {
@@ -109,10 +116,10 @@ function testConsoleRepeats(hud) {
       },
       {
         name: "'undefined' console.log message",
         text: "undefined",
         category: CATEGORY_WEBDEV,
         repeats: 1,
       },
     ],
-  }).then(finishTest);
+  });
 }
diff --git a/browser/devtools/webconsole/test/browser_result_format_as_string.js b/browser/devtools/webconsole/test/browser_result_format_as_string.js
--- a/browser/devtools/webconsole/test/browser_result_format_as_string.js
+++ b/browser/devtools/webconsole/test/browser_result_format_as_string.js
@@ -1,41 +1,36 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 // Make sure that JS eval result are properly formatted as strings.
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-result-format-as-string.html";
 
-function test()
-{
-  waitForExplicitFinish();
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
 
-  addTab(TEST_URI);
+  let hud = yield openConsole();
 
-  gBrowser.selectedBrowser.addEventListener("load", function onLoad() {
-    gBrowser.selectedBrowser.removeEventListener("load", onLoad, true);
-    openConsole(null, performTest);
-  }, true);
-}
-
-function performTest(hud)
-{
   hud.jsterm.clearOutput(true);
 
-  hud.jsterm.execute("document.querySelector('p')", (msg) => {
-    is(hud.outputNode.textContent.indexOf("bug772506_content"), -1,
-       "no content element found");
-    ok(!hud.outputNode.querySelector("#foobar"), "no #foobar element found");
+  let msg = yield execute(hud, "document.querySelector('p')");
 
-    ok(msg, "eval output node found");
-    is(msg.textContent.indexOf("<div>"), -1,
-       "<div> string is not displayed");
-    isnot(msg.textContent.indexOf("<p>"), -1,
-          "<p> string is displayed");
+  is(hud.outputNode.textContent.indexOf("bug772506_content"), -1,
+     "no content element found");
+  ok(!hud.outputNode.querySelector("#foobar"), "no #foobar element found");
 
-    EventUtils.synthesizeMouseAtCenter(msg, {type: "mousemove"});
-    ok(!gBrowser._bug772506, "no content variable");
+  ok(msg, "eval output node found");
+  is(msg.textContent.indexOf("<div>"), -1,
+     "<div> string is not displayed");
+  isnot(msg.textContent.indexOf("<p>"), -1,
+        "<p> string is displayed");
 
-    finishTest();
-  });
+  EventUtils.synthesizeMouseAtCenter(msg, {type: "mousemove"});
+  ok(!gBrowser._bug772506, "no content variable");
+});
+
+function execute(hud, str) {
+  let deferred = promise.defer();
+  hud.jsterm.execute(str, deferred.resolve);
+  return deferred.promise;
 }
diff --git a/browser/devtools/webconsole/test/browser_warn_user_about_replaced_api.js b/browser/devtools/webconsole/test/browser_warn_user_about_replaced_api.js
--- a/browser/devtools/webconsole/test/browser_warn_user_about_replaced_api.js
+++ b/browser/devtools/webconsole/test/browser_warn_user_about_replaced_api.js
@@ -1,79 +1,81 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 const TEST_REPLACED_API_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console-replaced-api.html";
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/testscript.js";
+const PREF = "devtools.webconsole.persistlog";
 
-function test() {
-  waitForExplicitFinish();
+let test = asyncTest(function* () {
+  Services.prefs.setBoolPref(PREF, true);
 
-  const PREF = "devtools.webconsole.persistlog";
-  Services.prefs.setBoolPref(PREF, true);
-  registerCleanupFunction(() => Services.prefs.clearUserPref(PREF));
+  let { browser } = yield loadTab(TEST_URI);
+  let hud = yield openConsole();
 
-  // First test that the warning does not appear on a page that doesn't override
-  // the window.console object.
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, testWarningNotPresent);
-  }, true);
+  yield testWarningNotPresent(hud);
 
-  function testWarningNotPresent(hud)
-  {
+  let loaded = loadBrowser(browser);
+  content.location = TEST_REPLACED_API_URI;
+  yield loaded;
+
+  let hud2 = yield openConsole();
+
+  yield testWarningPresent(hud2);
+
+  Services.prefs.clearUserPref(PREF)
+});
+
+function testWarningNotPresent(hud)
+{
+  let deferred = promise.defer();
+
+  is(hud.outputNode.textContent.indexOf("logging API"), -1,
+     "no warning displayed");
+
+  // Bug 862024: make sure the warning doesn't show after page reload.
+  info("reload " + TEST_URI);
+  executeSoon(() => content.location.reload());
+
+  waitForMessages({
+    webconsole: hud,
+    messages: [{
+      text: "testscript.js",
+      category: CATEGORY_NETWORK,
+    }],
+  }).then(() => executeSoon(() => {
     is(hud.outputNode.textContent.indexOf("logging API"), -1,
        "no warning displayed");
+    closeConsole().then(deferred.resolve);
+  }));
 
-    // Bug 862024: make sure the warning doesn't show after page reload.
-    info("reload " + TEST_URI);
-    executeSoon(() => content.location.reload());
+  return deferred.promise;
+}
 
-    waitForMessages({
-      webconsole: hud,
-      messages: [{
-        text: "testscript.js",
-        category: CATEGORY_NETWORK,
-      }],
-    }).then(() => executeSoon(() => {
-      is(hud.outputNode.textContent.indexOf("logging API"), -1,
-         "no warning displayed");
+function testWarningPresent(hud)
+{
+  info("wait for the warning to show");
+  let deferred = promise.defer();
 
-      closeConsole(null, loadTestPage);
-    }));
-  }
+  let warning = {
+    webconsole: hud,
+    messages: [{
+      text: /logging API .+ disabled by a script/,
+      category: CATEGORY_JS,
+      severity: SEVERITY_WARNING,
+    }],
+  };
 
-  function loadTestPage()
-  {
-    info("load test " + TEST_REPLACED_API_URI);
-    browser.addEventListener("load", function onLoad() {
-      browser.removeEventListener("load", onLoad, true);
-      openConsole(null, testWarningPresent);
-    }, true);
-    content.location = TEST_REPLACED_API_URI;
-  }
+  waitForMessages(warning).then(() => {
+    hud.jsterm.clearOutput();
 
-  function testWarningPresent(hud)
-  {
-    info("wait for the warning to show");
-    let warning = {
-      webconsole: hud,
-      messages: [{
-        text: /logging API .+ disabled by a script/,
-        category: CATEGORY_JS,
-        severity: SEVERITY_WARNING,
-      }],
-    };
+    executeSoon(() => {
+      info("reload the test page and wait for the warning to show");
+      waitForMessages(warning).then(deferred.resolve);
+      content.location.reload();
+    });
+  });
 
-    waitForMessages(warning).then(() => {
-      hud.jsterm.clearOutput();
+  return deferred.promise;
+}
 
-      executeSoon(() => {
-        info("reload the test page and wait for the warning to show");
-        waitForMessages(warning).then(finishTest);
-        content.location.reload();
-      });
-    });
-  }
-}
diff --git a/browser/devtools/webconsole/test/browser_webconsole_allow_mixedcontent_securityerrors.js b/browser/devtools/webconsole/test/browser_webconsole_allow_mixedcontent_securityerrors.js
--- a/browser/devtools/webconsole/test/browser_webconsole_allow_mixedcontent_securityerrors.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_allow_mixedcontent_securityerrors.js
@@ -7,51 +7,55 @@
 // are logged to the console and have the correct "Learn More"
 // url appended to them.
 // Bug 875456 - Log mixed content messages from the Mixed Content
 // Blocker to the Security Pane in the Web Console
 
 const TEST_URI = "https://example.com/browser/browser/devtools/webconsole/test/test-mixedcontent-securityerrors.html";
 const LEARN_MORE_URI = "https://developer.mozilla.org/docs/Security/MixedContent";
 
-function test()
+let test = asyncTest(function* () {
+  yield pushPrefEnv();
+
+  yield loadTab(TEST_URI);
+
+  let hud = yield openConsole();
+
+  let results = yield waitForMessages({
+    webconsole: hud,
+    messages: [
+      {
+        name: "Logged mixed active content",
+        text: "Loading mixed (insecure) active content on a secure page \"http://example.com/\"",
+        category: CATEGORY_SECURITY,
+        severity: SEVERITY_WARNING,
+        objects: true,
+      },
+      {
+        name: "Logged mixed passive content - image",
+        text: "Loading mixed (insecure) display content on a secure page \"http://example.com/tests/image/test/mochitest/blue.png\"",
+        category: CATEGORY_SECURITY,
+        severity: SEVERITY_WARNING,
+        objects: true,
+      },
+    ],
+  });
+
+  testClickOpenNewTab(hud, results);
+});
+
+function pushPrefEnv()
 {
-  SpecialPowers.pushPrefEnv({"set":
+  let deferred = promise.defer();
+  let options = {"set":
       [["security.mixed_content.block_active_content", false],
        ["security.mixed_content.block_display_content", false]
-  ]}, loadingMixedContentTest);
-}
-
-function loadingMixedContentTest()
-{
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad(aEvent) {
-    browser.removeEventListener(aEvent.type, onLoad, true);
-    openConsole(null, function testSecurityErrorLogged (hud) {
-      waitForMessages({
-        webconsole: hud,
-        messages: [
-          {
-            name: "Logged mixed active content",
-            text: "Loading mixed (insecure) active content on a secure page \"http://example.com/\"",
-            category: CATEGORY_SECURITY,
-            severity: SEVERITY_WARNING,
-            objects: true,
-          },
-          {
-            name: "Logged mixed passive content - image",
-            text: "Loading mixed (insecure) display content on a secure page \"http://example.com/tests/image/test/mochitest/blue.png\"",
-            category: CATEGORY_SECURITY,
-            severity: SEVERITY_WARNING,
-            objects: true,
-          },
-        ],
-      }).then((results) => testClickOpenNewTab(hud, results));
-    });
-  }, true);
+  ]};
+  SpecialPowers.pushPrefEnv(options, deferred.resolve);
+  return deferred.promise;
 }
 
 function testClickOpenNewTab(hud, results) {
   let warningNode = results[0].clickableElements[0];
   ok(warningNode, "link element");
   ok(warningNode.classList.contains("learn-more-link"), "link class name");
 
   // Invoke the click event and check if a new tab would open to the correct page.
@@ -62,11 +66,9 @@ function testClickOpenNewTab(hud, result
       linkOpened = true;
     }
   }
 
   EventUtils.synthesizeMouse(warningNode, 2, 2, {},
                              warningNode.ownerDocument.defaultView);
   ok(linkOpened, "Clicking the Learn More Warning node opens the desired page");
   window.openUILinkIn = oldOpenUILinkIn;
-
-  finishTest();
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_assert.js b/browser/devtools/webconsole/test/browser_webconsole_assert.js
--- a/browser/devtools/webconsole/test/browser_webconsole_assert.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_assert.js
@@ -2,26 +2,27 @@
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 // Test that console.assert() works as expected (i.e. outputs only on falsy
 // asserts). See bug 760193.
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console-assert.html";
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+
+  let hud = yield openConsole();
+  yield consoleOpened(hud);
+});
 
 function consoleOpened(hud) {
-  waitForMessages({
+  hud.jsterm.execute("test()");
+
+  return waitForMessages({
     webconsole: hud,
     messages: [{
       text: "start",
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG,
     },
     {
       text: "false assert",
@@ -35,16 +36,11 @@ function consoleOpened(hud) {
     },
     {
       text: "end",
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG,
     }],
   }).then(() => {
     let nodes = hud.outputNode.querySelectorAll(".message");
-    is(nodes.length, 4, "only four messages are displayed, no output from the true assert");
-    finishTest();
+    is(nodes.length, 6, "only six messages are displayed, no output from the true assert");
   });
-
-  let button = content.document.querySelector("button");
-  ok(button, "we have the button");
-  EventUtils.sendMouseEvent({ type: "click" }, button, content);
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_autocomplete-properties-with-non-alphanumeric-names.js b/browser/devtools/webconsole/test/browser_webconsole_autocomplete-properties-with-non-alphanumeric-names.js
--- a/browser/devtools/webconsole/test/browser_webconsole_autocomplete-properties-with-non-alphanumeric-names.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_autocomplete-properties-with-non-alphanumeric-names.js
@@ -4,39 +4,37 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 "use strict";
 
 // Test that properties starting with underscores or dollars can be
 // autocompleted (bug 967468).
 
-function test() {
+
+let test = asyncTest(function*() {
   const TEST_URI = "data:text/html;charset=utf8,test autocompletion with $ or _";
-  Task.spawn(runner).then(finishTest);
+  yield loadTab(TEST_URI);
 
-  function* runner() {
-    function autocomplete(term) {
-      let deferred = promise.defer();
+  function autocomplete(term) {
+    let deferred = promise.defer();
 
-      jsterm.setInputValue(term);
-      jsterm.complete(jsterm.COMPLETE_HINT_ONLY, deferred.resolve);
+    jsterm.setInputValue(term);
+    jsterm.complete(jsterm.COMPLETE_HINT_ONLY, deferred.resolve);
 
-      yield deferred.promise;
+    yield deferred.promise;
 
-      ok(popup.itemCount > 0, "There's suggestions for '" + term + "'");
-    }
+    ok(popup.itemCount > 0, "There's suggestions for '" + term + "'");
+  }
 
-    yield addTab(TEST_URI);
-    let { jsterm } = yield openConsole(tab);
-    let popup = jsterm.autocompletePopup;
+  let { jsterm } = yield openConsole();
+  let popup = jsterm.autocompletePopup;
 
-    jsterm.execute("let testObject = {$$aaab: '', $$aaac: ''}");
+  jsterm.execute("let testObject = {$$aaab: '', $$aaac: ''}");
 
-    // Should work with bug 967468.
-    yield autocomplete("Object.__d");
-    yield autocomplete("testObject.$$a");
+  // Should work with bug 967468.
+  yield autocomplete("Object.__d");
+  yield autocomplete("testObject.$$a");
 
-    // Here's when things go wrong in bug 967468.
-    yield autocomplete("Object.__de");
-    yield autocomplete("testObject.$$aa");
-  }
-}
+  // Here's when things go wrong in bug 967468.
+  yield autocomplete("Object.__de");
+  yield autocomplete("testObject.$$aa");
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_autocomplete_and_selfxss.js b/browser/devtools/webconsole/test/browser_webconsole_autocomplete_and_selfxss.js
--- a/browser/devtools/webconsole/test/browser_webconsole_autocomplete_and_selfxss.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_autocomplete_and_selfxss.js
@@ -4,17 +4,27 @@
 
 const TEST_URI = "data:text/html;charset=utf-8,<p>test for bug 642615";
 
 XPCOMUtils.defineLazyServiceGetter(this, "clipboardHelper",
                                    "@mozilla.org/widget/clipboardhelper;1",
                                    "nsIClipboardHelper");
 let WebConsoleUtils = require("devtools/toolkit/webconsole/utils").Utils;
 
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+
+  let hud = yield openConsole();
+
+  yield consoleOpened(hud);
+});
+
 function consoleOpened(HUD) {
+  let deferred = promise.defer();
+
   let jsterm = HUD.jsterm;
   let stringToCopy = "foobazbarBug642615";
 
   jsterm.clearOutput();
 
   ok(!jsterm.completeNode.value, "no completeNode.value");
 
   jsterm.setInputValue("doc");
@@ -94,30 +104,24 @@ function consoleOpened(HUD) {
     is(jsterm.completeNode.value, completionValue,
        "same completeNode.value after undo");
 
     info("wait for completion update after clipboard paste (ctrl-v)");
     jsterm.once("autocomplete-updated", () => {
       ok(!jsterm.completeNode.value, "no completion value after paste (ctrl-v)");
 
       // using executeSoon() to get out of the webconsole event loop.
-      executeSoon(finishTest);
+      executeSoon(deferred.resolve);
     });
 
     // Get out of the webconsole event loop.
     executeSoon(() => {
       EventUtils.synthesizeKey("v", {accelKey: true});
     });
   }
 
   info("wait for completion value after typing 'docu'");
   jsterm.once("autocomplete-updated", onCompletionValue);
 
   EventUtils.synthesizeKey("u", {});
+
+  return deferred.promise;
 }
-
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
diff --git a/browser/devtools/webconsole/test/browser_webconsole_autocomplete_popup_close_on_tab_switch.js b/browser/devtools/webconsole/test/browser_webconsole_autocomplete_popup_close_on_tab_switch.js
--- a/browser/devtools/webconsole/test/browser_webconsole_autocomplete_popup_close_on_tab_switch.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_autocomplete_popup_close_on_tab_switch.js
@@ -2,41 +2,34 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Test that the autocomplete popup closes on switching tabs. See bug 900448.
 
 const TEST_URI = "data:text/html;charset=utf-8,<p>bug 900448 - autocomplete popup closes on tab switch";
 
-let popup = null;
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
+  let popup = hud.jsterm.autocompletePopup;
+  let popupShown = onPopupShown(popup._panel);
 
-registerCleanupFunction(function() {
-  popup = null;
+  hud.jsterm.setInputValue("sc");
+  EventUtils.synthesizeKey("r", {});
+
+  yield popupShown;
+
+  ok(!popup.isOpen, "Popup closes on tab switch");
 });
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
+function onPopupShown(panel) {
+  let finished = promise.defer();
 
-function consoleOpened(HUD) {
-  popup = HUD.jsterm.autocompletePopup;
-
-  popup._panel.addEventListener("popupshown", function popupOpened() {
-    popup._panel.removeEventListener("popupshown", popupOpened, false);
-    addTab("data:text/html;charset=utf-8,<p>testing autocomplete closes");
-    gBrowser.selectedBrowser.addEventListener("load", tab2Loaded, true);
+  panel.addEventListener("popupshown", function popupOpened() {
+    panel.removeEventListener("popupshown", popupOpened, false);
+    loadTab("data:text/html;charset=utf-8,<p>testing autocomplete closes").then(() => {
+      finished.resolve();
+    });
   }, false);
 
-  HUD.jsterm.setInputValue("sc");
-  EventUtils.synthesizeKey("r", {});
+  return finished.promise;
 }
-
-function tab2Loaded() {
-  gBrowser.selectedBrowser.removeEventListener("load", tab2Loaded, true);
-  ok(!popup.isOpen, "Popup closes on tab switch");
-  gBrowser.removeCurrentTab();
-  finishTest();
-}
diff --git a/browser/devtools/webconsole/test/browser_webconsole_basic_net_logging.js b/browser/devtools/webconsole/test/browser_webconsole_basic_net_logging.js
--- a/browser/devtools/webconsole/test/browser_webconsole_basic_net_logging.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_basic_net_logging.js
@@ -1,44 +1,42 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Tests that the page's resources are displayed in the console as they're
 // loaded
 
+"use strict";
+
 const TEST_NETWORK_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-network.html" + "?_date=" + Date.now();
 
-function test() {
-  addTab("data:text/html;charset=utf-8,Web Console basic network logging test");
-  browser.addEventListener("load", onLoad, true);
+let test = asyncTest(function* () {
+  yield loadTab("data:text/html;charset=utf-8,Web Console basic network logging test");
+  let hud = yield openConsole();
 
-  function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, function(hud) {
-      content.location = TEST_NETWORK_URI;
-      waitForMessages({
-        webconsole: hud,
-        messages: [{
-          text: "running network console",
-          category: CATEGORY_WEBDEV,
-          severity: SEVERITY_LOG,
-        },
-        {
-          text: "test-network.html",
-          category: CATEGORY_NETWORK,
-          severity: SEVERITY_LOG,
-        },
-        {
-          text: "testscript.js",
-          category: CATEGORY_NETWORK,
-          severity: SEVERITY_LOG,
-        },
-        {
-          text: "test-image.png",
-          category: CATEGORY_NETWORK,
-          severity: SEVERITY_LOG,
-        }],
-      }).then(finishTest);
-    });
-  }
-}
+  content.location = TEST_NETWORK_URI;
+
+  yield waitForMessages({
+    webconsole: hud,
+    messages: [{
+      text: "running network console",
+      category: CATEGORY_WEBDEV,
+      severity: SEVERITY_LOG,
+    },
+    {
+      text: "test-network.html",
+      category: CATEGORY_NETWORK,
+      severity: SEVERITY_LOG,
+    },
+    {
+      text: "testscript.js",
+      category: CATEGORY_NETWORK,
+      severity: SEVERITY_LOG,
+    },
+    {
+      text: "test-image.png",
+      category: CATEGORY_NETWORK,
+      severity: SEVERITY_LOG,
+    }],
+  });
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_block_mixedcontent_securityerrors.js b/browser/devtools/webconsole/test/browser_webconsole_block_mixedcontent_securityerrors.js
--- a/browser/devtools/webconsole/test/browser_webconsole_block_mixedcontent_securityerrors.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_block_mixedcontent_securityerrors.js
@@ -10,66 +10,71 @@
 // by clicking on the doorhanger shield and validates that the
 // appropriate messages are logged to console.
 // Bug 875456 - Log mixed content messages from the Mixed Content
 // Blocker to the Security Pane in the Web Console
 
 const TEST_URI = "https://example.com/browser/browser/devtools/webconsole/test/test-mixedcontent-securityerrors.html";
 const LEARN_MORE_URI = "https://developer.mozilla.org/docs/Security/MixedContent";
 
-function test()
+
+let test = asyncTest(function* () {
+  yield pushPrefEnv();
+
+  let { browser } = yield loadTab(TEST_URI);
+
+  let hud = yield openConsole();
+
+  let results = yield waitForMessages({
+    webconsole: hud,
+    messages: [
+      {
+        name: "Logged blocking mixed active content",
+        text: "Blocked loading mixed active content \"http://example.com/\"",
+        category: CATEGORY_SECURITY,
+        severity: SEVERITY_ERROR,
+        objects: true,
+      },
+      {
+        name: "Logged blocking mixed passive content - image",
+        text: "Blocked loading mixed active content \"http://example.com/\"",
+        category: CATEGORY_SECURITY,
+        severity: SEVERITY_ERROR,
+        objects: true,
+      },
+    ],
+  });
+
+  testClickOpenNewTab(hud, results[0]);
+
+  let results2 = yield mixedContentOverrideTest2(hud, browser);
+
+  testClickOpenNewTab(hud, results2[0]);
+});
+
+function pushPrefEnv()
 {
-  SpecialPowers.pushPrefEnv({"set": [["security.mixed_content.block_active_content", true],
-                            ["security.mixed_content.block_display_content", true]]}, blockMixedContentTest1);
+  let deferred = promise.defer();
+  let options = {"set": [["security.mixed_content.block_active_content", true],
+                            ["security.mixed_content.block_display_content", true]]};
+  SpecialPowers.pushPrefEnv(options, deferred.resolve);
+  return deferred.promise;
 }
 
-function blockMixedContentTest1()
-{
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad(aEvent) {
-    browser.removeEventListener(aEvent.type, onLoad, true);
-    openConsole(null, function testSecurityErrorLogged (hud) {
-      waitForMessages({
-        webconsole: hud,
-        messages: [
-          {
-            name: "Logged blocking mixed active content",
-            text: "Blocked loading mixed active content \"http://example.com/\"",
-            category: CATEGORY_SECURITY,
-            severity: SEVERITY_ERROR,
-            objects: true,
-          },
-          {
-            name: "Logged blocking mixed passive content - image",
-            text: "Blocked loading mixed active content \"http://example.com/\"",
-            category: CATEGORY_SECURITY,
-            severity: SEVERITY_ERROR,
-            objects: true,
-          },
-        ],
-      }).then(([result]) => {
-        testClickOpenNewTab(hud, result);
-        // Call the second (MCB override) test.
-        mixedContentOverrideTest2(hud);
-      });
-    });
-  }, true);
-}
-
-function mixedContentOverrideTest2(hud)
+function mixedContentOverrideTest2(hud, browser)
 {
   var notification = PopupNotifications.getNotification("bad-content", browser);
   ok(notification, "Mixed Content Doorhanger did appear");
   notification.reshow();
   ok(PopupNotifications.panel.firstChild.isMixedContentBlocked, "OK: Mixed Content is being blocked");
   // Click on the doorhanger.
   PopupNotifications.panel.firstChild.disableMixedContentProtection();
   notification.remove();
 
-  waitForMessages({
+  return waitForMessages({
     webconsole: hud,
     messages: [
       {
         name: "Logged blocking mixed active content",
         text: "Loading mixed (insecure) active content on a secure"+
           " page \"http://example.com/\"",
         category: CATEGORY_SECURITY,
         severity: SEVERITY_WARNING,
@@ -79,19 +84,16 @@ function mixedContentOverrideTest2(hud)
         name: "Logged blocking mixed passive content - image",
         text: "Loading mixed (insecure) display content on a secure page"+
           " \"http://example.com/tests/image/test/mochitest/blue.png\"",
         category: CATEGORY_SECURITY,
         severity: SEVERITY_WARNING,
         objects: true,
       },
     ],
-  }).then(([result]) => {
-    testClickOpenNewTab(hud, result);
-    finishTest();
   });
 }
 
 function testClickOpenNewTab(hud, match) {
   let warningNode = match.clickableElements[0];
   ok(warningNode, "link element");
   ok(warningNode.classList.contains("learn-more-link"), "link class name");
 
@@ -104,10 +106,9 @@ function testClickOpenNewTab(hud, match)
       linkOpened = true;
     }
   }
 
   EventUtils.synthesizeMouse(warningNode, 2, 2, {},
                              warningNode.ownerDocument.defaultView);
   ok(linkOpened, "Clicking the Learn More Warning node opens the desired page");
   window.openUILinkIn = oldOpenUILinkIn;
-
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_1006027_message_timestamps_incorrect.js b/browser/devtools/webconsole/test/browser_webconsole_bug_1006027_message_timestamps_incorrect.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_1006027_message_timestamps_incorrect.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_1006027_message_timestamps_incorrect.js
@@ -1,12 +1,14 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+"use strict";
+
 function test() {
   Task.spawn(runner).then(finishTest);
 
   function* runner() {
     const {tab} = yield loadTab("data:text/html;charset=utf8,<title>Test for Bug 1006027");
 
     const target = TargetFactory.forTab(tab);
     const hud = yield openConsole(tab);
@@ -32,9 +34,8 @@ function test() {
          return Date.parse('T'+String.trim(value.textContent));
       });
 
     let minTimestamp = Math.min.apply(null, aTimestampMilliseconds);
     let maxTimestamp = Math.max.apply(null, aTimestampMilliseconds);
     ok(Math.abs(maxTimestamp - minTimestamp) < 1000, "console.log message timestamp spread < 1000ms confirmed");
   }
 }
-
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_1010953_cspro.js b/browser/devtools/webconsole/test/browser_webconsole_bug_1010953_cspro.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_1010953_cspro.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_1010953_cspro.js
@@ -9,51 +9,39 @@ a script that is allowed by the CSP head
 an image which is allowed by the CSPRO header but not by the CSP header.
 
 So we expect a warning (image has been blocked) and a report
  (script should not load and was reported)
 
 The expected console messages in the constants CSP_VIOLATION_MSG and CSP_REPORT_MSG are confirmed to be found in the console messages.
 */
 
+"use strict";
+
+const TEST_URI = "data:text/html;charset=utf8,Web Console CSP report only test (bug 1010953)";
 const TEST_VIOLATION = "http://example.com/browser/browser/devtools/webconsole/test/test_bug_1010953_cspro.html";
 const CSP_VIOLATION_MSG = 'Content Security Policy: The page\'s settings blocked the loading of a resource at http://some.example.com/test.png ("img-src http://example.com").';
 const CSP_REPORT_MSG = 'Content Security Policy: The page\'s settings observed the loading of a resource at http://some.example.com/test_bug_1010953_cspro.js ("script-src http://example.com"). A CSP report is being sent.';
 
+let test = asyncTest(function* () {
+  let { browser } = yield loadTab(TEST_URI);
 
-let hud = undefined;
+  let hud = yield openConsole();
 
-function test() {
-  addTab("data:text/html;charset=utf8,Web Console CSP report only test (bug 1010953)");
-  browser.addEventListener("load", function _onLoad() {
-    browser.removeEventListener("load", _onLoad, true);
-    openConsole(null, loadDocument);
-  }, true);
-}
+  hud.jsterm.clearOutput();
 
-function loadDocument(theHud){
-  hud = theHud;
-  hud.jsterm.clearOutput()
-  browser.addEventListener("load", onLoad, true);
+  let loaded = loadBrowser(browser);
   content.location = TEST_VIOLATION;
-}
+  yield loaded;
 
-function onLoad(aEvent) {
-  browser.removeEventListener("load", onLoad, true);
-  testViolationMessage();
-}
-
-function testViolationMessage(){
   let aOutputNode = hud.outputNode;
 
-  waitForSuccess({
-      name: "Confirmed that CSP and CSP-Report-Only log different messages to the console.",
-      validatorFn: function() {
-        console.log(hud.outputNode.textContent);
-        let success = false;
-        success = hud.outputNode.textContent.indexOf(CSP_VIOLATION_MSG) > -1 &&
-                  hud.outputNode.textContent.indexOf(CSP_REPORT_MSG) > -1;
-        return success;
-      },
-      successFn: finishTest,
-      failureFn: finishTest,
-    });
-}
+  yield waitForSuccess({
+    name: "Confirmed that CSP and CSP-Report-Only log different messages to the console.",
+    validator: function() {
+      console.log(hud.outputNode.textContent);
+      let success = false;
+      success = hud.outputNode.textContent.indexOf(CSP_VIOLATION_MSG) > -1 &&
+                hud.outputNode.textContent.indexOf(CSP_REPORT_MSG) > -1;
+      return success;
+    }
+  });
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_579412_input_focus.js b/browser/devtools/webconsole/test/browser_webconsole_bug_579412_input_focus.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_579412_input_focus.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_579412_input_focus.js
@@ -1,25 +1,19 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Tests that the input field is focused when the console is opened.
 
+"use strict";
+
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("DOMContentLoaded", testInputFocus, false);
-}
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
+  hud.jsterm.clearOutput();
 
-function testInputFocus() {
-  browser.removeEventListener("DOMContentLoaded", testInputFocus, false);
-
-  openConsole(null, function(hud) {
-    let inputNode = hud.jsterm.inputNode;
-    ok(inputNode.getAttribute("focused"), "input node is focused");
-
-    finishTest();
-  });
-}
-
+  let inputNode = hud.jsterm.inputNode;
+  ok(inputNode.getAttribute("focused"), "input node is focused");
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_580001_closing_after_completion.js b/browser/devtools/webconsole/test/browser_webconsole_bug_580001_closing_after_completion.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_580001_closing_after_completion.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_580001_closing_after_completion.js
@@ -3,42 +3,46 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Tests to ensure that errors don't appear when the console is closed while a
 // completion is being performed.
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, testClosingAfterCompletion);
-  }, true);
-}
 
-function testClosingAfterCompletion(hud) {
+let test = asyncTest(function* () {
+  let { browser } = yield loadTab(TEST_URI);
+
+  let hud = yield openConsole();
+  yield testClosingAfterCompletion(hud, browser);
+});
+
+function testClosingAfterCompletion(hud, browser) {
+  let deferred = promise.defer();
+
   let inputNode = hud.jsterm.inputNode;
 
   let errorWhileClosing = false;
   function errorListener(evt) {
     errorWhileClosing = true;
   }
 
   browser.addEventListener("error", errorListener, false);
 
   // Focus the inputNode and perform the keycombo to close the WebConsole.
   inputNode.focus();
 
   gDevTools.once("toolbox-destroyed", function() {
     browser.removeEventListener("error", errorListener, false);
     is(errorWhileClosing, false, "no error while closing the WebConsole");
-    finishTest();
+    deferred.resolve();
   });
 
   if (Services.appinfo.OS == "Darwin") {
     EventUtils.synthesizeKey("i", { accelKey: true, altKey: true });
   } else {
     EventUtils.synthesizeKey("i", { accelKey: true, shiftKey: true });
   }
+
+  return deferred.promise;
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_580454_timestamp_l10n.js b/browser/devtools/webconsole/test/browser_webconsole_bug_580454_timestamp_l10n.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_580454_timestamp_l10n.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_580454_timestamp_l10n.js
@@ -5,32 +5,26 @@
  *
  * Contributor(s):
  *  Patrick Walton <pcwalton@mozilla.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
 // Tests that appropriately-localized timestamps are printed.
 
+"use strict";
+
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("DOMContentLoaded", testTimestamp, false);
-
-  function testTimestamp()
-  {
-    browser.removeEventListener("DOMContentLoaded", testTimestamp, false);
-    const TEST_TIMESTAMP = 12345678;
-    let date = new Date(TEST_TIMESTAMP);
-    let localizedString = WCU_l10n.timestampString(TEST_TIMESTAMP);
-    isnot(localizedString.indexOf(date.getHours()), -1, "the localized " +
-          "timestamp contains the hours");
-    isnot(localizedString.indexOf(date.getMinutes()), -1, "the localized " +
-          "timestamp contains the minutes");
-    isnot(localizedString.indexOf(date.getSeconds()), -1, "the localized " +
-          "timestamp contains the seconds");
-    isnot(localizedString.indexOf(date.getMilliseconds()), -1, "the localized " +
-          "timestamp contains the milliseconds");
-    finishTest();
-  }
-}
-
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
+  const TEST_TIMESTAMP = 12345678;
+  let date = new Date(TEST_TIMESTAMP);
+  let localizedString = WCU_l10n.timestampString(TEST_TIMESTAMP);
+  isnot(localizedString.indexOf(date.getHours()), -1, "the localized " +
+        "timestamp contains the hours");
+  isnot(localizedString.indexOf(date.getMinutes()), -1, "the localized " +
+        "timestamp contains the minutes");
+  isnot(localizedString.indexOf(date.getSeconds()), -1, "the localized " +
+        "timestamp contains the seconds");
+  isnot(localizedString.indexOf(date.getMilliseconds()), -1, "the localized " +
+        "timestamp contains the milliseconds");
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_582201_duplicate_errors.js b/browser/devtools/webconsole/test/browser_webconsole_bug_582201_duplicate_errors.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_582201_duplicate_errors.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_582201_duplicate_errors.js
@@ -1,47 +1,44 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Tests that exceptions thrown by content don't show up twice in the Web
 // Console.
 
-const TEST_DUPLICATE_ERROR_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-duplicate-error.html";
+"use strict";
 
-function test() {
-  addTab("data:text/html;charset=utf8,hello world");
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
+const INIT_URI = "data:text/html;charset=utf8,hello world";
+const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-duplicate-error.html";
 
-  function consoleOpened(hud)
-  {
-    expectUncaughtException();
-    content.location = TEST_DUPLICATE_ERROR_URI;
+let test = asyncTest(function* () {
+  yield loadTab(INIT_URI);
 
-    waitForMessages({
-      webconsole: hud,
-      messages: [{
-        text: "fooDuplicateError1",
-        category: CATEGORY_JS,
-        severity: SEVERITY_ERROR,
-      },
-      {
-        text: "test-duplicate-error.html",
-        category: CATEGORY_NETWORK,
-        severity: SEVERITY_LOG,
-      }],
-    }).then(() => {
-      let text = hud.outputNode.textContent;
-      let error1pos = text.indexOf("fooDuplicateError1");
-      ok(error1pos > -1, "found fooDuplicateError1");
-      if (error1pos > -1) {
-        ok(text.indexOf("fooDuplicateError1", error1pos + 1) == -1,
-          "no duplicate for fooDuplicateError1");
-      }
+  let hud = yield openConsole();
 
-      finishTest();
-    });
+  expectUncaughtException();
+
+  content.location = TEST_URI;
+
+  yield waitForMessages({
+    webconsole: hud,
+    messages: [{
+      text: "fooDuplicateError1",
+      category: CATEGORY_JS,
+      severity: SEVERITY_ERROR,
+    },
+    {
+      text: "test-duplicate-error.html",
+      category: CATEGORY_NETWORK,
+      severity: SEVERITY_LOG,
+    }],
+  });
+
+  let text = hud.outputNode.textContent;
+  let error1pos = text.indexOf("fooDuplicateError1");
+  ok(error1pos > -1, "found fooDuplicateError1");
+  if (error1pos > -1) {
+    ok(text.indexOf("fooDuplicateError1", error1pos + 1) == -1,
+      "no duplicate for fooDuplicateError1");
   }
-}
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_583816_No_input_and_Tab_key_pressed.js b/browser/devtools/webconsole/test/browser_webconsole_bug_583816_No_input_and_Tab_key_pressed.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_583816_No_input_and_Tab_key_pressed.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_583816_No_input_and_Tab_key_pressed.js
@@ -1,22 +1,21 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/browser/test-console.html";
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, testCompletion);
-  }, true);
-}
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+
+  let hud = yield openConsole();
+  testCompletion(hud);
+});
 
 function testCompletion(hud) {
   var jsterm = hud.jsterm;
   var input = jsterm.inputNode;
 
   jsterm.setInputValue("");
   EventUtils.synthesizeKey("VK_TAB", {});
   is(jsterm.completeNode.value, "<- no result", "<- no result - matched");
@@ -24,12 +23,9 @@ function testCompletion(hud) {
   is(input.getAttribute("focused"), "true", "input is still focused");
 
   //Any thing which is not in property autocompleter
   jsterm.setInputValue("window.Bug583816");
   EventUtils.synthesizeKey("VK_TAB", {});
   is(jsterm.completeNode.value, "                <- no result", "completenode content - matched");
   is(input.value, "window.Bug583816", "inputnode content - matched");
   is(input.getAttribute("focused"), "true", "input is still focused");
-
-  jsterm = input = null;
-  finishTest();
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_585237_line_limit.js b/browser/devtools/webconsole/test/browser_webconsole_bug_585237_line_limit.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_585237_line_limit.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_585237_line_limit.js
@@ -8,99 +8,78 @@
  *  Mihai ucan <mihai.sucan@gmail.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
 // Tests that the Web Console limits the number of lines displayed according to
 // the user's preferences.
 
 const TEST_URI = "data:text/html;charset=utf8,test for bug 585237";
-let hud, testDriver;
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, function(aHud) {
-      hud = aHud;
-      testDriver = testGen();
-      testNext();
-    });
-  }, true);
-}
+let outputNode;
 
-function testNext() {
-  testDriver.next();
-}
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
 
-function testGen() {
+  let hud = yield openConsole();
+
   let console = content.console;
   outputNode = hud.outputNode;
 
   hud.jsterm.clearOutput();
 
   let prefBranch = Services.prefs.getBranch("devtools.hud.loglimit.");
   prefBranch.setIntPref("console", 20);
 
   for (let i = 0; i < 30; i++) {
     console.log("foo #" + i); // must change message to prevent repeats
   }
 
-  waitForMessages({
+  yield waitForMessages({
     webconsole: hud,
     messages: [{
       text: "foo #29",
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG,
     }],
-  }).then(testNext);
-
-  yield undefined;
+  });
 
   is(countMessageNodes(), 20, "there are 20 message nodes in the output " +
      "when the log limit is set to 20");
 
   console.log("bar bug585237");
 
-  waitForMessages({
+  yield waitForMessages({
     webconsole: hud,
     messages: [{
       text: "bar bug585237",
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG,
     }],
-  }).then(testNext);
-
-  yield undefined;
+  });
 
   is(countMessageNodes(), 20, "there are still 20 message nodes in the " +
      "output when adding one more");
 
   prefBranch.setIntPref("console", 30);
   for (let i = 0; i < 20; i++) {
     console.log("boo #" + i); // must change message to prevent repeats
   }
 
-  waitForMessages({
+  yield waitForMessages({
     webconsole: hud,
     messages: [{
       text: "boo #19",
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG,
     }],
-  }).then(testNext);
-
-  yield undefined;
+  });
 
   is(countMessageNodes(), 30, "there are 30 message nodes in the output " +
      "when the log limit is set to 30");
 
   prefBranch.clearUserPref("console");
-  hud = testDriver = prefBranch = console = outputNode = null;
-  finishTest();
-
-  yield undefined;
-}
+});
 
 function countMessageNodes() {
   return outputNode.querySelectorAll(".message").length;
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_585956_console_trace.js b/browser/devtools/webconsole/test/browser_webconsole_bug_585956_console_trace.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_585956_console_trace.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_585956_console_trace.js
@@ -1,13 +1,15 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+"use strict";
+
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-bug-585956-console-trace.html";
 
 function test() {
   Task.spawn(runner).then(finishTest);
 
   function* runner() {
     let {tab} = yield loadTab("data:text/html;charset=utf8,<p>hello");
     let hud = yield openConsole(tab);
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js b/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_keys.js
@@ -1,36 +1,45 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 const TEST_URI = "data:text/html;charset=utf-8,<p>bug 585991 - autocomplete popup keyboard usage test";
 let HUD, popup, jsterm, inputNode, completeNode;
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
+
+  yield consoleOpened(hud);
+  yield popupHideAfterTab();
+  yield testReturnKey();
+  yield dontShowArrayNumbers();
+  yield testReturnWithNoSelection();
+  yield popupHideAfterReturnWithNoSelection();
+  yield testCompletionInText();
+  yield popupHideAfterCompletionInText();
+});
 
 function consoleOpened(aHud) {
+  let deferred = promise.defer();
   HUD = aHud;
   info("web console opened");
 
   jsterm = HUD.jsterm;
 
   jsterm.execute("window.foobarBug585991={" +
     "'item0': 'value0'," +
     "'item1': 'value1'," +
     "'item2': 'value2'," +
     "'item3': 'value3'" +
   "}");
+  jsterm.execute("window.testBug873250a = 'hello world';"
+    + "window.testBug873250b = 'hello world 2';");
   popup = jsterm.autocompletePopup;
   completeNode = jsterm.completeNode;
   inputNode = jsterm.inputNode;
 
   ok(!popup.isOpen, "popup is not open");
 
   popup._panel.addEventListener("popupshown", function onShown() {
     popup._panel.removeEventListener("popupshown", onShown, false);
@@ -105,30 +114,35 @@ function consoleOpened(aHud) {
 
     EventUtils.synthesizeKey("VK_END", {});
     is(popup.selectedIndex, 17, "index is last after End");
 
     EventUtils.synthesizeKey("VK_HOME", {});
     is(popup.selectedIndex, 0, "index is first after Home");
 
     info("press Tab and wait for popup to hide");
-    popup._panel.addEventListener("popuphidden", popupHideAfterTab, false);
+    popup._panel.addEventListener("popuphidden", function popupHidden() {
+      popup._panel.removeEventListener("popuphidden", popupHidden, false);
+      deferred.resolve();
+    }, false);
     EventUtils.synthesizeKey("VK_TAB", {});
   }, false);
 
   info("wait for completion: window.foobarBug585991.");
   jsterm.setInputValue("window.foobarBug585991");
   EventUtils.synthesizeKey(".", {});
+
+  return deferred.promise;
 }
 
 function popupHideAfterTab()
 {
+  let deferred = promise.defer();
+
   // At this point the completion suggestion should be accepted.
-  popup._panel.removeEventListener("popuphidden", popupHideAfterTab, false);
-
   ok(!popup.isOpen, "popup is not open");
 
   is(inputNode.value, "window.foobarBug585991.watch",
      "completion was successful after VK_TAB");
 
   ok(!completeNode.value, "completeNode is empty");
 
   popup._panel.addEventListener("popupshown", function onShown() {
@@ -153,34 +167,38 @@ function popupHideAfterTab()
 
       ok(!popup.isOpen, "popup is not open after VK_ESCAPE");
 
       is(inputNode.value, "window.foobarBug585991.",
          "completion was cancelled");
 
       ok(!completeNode.value, "completeNode is empty");
 
-      executeSoon(testReturnKey);
+      deferred.resolve();
     }, false);
 
     info("press Escape to close the popup");
     executeSoon(function() {
       EventUtils.synthesizeKey("VK_ESCAPE", {});
     });
   }, false);
 
   info("wait for completion: window.foobarBug585991.");
   executeSoon(function() {
     jsterm.setInputValue("window.foobarBug585991");
     EventUtils.synthesizeKey(".", {});
   });
+
+  return deferred.promise;
 }
 
 function testReturnKey()
 {
+  let deferred = promise.defer();
+
   popup._panel.addEventListener("popupshown", function onShown() {
     popup._panel.removeEventListener("popupshown", onShown, false);
 
     ok(popup.isOpen, "popup is open");
 
     is(popup.itemCount, 18, "popup.itemCount is correct");
 
     is(popup.selectedIndex, 17, "First index from bottom is selected");
@@ -205,143 +223,152 @@ function testReturnKey()
 
       ok(!popup.isOpen, "popup is not open after VK_RETURN");
 
       is(inputNode.value, "window.foobarBug585991.valueOf",
          "completion was successful after VK_RETURN");
 
       ok(!completeNode.value, "completeNode is empty");
 
-      dontShowArrayNumbers();
+      deferred.resolve();
     }, false);
 
     info("press Return to accept suggestion. wait for popup to hide");
 
     executeSoon(() => EventUtils.synthesizeKey("VK_RETURN", {}));
   }, false);
 
   info("wait for completion suggestions: window.foobarBug585991.");
 
   executeSoon(function() {
     jsterm.setInputValue("window.foobarBug58599");
     EventUtils.synthesizeKey("1", {});
     EventUtils.synthesizeKey(".", {});
   });
+
+  return deferred.promise;
 }
 
 function dontShowArrayNumbers()
 {
+  let deferred = promise.defer();
+
   info("dontShowArrayNumbers");
   content.wrappedJSObject.foobarBug585991 = ["Sherlock Holmes"];
 
   let jsterm = HUD.jsterm;
   let popup = jsterm.autocompletePopup;
   let completeNode = jsterm.completeNode;
 
   popup._panel.addEventListener("popupshown", function onShown() {
     popup._panel.removeEventListener("popupshown", onShown, false);
 
     let sameItems = popup.getItems().map(function(e) {return e.label;});
     ok(!sameItems.some(function(prop, index) { prop === "0"; }),
        "Completing on an array doesn't show numbers.");
 
-    popup._panel.addEventListener("popuphidden", testReturnWithNoSelection, false);
+    popup._panel.addEventListener("popuphidden", function popupHidden() {
+      popup._panel.removeEventListener("popuphidden", popupHidden, false);
+      deferred.resolve();
+    }, false);
 
     info("wait for popup to hide");
     executeSoon(() => EventUtils.synthesizeKey("VK_ESCAPE", {}));
   }, false);
 
   info("wait for popup to show");
   executeSoon(() => {
     jsterm.setInputValue("window.foobarBug585991");
     EventUtils.synthesizeKey(".", {});
   });
+
+  return deferred.promise;
 }
 
 function testReturnWithNoSelection()
 {
-  popup._panel.removeEventListener("popuphidden", testReturnWithNoSelection, false);
+  let deferred = promise.defer();
 
   info("test pressing return with open popup, but no selection, see bug 873250");
-  content.wrappedJSObject.testBug873250a = "hello world";
-  content.wrappedJSObject.testBug873250b = "hello world 2";
 
   popup._panel.addEventListener("popupshown", function onShown() {
     popup._panel.removeEventListener("popupshown", onShown);
 
     ok(popup.isOpen, "popup is open");
     is(popup.itemCount, 2, "popup.itemCount is correct");
     isnot(popup.selectedIndex, -1, "popup.selectedIndex is correct");
 
     info("press Return and wait for popup to hide");
-    popup._panel.addEventListener("popuphidden", popupHideAfterReturnWithNoSelection);
+    popup._panel.addEventListener("popuphidden", function popupHidden() {
+      popup._panel.removeEventListener("popuphidden", popupHidden);
+      deferred.resolve();
+    });
     executeSoon(() => EventUtils.synthesizeKey("VK_RETURN", {}));
   });
 
   executeSoon(() => {
     info("wait for popup to show");
     jsterm.setInputValue("window.testBu");
     EventUtils.synthesizeKey("g", {});
   });
+
+  return deferred.promise;
 }
 
 function popupHideAfterReturnWithNoSelection()
 {
-  popup._panel.removeEventListener("popuphidden", popupHideAfterReturnWithNoSelection);
-
   ok(!popup.isOpen, "popup is not open after VK_RETURN");
 
   is(inputNode.value, "", "inputNode is empty after VK_RETURN");
   is(completeNode.value, "", "completeNode is empty");
   is(jsterm.history[jsterm.history.length-1], "window.testBug",
      "jsterm history is correct");
 
-  executeSoon(testCompletionInText);
+  return promise.resolve();
 }
 
 function testCompletionInText()
 {
   info("test that completion works inside text, see bug 812618");
 
+  let deferred = promise.defer();
+
   popup._panel.addEventListener("popupshown", function onShown() {
     popup._panel.removeEventListener("popupshown", onShown);
 
     ok(popup.isOpen, "popup is open");
     is(popup.itemCount, 2, "popup.itemCount is correct");
 
     EventUtils.synthesizeKey("VK_DOWN", {});
     is(popup.selectedIndex, 0, "popup.selectedIndex is correct");
     ok(!completeNode.value, "completeNode.value is empty");
 
     let items = popup.getItems().reverse().map(e => e.label);
     let sameItems = items.every((prop, index) =>
       ["testBug873250a", "testBug873250b"][index] === prop);
     ok(sameItems, "getItems returns the items we expect");
 
     info("press Tab and wait for popup to hide");
-    popup._panel.addEventListener("popuphidden", popupHideAfterCompletionInText);
+    popup._panel.addEventListener("popuphidden", function popupHidden() {
+      popup._panel.removeEventListener("popuphidden", popupHidden);
+      deferred.resolve();
+    });
     EventUtils.synthesizeKey("VK_TAB", {});
   });
 
   jsterm.setInputValue("dump(window.testBu)");
   inputNode.selectionStart = inputNode.selectionEnd = 18;
   EventUtils.synthesizeKey("g", {});
+  return deferred.promise;
 }
 
 function popupHideAfterCompletionInText()
 {
   // At this point the completion suggestion should be accepted.
-  popup._panel.removeEventListener("popuphidden", popupHideAfterCompletionInText);
-
   ok(!popup.isOpen, "popup is not open");
   is(inputNode.value, "dump(window.testBug873250b)",
      "completion was successful after VK_TAB");
   is(inputNode.selectionStart, 26, "cursor location is correct");
   is(inputNode.selectionStart, inputNode.selectionEnd, "cursor location (confirmed)");
   ok(!completeNode.value, "completeNode is empty");
 
-  finishUp();
+  return promise.resolve();
 }
-
-function finishUp() {
-  HUD = popup = jsterm = inputNode = completeNode = null;
-  finishTest();
-}
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_popup.js b/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_popup.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_popup.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_585991_autocomplete_popup.js
@@ -1,24 +1,27 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 const TEST_URI = "data:text/html;charset=utf-8,<p>bug 585991 - autocomplete popup test";
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
+"use strict";
+
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
+
+  yield consoleOpened(hud);
+});
 
 function consoleOpened(HUD) {
+  let deferred = promise.defer();
+
   let items = [
     {label: "item0", value: "value0"},
     {label: "item1", value: "value1"},
     {label: "item2", value: "value2"},
   ];
 
   let popup = HUD.jsterm.autocompletePopup;
 
@@ -101,14 +104,16 @@ function consoleOpened(HUD) {
     is(popup.itemCount, items.length - 1, "item2 removed");
 
     popup.clearItems();
     is(popup.itemCount, 0, "items cleared");
     ok(!input.hasAttribute("aria-activedescendant"),
        "no aria-activedescendant");
 
     popup.hidePopup();
-    finishTest();
+    deferred.resolve();
   }, false);
 
   popup.openPopup();
+
+  return deferred.promise;
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_586388_select_all.js b/browser/devtools/webconsole/test/browser_webconsole_bug_586388_select_all.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_586388_select_all.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_586388_select_all.js
@@ -5,88 +5,87 @@
  *
  * Contributor(s):
  *  Patrick Walton <pcwalton@mozilla.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
 const TEST_URI = "http://example.com/";
 
-function test() {
-  let hud;
+"use strict";
 
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, testSelectionWhenMovingBetweenBoxes);
-  }, true);
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
 
-  function testSelectionWhenMovingBetweenBoxes(aHud) {
-    hud = aHud;
-    let jsterm = hud.jsterm;
+  let hud = yield openConsole();
+  yield testSelectionWhenMovingBetweenBoxes(hud);
+  performTestsAfterOutput(hud);
+})
 
-    // Fill the console with some output.
-    jsterm.clearOutput();
-    jsterm.execute("1 + 2");
-    jsterm.execute("3 + 4");
-    jsterm.execute("5 + 6");
+function testSelectionWhenMovingBetweenBoxes(aHud) {
+  let hud = aHud;
+  let jsterm = hud.jsterm;
 
-    waitForMessages({
-      webconsole: hud,
-      messages: [{
-        text: "3",
-        category: CATEGORY_OUTPUT,
-      },
-      {
-        text: "7",
-        category: CATEGORY_OUTPUT,
-      },
-      {
-        text: "11",
-        category: CATEGORY_OUTPUT,
-      }],
-    }).then(performTestsAfterOutput);
-  }
+  // Fill the console with some output.
+  jsterm.clearOutput();
+  jsterm.execute("1 + 2");
+  jsterm.execute("3 + 4");
+  jsterm.execute("5 + 6");
 
-  function performTestsAfterOutput() {
-    let outputNode = hud.outputNode;
+  return waitForMessages({
+    webconsole: hud,
+    messages: [{
+      text: "3",
+      category: CATEGORY_OUTPUT,
+    },
+    {
+      text: "7",
+      category: CATEGORY_OUTPUT,
+    },
+    {
+      text: "11",
+      category: CATEGORY_OUTPUT,
+    }],
+  });
+}
 
-    ok(outputNode.childNodes.length >= 3, "the output node has children after " +
-       "executing some JavaScript");
+function performTestsAfterOutput(aHud) {
+  let hud = aHud;
+  let outputNode = hud.outputNode;
 
-    // Test that the global Firefox "Select All" functionality (e.g. Edit >
-    // Select All) works properly in the Web Console.
-    let commandController = hud.ui._commandController;
-    ok(commandController != null, "the window has a command controller object");
+  ok(outputNode.childNodes.length >= 3, "the output node has children after " +
+     "executing some JavaScript");
 
-    commandController.selectAll();
+  // Test that the global Firefox "Select All" functionality (e.g. Edit >
+  // Select All) works properly in the Web Console.
+  let commandController = hud.ui._commandController;
+  ok(commandController != null, "the window has a command controller object");
 
-    let selectedCount = hud.ui.output.getSelectedMessages().length;
-    is(selectedCount, outputNode.childNodes.length,
-       "all console messages are selected after performing a regular browser " +
-       "select-all operation");
+  commandController.selectAll();
 
-    hud.iframeWindow.getSelection().removeAllRanges();
+  let selectedCount = hud.ui.output.getSelectedMessages().length;
+  is(selectedCount, outputNode.childNodes.length,
+     "all console messages are selected after performing a regular browser " +
+     "select-all operation");
 
-    // Test the context menu "Select All" (which has a different code path) works
-    // properly as well.
-    let contextMenuId = outputNode.parentNode.getAttribute("context");
-    let contextMenu = hud.ui.document.getElementById(contextMenuId);
-    ok(contextMenu != null, "the output node has a context menu");
+  hud.iframeWindow.getSelection().removeAllRanges();
 
-    let selectAllItem = contextMenu.querySelector("*[command='cmd_selectAll']");
-    ok(selectAllItem != null,
-       "the context menu on the output node has a \"Select All\" item");
+  // Test the context menu "Select All" (which has a different code path) works
+  // properly as well.
+  let contextMenuId = outputNode.parentNode.getAttribute("context");
+  let contextMenu = hud.ui.document.getElementById(contextMenuId);
+  ok(contextMenu != null, "the output node has a context menu");
 
-    outputNode.focus();
+  let selectAllItem = contextMenu.querySelector("*[command='cmd_selectAll']");
+  ok(selectAllItem != null,
+     "the context menu on the output node has a \"Select All\" item");
 
-    selectAllItem.doCommand();
+  outputNode.focus();
 
-    let selectedCount = hud.ui.output.getSelectedMessages().length;
-    is(selectedCount, outputNode.childNodes.length,
-       "all console messages are selected after performing a select-all " +
-       "operation from the context menu");
+  selectAllItem.doCommand();
 
-    hud.iframeWindow.getSelection().removeAllRanges();
+  let selectedCount = hud.ui.output.getSelectedMessages().length;
+  is(selectedCount, outputNode.childNodes.length,
+     "all console messages are selected after performing a select-all " +
+     "operation from the context menu");
 
-    finishTest();
-  }
+  hud.iframeWindow.getSelection().removeAllRanges();
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_587617_output_copy.js b/browser/devtools/webconsole/test/browser_webconsole_bug_587617_output_copy.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_587617_output_copy.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_587617_output_copy.js
@@ -7,27 +7,31 @@
  *  Patrick Walton <pcwalton@mozilla.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
 let HUD, outputNode;
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
+"use strict";
+
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+
+  let hud = yield openConsole();
+  yield consoleOpened(hud);
+  yield testContextMenuCopy();
+});
 
 function consoleOpened(aHud) {
   HUD = aHud;
 
+  let deferred = promise.defer();
+
   // See bugs 574036, 586386 and 587617.
   outputNode = HUD.outputNode;
 
   HUD.jsterm.clearOutput();
 
   let controller = top.document.commandDispatcher.
                    getControllerForCommand("cmd_copy");
   is(controller.isCommandEnabled("cmd_copy"), false, "cmd_copy is disabled");
@@ -52,32 +56,37 @@ function consoleOpened(aHud) {
     is(controller.isCommandEnabled("cmd_copy"), true, "cmd_copy is enabled");
 
     let selection = HUD.iframeWindow.getSelection() + "";
     isnot(selection.indexOf("bug587617"), -1,
           "selection text includes 'bug587617'");
 
     waitForClipboard((str) => { return selection.trim() == str.trim(); },
       () => { goDoCommand("cmd_copy") },
-      testContextMenuCopy, testContextMenuCopy);
+      deferred.resolve, deferred.resolve);
   });
+  return deferred.promise;
 }
 
 // Test that the context menu "Copy" (which has a different code path) works
 // properly as well.
 function testContextMenuCopy() {
+  let deferred = promise.defer();
+
   let contextMenuId = outputNode.parentNode.getAttribute("context");
   let contextMenu = HUD.ui.document.getElementById(contextMenuId);
   ok(contextMenu, "the output node has a context menu");
 
   let copyItem = contextMenu.querySelector("*[command='cmd_copy']");
   ok(copyItem, "the context menu on the output node has a \"Copy\" item");
 
   let selection = HUD.iframeWindow.getSelection() + "";
 
   copyItem.doCommand();
 
   waitForClipboard((str) => { return selection.trim() == str.trim(); },
     () => { goDoCommand("cmd_copy") },
-    finishTest, finishTest);
+    deferred.resolve, deferred.resolve);
   HUD = outputNode = null;
+
+  return deferred.promise;
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_588342_document_focus.js b/browser/devtools/webconsole/test/browser_webconsole_bug_588342_document_focus.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_588342_document_focus.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_588342_document_focus.js
@@ -4,36 +4,34 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  *
  * Contributor(s):
  *  Mihai ucan <mihai.sucan@gmail.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
 const TEST_URI = "data:text/html;charset=utf-8,Web Console test for bug 588342";
-let fm;
 
-function test() {
-  fm = Cc["@mozilla.org/focus-manager;1"].getService(Ci.nsIFocusManager);
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
+let fm = Cc["@mozilla.org/focus-manager;1"].getService(Ci.nsIFocusManager);
+
+"use strict";
+
+let test = asyncTest(function* () {
+  let { browser } = yield loadTab(TEST_URI);
+
+  let hud = yield openConsole();
+  yield consoleOpened(hud);
+
+  is(fm.focusedWindow, browser.contentWindow,
+     "content document has focus");
+});
 
 function consoleOpened(hud) {
+  let deferred = promise.defer();
   waitForFocus(function() {
     is(hud.jsterm.inputNode.getAttribute("focused"), "true",
        "jsterm input is focused on web console open");
     isnot(fm.focusedWindow, content, "content document has no focus");
-    closeConsole(null, consoleClosed);
+    closeConsole(null).then(deferred.resolve);
   }, hud.iframeWindow);
+
+  return deferred.promise;
 }
-
-function consoleClosed() {
-  is(fm.focusedWindow, browser.contentWindow,
-     "content document has focus");
-
-  fm = null;
-  finishTest();
-}
-
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_588730_text_node_insertion.js b/browser/devtools/webconsole/test/browser_webconsole_bug_588730_text_node_insertion.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_588730_text_node_insertion.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_588730_text_node_insertion.js
@@ -2,27 +2,30 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Tests that adding text to one of the output labels doesn't cause errors.
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, testTextNodeInsertion);
-  }, true);
-}
+"use strict";
+
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+
+  let hud = yield openConsole();
+
+  yield testTextNodeInsertion(hud);
+});
 
 // Test for bug 588730: Adding a text node to an existing label element causes
 // warnings
 function testTextNodeInsertion(hud) {
+  let deferred = promise.defer();
   let outputNode = hud.outputNode;
 
   let label = document.createElementNS(
     "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul", "label");
   outputNode.appendChild(label);
 
   let error = false;
   let listener = {
@@ -38,12 +41,13 @@ function testTextNodeInsertion(hud) {
 
   // This shouldn't fail.
   label.appendChild(document.createTextNode("foo"));
 
   executeSoon(function() {
     Services.console.unregisterListener(listener);
     ok(!error, "no error when adding text nodes as children of labels");
 
-    finishTest();
+    return deferred.resolve();
   });
+  return deferred.promise;
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_588967_input_expansion.js b/browser/devtools/webconsole/test/browser_webconsole_bug_588967_input_expansion.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_588967_input_expansion.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_588967_input_expansion.js
@@ -1,22 +1,25 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, testInputExpansion);
-  }, true);
-}
+"use strict";
+
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+
+  let hud = yield openConsole();
+
+  testInputExpansion(hud);
+});
+
 
 function testInputExpansion(hud) {
   let input = hud.jsterm.inputNode;
 
   input.focus();
 
   is(input.getAttribute("multiline"), "true", "multiline is enabled");
 
@@ -33,12 +36,10 @@ function testInputExpansion(hud) {
   ok(input.clientHeight > ordinaryHeight, "the input expanded");
 
   // Test if the inputNode shrinks again.
   input.value = "";
   EventUtils.synthesizeKey("d", {});
   is(input.clientHeight, ordinaryHeight, "the input's height is normal again");
 
   input = length = null;
-
-  finishTest();
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_589162_css_filter.js b/browser/devtools/webconsole/test/browser_webconsole_bug_589162_css_filter.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_589162_css_filter.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_589162_css_filter.js
@@ -4,16 +4,18 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  *
  * Contributor(s):
  *  Mihai ucan <mihai.sucan@gmail.com>
  *  Patrick Walton <pcwalton@mozilla.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
+"use strict"
+
 const TEST_URI = "data:text/html;charset=utf-8,<div style='font-size:3em;" +
   "foobarCssParser:baz'>test CSS parser filter</div>";
 
 /**
  * Unit test for bug 589162:
  * CSS filtering on the console does not work
  */
 function test() {
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_592442_closing_brackets.js b/browser/devtools/webconsole/test/browser_webconsole_bug_592442_closing_brackets.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_592442_closing_brackets.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_592442_closing_brackets.js
@@ -8,34 +8,30 @@
  *  Patrick Walton <pcwalton@mozilla.com>
  *  Mihai ucan <mihai.sucan@gmail.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
 // Tests that, when the user types an extraneous closing bracket, no error
 // appears.
 
-function test() {
-  addTab("data:text/html;charset=utf-8,test for bug 592442");
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, testExtraneousClosingBrackets);
-  }, true);
-}
+"use strict";
 
-function testExtraneousClosingBrackets(hud) {
+const TEST_URI = "data:text/html;charset=utf-8,test for bug 592442";
+
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
+  hud.jsterm.clearOutput();
   let jsterm = hud.jsterm;
 
   jsterm.setInputValue("document.getElementById)");
 
   let error = false;
   try {
     jsterm.complete(jsterm.COMPLETE_HINT_ONLY);
   }
   catch (ex) {
     error = true;
   }
 
   ok(!error, "no error was thrown when an extraneous bracket was inserted");
-
-  finishTest();
-}
-
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_594477_clickable_output.js b/browser/devtools/webconsole/test/browser_webconsole_bug_594477_clickable_output.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_594477_clickable_output.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_594477_clickable_output.js
@@ -5,77 +5,91 @@
  *
  * Contributor(s):
  *  Mihai ucan <mihai.sucan@gmail.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 let HUD;
+let outputItem;
+let outputNode;
 
-let outputItem;
+"use strict";
 
-function consoleOpened(aHud) {
-  HUD = aHud;
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
 
+  HUD = yield openConsole();
   outputNode = HUD.outputNode;
 
-  browser.addEventListener("load", tabLoad2, true);
+  // reload the tab
+  BrowserReload();
+  yield loadBrowser(gBrowser.selectedBrowser);
 
-  // Reload so we get some output in the console.
-  browser.contentWindow.location.reload();
-}
+  let event = yield clickEvents();
+  yield testClickAgain(event);
+  yield networkPanelHidden();
+});
 
-function tabLoad2(aEvent) {
-  browser.removeEventListener(aEvent.type, tabLoad2, true);
+function clickEvents() {
+  let deferred = promise.defer();
 
   waitForMessages({
     webconsole: HUD,
     messages: [{
       text: "test-console.html",
       category: CATEGORY_NETWORK,
       severity: SEVERITY_LOG,
     }],
   }).then(([result]) => {
     let msg = [...result.matched][0];
     outputItem = msg.querySelector(".message-body .url");
     ok(outputItem, "found a network message");
-    document.addEventListener("popupshown", networkPanelShown, false);
+    document.addEventListener("popupshown", function onPanelShown(event) {
+      document.removeEventListener("popupshown", onPanelShown, false);
+      deferred.resolve(event);
+    }, false);
 
     // Send the mousedown and click events such that the network panel opens.
     EventUtils.sendMouseEvent({type: "mousedown"}, outputItem);
     EventUtils.sendMouseEvent({type: "click"}, outputItem);
   });
+
+  return deferred.promise;
 }
 
-function networkPanelShown(aEvent) {
-  document.removeEventListener(aEvent.type, networkPanelShown, false);
+function testClickAgain(event) {
+  info("testClickAgain");
 
-  info("networkPanelShown");
+  let deferred = promise.defer();
 
   document.addEventListener("popupshown", networkPanelShowFailure, false);
 
   // The network panel should not open for the second time.
   EventUtils.sendMouseEvent({type: "mousedown"}, outputItem);
   EventUtils.sendMouseEvent({type: "click"}, outputItem);
 
   executeSoon(function() {
-    aEvent.target.addEventListener("popuphidden", networkPanelHidden, false);
-    aEvent.target.hidePopup();
+    document.addEventListener("popuphidden", function onHidden() {
+      document.removeEventListener("popuphidden", onHidden, false);
+      deferred.resolve();
+    }, false);
+    event.target.hidePopup();
   });
+
+  return deferred.promise;
 }
 
-function networkPanelShowFailure(aEvent) {
-  document.removeEventListener(aEvent.type, networkPanelShowFailure, false);
-
+function networkPanelShowFailure() {
   ok(false, "the network panel should not show");
 }
 
-function networkPanelHidden(aEvent) {
-  this.removeEventListener(aEvent.type, networkPanelHidden, false);
+function networkPanelHidden() {
+  let deferred = promise.defer();
 
   info("networkPanelHidden");
 
   // The network panel should not show because this is a mouse event that starts
   // in a position and ends in another.
   EventUtils.sendMouseEvent({type: "mousedown", clientX: 3, clientY: 4},
     outputItem);
   EventUtils.sendMouseEvent({type: "click", clientX: 5, clientY: 6},
@@ -96,36 +110,20 @@ function networkPanelHidden(aEvent) {
   executeSoon(function() {
     document.removeEventListener("popupshown", networkPanelShowFailure, false);
 
     // Done with the network output. Now test the jsterm output and the property
     // panel.
     HUD.jsterm.execute("document", (msg) => {
       info("jsterm execute 'document' callback");
 
-      HUD.jsterm.once("variablesview-open", onVariablesViewOpen);
+      HUD.jsterm.once("variablesview-open", deferred.resolve);
       let outputItem = msg.querySelector(".message-body a");
       ok(outputItem, "jsterm output message found");
 
       // Send the mousedown and click events such that the property panel opens.
       EventUtils.sendMouseEvent({type: "mousedown"}, outputItem);
       EventUtils.sendMouseEvent({type: "click"}, outputItem);
     });
   });
+
+  return deferred.promise;
 }
-
-function onVariablesViewOpen() {
-  info("onVariablesViewOpen");
-
-  executeSoon(function() {
-    HUD = outputItem = null;
-    executeSoon(finishTest);
-  });
-}
-
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
-
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_594497_history_arrow_keys.js b/browser/devtools/webconsole/test/browser_webconsole_bug_594497_history_arrow_keys.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_594497_history_arrow_keys.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_594497_history_arrow_keys.js
@@ -5,37 +5,43 @@
  *
  * Contributor(s):
  *  Mihai ucan <mihai.sucan@gmail.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
 let inputNode, values;
 
-function tabLoad(aEvent) {
-  browser.removeEventListener(aEvent.type, tabLoad, true);
+let TEST_URI = "data:text/html;charset=utf-8,Web Console test for bug 594497 and bug 619598";
+"use strict";
 
-  openConsole(null, function(HUD) {
-    inputNode = HUD.jsterm.inputNode;
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
 
-    inputNode.focus();
+  let hud = yield openConsole();
 
-    ok(!inputNode.value, "inputNode.value is empty");
+  setup(hud);
+  performTests();
+});
 
-    values = ["document", "window", "document.body"];
-    values.push(values.join(";\n"), "document.location");
+function setup(HUD) {
+  inputNode = HUD.jsterm.inputNode;
 
-    // Execute each of the values;
-    for (let i = 0; i < values.length; i++) {
-      HUD.jsterm.setInputValue(values[i]);
-      HUD.jsterm.execute();
-    }
+  inputNode.focus();
 
-    performTests();
-  });
+  ok(!inputNode.value, "inputNode.value is empty");
+
+  values = ["document", "window", "document.body"];
+  values.push(values.join(";\n"), "document.location");
+
+  // Execute each of the values;
+  for (let i = 0; i < values.length; i++) {
+    HUD.jsterm.setInputValue(values[i]);
+    HUD.jsterm.execute();
+  }
 }
 
 function performTests() {
   EventUtils.synthesizeKey("VK_UP", {});
 
   is(inputNode.value, values[4],
      "VK_UP: inputNode.value #4 is correct");
 
@@ -140,18 +146,9 @@ function performTests() {
 
   is(inputNode.value, values[4],
      "VK_DOWN: inputNode.value #4 is correct");
 
   EventUtils.synthesizeKey("VK_DOWN", {});
 
   ok(!inputNode.value,
      "VK_DOWN: inputNode.value is empty");
-
-  inputNode = values = null;
-  executeSoon(finishTest);
 }
-
-function test() {
-  addTab("data:text/html;charset=utf-8,Web Console test for bug 594497 and bug 619598");
-  browser.addEventListener("load", tabLoad, true);
-}
-
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_595223_file_uri.js b/browser/devtools/webconsole/test/browser_webconsole_bug_595223_file_uri.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_595223_file_uri.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_595223_file_uri.js
@@ -1,19 +1,48 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+"use strict";
+
+const PREF = "devtools.webconsole.persistlog";
 const TEST_FILE = "test-network.html";
+const TEST_URI = "data:text/html;charset=utf8,<p>test file URI";
 
-function tabReload(aEvent) {
-  browser.removeEventListener(aEvent.type, tabReload, true);
+let hud;
 
-  waitForMessages({
+let test = asyncTest(function* () {
+  Services.prefs.setBoolPref(PREF, true);
+
+  let jar = getJar(getRootDirectory(gTestPath));
+  let dir = jar ?
+            extractJarToTmp(jar) :
+            getChromeDir(getResolvedURI(gTestPath));
+
+  dir.append(TEST_FILE);
+  let uri = Services.io.newFileURI(dir);
+
+  let { browser } = yield loadTab(TEST_URI);
+
+  hud = yield openConsole();
+  hud.jsterm.clearOutput();
+
+  let loaded = loadBrowser(browser);
+  content.location = uri.spec;
+  yield loaded;
+
+  yield testMessages();
+
+  Services.prefs.clearUserPref(PREF);
+});
+
+function testMessages() {
+  return waitForMessages({
     webconsole: hud,
     messages: [{
       text: "running network console logging tests",
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG,
     },
     {
       text: "test-network.html",
@@ -25,35 +54,10 @@ function tabReload(aEvent) {
       category: CATEGORY_NETWORK,
       severity: SEVERITY_LOG,
     },
     {
       text: "testscript.js",
       category: CATEGORY_NETWORK,
       severity: SEVERITY_LOG,
     }],
-  }).then(finishTest);
+  })
 }
-
-function test() {
-  let jar = getJar(getRootDirectory(gTestPath));
-  let dir = jar ?
-            extractJarToTmp(jar) :
-            getChromeDir(getResolvedURI(gTestPath));
-  dir.append(TEST_FILE);
-
-  let uri = Services.io.newFileURI(dir);
-
-  const PREF = "devtools.webconsole.persistlog";
-  Services.prefs.setBoolPref(PREF, true);
-  registerCleanupFunction(() => Services.prefs.clearUserPref(PREF));
-
-  addTab("data:text/html;charset=utf8,<p>test file URI");
-  browser.addEventListener("load", function tabLoad() {
-    browser.removeEventListener("load", tabLoad, true);
-    openConsole(null, function(aHud) {
-      hud = aHud;
-      hud.jsterm.clearOutput();
-      browser.addEventListener("load", tabReload, true);
-      content.location = uri.spec;
-    });
-  }, true);
-}
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_597460_filter_scroll.js b/browser/devtools/webconsole/test/browser_webconsole_bug_597460_filter_scroll.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_597460_filter_scroll.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_597460_filter_scroll.js
@@ -4,19 +4,33 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  *
  * Contributor(s):
  *  Mihai ucan <mihai.sucan@gmail.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-network.html";
+const PREF = "devtools.webconsole.persistlog";
 
-function consoleOpened(aHud) {
-  hud = aHud;
+let test = asyncTest(function* () {
+  Services.prefs.setBoolPref(PREF, true);
+
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
+
+  let results = yield consoleOpened(hud);
+
+  testScroll(results, hud);
+
+  Services.prefs.clearUserPref(PREF);
+});
+
+function consoleOpened(hud) {
+  let deferred = promise.defer();
 
   for (let i = 0; i < 200; i++) {
     content.console.log("test message " + i);
   }
 
   hud.setFilterState("network", false);
   hud.setFilterState("networkinfo", false);
 
@@ -34,22 +48,25 @@ function consoleOpened(aHud) {
   }).then(() => {
     waitForMessages({
       webconsole: hud,
       messages: [{
         text: "test-network.html",
         category: CATEGORY_NETWORK,
         severity: SEVERITY_LOG,
       }],
-    }).then(testScroll);
+    }).then(deferred.resolve);
+
     content.location.reload();
   });
+
+  return deferred.promise;
 }
 
-function testScroll([result]) {
+function testScroll([result], hud) {
   let scrollNode = hud.outputNode.parentNode;
   let msgNode = [...result.matched][0];
   ok(msgNode.classList.contains("filtered-by-type"),
     "network message is filtered by type");
   ok(msgNode.classList.contains("filtered-by-string"),
     "network message is filtered by string");
 
   ok(scrollNode.scrollTop > 0, "scroll location is not at the top");
@@ -57,23 +74,9 @@ function testScroll([result]) {
   // Make sure the Web Console output is scrolled as near as possible to the
   // bottom.
   let nodeHeight = msgNode.clientHeight;
   ok(scrollNode.scrollTop >= scrollNode.scrollHeight - scrollNode.clientHeight -
      nodeHeight * 2, "scroll location is correct");
 
   hud.setFilterState("network", true);
   hud.setFilterState("networkinfo", true);
-
-  executeSoon(finishTest);
 }
-
-function test() {
-  const PREF = "devtools.webconsole.persistlog";
-  Services.prefs.setBoolPref(PREF, true);
-  registerCleanupFunction(() => Services.prefs.clearUserPref(PREF));
-
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_597756_reopen_closed_tab.js b/browser/devtools/webconsole/test/browser_webconsole_bug_597756_reopen_closed_tab.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_597756_reopen_closed_tab.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_597756_reopen_closed_tab.js
@@ -5,60 +5,56 @@
  *
  * Contributor(s):
  *  Mihai ucan <mihai.sucan@gmail.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-bug-597756-reopen-closed-tab.html";
 
-let newTabIsOpen = false;
+let HUD;
 
-function tabLoaded(aEvent) {
-  gBrowser.selectedBrowser.removeEventListener(aEvent.type, tabLoaded, true);
+let test = asyncTest(function* () {
+  expectUncaughtException();
 
-  openConsole(gBrowser.selectedTab, function() {
-    gBrowser.selectedBrowser.addEventListener("load", tabReloaded, true);
-    expectUncaughtException();
-    content.location.reload();
-  });
+  let { browser } = yield loadTab(TEST_URI);
+  HUD = yield openConsole();
+
+  expectUncaughtException();
+
+  yield reload(browser);
+
+  yield testMessages();
+
+  yield closeConsole();
+
+  // Close and reopen
+  gBrowser.removeCurrentTab();
+
+  expectUncaughtException();
+
+  let { browser } = yield loadTab(TEST_URI);
+  HUD = yield openConsole();
+
+  expectUncaughtException();
+
+  yield reload(browser);
+
+  yield testMessages();
+});
+
+function reload(browser) {
+  let loaded = loadBrowser(browser);
+  content.location.reload();
+  return loaded;
 }
 
-function tabReloaded(aEvent) {
-  gBrowser.selectedBrowser.removeEventListener(aEvent.type, tabReloaded, true);
-
-  let HUD = HUDService.getHudByWindow(content);
-  ok(HUD, "Web Console is open");
-
-  waitForMessages({
+function testMessages() {
+  return waitForMessages({
     webconsole: HUD,
     messages: [{
       name: "error message displayed",
       text: "fooBug597756_error",
       category: CATEGORY_JS,
       severity: SEVERITY_ERROR,
     }],
-  }).then(() => {
-    if (newTabIsOpen) {
-      finishTest();
-      return;
-    }
-
-    closeConsole(gBrowser.selectedTab, () => {
-      gBrowser.removeCurrentTab();
-
-      let newTab = gBrowser.addTab();
-      gBrowser.selectedTab = newTab;
-
-      newTabIsOpen = true;
-      gBrowser.selectedBrowser.addEventListener("load", tabLoaded, true);
-      expectUncaughtException();
-      content.location = TEST_URI;
-    });
   });
 }
-
-function test() {
-  expectUncaughtException();
-  addTab(TEST_URI);
-  browser.addEventListener("load", tabLoaded, true);
-}
-
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_599725_response_headers.js b/browser/devtools/webconsole/test/browser_webconsole_bug_599725_response_headers.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_599725_response_headers.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_599725_response_headers.js
@@ -3,21 +3,24 @@
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  *
  * Contributor(s):
  *  Mihai ucan <mihai.sucan@gmail.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
+const INIT_URI = "data:text/plain;charset=utf8,hello world";
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-bug-599725-response-headers.sjs";
 
 let loads = 0;
 function performTest(aRequest, aConsole)
 {
+  let deferred = promise.defer();
+
   loads++;
   ok(aRequest, "page load was logged");
   if (loads != 2) {
     return;
   }
 
   let headers = null;
 
@@ -45,32 +48,41 @@ function performTest(aRequest, aConsole)
       if (contentType || contentLength == 60) {
         console.debug("lastFinishedRequest", lastFinishedRequest,
                       "request", lastFinishedRequest.request,
                       "response", lastFinishedRequest.response,
                       "updates", lastFinishedRequest.updates,
                       "response headers", headers);
       }
 
-      executeSoon(finishTest);
+      executeSoon(deferred.resolve);
     });
 
   HUDService.lastFinishedRequest.callback = null;
+
+  return deferred.promise;
 }
 
-function test()
-{
-  addTab("data:text/plain;charset=utf8,hello world");
+function waitForRequest() {
+  let deferred = promise.defer();
+  HUDService.lastFinishedRequest.callback = (req, console) => {
+    performTest(req, console).then(deferred.resolve);
+  };
+  return deferred.promise;
+}
 
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, () => {
-      HUDService.lastFinishedRequest.callback = performTest;
+let test = asyncTest(function* () {
+  let { browser } = yield loadTab(INIT_URI);
 
-      browser.addEventListener("load", function onReload() {
-        browser.removeEventListener("load", onReload, true);
-        executeSoon(() => content.location.reload());
-      }, true);
+  let hud = yield openConsole();
 
-      executeSoon(() => content.location = TEST_URI);
-    });
-  }, true);
-}
+  let gotLastRequest = waitForRequest();
+
+  let loaded = loadBrowser(browser);
+  content.location = TEST_URI;
+  yield loaded;
+
+  let reloaded = loadBrowser(browser);
+  content.location.reload();
+  yield reloaded;
+
+  yield gotLastRequest;
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_600183_charset.js b/browser/devtools/webconsole/test/browser_webconsole_bug_600183_charset.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_600183_charset.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_600183_charset.js
@@ -3,51 +3,64 @@
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  *
  * Contributor(s):
  *  Mihai ucan <mihai.sucan@gmail.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
+const INIT_URI = "data:text/html;charset=utf-8,Web Console - bug 600183 test";
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-bug-600183-charset.html";
 
 function performTest(lastFinishedRequest, aConsole)
 {
+  let deferred = promise.defer();
+
   ok(lastFinishedRequest, "charset test page was loaded and logged");
   HUDService.lastFinishedRequest.callback = null;
 
   executeSoon(() => {
     aConsole.webConsoleClient.getResponseContent(lastFinishedRequest.actor,
       (aResponse) => {
         ok(!aResponse.contentDiscarded, "response body was not discarded");
 
         let body = aResponse.content.text;
         ok(body, "we have the response body");
 
         let chars = "\u7684\u95ee\u5019!"; // !
         isnot(body.indexOf("<p>" + chars + "</p>"), -1,
           "found the chinese simplified string");
 
         HUDService.lastFinishedRequest.callback = null;
-        executeSoon(finishTest);
+        executeSoon(deferred.resolve);
       });
   });
+
+  return deferred.promise;
 }
 
-function test()
-{
-  addTab("data:text/html;charset=utf-8,Web Console - bug 600183 test");
+function waitForRequest() {
+  let deferred = promise.defer();
+  HUDService.lastFinishedRequest.callback = (req, console) => {
+    performTest(req, console).then(deferred.resolve);
+  };
+  return deferred.promise;
+}
 
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
+let test = asyncTest(function* () {
+  let { browser } = yield loadTab(INIT_URI);
 
-    openConsole(null, function(hud) {
-      hud.ui.setSaveRequestAndResponseBodies(true).then(() => {
-        ok(hud.ui._saveRequestAndResponseBodies,
-          "The saveRequestAndResponseBodies property was successfully set.");
+  let hud = yield openConsole();
 
-        HUDService.lastFinishedRequest.callback = performTest;
-        content.location = TEST_URI;
-      });
-    });
-  }, true);
-}
+  yield hud.ui.setSaveRequestAndResponseBodies(true);
+
+  ok(hud.ui._saveRequestAndResponseBodies,
+    "The saveRequestAndResponseBodies property was successfully set.");
+
+  let gotLastRequest = waitForRequest();
+
+  let loaded = loadBrowser(browser);
+  content.location = TEST_URI;
+  yield loaded;
+
+  yield gotLastRequest;
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_601177_log_levels.js b/browser/devtools/webconsole/test/browser_webconsole_bug_601177_log_levels.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_601177_log_levels.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_601177_log_levels.js
@@ -3,75 +3,71 @@
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  *
  * Contributor(s):
  *  Mihai ucan <mihai.sucan@gmail.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
-const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-bug-601177-log-levels.html";
+const TEST_URI = "data:text/html;charset=utf-8,Web Console test for bug 601177: log levels";
+const TEST_URI2 = "http://example.com/browser/browser/devtools/webconsole/test/test-bug-601177-log-levels.html";
 
-function test()
-{
-  //requestLongerTimeout(20);
-  //FIXME
+let test = asyncTest(function* () {
   Services.prefs.setBoolPref("javascript.options.strict", true);
-  registerCleanupFunction(function() {
-    Services.prefs.clearUserPref("javascript.options.strict");
+
+  let { browser } = yield loadTab(TEST_URI);
+
+  let hud = yield openConsole();
+
+  expectUncaughtException();
+
+  yield testLogLevels(hud);
+
+  Services.prefs.clearUserPref("javascript.options.strict");
+});
+
+function testLogLevels(hud) {
+  content.location = TEST_URI2;
+
+  info("waiting for messages");
+
+  return waitForMessages({
+    webconsole: hud,
+    messages: [
+      {
+        text: "test-bug-601177-log-levels.html",
+        category: CATEGORY_NETWORK,
+        severity: SEVERITY_LOG,
+      },
+      {
+        text: "test-bug-601177-log-levels.js",
+        category: CATEGORY_NETWORK,
+        severity: SEVERITY_LOG,
+      },
+      {
+        text: "test-image.png",
+        category: CATEGORY_NETWORK,
+        severity: SEVERITY_LOG,
+      },
+      {
+        text: "foobar-known-to-fail.png",
+        category: CATEGORY_NETWORK,
+        severity: SEVERITY_ERROR,
+      },
+      {
+        text: "foobarBug601177exception",
+        category: CATEGORY_JS,
+        severity: SEVERITY_ERROR,
+      },
+      {
+        text: "undefinedPropertyBug601177",
+        category: CATEGORY_JS,
+        severity: SEVERITY_WARNING,
+      },
+      {
+        text: "foobarBug601177strictError",
+        category: CATEGORY_JS,
+        severity: SEVERITY_WARNING,
+      },
+    ],
   });
-
-  addTab("data:text/html;charset=utf-8,Web Console test for bug 601177: log levels");
-
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-
-  function consoleOpened(hud)
-  {
-    expectUncaughtException();
-    content.location = TEST_URI;
-
-    info("waiting for messages");
-
-    waitForMessages({
-      webconsole: hud,
-      messages: [
-        {
-          text: "test-bug-601177-log-levels.html",
-          category: CATEGORY_NETWORK,
-          severity: SEVERITY_LOG,
-        },
-        {
-          text: "test-bug-601177-log-levels.js",
-          category: CATEGORY_NETWORK,
-          severity: SEVERITY_LOG,
-        },
-        {
-          text: "test-image.png",
-          category: CATEGORY_NETWORK,
-          severity: SEVERITY_LOG,
-        },
-        {
-          text: "foobar-known-to-fail.png",
-          category: CATEGORY_NETWORK,
-          severity: SEVERITY_ERROR,
-        },
-        {
-          text: "foobarBug601177exception",
-          category: CATEGORY_JS,
-          severity: SEVERITY_ERROR,
-        },
-        {
-          text: "undefinedPropertyBug601177",
-          category: CATEGORY_JS,
-          severity: SEVERITY_WARNING,
-        },
-        {
-          text: "foobarBug601177strictError",
-          category: CATEGORY_JS,
-          severity: SEVERITY_WARNING,
-        },
-      ],
-    }).then(finishTest);
-  }
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_601667_filter_buttons.js b/browser/devtools/webconsole/test/browser_webconsole_bug_601667_filter_buttons.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_601667_filter_buttons.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_601667_filter_buttons.js
@@ -1,41 +1,39 @@
 /* Any copyright is dedicated to the Public Domain.
    http://creativecommons.org/publicdomain/zero/1.0/ */
 
 // Tests that the filter button UI logic works correctly.
 
 const TEST_URI = "http://example.com/";
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, testFilterButtons);
-  }, true);
-}
+let hud, hudId, hudBox;
 
-function testFilterButtons(aHud) {
-  hud = aHud;
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+
+  hud = yield openConsole();
   hudId = hud.hudId;
   hudBox = hud.ui.rootElement;
 
+  testFilterButtons();
+});
+
+function testFilterButtons() {
   testMenuFilterButton("net");
   testMenuFilterButton("css");
   testMenuFilterButton("js");
   testMenuFilterButton("logging");
   testMenuFilterButton("security");
 
   testIsolateFilterButton("net");
   testIsolateFilterButton("css");
   testIsolateFilterButton("js");
   testIsolateFilterButton("logging");
   testIsolateFilterButton("security");
-
-  finishTest();
 }
 
 function testMenuFilterButton(aCategory) {
   let selector = ".webconsole-filter-button[category=\"" + aCategory + "\"]";
   let button = hudBox.querySelector(selector);
   ok(button, "we have the \"" + aCategory + "\" button");
 
   let firstMenuItem = button.querySelector("menuitem");
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_602572_log_bodies_checkbox.js b/browser/devtools/webconsole/test/browser_webconsole_bug_602572_log_bodies_checkbox.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_602572_log_bodies_checkbox.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_602572_log_bodies_checkbox.js
@@ -5,16 +5,18 @@
  *
  * Contributor(s):
  *   Mihai ucan <mihai.sucan@gmail.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
 let menuitems = [], menupopups = [], huds = [], tabs = [], runCount = 0;
 
+browser_webconsole_bug_602572_log_bodies_checkbox.js
+
 function test()
 {
   if (runCount == 0) {
     requestLongerTimeout(2);
   }
 
   // open tab 1
   addTab("data:text/html;charset=utf-8,Web Console test for bug 602572: log bodies checkbox. tab 1");
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_603750_websocket.js b/browser/devtools/webconsole/test/browser_webconsole_bug_603750_websocket.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_603750_websocket.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_603750_websocket.js
@@ -4,36 +4,34 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  *
  * Contributor(s):
  *  Mihai ucan <mihai.sucan@gmail.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-bug-603750-websocket.html";
+const TEST_URI2 = "data:text/html;charset=utf-8,Web Console test for bug 603750: Web Socket errors";
 
-function test() {
-  addTab("data:text/html;charset=utf-8,Web Console test for bug 603750: Web Socket errors");
-  browser.addEventListener("load", function tabLoad() {
-    browser.removeEventListener("load", tabLoad, true);
-    openConsole(null, (hud) => {
-      content.location = TEST_URI;
-      info("waiting for websocket errors");
-      waitForMessages({
-        webconsole: hud,
-        messages: [
-          {
-            text: "ws://0.0.0.0:81",
-            source: { url: "test-bug-603750-websocket.js" },
-            category: CATEGORY_JS,
-            severity: SEVERITY_ERROR,
-          },
-          {
-            text: "ws://0.0.0.0:82",
-            source: { url: "test-bug-603750-websocket.js" },
-            category: CATEGORY_JS,
-            severity: SEVERITY_ERROR,
-          },
-        ]}).then(finishTest);
-    });
-  }, true);
-}
+let test = asyncTest(function* () {
+  let { browser } = yield loadTab(TEST_URI2);
 
+  let hud = yield openConsole();
+
+  content.location = TEST_URI;
+
+  yield waitForMessages({
+    webconsole: hud,
+    messages: [
+      {
+        text: "ws://0.0.0.0:81",
+        source: { url: "test-bug-603750-websocket.js" },
+        category: CATEGORY_JS,
+        severity: SEVERITY_ERROR,
+      },
+      {
+        text: "ws://0.0.0.0:82",
+        source: { url: "test-bug-603750-websocket.js" },
+        category: CATEGORY_JS,
+        severity: SEVERITY_ERROR,
+      },
+    ]});
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_611795.js b/browser/devtools/webconsole/test/browser_webconsole_bug_611795.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_611795.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_611795.js
@@ -1,64 +1,62 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* Any copyright is dedicated to the Public Domain.
    http://creativecommons.org/publicdomain/zero/1.0/ */
 
 const TEST_URI = 'data:text/html;charset=utf-8,<div style="-moz-opacity:0;">test repeated' +
                  ' css warnings</div><p style="-moz-opacity:0">hi</p>';
+let hud;
+
+"use strict";
+
+/**
+ * Unit test for bug 611795:
+ * Repeated CSS messages get collapsed into one.
+ */
+
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+
+  hud = yield openConsole();
+  hud.jsterm.clearOutput(true);
+
+  BrowserReload();
+  yield loadBrowser(gBrowser.selectedBrowser);
+
+  yield onContentLoaded();
+  yield testConsoleLogRepeats();
+});
 
 function onContentLoaded()
 {
-  browser.removeEventListener("load", onContentLoaded, true);
-
-  let HUD = HUDService.getHudByWindow(content);
-
   let cssWarning = "Unknown property '-moz-opacity'.  Declaration dropped.";
 
-  waitForMessages({
-    webconsole: HUD,
+  return waitForMessages({
+    webconsole: hud,
     messages: [{
       text: cssWarning,
       category: CATEGORY_CSS,
       severity: SEVERITY_WARNING,
       repeats: 2,
     }],
-  }).then(testConsoleLogRepeats);
+  });
 }
 
 function testConsoleLogRepeats()
 {
-  let HUD = HUDService.getHudByWindow(content);
-  let jsterm = HUD.jsterm;
+  let jsterm = hud.jsterm;
 
   jsterm.clearOutput();
 
   jsterm.setInputValue("for (let i = 0; i < 10; ++i) console.log('this is a line of reasonably long text that I will use to verify that the repeated text node is of an appropriate size.');");
   jsterm.execute();
 
-  waitForMessages({
-    webconsole: HUD,
+  return waitForMessages({
+    webconsole: hud,
     messages: [{
       text: "this is a line of reasonably long text",
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG,
       repeats: 10,
     }],
-  }).then(finishTest);
+  });
 }
-
-/**
- * Unit test for bug 611795:
- * Repeated CSS messages get collapsed into one.
- */
-function test()
-{
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, function(aHud) {
-      // Clear cached messages that are shown once the Web Console opens.
-      aHud.jsterm.clearOutput(true);
-      browser.addEventListener("load", onContentLoaded, true);
-      content.location.reload();
-    });
-  }, true);
-}
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_613013_console_api_iframe.js b/browser/devtools/webconsole/test/browser_webconsole_bug_613013_console_api_iframe.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_613013_console_api_iframe.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_613013_console_api_iframe.js
@@ -5,48 +5,25 @@
  *
  * Contributor(s):
  *  Mihai ucan <mihai.sucan@gmail.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-bug-613013-console-api-iframe.html";
 
-let TestObserver = {
-  QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver]),
 
-  observe: function test_observe(aMessage, aTopic, aData)
-  {
-    if (aTopic == "console-api-log-event") {
-      executeSoon(performTest);
-    }
-  }
-};
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
 
-function tabLoad(aEvent) {
-  browser.removeEventListener(aEvent.type, tabLoad, true);
+  let hud = yield openConsole();
 
-  openConsole(null, function(aHud) {
-    hud = aHud;
-    Services.obs.addObserver(TestObserver, "console-api-log-event", false);
-    content.location.reload();
-  });
-}
+  BrowserReload();
 
-function performTest() {
-  Services.obs.removeObserver(TestObserver, "console-api-log-event");
-  TestObserver = null;
-
-  waitForMessages({
+  yield waitForMessages({
     webconsole: hud,
     messages: [{
       text: "foobarBug613013",
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG,
     }],
-  }).then(finishTest);
-}
-
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", tabLoad, true);
-}
-
+  });
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_613642_maintain_scroll.js b/browser/devtools/webconsole/test/browser_webconsole_bug_613642_maintain_scroll.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_613642_maintain_scroll.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_613642_maintain_scroll.js
@@ -2,127 +2,115 @@
 /*
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  *
  * Contributor(s):
  *   Mihai ucan <mihai.sucan@gmail.com>
  */
 
-let hud, testDriver;
+let TEST_URI = "data:text/html;charset=utf-8,Web Console test for bug 613642: remember scroll location";
 
-function testNext() {
-  testDriver.next();
-}
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
 
-function testGen() {
+  let hud = yield openConsole();
+
   hud.jsterm.clearOutput();
   let outputNode = hud.outputNode;
   let scrollBox = outputNode.parentNode;
 
   for (let i = 0; i < 150; i++) {
     content.console.log("test message " + i);
   }
 
-  waitForMessages({
+  yield waitForMessages({
     webconsole: hud,
     messages: [{
       text: "test message 149",
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG,
     }],
-  }).then(testNext);
-
-  yield undefined;
+  });
 
   ok(scrollBox.scrollTop > 0, "scroll location is not at the top");
 
   // scroll to the first node
   outputNode.focus();
 
+  let scrolled = promise.defer();
+
   scrollBox.onscroll = () => {
     info("onscroll top " + scrollBox.scrollTop);
     if (scrollBox.scrollTop != 0) {
       // Wait for scroll to 0.
       return;
     }
     scrollBox.onscroll = null;
     is(scrollBox.scrollTop, 0, "scroll location updated (moved to top)");
-    testNext();
+    scrolled.resolve();
   };
   EventUtils.synthesizeKey("VK_HOME", {}, hud.iframeWindow);
 
-  yield undefined;
+  yield scrolled.promise;
+
 
   // add a message and make sure scroll doesn't change
   content.console.log("test message 150");
 
-  waitForMessages({
+  yield waitForMessages({
     webconsole: hud,
     messages: [{
       text: "test message 150",
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG,
     }],
-  }).then(testNext);
+  });
 
-  yield undefined;
-
+  let scrolled = promise.defer();
   scrollBox.onscroll = () => {
     if (scrollBox.scrollTop != 0) {
       // Wait for scroll to stabilize at the top.
       return;
     }
     scrollBox.onscroll = null;
     is(scrollBox.scrollTop, 0, "scroll location is still at the top");
-    testNext();
+    scrolled.resolve();
   };
 
   // Make sure that scroll stabilizes at the top. executeSoon() is needed for
   // the yield to work.
   executeSoon(scrollBox.onscroll);
 
-  yield undefined;
+  yield scrolled.promise;
 
   // scroll back to the bottom
   outputNode.lastChild.focus();
 
+  let scrolled = promise.defer();
   scrollBox.onscroll = () => {
     if (scrollBox.scrollTop == 0) {
       // Wait for scroll to bottom.
       return;
     }
     scrollBox.onscroll = null;
     isnot(scrollBox.scrollTop, 0, "scroll location updated (moved to bottom)");
-    testNext();
+    scrolled.resolve();
   };
   EventUtils.synthesizeKey("VK_END", {});
-  yield undefined;
+  yield scrolled.promise;
 
   let oldScrollTop = scrollBox.scrollTop;
 
   content.console.log("test message 151");
 
+  let scrolled = promise.defer();
   scrollBox.onscroll = () => {
     if (scrollBox.scrollTop == oldScrollTop) {
       // Wait for scroll to change.
       return;
     }
     scrollBox.onscroll = null;
     isnot(scrollBox.scrollTop, oldScrollTop, "scroll location updated (moved to bottom again)");
-    hud = testDriver = null;
-    finishTest();
+    scrolled.resolve();
   };
-
-  yield undefined;
-}
-
-function test() {
-  addTab("data:text/html;charset=utf-8,Web Console test for bug 613642: remember scroll location");
-  browser.addEventListener("load", function tabLoad(aEvent) {
-    browser.removeEventListener(aEvent.type, tabLoad, true);
-    openConsole(null, function(aHud) {
-      hud = aHud;
-      testDriver = testGen();
-      testDriver.next();
-    });
-  }, true);
-}
+  yield scrolled.promise;
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_613642_prune_scroll.js b/browser/devtools/webconsole/test/browser_webconsole_bug_613642_prune_scroll.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_613642_prune_scroll.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_613642_prune_scroll.js
@@ -2,44 +2,46 @@
 /*
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  *
  * Contributor(s):
  *   Mihai ucan <mihai.sucan@gmail.com>
  */
 
-let hud, testDriver;
+"use strict";
 
-function testNext() {
-  testDriver.next();
-}
+const TEST_URI = "data:text/html;charset=utf-8,Web Console test for bug 613642: maintain scroll with pruning of old messages";
 
-function testGen() {
+let hud;
+
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+
+  let hud = yield openConsole();
+
   hud.jsterm.clearOutput();
 
   let outputNode = hud.outputNode;
 
   Services.prefs.setIntPref("devtools.hud.loglimit.console", 140);
   let scrollBoxElement = outputNode.parentNode;
 
   for (let i = 0; i < 150; i++) {
     content.console.log("test message " + i);
   }
 
-  waitForMessages({
+  yield waitForMessages({
     webconsole: hud,
     messages: [{
       text: "test message 149",
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG,
     }],
-  }).then(testNext);
-
-  yield undefined;
+  });
 
   let oldScrollTop = scrollBoxElement.scrollTop;
   isnot(oldScrollTop, 0, "scroll location is not at the top");
 
   let firstNode = outputNode.firstChild;
   ok(firstNode, "found the first message");
 
   let msgNode = outputNode.children[80];
@@ -51,47 +53,27 @@ function testGen() {
   isnot(scrollBoxElement.scrollTop, oldScrollTop,
         "scroll location updated (scrolled to message)");
 
   oldScrollTop = scrollBoxElement.scrollTop;
 
   // add a message
   content.console.log("hello world");
 
-  waitForMessages({
+  yield waitForMessages({
     webconsole: hud,
     messages: [{
       text: "hello world",
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG,
     }],
-  }).then(testNext);
-
-  yield undefined;
+  });
 
   // Scroll location needs to change, because one message is also removed, and
   // we need to scroll a bit towards the top, to keep the current view in sync.
   isnot(scrollBoxElement.scrollTop, oldScrollTop,
         "scroll location updated (added a message)");
 
   isnot(outputNode.firstChild, firstNode,
         "first message removed");
 
   Services.prefs.clearUserPref("devtools.hud.loglimit.console");
-
-  hud = testDriver = null;
-  finishTest();
-
-  yield undefined;
-}
-
-function test() {
-  addTab("data:text/html;charset=utf-8,Web Console test for bug 613642: maintain scroll with pruning of old messages");
-  browser.addEventListener("load", function tabLoad(aEvent) {
-    browser.removeEventListener(aEvent.type, tabLoad, true);
-
-    openConsole(null, function(aHud) {
-      hud = aHud;
-      testDriver = testGen();
-      testDriver.next();
-    });
-  }, true);
-}
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_614793_jsterm_scroll.js b/browser/devtools/webconsole/test/browser_webconsole_bug_614793_jsterm_scroll.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_614793_jsterm_scroll.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_614793_jsterm_scroll.js
@@ -2,17 +2,31 @@
 /*
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  *
  * Contributor(s):
  *   Mihai ucan <mihai.sucan@gmail.com>
  */
 
+const TEST_URI = "data:text/html;charset=utf-8,Web Console test for bug 614793: jsterm result scroll";
+
+"use strict";
+
+let test = asyncTest(function* () {
+  let { browser } = yield loadTab(TEST_URI);
+
+  let hud = yield openConsole();
+
+  yield consoleOpened(hud);
+});
+
 function consoleOpened(hud) {
+  let deferred = promise.defer();
+
   hud.jsterm.clearOutput();
 
   let scrollNode = hud.outputNode.parentNode;
 
   for (let i = 0; i < 150; i++) {
     content.console.log("test message " + i);
   }
 
@@ -37,20 +51,13 @@ function consoleOpened(hud) {
     isnot(scrollNode.scrollTop, oldScrollTop, "scroll location updated");
 
     oldScrollTop = scrollNode.scrollTop;
 
     msg.scrollIntoView(false);
 
     is(scrollNode.scrollTop, oldScrollTop, "scroll location is the same");
 
-    finishTest();
+    deferred.resolve();
   }
+
+  return deferred.promise;
 }
-
-function test() {
-  addTab("data:text/html;charset=utf-8,Web Console test for bug 614793: jsterm result scroll");
-  browser.addEventListener("load", function onLoad(aEvent) {
-    browser.removeEventListener(aEvent.type, onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
-
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_618078_network_exceptions.js b/browser/devtools/webconsole/test/browser_webconsole_bug_618078_network_exceptions.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_618078_network_exceptions.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_618078_network_exceptions.js
@@ -1,31 +1,29 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Tests that we report JS exceptions in event handlers coming from
 // network requests, like onreadystate for XHR. See bug 618078.
 
-const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-bug-618078-network-exceptions.html";
+const TEST_URI = "data:text/html;charset=utf-8,Web Console test for bug 618078";
+const TEST_URI2 = "http://example.com/browser/browser/devtools/webconsole/test/test-bug-618078-network-exceptions.html";
 
-function test()
-{
-  addTab("data:text/html;charset=utf-8,Web Console test for bug 618078");
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
 
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, function(hud) {
-      expectUncaughtException();
-      content.location = TEST_URI;
+  let hud = yield openConsole();
 
-      waitForMessages({
-        webconsole: hud,
-        messages: [{
-          text: "bug618078exception",
-          category: CATEGORY_JS,
-          severity: SEVERITY_ERROR,
-        }],
-      }).then(finishTest);
-    });
-  }, true);
-}
+  expectUncaughtException();
+
+  content.location = TEST_URI2;
+
+  yield waitForMessages({
+    webconsole: hud,
+    messages: [{
+      text: "bug618078exception",
+      category: CATEGORY_JS,
+      severity: SEVERITY_ERROR,
+    }],
+  });
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_618311_close_panels.js b/browser/devtools/webconsole/test/browser_webconsole_bug_618311_close_panels.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_618311_close_panels.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_618311_close_panels.js
@@ -1,37 +1,37 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
 
-    openConsole(null, function(hud) {
-      content.location.reload();
+  let hud = yield openConsole();
 
-      waitForMessages({
-        webconsole: hud,
-        messages: [{
-          text: "test-console.html",
-          category: CATEGORY_NETWORK,
-          severity: SEVERITY_LOG,
-        }],
-      }).then(performTest);
-    });
-  }, true);
-}
+  BrowserReload();
 
-function performTest(results) {
-  let HUD = HUDService.getHudByWindow(content);
+  let results = yield waitForMessages({
+    webconsole: hud,
+    messages: [{
+      text: "test-console.html",
+      category: CATEGORY_NETWORK,
+      severity: SEVERITY_LOG,
+    }],
+  })
+
+  yield performTest(hud, results);
+});
+
+
+function performTest(HUD, results) {
+  let deferred = promise.defer();
 
   let networkMessage = [...results[0].matched][0];
   ok(networkMessage, "network message element");
 
   let networkLink = networkMessage.querySelector(".url");
   ok(networkLink, "found network message link");
 
   let popupset = document.getElementById("mainPopupSet");
@@ -64,25 +64,27 @@ function performTest(results) {
   let onpopuphidden = function() {
     document.removeEventListener("popuphidden", onpopuphidden, false);
     hiddenPopups++;
 
     executeSoon(function() {
       let popups = popupset.querySelectorAll("panel[hudId=" + HUD.hudId + "]");
       is(popups.length, 0, "no popups found");
 
-      executeSoon(finishTest);
+      executeSoon(deferred.resolve);
     });
   };
 
   document.addEventListener("popupshown", onpopupshown, false);
 
   registerCleanupFunction(function() {
     is(popupsShown, 1, "correct number of popups shown");
     if (popupsShown != 1) {
       document.removeEventListener("popupshown", onpopupshown, false);
     }
   });
 
   EventUtils.sendMouseEvent({ type: "mousedown" }, networkLink, HUD.iframeWindow);
   EventUtils.sendMouseEvent({ type: "mouseup" }, networkLink, HUD.iframeWindow);
   EventUtils.sendMouseEvent({ type: "click" }, networkLink, HUD.iframeWindow);
+
+  return deferred.promise;
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_621644_jsterm_dollar.js b/browser/devtools/webconsole/test/browser_webconsole_bug_621644_jsterm_dollar.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_621644_jsterm_dollar.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_621644_jsterm_dollar.js
@@ -4,37 +4,46 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  *
  * Contributor(s):
  *   Mihai Sucan <mihai.sucan@gmail.com>
  */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-bug-621644-jsterm-dollar.html";
 
-function test$(HUD) {
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+
+  let hud = yield openConsole();
+
+  yield test$(hud);
+  yield test$$(hud);
+});
+
+
+function* test$(HUD) {
+  let deferred = promise.defer();
+
   HUD.jsterm.clearOutput();
 
   HUD.jsterm.execute("$(document.body)", (msg) => {
     ok(msg.textContent.indexOf("<p>") > -1,
        "jsterm output is correct for $()");
+    deferred.resolve();
+  });
 
-    test$$(HUD);
-  });
+  return deferred.promise;
 }
 
 function test$$(HUD) {
+  let deferred = promise.defer();
+
   HUD.jsterm.clearOutput();
 
   HUD.jsterm.setInputValue();
   HUD.jsterm.execute("$$(document)", (msg) => {
     ok(msg.textContent.indexOf("621644") > -1,
        "jsterm output is correct for $$()");
-    finishTest();
+    deferred.resolve();
   });
+
+  return deferred.promise;
 }
-
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, test$);
-  }, true);
-}
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_622303_persistent_filters.js b/browser/devtools/webconsole/test/browser_webconsole_bug_622303_persistent_filters.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_622303_persistent_filters.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_622303_persistent_filters.js
@@ -20,29 +20,43 @@ let prefs = {
   "logging": [
      "error",
      "warn",
      "info",
      "log"
   ]
 };
 
-function test() {
+let test = asyncTest(function* () {
   // Set all prefs to true
   for (let category in prefs) {
     prefs[category].forEach(function(pref) {
       Services.prefs.setBoolPref("devtools.webconsole.filter." + pref, true);
     });
   }
 
-  addTab("about:blank");
-  openConsole(null, onConsoleOpen);
-}
+  yield loadTab("about:blank");
+
+  let hud = yield openConsole();
+
+  let hud2 = yield onConsoleOpen(hud);
+  let hud3 = yield onConsoleReopen1(hud2);
+  yield onConsoleReopen2(hud3);
+
+  // Clear prefs
+  for (let category in prefs) {
+    prefs[category].forEach(function(pref) {
+      Services.prefs.clearUserPref("devtools.webconsole.filter." + pref);
+    });
+  }
+});
 
 function onConsoleOpen(hud) {
+  let deferred = promise.defer();
+
   let hudBox = hud.ui.rootElement;
 
   // Check if the filters menuitems exists and are checked
   for (let category in prefs) {
     let button = hudBox.querySelector(".webconsole-filter-button[category=\""
                                       + category + "\"]");
     ok(isChecked(button), "main button for " + category + " category is checked");
 
@@ -55,22 +69,27 @@ function onConsoleOpen(hud) {
   // Set all prefs to false
   for (let category in prefs) {
     prefs[category].forEach(function(pref) {
       hud.setFilterState(pref, false);
     });
   }
 
   //Re-init the console
-  closeConsole(null, function() {
-    openConsole(null, onConsoleReopen1);
+  closeConsole().then(() => {
+    openConsole().then(deferred.resolve);
   });
+
+  return deferred.promise;
 }
 
 function onConsoleReopen1(hud) {
+  info("testing after reopening once");
+  let deferred = promise.defer();
+
   let hudBox = hud.ui.rootElement;
 
   // Check if the filter button and menuitems are unchecked
   for (let category in prefs) {
     let button = hudBox.querySelector(".webconsole-filter-button[category=\""
                                            + category + "\"]");
     ok(isUnchecked(button), "main button for " + category + " category is not checked");
 
@@ -81,44 +100,38 @@ function onConsoleReopen1(hud) {
   }
 
   // Set first pref in each category to true
   for (let category in prefs) {
     hud.setFilterState(prefs[category][0], true);
   }
 
   // Re-init the console
-  closeConsole(null, function() {
-    openConsole(null, onConsoleReopen2);
+  closeConsole().then(() => {
+    openConsole().then(deferred.resolve);
   });
+
+  return deferred.promise;
 }
 
 function onConsoleReopen2(hud) {
+  info("testing after reopening again");
+
   let hudBox = hud.ui.rootElement;
 
   // Check the main category button is checked and first menuitem is checked
   for (let category in prefs) {
     let button = hudBox.querySelector(".webconsole-filter-button[category=\""
                                            + category + "\"]");
     ok(isChecked(button), category  + " button is checked when first pref is true");
 
     let pref = prefs[category][0];
     let menuitem = hudBox.querySelector("menuitem[prefKey=" + pref + "]");
     ok(isChecked(menuitem), "first " + category + " menuitem is checked");
   }
-
-  // Clear prefs
-  for (let category in prefs) {
-    prefs[category].forEach(function(pref) {
-      Services.prefs.clearUserPref("devtools.webconsole.filter." + pref);
-    });
-  }
-
-  prefs = null;
-  finishTest();
 }
 
 function isChecked(aNode) {
   return aNode.getAttribute("checked") === "true";
 }
 
 function isUnchecked(aNode) {
   return aNode.getAttribute("checked") === "false";
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_623749_ctrl_a_select_all_winnt.js b/browser/devtools/webconsole/test/browser_webconsole_bug_623749_ctrl_a_select_all_winnt.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_623749_ctrl_a_select_all_winnt.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_623749_ctrl_a_select_all_winnt.js
@@ -1,32 +1,28 @@
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 // Test for https://bugzilla.mozilla.org/show_bug.cgi?id=623749
 // Map Control + A to Select All, In the web console input, on Windows
 
-function test() {
-  addTab("data:text/html;charset=utf-8,Test console for bug 623749");
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, runTest);
-  }, true);
-}
+const TEST_URI = "data:text/html;charset=utf-8,Test console for bug 623749";
 
-function runTest(HUD) {
-  let jsterm = HUD.jsterm;
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+
+  let hud = yield openConsole();
+
+  let jsterm = hud.jsterm;
   jsterm.setInputValue("Ignore These Four Words");
   let inputNode = jsterm.inputNode;
 
   // Test select all with Control + A.
   EventUtils.synthesizeKey("a", { ctrlKey: true });
   let inputLength = inputNode.selectionEnd - inputNode.selectionStart;
   is(inputLength, inputNode.value.length, "Select all of input");
 
   // Test do nothing on Control + E.
   jsterm.setInputValue("Ignore These Four Words");
   inputNode.selectionStart = 0;
   EventUtils.synthesizeKey("e", { ctrlKey: true });
   is(inputNode.selectionStart, 0, "Control + E does not move to end of input");
-
-  executeSoon(finishTest);
-}
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_630733_response_redirect_headers.js b/browser/devtools/webconsole/test/browser_webconsole_bug_630733_response_redirect_headers.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_630733_response_redirect_headers.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_630733_response_redirect_headers.js
@@ -2,79 +2,99 @@
 /*
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  *
  * Contributor(s):
  *   Mihai Sucan <mihai.sucan@gmail.com>
  */
 
-const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-bug-630733-response-redirect-headers.sjs";
+const TEST_URI = "data:text/html;charset=utf-8,<p>Web Console test for bug 630733";
+const TEST_URI2 = "http://example.com/browser/browser/devtools/webconsole/test/test-bug-630733-response-redirect-headers.sjs";
 
 let lastFinishedRequests = {};
 let webConsoleClient;
 
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+
+  let hud = yield openConsole();
+
+  yield consoleOpened(hud);
+  yield getHeaders();
+  yield getContent();
+
+  performTest();
+});
+
 function consoleOpened(hud)
 {
+  let deferred = promise.defer();
+
   webConsoleClient = hud.ui.webConsoleClient;
   hud.ui.setSaveRequestAndResponseBodies(true).then(() => {
     ok(hud.ui._saveRequestAndResponseBodies,
       "The saveRequestAndResponseBodies property was successfully set.");
 
-    HUDService.lastFinishedRequest.callback = requestDoneCallback;
-    content.location = TEST_URI;
+    HUDService.lastFinishedRequest.callback = (aHttpRequest)  => {
+      let status = aHttpRequest.response.status;
+      lastFinishedRequests[status] = aHttpRequest;
+      if ("301" in lastFinishedRequests &&
+          "404" in lastFinishedRequests) {
+        deferred.resolve();
+      }
+    }
+    content.location = TEST_URI2;
   });
-}
 
-function requestDoneCallback(aHttpRequest)
-{
-  let status = aHttpRequest.response.status;
-  lastFinishedRequests[status] = aHttpRequest;
-  if ("301" in lastFinishedRequests &&
-      "404" in lastFinishedRequests) {
-    getHeaders();
-  }
+  return deferred.promise;
 }
 
 function getHeaders()
 {
+  let deferred = promise.defer();
+
   HUDService.lastFinishedRequest.callback = null;
 
   ok("301" in lastFinishedRequests, "request 1: 301 Moved Permanently");
   ok("404" in lastFinishedRequests, "request 2: 404 Not found");
 
   webConsoleClient.getResponseHeaders(lastFinishedRequests["301"].actor,
     function (aResponse) {
       lastFinishedRequests["301"].response.headers = aResponse.headers;
 
       webConsoleClient.getResponseHeaders(lastFinishedRequests["404"].actor,
         function (aResponse) {
           lastFinishedRequests["404"].response.headers = aResponse.headers;
-          executeSoon(getContent);
+          executeSoon(deferred.resolve);
         });
     });
+  return deferred.promise;
 }
 
 function getContent()
 {
+  let deferred = promise.defer();
+
   webConsoleClient.getResponseContent(lastFinishedRequests["301"].actor,
     function (aResponse) {
       lastFinishedRequests["301"].response.content = aResponse.content;
       lastFinishedRequests["301"].discardResponseBody = aResponse.contentDiscarded;
 
       webConsoleClient.getResponseContent(lastFinishedRequests["404"].actor,
         function (aResponse) {
           lastFinishedRequests["404"].response.content = aResponse.content;
           lastFinishedRequests["404"].discardResponseBody =
             aResponse.contentDiscarded;
 
           webConsoleClient = null;
-          executeSoon(performTest);
+          executeSoon(deferred.resolve);
         });
     });
+  return deferred.promise;
 }
 
 function performTest()
 {
   function readHeader(aName)
   {
     for (let header of headers) {
       if (header.name == aName) {
@@ -102,20 +122,9 @@ function performTest()
   ok(!readHeader("Location"), "no Location header");
   ok(!readHeader("x-foobar-bug630733"), "no X-Foobar-bug630733 header");
 
   body = lastFinishedRequests["404"].response.content.text;
   isnot(body.indexOf("404"), -1,
         "body is correct for request 2");
 
   lastFinishedRequests = null;
-  executeSoon(finishTest);
 }
-
-function test()
-{
-  addTab("data:text/html;charset=utf-8,<p>Web Console test for bug 630733");
-
-  browser.addEventListener("load", function onLoad(aEvent) {
-    browser.removeEventListener(aEvent.type, onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_644419_log_limits.js b/browser/devtools/webconsole/test/browser_webconsole_bug_644419_log_limits.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_644419_log_limits.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_644419_log_limits.js
@@ -2,145 +2,151 @@
 /*
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // Tests that the Web Console limits the number of lines displayed according to
 // the limit set for each category.
 
+const INIT_URI = "data:text/html;charset=utf-8,Web Console test for bug 644419: Console should " +
+                 "have user-settable log limits for each message category";
+
 const TEST_URI = "http://example.com/browser/browser/devtools/" +
                  "webconsole/test/test-bug-644419-log-limits.html";
 
 let hud, outputNode;
 
-function test() {
-  addTab("data:text/html;charset=utf-8,Web Console test for bug 644419: Console should " +
-         "have user-settable log limits for each message category");
-  browser.addEventListener("load", onLoad, true);
-}
+let test = asyncTest(function* () {
+  let { browser } = yield loadTab(INIT_URI);
 
-function onLoad(aEvent) {
-  browser.removeEventListener(aEvent.type, onLoad, true);
+  hud = yield openConsole();
 
-  openConsole(null, function(aHud) {
-    aHud.jsterm.clearOutput();
-    hud = aHud;
-    outputNode = aHud.outputNode;
+  hud.jsterm.clearOutput();
+  outputNode = hud.outputNode;
 
-    browser.addEventListener("load", testWebDevLimits, true);
-    expectUncaughtException();
-    content.location = TEST_URI;
-  });
-}
+  let loaded = loadBrowser(browser);
 
-function testWebDevLimits(aEvent) {
-  browser.removeEventListener(aEvent.type, testWebDevLimits, true);
+  expectUncaughtException();
+
+  content.location = TEST_URI;
+  yield loaded;
+
+  yield testWebDevLimits();
+  yield testWebDevLimits2();
+  yield testJsLimits();
+  yield testJsLimits2();
+
+  yield testNetLimits();
+  yield loadImage();
+  yield testCssLimits();
+  yield testCssLimits2();
+});
+
+function testWebDevLimits() {
   Services.prefs.setIntPref("devtools.hud.loglimit.console", 10);
 
   // Find the sentinel entry.
-  waitForMessages({
+  return waitForMessages({
     webconsole: hud,
     messages: [{
       text: "bar is not defined",
       category: CATEGORY_JS,
       severity: SEVERITY_ERROR,
     }],
-  }).then(testWebDevLimits2);
+  })
 }
 
 function testWebDevLimits2() {
   // Fill the log with Web Developer errors.
   for (let i = 0; i < 11; i++) {
     content.console.log("test message " + i);
   }
 
-  waitForMessages({
+  return waitForMessages({
     webconsole: hud,
     messages: [{
       text: "test message 10",
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG,
     }],
   }).then(() => {
     testLogEntry(outputNode, "test message 0", "first message is pruned", false, true);
     findLogEntry("test message 1");
     // Check if the sentinel entry is still there.
     findLogEntry("bar is not defined");
 
     Services.prefs.clearUserPref("devtools.hud.loglimit.console");
-    testJsLimits();
   });
 }
 
 function testJsLimits() {
   Services.prefs.setIntPref("devtools.hud.loglimit.exception", 10);
 
   hud.jsterm.clearOutput();
   content.console.log("testing JS limits");
 
   // Find the sentinel entry.
-  waitForMessages({
+  return waitForMessages({
     webconsole: hud,
     messages: [{
       text: "testing JS limits",
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG,
     }],
-  }).then(testJsLimits2);
+  });
 }
 
 function testJsLimits2() {
   // Fill the log with JS errors.
   let head = content.document.getElementsByTagName("head")[0];
   for (let i = 0; i < 11; i++) {
     var script = content.document.createElement("script");
     script.text = "fubar" + i + ".bogus(6);";
+
     expectUncaughtException();
     head.insertBefore(script, head.firstChild);
   }
 
-  waitForMessages({
+  return waitForMessages({
     webconsole: hud,
     messages: [{
       text: "fubar10 is not defined",
       category: CATEGORY_JS,
       severity: SEVERITY_ERROR,
     }],
   }).then(() => {
     testLogEntry(outputNode, "fubar0 is not defined", "first message is pruned", false, true);
     findLogEntry("fubar1 is not defined");
     // Check if the sentinel entry is still there.
     findLogEntry("testing JS limits");
 
     Services.prefs.clearUserPref("devtools.hud.loglimit.exception");
-    testNetLimits();
   });
 }
 
 var gCounter, gImage;
 
 function testNetLimits() {
   Services.prefs.setIntPref("devtools.hud.loglimit.network", 10);
 
   hud.jsterm.clearOutput();
   content.console.log("testing Net limits");
 
   // Find the sentinel entry.
-  waitForMessages({
+  return waitForMessages({
     webconsole: hud,
     messages: [{
       text: "testing Net limits",
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG,
     }],
   }).then(() => {
     // Fill the log with network messages.
     gCounter = 0;
-    loadImage();
   });
 }
 
 function loadImage() {
   if (gCounter < 11) {
     let body = content.document.getElementsByTagName("body")[0];
     gImage && gImage.removeEventListener("load", loadImage, true);
     gImage = content.document.createElement("img");
@@ -148,72 +154,70 @@ function loadImage() {
     body.insertBefore(gImage, body.firstChild);
     gImage.addEventListener("load", loadImage, true);
     gCounter++;
     return;
   }
 
   is(gCounter, 11, "loaded 11 files");
 
-  waitForMessages({
+  return waitForMessages({
     webconsole: hud,
     messages: [{
       text: "test-image.png",
       url: "test-image.png?_fubar=10",
       category: CATEGORY_NETWORK,
       severity: SEVERITY_LOG,
     }],
   }).then(() => {
     let msgs = outputNode.querySelectorAll(".message[category=network]");
     is(msgs.length, 10, "number of network messages");
     isnot(msgs[0].url.indexOf("fubar=1"), -1, "first network message");
     isnot(msgs[1].url.indexOf("fubar=2"), -1, "second network message");
     findLogEntry("testing Net limits");
 
     Services.prefs.clearUserPref("devtools.hud.loglimit.network");
-    testCssLimits();
   });
 }
 
 function testCssLimits() {
   Services.prefs.setIntPref("devtools.hud.loglimit.cssparser", 10);
 
   hud.jsterm.clearOutput();
   content.console.log("testing CSS limits");
 
   // Find the sentinel entry.
-  waitForMessages({
+  return waitForMessages({
     webconsole: hud,
     messages: [{
       text: "testing CSS limits",
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG,
     }],
-  }).then(testCssLimits2);
+  });
 }
 
 function testCssLimits2() {
   // Fill the log with CSS errors.
   let body = content.document.getElementsByTagName("body")[0];
   for (let i = 0; i < 11; i++) {
     var div = content.document.createElement("div");
     div.setAttribute("style", "-moz-foobar" + i + ": 42;");
     body.insertBefore(div, body.firstChild);
   }
 
-  waitForMessages({
+  return waitForMessages({
     webconsole: hud,
     messages: [{
       text: "-moz-foobar10",
       category: CATEGORY_CSS,
       severity: SEVERITY_WARNING,
     }],
   }).then(() => {
     testLogEntry(outputNode, "Unknown property '-moz-foobar0'",
                  "first message is pruned", false, true);
     findLogEntry("Unknown property '-moz-foobar1'");
     // Check if the sentinel entry is still there.
     findLogEntry("testing CSS limits");
 
     Services.prefs.clearUserPref("devtools.hud.loglimit.cssparser");
-    finishTest();
   });
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_646025_console_file_location.js b/browser/devtools/webconsole/test/browser_webconsole_bug_646025_console_file_location.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_646025_console_file_location.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_646025_console_file_location.js
@@ -1,56 +1,54 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Tests that console logging methods display the method location along with
 // the output in the console.
 
-const TEST_URI = "http://example.com/browser/browser/devtools/" +
+const TEST_URI = "data:text/html;charset=utf-8,Web Console file location display test";
+const TEST_URI2 = "http://example.com/browser/browser/devtools/" +
                  "webconsole/test/" +
                  "test-bug-646025-console-file-location.html";
 
-function test() {
-  addTab("data:text/html;charset=utf-8,Web Console file location display test");
-  browser.addEventListener("load", onLoad, true);
-}
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
 
-function onLoad(aEvent) {
-  browser.removeEventListener(aEvent.type, onLoad, true);
-  openConsole(null, function(hud) {
-    content.location = TEST_URI;
-    waitForMessages({
-      webconsole: hud,
-      messages: [{
-        text: "message for level log",
-        category: CATEGORY_WEBDEV,
-        severity: SEVERITY_LOG,
-        source: { url: "test-file-location.js", line: 5 },
-      },
-      {
-        text: "message for level info",
-        category: CATEGORY_WEBDEV,
-        severity: SEVERITY_INFO,
-        source: { url: "test-file-location.js", line: 6 },
-      },
-      {
-        text: "message for level warn",
-        category: CATEGORY_WEBDEV,
-        severity: SEVERITY_WARNING,
-        source: { url: "test-file-location.js", line: 7 },
-      },
-      {
-        text: "message for level error",
-        category: CATEGORY_WEBDEV,
-        severity: SEVERITY_ERROR,
-        source: { url: "test-file-location.js", line: 8 },
-      },
-      {
-        text: "message for level debug",
-        category: CATEGORY_WEBDEV,
-        severity: SEVERITY_LOG,
-        source: { url: "test-file-location.js", line: 9 },
-      }],
-    }).then(finishTest);
+  let hud = yield openConsole();
+
+  content.location = TEST_URI2;
+
+  yield waitForMessages({
+    webconsole: hud,
+    messages: [{
+      text: "message for level log",
+      category: CATEGORY_WEBDEV,
+      severity: SEVERITY_LOG,
+      source: { url: "test-file-location.js", line: 5 },
+    },
+    {
+      text: "message for level info",
+      category: CATEGORY_WEBDEV,
+      severity: SEVERITY_INFO,
+      source: { url: "test-file-location.js", line: 6 },
+    },
+    {
+      text: "message for level warn",
+      category: CATEGORY_WEBDEV,
+      severity: SEVERITY_WARNING,
+      source: { url: "test-file-location.js", line: 7 },
+    },
+    {
+      text: "message for level error",
+      category: CATEGORY_WEBDEV,
+      severity: SEVERITY_ERROR,
+      source: { url: "test-file-location.js", line: 8 },
+    },
+    {
+      text: "message for level debug",
+      category: CATEGORY_WEBDEV,
+      severity: SEVERITY_LOG,
+      source: { url: "test-file-location.js", line: 9 },
+    }],
   });
-}
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_651501_document_body_autocomplete.js b/browser/devtools/webconsole/test/browser_webconsole_bug_651501_document_body_autocomplete.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_651501_document_body_autocomplete.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_651501_document_body_autocomplete.js
@@ -1,28 +1,37 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /*
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // Tests that document.body autocompletes in the web console.
+const TEST_URI = "data:text/html;charset=utf-8,Web Console autocompletion bug in document.body";
 
-function test() {
-  addTab("data:text/html;charset=utf-8,Web Console autocompletion bug in document.body");
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
+"use strict";
 
 let gHUD;
 
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+
+  gHUD = yield openConsole();
+
+  yield consoleOpened();
+  yield autocompletePopupHidden();
+  let view = yield testPropertyPanel();
+  yield onVariablesViewReady(view);
+
+  gHUD = null;
+});
+
 function consoleOpened(aHud) {
-  gHUD = aHud;
+  let deferred = promise.defer();
+
   let jsterm = gHUD.jsterm;
   let popup = jsterm.autocompletePopup;
   let completeNode = jsterm.completeNode;
 
   ok(!popup.isOpen, "popup is not open");
 
   popup._panel.addEventListener("popupshown", function onShown() {
     popup._panel.removeEventListener("popupshown", onShown, false);
@@ -33,61 +42,68 @@ function consoleOpened(aHud) {
        "popup.itemCount is correct");
     isnot(jsterm._autocompleteCache.indexOf("addEventListener"), -1,
           "addEventListener is in the list of suggestions");
     isnot(jsterm._autocompleteCache.indexOf("bgColor"), -1,
           "bgColor is in the list of suggestions");
     isnot(jsterm._autocompleteCache.indexOf("ATTRIBUTE_NODE"), -1,
           "ATTRIBUTE_NODE is in the list of suggestions");
 
-    popup._panel.addEventListener("popuphidden", autocompletePopupHidden, false);
+    popup._panel.addEventListener("popuphidden", deferred.resolve, false);
 
     EventUtils.synthesizeKey("VK_ESCAPE", {});
   }, false);
 
   jsterm.setInputValue("document.body");
   EventUtils.synthesizeKey(".", {});
+
+  return deferred.promise;
 }
 
 function autocompletePopupHidden()
 {
+  let deferred = promise.defer();
+
   let jsterm = gHUD.jsterm;
   let popup = jsterm.autocompletePopup;
   let completeNode = jsterm.completeNode;
   let inputNode = jsterm.inputNode;
 
   popup._panel.removeEventListener("popuphidden", autocompletePopupHidden, false);
 
   ok(!popup.isOpen, "popup is not open");
 
   jsterm.once("autocomplete-updated", function() {
     is(completeNode.value, testStr + "dy", "autocomplete shows document.body");
-    testPropertyPanel();
+    deferred.resolve();
   });
 
   let inputStr = "document.b";
   jsterm.setInputValue(inputStr);
   EventUtils.synthesizeKey("o", {});
   let testStr = inputStr.replace(/./g, " ") + " ";
+
+  return deferred.promise;
 }
 
 function testPropertyPanel()
 {
+  let deferred = promise.defer();
+
   let jsterm = gHUD.jsterm;
   jsterm.clearOutput();
   jsterm.execute("document", (msg) => {
-    jsterm.once("variablesview-fetched", onVariablesViewReady);
+    jsterm.once("variablesview-fetched", (aEvent, aView) => {
+      deferred.resolve(aView);
+    });
     let anchor = msg.querySelector(".message-body a");
     EventUtils.synthesizeMouse(anchor, 2, 2, {}, gHUD.iframeWindow);
   });
+
+  return deferred.promise;
 }
 
-function onVariablesViewReady(aEvent, aView)
+function onVariablesViewReady(aView)
 {
-  findVariableViewProperties(aView, [
+  return findVariableViewProperties(aView, [
     { name: "body", value: "<body>" },
-  ], { webconsole: gHUD }).then(finishUp);
+  ], { webconsole: gHUD });
 }
-
-function finishUp() {
-  gHUD = null;
-  finishTest();
-}
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_658368_time_methods.js b/browser/devtools/webconsole/test/browser_webconsole_bug_658368_time_methods.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_658368_time_methods.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_658368_time_methods.js
@@ -1,87 +1,66 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /*
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // Tests that the Console API implements the time() and timeEnd() methods.
 
-function test() {
-  addTab("http://example.com/browser/browser/devtools/webconsole/" +
-         "test/test-bug-658368-time-methods.html");
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    Task.spawn(runner);
-  }, true);
+const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/" +
+         "test/test-bug-658368-time-methods.html";
 
-  function* runner() {
-    let hud1 = yield openConsole();
+const TEST_URI2 = "data:text/html;charset=utf-8,<script>" +
+           "console.timeEnd('bTimer');</script>";
 
-    yield waitForMessages({
-      webconsole: hud1,
-      messages: [{
-        name: "aTimer started",
-        consoleTime: "aTimer",
-      }, {
-        name: "aTimer end",
-        consoleTimeEnd: "aTimer",
-      }],
-    });
-
-    let deferred = promise.defer();
-
-    // The next test makes sure that timers with the same name but in separate
-    // tabs, do not contain the same value.
-    addTab("data:text/html;charset=utf-8,<script>" +
-           "console.timeEnd('bTimer');</script>");
-    browser.addEventListener("load", function onLoad() {
-      browser.removeEventListener("load", onLoad, true);
-      openConsole().then((hud) => {
-        deferred.resolve(hud);
-      });
-    }, true);
-
-    let hud2 = yield deferred.promise;
-
-    testLogEntry(hud2.outputNode, "bTimer: timer started",
-                 "bTimer was not started", false, true);
-
-    // The next test makes sure that timers with the same name but in separate
-    // pages, do not contain the same value.
-    content.location = "data:text/html;charset=utf-8,<script>" +
+const TEST_URI3 = "data:text/html;charset=utf-8,<script>" +
                        "console.time('bTimer');</script>";
 
-    yield waitForMessages({
-      webconsole: hud2,
-      messages: [{
-        name: "bTimer started",
-        consoleTime: "bTimer",
-      }],
-    });
-
-    hud2.jsterm.clearOutput();
-
-    deferred = promise.defer();
-
-    // Now the following console.timeEnd() call shouldn't display anything,
-    // if the timers in different pages are not related.
-    browser.addEventListener("load", function onLoad() {
-      browser.removeEventListener("load", onLoad, true);
-      deferred.resolve(null);
-    }, true);
-
-    content.location = "data:text/html;charset=utf-8," +
+const TEST_URI4 = "data:text/html;charset=utf-8," +
                        "<script>console.timeEnd('bTimer');</script>";
 
-    yield deferred.promise;
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
 
-    testLogEntry(hud2.outputNode, "bTimer: timer started",
-                 "bTimer was not started", false, true);
+  let hud1 = yield openConsole();
 
-    yield closeConsole(gBrowser.selectedTab);
+  yield waitForMessages({
+    webconsole: hud1,
+    messages: [{
+      name: "aTimer started",
+      consoleTime: "aTimer",
+    }, {
+      name: "aTimer end",
+      consoleTimeEnd: "aTimer",
+    }],
+  });
 
-    gBrowser.removeCurrentTab();
+  // The next test makes sure that timers with the same name but in separate
+  // tabs, do not contain the same value.
+  let { browser } = yield loadTab(TEST_URI2);
+  let hud2 = yield openConsole();
 
-    executeSoon(finishTest);
-  }
-}
+  testLogEntry(hud2.outputNode, "bTimer: timer started",
+               "bTimer was not started", false, true);
+
+  // The next test makes sure that timers with the same name but in separate
+  // pages, do not contain the same value.
+  content.location = TEST_URI3;
+
+  yield waitForMessages({
+    webconsole: hud2,
+    messages: [{
+      name: "bTimer started",
+      consoleTime: "bTimer",
+    }],
+  });
+
+  hud2.jsterm.clearOutput();
+
+  // Now the following console.timeEnd() call shouldn't display anything,
+  // if the timers in different pages are not related.
+  content.location = TEST_URI4;
+  yield loadBrowser(browser);
+
+  testLogEntry(hud2.outputNode, "bTimer: timer started",
+               "bTimer was not started", false, true);
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_659907_console_dir.js b/browser/devtools/webconsole/test/browser_webconsole_bug_659907_console_dir.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_659907_console_dir.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_659907_console_dir.js
@@ -1,29 +1,28 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /*
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // Tests that console.dir works as intended.
 
-function test() {
-  addTab("data:text/html;charset=utf-8,Web Console test for bug 659907: Expand console " +
-         "object with a dir method");
-  browser.addEventListener("load", function onLoad(aEvent) {
-    browser.removeEventListener(aEvent.type, onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
+"use strict";
 
-function consoleOpened(hud) {
+const TEST_URI = "data:text/html;charset=utf-8,Web Console test for bug 659907: " +
+  "Expand console object with a dir method"
+
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
+  hud.jsterm.clearOutput();
+
   hud.jsterm.execute("console.dir(document)");
-  hud.jsterm.once("variablesview-fetched", testConsoleDir.bind(null, hud));
-}
 
-function testConsoleDir(hud, ev, view) {
-  findVariableViewProperties(view, [
+  let varView = yield hud.jsterm.once("variablesview-fetched");
+
+  yield findVariableViewProperties(varView, [
     { name: "__proto__.__proto__.querySelectorAll", value: "querySelectorAll()" },
     { name: "location", value: /Location \u2192 data:Web/ },
     { name: "__proto__.write", value: "write()" },
-  ], { webconsole: hud }).then(finishTest);
-}
+  ], { webconsole: hud });
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_660806_history_nav.js b/browser/devtools/webconsole/test/browser_webconsole_bug_660806_history_nav.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_660806_history_nav.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_660806_history_nav.js
@@ -1,35 +1,37 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* Any copyright is dedicated to the Public Domain.
    http://creativecommons.org/publicdomain/zero/1.0/ */
 
 const TEST_URI = "data:text/html;charset=utf-8,<p>bug 660806 - history navigation must not show the autocomplete popup";
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+
+  let hud = yield openConsole();
+
+  yield consoleOpened(hud);
+});
 
 function consoleOpened(HUD)
 {
-  content.wrappedJSObject.foobarBug660806 = {
-    "location": "value0",
-    "locationbar": "value1",
-  };
+  let deferred = promise.defer();
 
   let jsterm = HUD.jsterm;
   let popup = jsterm.autocompletePopup;
   let onShown = function() {
     ok(false, "popup shown");
   };
 
+  jsterm.execute("window.foobarBug660806 = {\
+    'location': 'value0',\
+    'locationbar': 'value1'\
+  }");
+
   popup._panel.addEventListener("popupshown", onShown, false);
 
   ok(!popup.isOpen, "popup is not open");
 
   ok(!jsterm.lastInputValue, "no lastInputValue");
   jsterm.setInputValue("window.foobarBug660806.location");
   is(jsterm.lastInputValue, "window.foobarBug660806.location",
      "lastInputValue is correct");
@@ -38,11 +40,12 @@ function consoleOpened(HUD)
   EventUtils.synthesizeKey("VK_UP", {});
 
   is(jsterm.lastInputValue, "window.foobarBug660806.location",
      "lastInputValue is correct, again");
 
   executeSoon(function() {
     ok(!popup.isOpen, "popup is not open");
     popup._panel.removeEventListener("popupshown", onShown, false);
-    executeSoon(finishTest);
+    executeSoon(deferred.resolve);
   });
+  return deferred.promise;
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_664131_console_group.js b/browser/devtools/webconsole/test/browser_webconsole_bug_664131_console_group.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_664131_console_group.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_664131_console_group.js
@@ -2,78 +2,76 @@
 /*
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // Tests that console.group/groupEnd works as intended.
 const TEST_URI = "data:text/html;charset=utf-8,Web Console test for bug 664131: Expand console object with group methods";
 
-function test() {
-  Task.spawn(runner).then(finishTest);
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
 
-  function* runner() {
-    let {tab} = yield loadTab(TEST_URI);
-    let hud = yield openConsole(tab);
-    let outputNode = hud.outputNode;
+  let hud = yield openConsole();
+  let jsterm = hud.jsterm;
+  let outputNode = hud.outputNode;
 
-    hud.jsterm.clearOutput();
+  hud.jsterm.clearOutput();
 
-    content.console.group("bug664131a");
+  jsterm.execute("console.group('bug664131a')")
 
-    yield waitForMessages({
-      webconsole: hud,
-      messages: [{
-        text: "bug664131a",
-        consoleGroup: 1,
-      }],
-    });
+  yield waitForMessages({
+    webconsole: hud,
+    messages: [{
+      text: "bug664131a",
+      consoleGroup: 1,
+    }],
+  });
 
-    content.console.log("bug664131a-inside");
+  jsterm.execute("console.log('bug664131a-inside')")
 
-    yield waitForMessages({
-      webconsole: hud,
-      messages: [{
-        text: "bug664131a-inside",
-        category: CATEGORY_WEBDEV,
-        severity: SEVERITY_LOG,
-        groupDepth: 1,
-      }],
-    });
+  yield waitForMessages({
+    webconsole: hud,
+    messages: [{
+      text: "bug664131a-inside",
+      category: CATEGORY_WEBDEV,
+      severity: SEVERITY_LOG,
+      groupDepth: 1,
+    }],
+  });
 
-    content.console.groupEnd("bug664131a");
-    content.console.log("bug664131-outside");
+  jsterm.execute('console.groupEnd("bug664131a")');
+  jsterm.execute('console.log("bug664131-outside")');
 
-    yield waitForMessages({
-      webconsole: hud,
-      messages: [{
-        text: "bug664131-outside",
-        category: CATEGORY_WEBDEV,
-        severity: SEVERITY_LOG,
-        groupDepth: 0,
-      }],
-    });
+  yield waitForMessages({
+    webconsole: hud,
+    messages: [{
+      text: "bug664131-outside",
+      category: CATEGORY_WEBDEV,
+      severity: SEVERITY_LOG,
+      groupDepth: 0,
+    }],
+  });
 
-    content.console.groupCollapsed("bug664131b");
+  jsterm.execute('console.groupCollapsed("bug664131b")');
 
-    yield waitForMessages({
-      webconsole: hud,
-      messages: [{
-        text: "bug664131b",
-        consoleGroup: 1,
-      }],
-    });
+  yield waitForMessages({
+    webconsole: hud,
+    messages: [{
+      text: "bug664131b",
+      consoleGroup: 1,
+    }],
+  });
 
-    // Test that clearing the console removes the indentation.
-    hud.jsterm.clearOutput();
-    content.console.log("bug664131-cleared");
+  // Test that clearing the console removes the indentation.
+  hud.jsterm.clearOutput();
+  jsterm.execute('console.log("bug664131-cleared")');
 
-    yield waitForMessages({
-      webconsole: hud,
-      messages: [{
-        text: "bug664131-cleared",
-        category: CATEGORY_WEBDEV,
-        severity: SEVERITY_LOG,
-        groupDepth: 0,
-      }],
-    });
-  }
-}
+  yield waitForMessages({
+    webconsole: hud,
+    messages: [{
+      text: "bug664131-cleared",
+      category: CATEGORY_WEBDEV,
+      severity: SEVERITY_LOG,
+      groupDepth: 0,
+    }],
+  });
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_686937_autocomplete_JSTerm_helpers.js b/browser/devtools/webconsole/test/browser_webconsole_bug_686937_autocomplete_JSTerm_helpers.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_686937_autocomplete_JSTerm_helpers.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_686937_autocomplete_JSTerm_helpers.js
@@ -2,73 +2,57 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Tests that the autocompletion results contain the names of JSTerm helpers.
 
 const TEST_URI = "data:text/html;charset=utf8,<p>test JSTerm Helpers autocomplete";
 
-let testDriver;
+let jsterm;
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, function(hud) {
-      testDriver = testCompletion(hud);
-      testDriver.next();
-    });
-  }, true);
-}
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
 
-function testNext() {
-  executeSoon(function() {
-    testDriver.next();
-  });
-}
+  let hud = yield openConsole();
 
-function testCompletion(hud) {
-  let jsterm = hud.jsterm;
+  jsterm = hud.jsterm;
   let input = jsterm.inputNode;
   let popup = jsterm.autocompletePopup;
 
   // Test if 'i' gives 'inspect'
   input.value = "i";
   input.setSelectionRange(1, 1);
-  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
-  yield;
+  yield complete(jsterm.COMPLETE_HINT_ONLY);
 
   let newItems = popup.getItems().map(function(e) {return e.label;});
   ok(newItems.indexOf("inspect") > -1, "autocomplete results contain helper 'inspect'");
-  
+
   // Test if 'window.' does not give 'inspect'.
   input.value = "window.";
   input.setSelectionRange(7, 7);
-  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
-  yield;
+  yield complete(jsterm.COMPLETE_HINT_ONLY);
 
   newItems = popup.getItems().map(function(e) {return e.label;});
   is(newItems.indexOf("inspect"), -1, "autocomplete results do not contain helper 'inspect'");
 
-
-// Test if 'dump(i' gives 'inspect'
+  // Test if 'dump(i' gives 'inspect'
   input.value = "dump(i";
   input.setSelectionRange(6, 6);
-  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
-  yield;
+  yield complete(jsterm.COMPLETE_HINT_ONLY);
 
   newItems = popup.getItems().map(function(e) {return e.label;});
   ok(newItems.indexOf("inspect") > -1, "autocomplete results contain helper 'inspect'");
 
-// Test if 'window.dump(i' gives 'inspect'
+  // Test if 'window.dump(i' gives 'inspect'
   input.value = "window.dump(i";
   input.setSelectionRange(13, 13);
-  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
-  yield;
+  yield complete(jsterm.COMPLETE_HINT_ONLY);
 
   newItems = popup.getItems().map(function(e) {return e.label;});
   ok(newItems.indexOf("inspect") > -1, "autocomplete results contain helper 'inspect'");
+});
 
-  testDriver = jsterm = input = popup = newItems = null;
-  executeSoon(finishTest);
-  yield;
-}
+function complete(type) {
+  let updated = jsterm.once("autocomplete-updated");
+  jsterm.complete(type);
+  return updated;
+}
\ No newline at end of file
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_704295.js b/browser/devtools/webconsole/test/browser_webconsole_bug_704295.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_704295.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_704295.js
@@ -2,41 +2,38 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Tests for bug 704295
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, testCompletion);
-  }, true);
-}
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+
+  let hud = yield openConsole();
+
+  testCompletion(hud);
+});
 
 function testCompletion(hud) {
   var jsterm = hud.jsterm;
   var input = jsterm.inputNode;
 
   // Test typing 'var d = 5;' and press RETURN
   jsterm.setInputValue("var d = ");
   EventUtils.synthesizeKey("5", {});
   EventUtils.synthesizeKey(";", {});
   is(input.value, "var d = 5;", "var d = 5;");
   is(jsterm.completeNode.value, "", "no completion");
   EventUtils.synthesizeKey("VK_RETURN", {});
   is(jsterm.completeNode.value, "", "clear completion on execute()");
-  
+
   // Test typing 'var a = d' and press RETURN
   jsterm.setInputValue("var a = ");
   EventUtils.synthesizeKey("d", {});
   is(input.value, "var a = d", "var a = d");
   is(jsterm.completeNode.value, "", "no completion");
   EventUtils.synthesizeKey("VK_RETURN", {});
   is(jsterm.completeNode.value, "", "clear completion on execute()");
-  
-  jsterm = input = null;
-  finishTest();
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_734061_No_input_change_and_Tab_key_pressed.js b/browser/devtools/webconsole/test/browser_webconsole_bug_734061_No_input_change_and_Tab_key_pressed.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_734061_No_input_change_and_Tab_key_pressed.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_734061_No_input_change_and_Tab_key_pressed.js
@@ -1,24 +1,20 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/browser/test-console.html";
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, testInputChange);
-  }, true);
-}
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
 
-function testInputChange(hud) {
+  let hud = yield openConsole();
+
   var jsterm = hud.jsterm;
   var input = jsterm.inputNode;
 
   is(input.getAttribute("focused"), "true", "input has focus");
   EventUtils.synthesizeKey("VK_TAB", {});
   is(input.getAttribute("focused"), "", "focus moved away");
 
   // Test user changed something
@@ -28,12 +24,9 @@ function testInputChange(hud) {
   is(input.getAttribute("focused"), "true", "input is still focused");
 
   // Test non empty input but not changed since last focus
   input.blur();
   input.focus();
   EventUtils.synthesizeKey("VK_RIGHT", {});
   EventUtils.synthesizeKey("VK_TAB", {});
   is(input.getAttribute("focused"), "", "input moved away");
-
-  jsterm = input = null;
-  finishTest();
-}
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_737873_mixedcontent.js b/browser/devtools/webconsole/test/browser_webconsole_bug_737873_mixedcontent.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_737873_mixedcontent.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_737873_mixedcontent.js
@@ -5,34 +5,37 @@
  *
  * Contributor(s):
  *  Tanvi Vyas <tanvi@mozilla.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
 // Tests that the Web Console Mixed Content messages are displayed
 
+const TEST_URI = "data:text/html;charset=utf8,Web Console mixed content test";
 const TEST_HTTPS_URI = "https://example.com/browser/browser/devtools/webconsole/test/test-bug-737873-mixedcontent.html";
 
-function test() {
-  addTab("data:text/html;charset=utf8,Web Console mixed content test");
-  browser.addEventListener("load", onLoad, true);
-}
-
-function onLoad(aEvent) {
-  browser.removeEventListener("load", onLoad, true);
+let test = asyncTest(function* () {
   Services.prefs.setBoolPref("security.mixed_content.block_display_content", false);
   Services.prefs.setBoolPref("security.mixed_content.block_active_content", false);
-  openConsole(null, testMixedContent);
-}
+
+  yield loadTab(TEST_URI);
+
+  let hud = yield openConsole();
+
+  yield testMixedContent(hud);
+
+  Services.prefs.clearUserPref("security.mixed_content.block_display_content");
+  Services.prefs.clearUserPref("security.mixed_content.block_active_content");
+});
 
 function testMixedContent(hud) {
   content.location = TEST_HTTPS_URI;
 
-  waitForMessages({
+  return waitForMessages({
     webconsole: hud,
     messages: [{
       text: "example.com",
       category: CATEGORY_NETWORK,
       severity: SEVERITY_WARNING,
     }],
   }).then((results) => {
     let msg = [...results[0].matched][0];
@@ -59,15 +62,10 @@ function testMixedContent(hud) {
 
     ok(!msg.classList.contains("filtered-by-type"), "message is not filtered");
 
     hud.setFilterState("netwarn", false);
 
     ok(msg.classList.contains("filtered-by-type"), "message is filtered");
 
     hud.setFilterState("netwarn", true);
-
-    Services.prefs.clearUserPref("security.mixed_content.block_display_content");
-    Services.prefs.clearUserPref("security.mixed_content.block_active_content");
-
-    finishTest();
   });
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_762593_insecure_passwords_about_blank_web_console_warning.js b/browser/devtools/webconsole/test/browser_webconsole_bug_762593_insecure_passwords_about_blank_web_console_warning.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_762593_insecure_passwords_about_blank_web_console_warning.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_762593_insecure_passwords_about_blank_web_console_warning.js
@@ -3,27 +3,26 @@
 /*
  * Tests that errors about insecure passwords are logged
  * to the web console
  */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-bug-762593-insecure-passwords-about-blank-web-console-warning.html";
 const INSECURE_PASSWORD_MSG = "Password fields present on an insecure (http://) page. This is a security risk that allows user login credentials to be stolen.";
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad(aEvent) {
-    browser.removeEventListener(aEvent.type, onLoad, true);
-    openConsole(null, function testInsecurePasswordErrorLogged (hud) {
-      waitForMessages({
-        webconsole: hud,
-        messages: [
-          {
-            name: "Insecure password error displayed successfully",
-            text: INSECURE_PASSWORD_MSG,
-            category: CATEGORY_SECURITY,
-            severity: SEVERITY_WARNING
-          },
-        ],
-      }).then(finishTest);
-    });
-  }, true);
-}
+
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+
+  let hud = yield openConsole();
+
+  yield waitForMessages({
+    webconsole: hud,
+    messages: [
+      {
+        name: "Insecure password error displayed successfully",
+        text: INSECURE_PASSWORD_MSG,
+        category: CATEGORY_SECURITY,
+        severity: SEVERITY_WARNING
+      },
+    ],
+  });
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_762593_insecure_passwords_web_console_warning.js b/browser/devtools/webconsole/test/browser_webconsole_bug_762593_insecure_passwords_web_console_warning.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_762593_insecure_passwords_web_console_warning.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_762593_insecure_passwords_web_console_warning.js
@@ -6,47 +6,48 @@
  */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-bug-762593-insecure-passwords-web-console-warning.html";
 const INSECURE_PASSWORD_MSG = "Password fields present on an insecure (http://) page. This is a security risk that allows user login credentials to be stolen.";
 const INSECURE_FORM_ACTION_MSG = "Password fields present in a form with an insecure (http://) form action. This is a security risk that allows user login credentials to be stolen.";
 const INSECURE_IFRAME_MSG = "Password fields present on an insecure (http://) iframe. This is a security risk that allows user login credentials to be stolen.";
 const INSECURE_PASSWORDS_URI = "https://developer.mozilla.org/docs/Security/InsecurePasswords";
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad(aEvent) {
-    browser.removeEventListener(aEvent.type, onLoad, true);
-    openConsole(null, function testInsecurePasswordErrorLogged (hud) {
-      waitForMessages({
-        webconsole: hud,
-        messages: [
-          {
-            name: "Insecure password error displayed successfully",
-            text: INSECURE_PASSWORD_MSG,
-            category: CATEGORY_SECURITY,
-            severity: SEVERITY_WARNING
-          },
-          {
-            name: "Insecure iframe error displayed successfully",
-            text: INSECURE_IFRAME_MSG,
-            category: CATEGORY_SECURITY,
-            severity: SEVERITY_WARNING
-          },
-          {
-            name: "Insecure form action error displayed successfully",
-            text: INSECURE_FORM_ACTION_MSG,
-            category: CATEGORY_SECURITY,
-            severity: SEVERITY_WARNING
-          },
-        ],
-      }).then(testClickOpenNewTab.bind(null, hud));
-    });
-  }, true);
-}
+
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+
+  let hud = yield openConsole();
+
+  let result = yield waitForMessages({
+    webconsole: hud,
+    messages: [
+      {
+        name: "Insecure password error displayed successfully",
+        text: INSECURE_PASSWORD_MSG,
+        category: CATEGORY_SECURITY,
+        severity: SEVERITY_WARNING
+      },
+      {
+        name: "Insecure iframe error displayed successfully",
+        text: INSECURE_IFRAME_MSG,
+        category: CATEGORY_SECURITY,
+        severity: SEVERITY_WARNING
+      },
+      {
+        name: "Insecure form action error displayed successfully",
+        text: INSECURE_FORM_ACTION_MSG,
+        category: CATEGORY_SECURITY,
+        severity: SEVERITY_WARNING
+      },
+    ],
+  });
+
+  testClickOpenNewTab(hud, result);
+});
 
 function testClickOpenNewTab(hud, [result]) {
   let msg = [...result.matched][0];
   let warningNode = msg.querySelector(".learn-more-link");
   ok(warningNode, "learn more link");
 
   // Invoke the click event and check if a new tab would open to the correct
   // page
@@ -57,11 +58,9 @@ function testClickOpenNewTab(hud, [resul
       linkOpened = true;
     }
   }
 
   EventUtils.synthesizeMouse(warningNode, 2, 2, {},
                              warningNode.ownerDocument.defaultView);
   ok(linkOpened, "Clicking the Insecure Passwords Warning node opens the desired page");
   window.openUILinkIn = oldOpenUILinkIn;
-
-  finishTest();
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_764572_output_open_url.js b/browser/devtools/webconsole/test/browser_webconsole_bug_764572_output_open_url.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_764572_output_open_url.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_764572_output_open_url.js
@@ -5,88 +5,89 @@
 // This is a test for the Open URL context menu item
 // that is shown for network requests
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html"
 const COMMAND_NAME = "consoleCmd_openURL";
 const CONTEXT_MENU_ID = "#menu_openURL";
 
 let HUD = null, outputNode = null, contextMenu = null;
 
-function test() {
-  let original = Services.prefs.getBoolPref("devtools.webconsole.filter.networkinfo");
+let test = asyncTest(function* () {
   Services.prefs.setBoolPref("devtools.webconsole.filter.networkinfo", true);
-  registerCleanupFunction(() => {
-    Services.prefs.setBoolPref("devtools.webconsole.filter.networkinfo", original);
-  });
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
 
-function consoleOpened(aHud) {
-  HUD = aHud;
-  outputNode = aHud.outputNode;
+  yield loadTab(TEST_URI);
+  HUD = yield openConsole();
+
+  let results = yield consoleOpened();
+  yield onConsoleMessage(results);
+
+  let results2 = yield testOnNetActivity();
+  let msg = yield onNetworkMessage(results2);
+
+  yield testOnNetActivity_contextmenu(msg);
+
+  Services.prefs.clearUserPref("devtools.webconsole.filter.networkinfo");
+});
+
+function consoleOpened() {
+  outputNode = HUD.outputNode;
   contextMenu = HUD.iframeWindow.document.getElementById("output-contextmenu");
 
-  registerCleanupFunction(() => {
-    HUD = outputNode = contextMenu = null;
-  });
-
   HUD.jsterm.clearOutput();
 
   content.console.log("bug 764572");
 
-  waitForMessages({
+  return waitForMessages({
     webconsole: HUD,
     messages: [{
       text: "bug 764572",
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG,
     }],
-  }).then(onConsoleMessage);
+  });
 }
 
 function onConsoleMessage(aResults) {
   outputNode.focus();
   outputNode.selectedItem = [...aResults[0].matched][0];
 
   // Check if the command is disabled non-network messages.
   goUpdateCommand(COMMAND_NAME);
   let controller = top.document.commandDispatcher
                    .getControllerForCommand(COMMAND_NAME);
 
   let isDisabled = !controller || !controller.isCommandEnabled(COMMAND_NAME);
   ok(isDisabled, COMMAND_NAME + " should be disabled.");
 
   outputNode.selectedItem.scrollIntoView();
-  waitForContextMenu(contextMenu, outputNode.selectedItem, () => {
+  return waitForContextMenu(contextMenu, outputNode.selectedItem, () => {
     let isHidden = contextMenu.querySelector(CONTEXT_MENU_ID).hidden;
     ok(isHidden, CONTEXT_MENU_ID + " should be hidden.");
-  }, testOnNetActivity);
+  });
 }
 
 function testOnNetActivity() {
   HUD.jsterm.clearOutput();
 
   // Reload the url to show net activity in console.
   content.location.reload();
 
-  waitForMessages({
+  return waitForMessages({
     webconsole: HUD,
     messages: [{
       text: "test-console.html",
       category: CATEGORY_NETWORK,
       severity: SEVERITY_LOG,
     }],
-  }).then(onNetworkMessage);
+  });
 }
 
 function onNetworkMessage(aResults) {
+  let deferred = promise.defer();
+
   outputNode.focus();
   let msg = [...aResults[0].matched][0];
   ok(msg, "network message");
   HUD.ui.output.selectMessage(msg);
 
   let currentTab = gBrowser.selectedTab;
   let newTab = null;
 
@@ -95,32 +96,40 @@ function onNetworkMessage(aResults) {
     newTab = aEvent.target;
     newTab.linkedBrowser.addEventListener("load", onTabLoaded, true);
   }, true);
 
   function onTabLoaded() {
     newTab.linkedBrowser.removeEventListener("load", onTabLoaded, true);
     gBrowser.removeTab(newTab);
     gBrowser.selectedTab = currentTab;
-    executeSoon(testOnNetActivity_contextmenu.bind(null, msg));
+    executeSoon(deferred.resolve.bind(null, msg));
   }
 
   // Check if the command is enabled for a network message.
   goUpdateCommand(COMMAND_NAME);
   let controller = top.document.commandDispatcher
                    .getControllerForCommand(COMMAND_NAME);
   ok(controller.isCommandEnabled(COMMAND_NAME),
      COMMAND_NAME + " should be enabled.");
 
   // Try to open the URL.
   goDoCommand(COMMAND_NAME);
+
+  return deferred.promise;
 }
 
 function testOnNetActivity_contextmenu(msg) {
+  let deferred = promise.defer();
+
   outputNode.focus();
   HUD.ui.output.selectMessage(msg);
+  msg.scrollIntoView();
 
-  msg.scrollIntoView();
+  info("net activity context menu");
+
   waitForContextMenu(contextMenu, msg, () => {
     let isShown = !contextMenu.querySelector(CONTEXT_MENU_ID).hidden;
     ok(isShown, CONTEXT_MENU_ID + " should be shown.");
-  }, finishTest);
+  }).then(deferred.resolve);
+
+  return deferred.promise;
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_766001_JS_Console_in_Debugger.js b/browser/devtools/webconsole/test/browser_webconsole_bug_766001_JS_Console_in_Debugger.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_766001_JS_Console_in_Debugger.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_766001_JS_Console_in_Debugger.js
@@ -14,16 +14,17 @@ const TEST_URI = "http://example.com/bro
 function test() {
   let hud;
 
   requestLongerTimeout(2);
   Task.spawn(runner).then(finishTest);
 
   function* runner() {
     expectUncaughtException();
+
     let {tab} = yield loadTab(TEST_URI);
     hud = yield openConsole(tab);
 
     let [exceptionRule, consoleRule] = yield waitForMessages({
       webconsole: hud,
       messages: [{
         text: "document.bar",
         category: CATEGORY_JS,
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_770099_violation.js b/browser/devtools/webconsole/test/browser_webconsole_bug_770099_violation.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_770099_violation.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_770099_violation.js
@@ -2,45 +2,30 @@
 /* ***** BEGIN LICENSE BLOCK *****
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  *
  * ***** END LICENSE BLOCK ***** */
 
 // Tests that the Web Console CSP messages are displayed
 
+const TEST_URI = "data:text/html;charset=utf8,Web Console CSP violation test";
 const TEST_VIOLATION = "https://example.com/browser/browser/devtools/webconsole/test/test_bug_770099_violation.html";
 const CSP_VIOLATION_MSG = 'Content Security Policy: The page\'s settings blocked the loading of a resource at http://some.example.com/test.png ("default-src https://example.com").'
 
-let hud = undefined;
+let test = asyncTest(function* () {
+  let { browser } = yield loadTab(TEST_URI);
 
-function test() {
-  addTab("data:text/html;charset=utf8,Web Console CSP violation test");
-  browser.addEventListener("load", function _onLoad() {
-    browser.removeEventListener("load", _onLoad, true);
-    openConsole(null, loadDocument);
-  }, true);
-}
+  let hud = yield openConsole();
 
-function loadDocument(theHud){
-  hud = theHud;
-  hud.jsterm.clearOutput()
-  browser.addEventListener("load", onLoad, true);
+  hud.jsterm.clearOutput();
+
+  let loaded = loadBrowser(browser);
   content.location = TEST_VIOLATION;
-}
+  yield loaded;
 
-function onLoad(aEvent) {
-  browser.removeEventListener("load", onLoad, true);
-  testViolationMessage();
-}
-
-function testViolationMessage(){
-  let aOutputNode = hud.outputNode;
-
-  waitForSuccess({
-      name: "CSP policy URI warning displayed successfully",
-      validatorFn: function() {
-        return hud.outputNode.textContent.indexOf(CSP_VIOLATION_MSG) > -1;
-      },
-      successFn: finishTest,
-      failureFn: finishTest,
-    });
-}
+  yield waitForSuccess({
+    name: "CSP policy URI warning displayed successfully",
+    validator: function() {
+      return hud.outputNode.textContent.indexOf(CSP_VIOLATION_MSG) > -1;
+    }
+  });
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_782653_CSS_links_in_Style_Editor.js b/browser/devtools/webconsole/test/browser_webconsole_bug_782653_CSS_links_in_Style_Editor.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_782653_CSS_links_in_Style_Editor.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_782653_CSS_links_in_Style_Editor.js
@@ -4,32 +4,28 @@
  * http://creativecommons.org/publicdomain/zero/1.0/
  * ***** END LICENSE BLOCK ***** */
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test" +
                  "/test-bug-782653-css-errors.html";
 
 let nodes, hud, StyleEditorUI;
 
-function test()
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+
+  hud = yield openConsole();
+
+  let styleEditor = yield testViewSource();
+  yield onStyleEditorReady(styleEditor);
+});
+
+function testViewSource()
 {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, testViewSource);
-  }, true);
-}
-
-function testViewSource(aHud)
-{
-  hud = aHud;
-
-  registerCleanupFunction(function() {
-    nodes = hud = StyleEditorUI = null;
-  });
+  let deferred = promise.defer();
 
   waitForMessages({
     webconsole: hud,
     messages: [{
       text: "'font-weight'",
       category: CATEGORY_CSS,
       severity: SEVERITY_WARNING,
     },
@@ -49,94 +45,101 @@ function testViewSource(aHud)
     let target = TargetFactory.forTab(gBrowser.selectedTab);
     let toolbox = gDevTools.getToolbox(target);
     toolbox.once("styleeditor-selected", (event, panel) => {
       StyleEditorUI = panel.UI;
 
       let count = 0;
       StyleEditorUI.on("editor-added", function() {
         if (++count == 2) {
-          onStyleEditorReady(panel);
+          deferred.resolve(panel);
         }
       });
     });
 
     EventUtils.sendMouseEvent({ type: "click" }, nodes[0]);
   });
+
+  return deferred.promise;
 }
 
 function onStyleEditorReady(aPanel)
 {
+  let deferred = promise.defer();
+
   let win = aPanel.panelWindow;
   ok(win, "Style Editor Window is defined");
   ok(StyleEditorUI, "Style Editor UI is defined");
 
   waitForFocus(function() {
     info("style editor window focused");
 
     let href = nodes[0].getAttribute("title");
     let line = nodes[0].sourceLine;
     ok(line, "found source line");
 
-    checkStyleEditorForSheetAndLine(href, line - 1, function() {
+    checkStyleEditorForSheetAndLine(href, line - 1).then(function() {
       info("first check done");
 
       let target = TargetFactory.forTab(gBrowser.selectedTab);
       let toolbox = gDevTools.getToolbox(target);
 
       let href = nodes[1].getAttribute("title");
       let line = nodes[1].sourceLine;
       ok(line, "found source line");
 
       toolbox.selectTool("webconsole").then(function() {
         info("webconsole selected");
 
         toolbox.once("styleeditor-selected", function(aEvent) {
           info(aEvent + " event fired");
 
-          checkStyleEditorForSheetAndLine(href, line - 1, function() {
-            info("second check done");
-            finishTest();
-          });
+          checkStyleEditorForSheetAndLine(href, line - 1).then(deferred.resolve);
         });
 
         EventUtils.sendMouseEvent({ type: "click" }, nodes[1]);
       });
     });
   }, win);
+
+  return deferred.promise;
 }
 
-function checkStyleEditorForSheetAndLine(aHref, aLine, aCallback)
+function checkStyleEditorForSheetAndLine(aHref, aLine)
 {
   let foundEditor = null;
   for (let editor of StyleEditorUI.editors) {
     if (editor.styleSheet.href == aHref) {
       foundEditor = editor;
       break;
     }
   }
 
   ok(foundEditor, "found style editor for " + aHref);
-  performLineCheck(foundEditor, aLine, aCallback);
+  return performLineCheck(foundEditor, aLine);
 }
 
-function performLineCheck(aEditor, aLine, aCallback)
+function performLineCheck(aEditor, aLine)
 {
+  let deferred = promise.defer();
+
   function checkForCorrectState()
   {
     is(aEditor.sourceEditor.getCursor().line, aLine,
        "correct line is selected");
     is(StyleEditorUI.selectedStyleSheetIndex, aEditor.styleSheet.styleSheetIndex,
        "correct stylesheet is selected in the editor");
 
-    aCallback && executeSoon(aCallback);
+    executeSoon(deferred.resolve);
   }
 
   info("wait for source editor to load");
 
   // Get out of the styleeditor-selected event loop.
   executeSoon(() => {
     aEditor.getSourceEditor().then(() => {
       // Get out of the editor's source-editor-load event loop.
       executeSoon(checkForCorrectState);
     });
   });
+
+  return deferred.promise;
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_804845_ctrl_key_nav.js b/browser/devtools/webconsole/test/browser_webconsole_bug_804845_ctrl_key_nav.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_804845_ctrl_key_nav.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_804845_ctrl_key_nav.js
@@ -6,39 +6,40 @@
  *
  * Contributor(s):
  *  zmgmoz <zmgmoz@gmail.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
 // Test navigation of webconsole contents via ctrl-a, ctrl-e, ctrl-p, ctrl-n
 // see https://bugzilla.mozilla.org/show_bug.cgi?id=804845
+"use strict";
+
+const TEST_URI = "data:text/html;charset=utf-8,Web Console test for bug 804845 and bug 619598";
 
 let jsterm, inputNode;
-function test() {
-  addTab("data:text/html;charset=utf-8,Web Console test for bug 804845 and bug 619598");
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, doTests);
-  }, true);
-}
+
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+
+  let hud = yield openConsole();
+
+  doTests(hud);
+});
 
 function doTests(HUD) {
   jsterm = HUD.jsterm;
   inputNode = jsterm.inputNode;
   ok(!jsterm.inputNode.value, "inputNode.value is empty");
   is(jsterm.inputNode.selectionStart, 0);
   is(jsterm.inputNode.selectionEnd, 0);
 
   testSingleLineInputNavNoHistory();
   testMultiLineInputNavNoHistory();
   testNavWithHistory();
-
-  jsterm = inputNode = null;
-  executeSoon(finishTest);
 }
 
 function testSingleLineInputNavNoHistory() {
   // Single char input
   EventUtils.synthesizeKey("1", {});
   is(inputNode.selectionStart, 1, "caret location after single char input");
 
   // nav to start/end with ctrl-a and ctrl-e;
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_817834_add_edited_input_to_history.js b/browser/devtools/webconsole/test/browser_webconsole_bug_817834_add_edited_input_to_history.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_817834_add_edited_input_to_history.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_817834_add_edited_input_to_history.js
@@ -8,23 +8,27 @@
  *  zmgmoz <zmgmoz@gmail.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
 // Test that user input that is not submitted in the command line input is not
 // lost after navigating in history.
 // See https://bugzilla.mozilla.org/show_bug.cgi?id=817834
 
-function test() {
-  addTab("data:text/html;charset=utf-8,Web Console test for bug 817834");
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, testEditedInputHistory);
-  }, true);
-}
+"use strict";
+
+const TEST_URI = "data:text/html;charset=utf-8,Web Console test for bug 817834";
+
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+
+  let hud = yield openConsole();
+
+  testEditedInputHistory(hud);
+});
 
 function testEditedInputHistory(HUD) {
   let jsterm = HUD.jsterm;
   let inputNode = jsterm.inputNode;
   ok(!inputNode.value, "inputNode.value is empty");
   is(inputNode.selectionStart, 0);
   is(inputNode.selectionEnd, 0);
 
@@ -51,11 +55,9 @@ function testEditedInputHistory(HUD) {
   is(inputNode.value, '"second item"', "test history up");
   EventUtils.synthesizeKey("VK_UP", {});
   is(inputNode.value, '"first item"', "test history up");
   EventUtils.synthesizeKey("VK_DOWN", {});
   is(inputNode.value, '"second item"', "test history down");
   EventUtils.synthesizeKey("VK_DOWN", {});
   is(inputNode.value, '"editing input 2"',
      "test history down restores new in-progress input again");
-
-  executeSoon(finishTest);
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_bug_837351_securityerrors.js b/browser/devtools/webconsole/test/browser_webconsole_bug_837351_securityerrors.js
--- a/browser/devtools/webconsole/test/browser_webconsole_bug_837351_securityerrors.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_bug_837351_securityerrors.js
@@ -1,34 +1,36 @@
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 const TEST_URI = "https://example.com/browser/browser/devtools/webconsole/test/test-bug-837351-security-errors.html";
 
-function run_test()
+let test = asyncTest(function* () {
+  yield pushPrefEnv();
+
+  yield loadTab(TEST_URI);
+
+  let hud = yield openConsole();
+
+  let button = hud.ui.rootElement.querySelector(".webconsole-filter-button[category=\"security\"]");
+  ok(button, "Found security button in the web console");
+
+  yield waitForMessages({
+    webconsole: hud,
+    messages: [
+      {
+        name: "Logged blocking mixed active content",
+        text: "Blocked loading mixed active content \"http://example.com/\"",
+        category: CATEGORY_SECURITY,
+        severity: SEVERITY_ERROR
+      },
+    ],
+  });
+});
+
+function pushPrefEnv()
 {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad(aEvent) {
-    browser.removeEventListener(aEvent.type, onLoad, true);
-    openConsole(null, function testSecurityErrorLogged (hud) {
-      let button = hud.ui.rootElement.querySelector(".webconsole-filter-button[category=\"security\"]");
-      ok(button, "Found security button in the web console");
-
-      waitForMessages({
-        webconsole: hud,
-        messages: [
-          {
-            name: "Logged blocking mixed active content",
-            text: "Blocked loading mixed active content \"http://example.com/\"",
-            category: CATEGORY_SECURITY,
-            severity: SEVERITY_ERROR
-          },
-        ],
-      }).then(finishTest);
-    });
-  }, true);
+  let deferred = promise.defer();
+  let options = {'set': [["security.mixed_content.block_active_content", true]]};
+  SpecialPowers.pushPrefEnv(options, deferred.resolve);
+  return deferred.promise;
 }
 
-function test()
-{
-  SpecialPowers.pushPrefEnv({'set': [["security.mixed_content.block_active_content", true]]}, run_test);
-}
-
diff --git a/browser/devtools/webconsole/test/browser_webconsole_cached_autocomplete.js b/browser/devtools/webconsole/test/browser_webconsole_cached_autocomplete.js
--- a/browser/devtools/webconsole/test/browser_webconsole_cached_autocomplete.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_cached_autocomplete.js
@@ -3,123 +3,104 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Tests that the cached autocomplete results are used when the new
 // user input is a subset of the existing completion results.
 
 const TEST_URI = "data:text/html;charset=utf8,<p>test cached autocompletion results";
 
-let testDriver;
+let jsterm;
 
-function test() {
-  requestLongerTimeout(2);
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, function(hud) {
-      testDriver = testCompletion(hud);
-      testDriver.next();
-    });
-  }, true);
-}
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
 
-function testNext() {
-  executeSoon(function() {
-    testDriver.next();
-  });
-}
+  let hud = yield openConsole();
 
-function testCompletion(hud) {
-  let jsterm = hud.jsterm;
+  jsterm = hud.jsterm;
   let input = jsterm.inputNode;
   let popup = jsterm.autocompletePopup;
 
   // Test if 'doc' gives 'document'
   input.value = "doc";
   input.setSelectionRange(3, 3);
-  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
-  yield undefined;
+  yield complete(jsterm.COMPLETE_HINT_ONLY);
 
   is(input.value, "doc", "'docu' completion (input.value)");
   is(jsterm.completeNode.value, "   ument", "'docu' completion (completeNode)");
 
   // Test typing 'window.'.
   input.value = "window.";
   input.setSelectionRange(7, 7);
-  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
-  yield undefined;
+  yield complete(jsterm.COMPLETE_HINT_ONLY);
 
   ok(popup.getItems().length > 0, "'window.' gave a list of suggestions")
 
-  content.wrappedJSObject.docfoobar = true;
+  jsterm.execute("window.docfoobar = true");
 
   // Test typing 'window.doc'.
   input.value = "window.doc";
   input.setSelectionRange(10, 10);
-  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
-  yield undefined;
+  yield complete(jsterm.COMPLETE_HINT_ONLY);
 
   let newItems = popup.getItems();
   ok(newItems.every(function(item) {
        return item.label != "docfoobar";
      }), "autocomplete cached results do not contain docfoobar. list has not been updated");
 
   // Test that backspace does not cause a request to the server
   input.value = "window.do";
   input.setSelectionRange(9, 9);
-  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
-  yield undefined;
+  yield complete(jsterm.COMPLETE_HINT_ONLY);
 
   newItems = popup.getItems();
   ok(newItems.every(function(item) {
        return item.label != "docfoobar";
      }), "autocomplete cached results do not contain docfoobar. list has not been updated");
 
-  delete content.wrappedJSObject.docfoobar;
+  jsterm.execute("delete window.docfoobar");
 
   // Test if 'window.getC' gives 'getComputedStyle'
   input.value = "window."
   input.setSelectionRange(7, 7);
-  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
-  yield undefined;
+  yield complete(jsterm.COMPLETE_HINT_ONLY);
+
   input.value = "window.getC";
   input.setSelectionRange(11, 11);
-  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
-  yield undefined;
+  yield complete(jsterm.COMPLETE_HINT_ONLY);
+
   newItems = popup.getItems();
   ok(!newItems.every(function(item) {
        return item.label != "getComputedStyle";
      }), "autocomplete results do contain getComputedStyle");
 
   // Test if 'dump(d' gives non-zero results
   input.value = "dump(d";
   input.setSelectionRange(6, 6);
-  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
-  yield undefined;
+  yield complete(jsterm.COMPLETE_HINT_ONLY);
 
   ok(popup.getItems().length > 0, "'dump(d' gives non-zero results");
 
   // Test that 'dump(window.)' works.
   input.value = "dump(window.)";
   input.setSelectionRange(12, 12);
-  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
-  yield undefined;
+  yield complete(jsterm.COMPLETE_HINT_ONLY);
 
-  content.wrappedJSObject.docfoobar = true;
+  jsterm.execute("window.docfoobar = true");
 
   // Make sure 'dump(window.doc)' does not contain 'docfoobar'.
   input.value = "dump(window.doc)";
   input.setSelectionRange(15, 15);
-  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
-  yield undefined;
+  yield complete(jsterm.COMPLETE_HINT_ONLY);
 
   newItems = popup.getItems();
   ok(newItems.every(function(item) {
        return item.label != "docfoobar";
      }), "autocomplete cached results do not contain docfoobar. list has not been updated");
 
-  delete content.wrappedJSObject.docfoobar;
+  jsterm.execute("delete window.docfoobar");
+});
 
-  testDriver = null;
-  executeSoon(finishTest);
-  yield undefined;
+function complete(type) {
+  let updated = jsterm.once("autocomplete-updated");
+  jsterm.complete(type);
+  return updated;
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_change_font_size.js b/browser/devtools/webconsole/test/browser_webconsole_change_font_size.js
--- a/browser/devtools/webconsole/test/browser_webconsole_change_font_size.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_change_font_size.js
@@ -3,28 +3,25 @@
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  *
  * Contributor(s):
  *  Jennifer Fong <jfong@mozilla.com>
  *
  * ***** END LICENSE BLOCK ***** */
 
+"use strict";
+
 const TEST_URI = "http://example.com/";
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    Services.prefs.setIntPref("devtools.webconsole.fontSize", 10);
-    HUDService.toggleBrowserConsole().then(testFontSizeChange);
-  }, true);
-}
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
+  Services.prefs.setIntPref("devtools.webconsole.fontSize", 10);
+  let hud = yield HUDService.toggleBrowserConsole();
 
-function testFontSizeChange(hud) {
   let inputNode = hud.jsterm.inputNode;
   let outputNode = hud.jsterm.outputNode;
   outputNode.focus();
 
   EventUtils.synthesizeKey("-", { accelKey: true }, hud.iframeWindow);
   is(inputNode.style.fontSize, "10px", "input font stays at same size with ctrl+-");
   is(outputNode.style.fontSize, inputNode.style.fontSize, "output font stays at same size with ctrl+-");
 
@@ -34,11 +31,9 @@ function testFontSizeChange(hud) {
 
   EventUtils.synthesizeKey("-", { accelKey: true }, hud.iframeWindow);
   is(inputNode.style.fontSize, "10px", "font decreased with ctrl+-");
   is(outputNode.style.fontSize, inputNode.style.fontSize, "output font stays at same size with ctrl+-");
 
   EventUtils.synthesizeKey("0", { accelKey: true }, hud.iframeWindow);
   is(inputNode.style.fontSize, "", "font reset with ctrl+0");
   is(outputNode.style.fontSize, inputNode.style.fontSize, "output font stays at same size with ctrl+0");
-
-  finishTest();
-}
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_chrome.js b/browser/devtools/webconsole/test/browser_webconsole_chrome.js
--- a/browser/devtools/webconsole/test/browser_webconsole_chrome.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_chrome.js
@@ -1,15 +1,17 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Tests that code completion works properly in chrome tabs, like about:credits.
 
+"use strict";
+
 function test() {
   Task.spawn(function*() {
     const {tab} = yield loadTab("about:config");
     ok(tab, "tab loaded");
 
     const hud = yield openConsole(tab);
     ok(hud, "we have a console");
     ok(hud.iframeWindow, "we have the console UI window");
diff --git a/browser/devtools/webconsole/test/browser_webconsole_clickable_urls.js b/browser/devtools/webconsole/test/browser_webconsole_clickable_urls.js
--- a/browser/devtools/webconsole/test/browser_webconsole_clickable_urls.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_clickable_urls.js
@@ -1,16 +1,18 @@
 /*
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // When strings containing URLs are entered into the webconsole,
 // check its output and ensure that the output can be clicked to open those URLs.
 
+"use strict";
+
 const TEST_URI = "data:text/html;charset=utf8,Bug 1005909 - Clickable URLS";
 
 let inputTests = [
 
   // 0: URL opens page when clicked.
   {
     input: "'http://example.com'",
     output: "http://example.com",
diff --git a/browser/devtools/webconsole/test/browser_webconsole_completion.js b/browser/devtools/webconsole/test/browser_webconsole_completion.js
--- a/browser/devtools/webconsole/test/browser_webconsole_completion.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_completion.js
@@ -2,119 +2,98 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Tests that code completion works properly.
 
 const TEST_URI = "data:text/html;charset=utf8,<p>test code completion";
 
-let testDriver;
+let jsterm;
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, function(hud) {
-      testDriver = testCompletion(hud);
-      testDriver.next();
-    });
-  }, true);
-}
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
 
-function testNext() {
-  executeSoon(function() {
-    testDriver.next();
-  });
-}
+  let hud = yield openConsole();
 
-function testCompletion(hud) {
-  let jsterm = hud.jsterm;
+  jsterm = hud.jsterm;
   let input = jsterm.inputNode;
 
   // Test typing 'docu'.
   input.value = "docu";
   input.setSelectionRange(4, 4);
-  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
-  yield undefined;
+  yield complete(jsterm.COMPLETE_HINT_ONLY);
 
   is(input.value, "docu", "'docu' completion (input.value)");
   is(jsterm.completeNode.value, "    ment", "'docu' completion (completeNode)");
 
   // Test typing 'docu' and press tab.
   input.value = "docu";
   input.setSelectionRange(4, 4);
-  jsterm.complete(jsterm.COMPLETE_FORWARD, testNext);
-  yield undefined;
+  yield complete(jsterm.COMPLETE_FORWARD);
 
   is(input.value, "document", "'docu' tab completion");
   is(input.selectionStart, 8, "start selection is alright");
   is(input.selectionEnd, 8, "end selection is alright");
   is(jsterm.completeNode.value.replace(/ /g, ""), "", "'docu' completed");
 
   // Test typing 'window.Ob' and press tab.  Just 'window.O' is
   // ambiguous: could be window.Object, window.Option, etc.
   input.value = "window.Ob";
   input.setSelectionRange(9, 9);
-  jsterm.complete(jsterm.COMPLETE_FORWARD, testNext);
-  yield undefined;
+  yield complete(jsterm.COMPLETE_FORWARD);
 
   is(input.value, "window.Object", "'window.Ob' tab completion");
 
   // Test typing 'document.getElem'.
   input.value = "document.getElem";
   input.setSelectionRange(16, 16);
-  jsterm.complete(jsterm.COMPLETE_FORWARD, testNext);
-  yield undefined;
+  yield complete(jsterm.COMPLETE_FORWARD);
 
   is(input.value, "document.getElem", "'document.getElem' completion");
   is(jsterm.completeNode.value, "                entsByTagNameNS", "'document.getElem' completion");
 
   // Test pressing tab another time.
-  jsterm.complete(jsterm.COMPLETE_FORWARD, testNext);
-  yield undefined;
+  yield jsterm.complete(jsterm.COMPLETE_FORWARD);
 
   is(input.value, "document.getElem", "'document.getElem' completion");
   is(jsterm.completeNode.value, "                entsByTagName", "'document.getElem' another tab completion");
 
   // Test pressing shift_tab.
-  jsterm.complete(jsterm.COMPLETE_BACKWARD, testNext);
-  yield undefined;
+  complete(jsterm.COMPLETE_BACKWARD);
 
   is(input.value, "document.getElem", "'document.getElem' untab completion");
   is(jsterm.completeNode.value, "                entsByTagNameNS", "'document.getElem' completion");
 
   jsterm.clearOutput();
 
   input.value = "docu";
-  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
-  yield undefined;
+  yield complete(jsterm.COMPLETE_HINT_ONLY);
 
   is(jsterm.completeNode.value, "    ment", "'docu' completion");
   jsterm.execute();
   is(jsterm.completeNode.value, "", "clear completion on execute()");
 
   // Test multi-line completion works
   input.value =                 "console.log('one');\nconsol";
-  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
-  yield undefined;
+  yield complete(jsterm.COMPLETE_HINT_ONLY);
 
   is(jsterm.completeNode.value, "                   \n      e", "multi-line completion");
 
   // Test non-object autocompletion.
   input.value = "Object.name.sl";
-  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
-  yield undefined;
+  yield complete(jsterm.COMPLETE_HINT_ONLY);
 
   is(jsterm.completeNode.value, "              ice", "non-object completion");
 
   // Test string literal autocompletion.
   input.value = "'Asimov'.sl";
-  jsterm.complete(jsterm.COMPLETE_HINT_ONLY, testNext);
-  yield undefined;
+  yield complete(jsterm.COMPLETE_HINT_ONLY);
 
   is(jsterm.completeNode.value, "           ice", "string literal completion");
+});
 
-  testDriver = jsterm = input = null;
-  executeSoon(finishTest);
-  yield undefined;
+
+function complete(type) {
+  let updated = jsterm.once("autocomplete-updated");
+  jsterm.complete(type);
+  return updated;
 }
-
diff --git a/browser/devtools/webconsole/test/browser_webconsole_console_logging_api.js b/browser/devtools/webconsole/test/browser_webconsole_console_logging_api.js
--- a/browser/devtools/webconsole/test/browser_webconsole_console_logging_api.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_console_logging_api.js
@@ -1,109 +1,101 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Tests that the basic console.log()-style APIs and filtering work.
 
+"use strict";
+
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
-let hud, outputNode;
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
+  hud.jsterm.clearOutput();
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    Task.spawn(runner);
-  }, true);
+  let outputNode = hud.outputNode;
 
-  function* runner() {
-    hud = yield openConsole();
-    outputNode = hud.outputNode;
+  let methods = ["log", "info", "warn", "error", "exception", "debug"];
+  for (let method of methods) {
+    yield testMethod(method, hud, outputNode);
+  }
+});
 
-    let methods = ["log", "info", "warn", "error", "exception", "debug"];
-    for (let method of methods) {
-      yield testMethod(method);
-    }
-
-    executeSoon(finishTest);
-  }
-}
-
-function* testMethod(aMethod) {
+function* testMethod(aMethod, aHud, aOutputNode) {
   let console = content.console;
 
-  hud.jsterm.clearOutput();
+  aHud.jsterm.clearOutput();
 
   console[aMethod]("foo-bar-baz");
   console[aMethod]("baar-baz");
 
   yield waitForMessages({
-    webconsole: hud,
+    webconsole: aHud,
     messages: [{
       text: "foo-bar-baz",
     }, {
       text: "baar-baz",
     }],
   });
 
-  setStringFilter("foo");
+  setStringFilter("foo", aHud);
 
-  is(outputNode.querySelectorAll(".filtered-by-string").length, 1,
+  is(aOutputNode.querySelectorAll(".filtered-by-string").length, 1,
      "1 hidden " + aMethod + " node via string filtering")
 
-  hud.jsterm.clearOutput();
+  aHud.jsterm.clearOutput();
 
   // now toggle the current method off - make sure no visible message
   // TODO: move all filtering tests into a separate test file: see bug 608135
 
   console[aMethod]("foo-bar-baz");
   yield waitForMessages({
-    webconsole: hud,
+    webconsole: aHud,
     messages: [{
       text: "foo-bar-baz",
     }],
   });
 
-  setStringFilter("");
+  setStringFilter("", aHud);
   let filter;
   switch(aMethod) {
     case "debug":
       filter = "log";
       break;
     case "exception":
       filter = "error";
       break;
     default:
       filter = aMethod;
       break;
   }
 
-  hud.setFilterState(filter, false);
+  aHud.setFilterState(filter, false);
 
-  is(outputNode.querySelectorAll(".filtered-by-type").length, 1,
+  is(aOutputNode.querySelectorAll(".filtered-by-type").length, 1,
      "1 message hidden for " + aMethod + " (logging turned off)")
 
-  hud.setFilterState(filter, true);
+  aHud.setFilterState(filter, true);
 
-  is(outputNode.querySelectorAll(".message:not(.filtered-by-type)").length, 1,
+  is(aOutputNode.querySelectorAll(".message:not(.filtered-by-type)").length, 1,
      "1 message shown for " + aMethod + " (logging turned on)")
 
-  hud.jsterm.clearOutput();
+  aHud.jsterm.clearOutput();
 
   // test for multiple arguments.
   console[aMethod]("foo", "bar");
 
   yield waitForMessages({
-    webconsole: hud,
+    webconsole: aHud,
     messages: [{
       text: '"foo" "bar"',
       category: CATEGORY_WEBDEV,
     }],
   })
 }
 
-function setStringFilter(aValue) {
-  hud.ui.filterBox.value = aValue;
-  hud.ui.adjustVisibilityOnSearchStringChange();
+function setStringFilter(aValue, aHud) {
+  aHud.ui.filterBox.value = aValue;
+  aHud.ui.adjustVisibilityOnSearchStringChange();
 }
-
diff --git a/browser/devtools/webconsole/test/browser_webconsole_dont_navigate_on_doubleclick.js b/browser/devtools/webconsole/test/browser_webconsole_dont_navigate_on_doubleclick.js
--- a/browser/devtools/webconsole/test/browser_webconsole_dont_navigate_on_doubleclick.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_dont_navigate_on_doubleclick.js
@@ -1,15 +1,17 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 // Tests that if a link in console is double clicked, the console frame doesn't
 // navigate to that destination (bug 975707).
 
+"use strict";
+
 function test() {
   let originalNetPref = Services.prefs.getBoolPref("devtools.webconsole.filter.networkinfo");
   registerCleanupFunction(() => {
     Services.prefs.setBoolPref("devtools.webconsole.filter.networkinfo", originalNetPref);
   });
   Services.prefs.setBoolPref("devtools.webconsole.filter.networkinfo", true);
   Task.spawn(runner).then(finishTest);
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_execution_scope.js b/browser/devtools/webconsole/test/browser_webconsole_execution_scope.js
--- a/browser/devtools/webconsole/test/browser_webconsole_execution_scope.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_execution_scope.js
@@ -1,41 +1,34 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Tests that commands run by the user are executed in content space.
 
+"use strict";
+
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, testExecutionScope);
-  }, true);
-}
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
+  hud.jsterm.clearOutput();
+  hud.jsterm.execute("window.location.href;");
 
-function testExecutionScope(hud) {
-  let jsterm = hud.jsterm;
-
-  jsterm.clearOutput();
-  jsterm.execute("window.location.href;");
-  waitForMessages({
+  let [input, output] = yield waitForMessages({
     webconsole: hud,
     messages: [{
       text: "window.location.href;",
       category: CATEGORY_INPUT,
     },
     {
       text: TEST_URI,
       category: CATEGORY_OUTPUT,
     }],
-  }).then(([input, output]) => {
-    let inputNode = [...input.matched][0];
-    let outputNode = [...output.matched][0];
-    is(inputNode.getAttribute("category"), "input", "input node category is correct");
-    is(outputNode.getAttribute("category"), "output", "output node category is correct");
-    finishTest();
   });
-}
 
+  let inputNode = [...input.matched][0];
+  let outputNode = [...output.matched][0];
+  is(inputNode.getAttribute("category"), "input", "input node category is correct");
+  is(outputNode.getAttribute("category"), "output", "output node category is correct");
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_expandable_timestamps.js b/browser/devtools/webconsole/test/browser_webconsole_expandable_timestamps.js
--- a/browser/devtools/webconsole/test/browser_webconsole_expandable_timestamps.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_expandable_timestamps.js
@@ -1,57 +1,55 @@
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 // Test for the message timestamps option: check if the preference toggles the
 // display of messages in the console output. See bug 722267.
 
-function test()
+let TEST_URI = "data:text/html;charset=utf-8,Web Console test for bug 722267 - " +
+               "preference for toggling timestamps in messages";
+let PREF_MESSAGE_TIMESTAMP = "devtools.webconsole.timestampMessages";
+let hud;
+
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+
+  hud = yield openConsole();
+  let panel = yield consoleOpened();
+
+  yield onOptionsPanelSelected(panel);
+  onPrefChanged();
+
+  Services.prefs.clearUserPref(PREF_MESSAGE_TIMESTAMP);
+});
+
+function consoleOpened()
 {
-  const PREF_MESSAGE_TIMESTAMP = "devtools.webconsole.timestampMessages";
-  let hud;
+  info("console opened");
+  let prefValue = Services.prefs.getBoolPref(PREF_MESSAGE_TIMESTAMP);
+  ok(!prefValue, "messages have no timestamp by default (pref check)");
+  ok(hud.outputNode.classList.contains("hideTimestamps"),
+     "messages have no timestamp (class name check)");
 
-  registerCleanupFunction(() => {
-    Services.prefs.clearUserPref(PREF_MESSAGE_TIMESTAMP);
-  });
+  let toolbox = gDevTools.getToolbox(hud.target);
+  return toolbox.selectTool("options");
+}
 
-  addTab("data:text/html;charset=utf-8,Web Console test for bug 722267 - " +
-         "preference for toggling timestamps in messages");
+function onOptionsPanelSelected(panel)
+{
+  info("options panel opened");
 
-  browser.addEventListener("load", function tabLoad() {
-    browser.removeEventListener("load", tabLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
+  let prefChanged = gDevTools.once("pref-changed", onPrefChanged);
 
-  function consoleOpened(aHud)
-  {
-    hud = aHud;
+  let checkbox = panel.panelDoc.getElementById("webconsole-timestamp-messages");
+  checkbox.click();
 
-    info("console opened");
-    let prefValue = Services.prefs.getBoolPref(PREF_MESSAGE_TIMESTAMP);
-    ok(!prefValue, "messages have no timestamp by default (pref check)");
-    ok(hud.outputNode.classList.contains("hideTimestamps"),
-       "messages have no timestamp (class name check)");
+  return prefChanged;
+}
 
-    let toolbox = gDevTools.getToolbox(hud.target);
-    toolbox.selectTool("options").then(onOptionsPanelSelected);
-  }
-
-  function onOptionsPanelSelected(panel)
-  {
-    info("options panel opened");
-
-    gDevTools.once("pref-changed", onPrefChanged);
-
-    let checkbox = panel.panelDoc.getElementById("webconsole-timestamp-messages");
-    checkbox.click();
-  }
-
-  function onPrefChanged()
-  {
-    info("pref changed");
-    let prefValue = Services.prefs.getBoolPref(PREF_MESSAGE_TIMESTAMP);
-    ok(prefValue, "messages have timestamps (pref check)");
-    ok(!hud.outputNode.classList.contains("hideTimestamps"),
-       "messages have timestamps (class name check)");
-    finishTest();
-  }
+function onPrefChanged()
+{
+  info("pref changed");
+  let prefValue = Services.prefs.getBoolPref(PREF_MESSAGE_TIMESTAMP);
+  ok(prefValue, "messages have timestamps (pref check)");
+  ok(!hud.outputNode.classList.contains("hideTimestamps"),
+     "messages have timestamps (class name check)");
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_for_of.js b/browser/devtools/webconsole/test/browser_webconsole_for_of.js
--- a/browser/devtools/webconsole/test/browser_webconsole_for_of.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_for_of.js
@@ -1,24 +1,27 @@
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 // A for-of loop in Web Console code can loop over a content NodeList.
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-for-of.html";
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, testForOf);
-  }, true);
-}
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+
+  let hud = yield openConsole();
+  yield testForOf(hud);
+});
 
 function testForOf(hud) {
+  let deferred = promise.defer();
+
   var jsterm = hud.jsterm;
   jsterm.execute("{ [x.tagName for (x of document.body.childNodes) if (x.nodeType === 1)].join(' '); }",
     (node) => {
       ok(/H1 DIV H2 P/.test(node.textContent),
         "for-of loop should find all top-level nodes");
-      finishTest();
+      deferred.resolve();
     });
+
+  return deferred.promise;
 }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_history.js b/browser/devtools/webconsole/test/browser_webconsole_history.js
--- a/browser/devtools/webconsole/test/browser_webconsole_history.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_history.js
@@ -1,30 +1,28 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Tests the console history feature accessed via the up and down arrow keys.
 
+"use strict";
+
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
 // Constants used for defining the direction of JSTerm input history navigation.
 const HISTORY_BACK = -1;
 const HISTORY_FORWARD = 1;
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, testHistory);
-  }, true);
-}
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
+  hud.jsterm.clearOutput();
 
-function testHistory(hud) {
   let jsterm = hud.jsterm;
   let input = jsterm.inputNode;
 
   let executeList = ["document", "window", "window.location"];
 
   for each (var item in executeList) {
     input.value = item;
     jsterm.execute();
@@ -55,12 +53,9 @@ function testHistory(hud) {
   jsterm.historyPeruse(HISTORY_FORWARD);
   jsterm.historyPeruse(HISTORY_FORWARD);
 
   is (input.value, "", "check input is still empty");
 
   let idxLast = executeList.length - 1;
   jsterm.historyPeruse(HISTORY_BACK);
   is (input.value, executeList[idxLast], "check history next idx:" + idxLast);
-
-  executeSoon(finishTest);
-}
-
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_input_field_focus_on_panel_select.js b/browser/devtools/webconsole/test/browser_webconsole_input_field_focus_on_panel_select.js
--- a/browser/devtools/webconsole/test/browser_webconsole_input_field_focus_on_panel_select.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_input_field_focus_on_panel_select.js
@@ -1,46 +1,33 @@
 /* Any copyright is dedicated to the Public Domain
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // Test that the JS input field is focused when the user switches back to the
 // web console from other tools, see bug 891581.
 
+"use strict";
+
 const TEST_URI = "data:text/html;charset=utf8,<p>hello";
 
-function test()
-{
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
+  hud.jsterm.clearOutput();
 
-function consoleOpened(hud)
-{
   is(hud.jsterm.inputNode.hasAttribute("focused"), true,
      "inputNode should be focused");
 
   hud.ui.filterBox.focus();
 
   is(hud.ui.filterBox.hasAttribute("focused"), true,
      "filterBox should be focused");
 
   is(hud.jsterm.inputNode.hasAttribute("focused"), false,
      "inputNode shouldn't be focused");
 
-  openDebugger().then(debuggerOpened);
-}
+  yield openDebugger();
+  hud = yield openConsole();
 
-function debuggerOpened()
-{
-  openConsole(null, consoleReopened);
-}
-
-function consoleReopened(hud)
-{
   is(hud.jsterm.inputNode.hasAttribute("focused"), true,
      "inputNode should be focused");
-
-  finishTest();
-}
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_inspect-parsed-documents.js b/browser/devtools/webconsole/test/browser_webconsole_inspect-parsed-documents.js
--- a/browser/devtools/webconsole/test/browser_webconsole_inspect-parsed-documents.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_inspect-parsed-documents.js
@@ -1,16 +1,17 @@
 /* vim: set ft=javascript ts=2 et sw=2 tw=80: */
 /* Any copyright is dedicated to the Public Domain.
    http://creativecommons.org/publicdomain/zero/1.0/ */
-"use strict";
 
 // Test that dynamically created (HTML|XML|SVG)Documents can be inspected by
 // clicking on the object in console (bug 1035198).
 
+"use strict;"
+
 const TEST_CASES = [
   {
     input: '(new DOMParser()).parseFromString("<a />", "text/html")',
     output: "HTMLDocument",
     inspectable: true,
   },
   {
     input: '(new DOMParser()).parseFromString("<a />", "application/xml")',
@@ -21,13 +22,14 @@ const TEST_CASES = [
     input: '(new DOMParser()).parseFromString("<svg></svg>", "image/svg+xml")',
     output: "SVGDocument",
     inspectable: true,
   },
 ];
 
 const TEST_URI = "data:text/html;charset=utf8," +
   "browser_webconsole_inspect-parsed-documents.js";
+
 let test = asyncTest(function* () {
     let {tab} = yield loadTab(TEST_URI);
     let hud = yield openConsole(tab);
     yield checkOutputForInputs(hud, TEST_CASES);
 });
diff --git a/browser/devtools/webconsole/test/browser_webconsole_js_input_expansion.js b/browser/devtools/webconsole/test/browser_webconsole_js_input_expansion.js
--- a/browser/devtools/webconsole/test/browser_webconsole_js_input_expansion.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_js_input_expansion.js
@@ -1,28 +1,25 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Tests that the input box expands as the user types long lines.
 
+"use strict";
+
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, testJSInputExpansion);
-  }, true);
-}
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
+  hud.jsterm.clearOutput();
 
-function testJSInputExpansion(hud) {
-  let jsterm = hud.jsterm;
-  let input = jsterm.inputNode;
+  let input = hud.jsterm.inputNode;
   input.focus();
 
   is(input.getAttribute("multiline"), "true", "multiline is enabled");
   // Tests if the inputNode expands.
   input.value = "hello\nworld\n";
   let length = input.value.length;
   input.selectionEnd = length;
   input.selectionStart = length;
@@ -50,11 +47,9 @@ function testJSInputExpansion(hud) {
   // Test if the inputNode shrinks again.
   input.value = "";
   EventUtils.synthesizeKey("d", {});
   let height = getHeight();
   info("height: " + height);
   info("initialHeight: " + initialHeight);
   let finalHeightDifference = Math.abs(initialHeight - height);
   ok(finalHeightDifference <= 1, "height shrank to original size within 1px");
-
-  finishTest();
-}
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_live_filtering_of_message_types.js b/browser/devtools/webconsole/test/browser_webconsole_live_filtering_of_message_types.js
--- a/browser/devtools/webconsole/test/browser_webconsole_live_filtering_of_message_types.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_live_filtering_of_message_types.js
@@ -1,62 +1,51 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Tests that the message type filter checkboxes work.
 
+"use strict";
+
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
-let hud;
-
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
-
-function consoleOpened(aHud) {
-  hud = aHud;
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
   hud.jsterm.clearOutput();
 
   let console = content.console;
 
   for (let i = 0; i < 50; i++) {
     console.log("foobarz #" + i);
   }
 
-  waitForMessages({
+  yield waitForMessages({
     webconsole: hud,
     messages: [{
       text: "foobarz #49",
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG,
     }],
-  }).then(testLiveFilteringOfMessageTypes);
-}
+  });
 
-function testLiveFilteringOfMessageTypes() {
   is(hud.outputNode.children.length, 50, "number of messages");
 
   hud.setFilterState("log", false);
-  is(countMessageNodes(), 0, "the log nodes are hidden when the " +
+  is(countMessageNodes(hud), 0, "the log nodes are hidden when the " +
     "corresponding filter is switched off");
 
   hud.setFilterState("log", true);
-  is(countMessageNodes(), 50, "the log nodes reappear when the " +
+  is(countMessageNodes(hud), 50, "the log nodes reappear when the " +
     "corresponding filter is switched on");
+});
 
-  finishTest();
-}
-
-function countMessageNodes() {
+function countMessageNodes(hud) {
   let messageNodes = hud.outputNode.querySelectorAll(".message");
   let displayedMessageNodes = 0;
   let view = hud.iframeWindow;
   for (let i = 0; i < messageNodes.length; i++) {
     let computedStyle = view.getComputedStyle(messageNodes[i], null);
     if (computedStyle.display !== "none") {
       displayedMessageNodes++;
     }
diff --git a/browser/devtools/webconsole/test/browser_webconsole_live_filtering_on_search_strings.js b/browser/devtools/webconsole/test/browser_webconsole_live_filtering_on_search_strings.js
--- a/browser/devtools/webconsole/test/browser_webconsole_live_filtering_on_search_strings.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_live_filtering_on_search_strings.js
@@ -1,106 +1,96 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Tests that the text filter box works.
 
+"use strict";
+
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
-let hud;
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
+  hud.jsterm.clearOutput();
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
-
-function consoleOpened(aHud) {
-  hud = aHud;
-  hud.jsterm.clearOutput();
   let console = content.console;
 
   for (let i = 0; i < 50; i++) {
     console.log("http://www.example.com/ " + i);
   }
 
-  waitForMessages({
+  yield waitForMessages({
     webconsole: hud,
     messages: [{
       text: "http://www.example.com/ 49",
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG,
     }],
-  }).then(testLiveFilteringOnSearchStrings);
-}
+  })
 
-function testLiveFilteringOnSearchStrings() {
   is(hud.outputNode.children.length, 50, "number of messages");
 
-  setStringFilter("http");
-  isnot(countMessageNodes(), 0, "the log nodes are not hidden when the " +
+  setStringFilter(hud, "http");
+  isnot(countMessageNodes(hud), 0, "the log nodes are not hidden when the " +
     "search string is set to \"http\"");
 
-  setStringFilter("hxxp");
-  is(countMessageNodes(), 0, "the log nodes are hidden when the search " +
+  setStringFilter(hud, "hxxp");
+  is(countMessageNodes(hud), 0, "the log nodes are hidden when the search " +
     "string is set to \"hxxp\"");
 
-  setStringFilter("ht tp");
-  isnot(countMessageNodes(), 0, "the log nodes are not hidden when the " +
+  setStringFilter(hud, "ht tp");
+  isnot(countMessageNodes(hud), 0, "the log nodes are not hidden when the " +
     "search string is set to \"ht tp\"");
 
-  setStringFilter(" zzzz   zzzz ");
-  is(countMessageNodes(), 0, "the log nodes are hidden when the search " +
+  setStringFilter(hud, " zzzz   zzzz ");
+  is(countMessageNodes(hud), 0, "the log nodes are hidden when the search " +
     "string is set to \" zzzz   zzzz \"");
 
-  setStringFilter("");
-  isnot(countMessageNodes(), 0, "the log nodes are not hidden when the " +
+  setStringFilter(hud, "");
+  isnot(countMessageNodes(hud), 0, "the log nodes are not hidden when the " +
     "search string is removed");
 
-  setStringFilter("\u9f2c");
-  is(countMessageNodes(), 0, "the log nodes are hidden when searching " +
+  setStringFilter(hud, "\u9f2c");
+  is(countMessageNodes(hud), 0, "the log nodes are hidden when searching " +
     "for weasels");
 
-  setStringFilter("\u0007");
-  is(countMessageNodes(), 0, "the log nodes are hidden when searching for " +
+  setStringFilter(hud, "\u0007");
+  is(countMessageNodes(hud), 0, "the log nodes are hidden when searching for " +
     "the bell character");
 
-  setStringFilter('"foo"');
-  is(countMessageNodes(), 0, "the log nodes are hidden when searching for " +
+  setStringFilter(hud, '"foo"');
+  is(countMessageNodes(hud), 0, "the log nodes are hidden when searching for " +
     'the string "foo"');
 
-  setStringFilter("'foo'");
-  is(countMessageNodes(), 0, "the log nodes are hidden when searching for " +
+  setStringFilter(hud, "'foo'");
+  is(countMessageNodes(hud), 0, "the log nodes are hidden when searching for " +
     "the string 'foo'");
 
-  setStringFilter("foo\"bar'baz\"boo'");
-  is(countMessageNodes(), 0, "the log nodes are hidden when searching for " +
+  setStringFilter(hud, "foo\"bar'baz\"boo'");
+  is(countMessageNodes(hud), 0, "the log nodes are hidden when searching for " +
     "the string \"foo\"bar'baz\"boo'\"");
+});
 
-  finishTest();
-}
-
-function countMessageNodes() {
+function countMessageNodes(hud) {
   let outputNode = hud.outputNode;
 
   let messageNodes = outputNode.querySelectorAll(".message");
   let displayedMessageNodes = 0;
   let view = hud.iframeWindow;
   for (let i = 0; i < messageNodes.length; i++) {
     let computedStyle = view.getComputedStyle(messageNodes[i], null);
     if (computedStyle.display !== "none") {
       displayedMessageNodes++;
     }
   }
 
   return displayedMessageNodes;
 }
 
-function setStringFilter(aValue)
+function setStringFilter(hud, aValue)
 {
   hud.ui.filterBox.value = aValue;
   hud.ui.adjustVisibilityOnSearchStringChange();
 }
 
diff --git a/browser/devtools/webconsole/test/browser_webconsole_log_file_filter.js b/browser/devtools/webconsole/test/browser_webconsole_log_file_filter.js
--- a/browser/devtools/webconsole/test/browser_webconsole_log_file_filter.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_log_file_filter.js
@@ -4,36 +4,38 @@
 
 // Tests that the text filter box works to filter based on filenames
 // where the logs were generated.
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-bug_923281_console_log_filter.html";
 
 let hud;
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
-}
+"use strict";
 
-function consoleOpened(aHud) {
-  hud = aHud;
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+
+  hud = yield openConsole();
+  yield consoleOpened();
+
+  testLiveFilteringOnSearchStrings();
+});
+
+function consoleOpened() {
   let console = content.console;
   console.log("sentinel log");
-  waitForMessages({
+  return waitForMessages({
     webconsole: hud,
     messages: [{
       text: "sentinel log",
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG
     }],
-  }).then(testLiveFilteringOnSearchStrings);
+  })
 }
 
 function testLiveFilteringOnSearchStrings() {
   is(hud.outputNode.children.length, 4, "number of messages");
 
   setStringFilter("random");
   is(countMessageNodes(), 1, "the log nodes not containing string " +
       "\"random\" are hidden");
@@ -46,18 +48,16 @@ function testLiveFilteringOnSearchString
   setStringFilter("test1");
   is(countMessageNodes(), 2, "show only log nodes containing string " +
       "\"test1\" or log nodes created from files with filename " +
       "containing \"test1\" as substring.");
 
   setStringFilter("");
   is(countMessageNodes(), 4, "show all log nodes on setting filter string " +
       "as \"\".");
-
-  finishTest();
 }
 
 function countMessageNodes() {
   let outputNode = hud.outputNode;
 
   let messageNodes = outputNode.querySelectorAll(".message");
   content.console.log(messageNodes.length);
   let displayedMessageNodes = 0;
diff --git a/browser/devtools/webconsole/test/browser_webconsole_message_node_id.js b/browser/devtools/webconsole/test/browser_webconsole_message_node_id.js
--- a/browser/devtools/webconsole/test/browser_webconsole_message_node_id.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_message_node_id.js
@@ -1,31 +1,27 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+"use strict";
+
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("DOMContentLoaded", onLoad, false);
-}
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
 
-function onLoad() {
-  browser.removeEventListener("DOMContentLoaded", onLoad, false);
-  openConsole(null, function(hud) {
-    content.console.log("a log message");
+  hud.jsterm.execute("console.log('a log message')");
 
-    waitForMessages({
+  let [result] = yield waitForMessages({
       webconsole: hud,
       messages: [{
         text: "a log message",
         category: CATEGORY_WEBDEV,
         severity: SEVERITY_LOG,
       }],
-    }).then(([result]) => {
-      let msg = [...result.matched][0];
-      ok(msg.getAttribute("id"), "log message has an ID");
-      finishTest();
-    });
   });
-}
+
+  let msg = [...result.matched][0];
+  ok(msg.getAttribute("id"), "log message has an ID");
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_notifications.js b/browser/devtools/webconsole/test/browser_webconsole_notifications.js
--- a/browser/devtools/webconsole/test/browser_webconsole_notifications.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_notifications.js
@@ -1,70 +1,77 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 const TEST_URI = "data:text/html;charset=utf-8,<p>Web Console test for notifications";
 
-function test() {
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+
+  let gotEvents = waitForEvents();
+
+  let hud = yield openConsole();
+
+  yield gotEvents;
+});
+
+function waitForEvents() {
+  let deferred = promise.defer();
+
+  function webConsoleCreated(aID)
+  {
+    Services.obs.removeObserver(observer, "web-console-created");
+    ok(HUDService.getHudReferenceById(aID), "We have a hud reference");
+    content.wrappedJSObject.console.log("adding a log message");
+  }
+
+  function webConsoleDestroyed(aID)
+  {
+    Services.obs.removeObserver(observer, "web-console-destroyed");
+    ok(!HUDService.getHudReferenceById(aID), "We do not have a hud reference");
+    executeSoon(deferred.resolve);
+  }
+
+  function webConsoleMessage(aID, aNodeID)
+  {
+    Services.obs.removeObserver(observer, "web-console-message-created");
+    ok(aID, "we have a console ID");
+    is(typeof aNodeID, "string", "message node id is a string");
+    executeSoon(closeConsole);
+  }
+
+  let observer = {
+
+    QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver]),
+
+    observe: function observe(aSubject, aTopic, aData)
+    {
+      aSubject = aSubject.QueryInterface(Ci.nsISupportsString);
+
+      switch(aTopic) {
+        case "web-console-created":
+          webConsoleCreated(aSubject.data);
+          break;
+        case "web-console-destroyed":
+          webConsoleDestroyed(aSubject.data);
+          break;
+        case "web-console-message-created":
+          webConsoleMessage(aSubject, aData);
+          break;
+        default:
+          break;
+      }
+    },
+
+    init: function init()
+    {
+      Services.obs.addObserver(this, "web-console-created", false);
+      Services.obs.addObserver(this, "web-console-destroyed", false);
+      Services.obs.addObserver(this, "web-console-message-created", false);
+    }
+  }
+
   observer.init();
-  addTab(TEST_URI);
-  browser.addEventListener("load", onLoad, true);
+
+  return deferred.promise;
 }
-
-function webConsoleCreated(aID)
-{
-  Services.obs.removeObserver(observer, "web-console-created");
-  ok(HUDService.getHudReferenceById(aID), "We have a hud reference");
-  content.wrappedJSObject.console.log("adding a log message");
-}
-
-function webConsoleDestroyed(aID)
-{
-  Services.obs.removeObserver(observer, "web-console-destroyed");
-  ok(!HUDService.getHudReferenceById(aID), "We do not have a hud reference");
-  executeSoon(finishTest);
-}
-
-function webConsoleMessage(aID, aNodeID)
-{
-  Services.obs.removeObserver(observer, "web-console-message-created");
-  ok(aID, "we have a console ID");
-  is(typeof aNodeID, "string", "message node id is a string");
-  executeSoon(closeConsole);
-}
-
-let observer = {
-
-  QueryInterface: XPCOMUtils.generateQI([Ci.nsIObserver]),
-
-  observe: function observe(aSubject, aTopic, aData)
-  {
-    aSubject = aSubject.QueryInterface(Ci.nsISupportsString);
-
-    switch(aTopic) {
-      case "web-console-created":
-        webConsoleCreated(aSubject.data);
-        break;
-      case "web-console-destroyed":
-        webConsoleDestroyed(aSubject.data);
-        break;
-      case "web-console-message-created":
-        webConsoleMessage(aSubject, aData);
-        break;
-      default:
-        break;
-    }
-  },
-
-  init: function init()
-  {
-    Services.obs.addObserver(this, "web-console-created", false);
-    Services.obs.addObserver(this, "web-console-destroyed", false);
-    Services.obs.addObserver(this, "web-console-message-created", false);
-  }
-};
-
-function onLoad() {
-  browser.removeEventListener("load", onLoad, true);
-  openConsole();
-}
diff --git a/browser/devtools/webconsole/test/browser_webconsole_open-links-without-callback.js b/browser/devtools/webconsole/test/browser_webconsole_open-links-without-callback.js
--- a/browser/devtools/webconsole/test/browser_webconsole_open-links-without-callback.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_open-links-without-callback.js
@@ -1,15 +1,17 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 // Tests that if a link without an onclick callback is clicked the link is
 // opened in a new tab and no exception occurs (bug 999236).
 
+"use strict";
+
 function test() {
   function* runner() {
     const TEST_EVAL_STRING = "document";
     const TEST_PAGE_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
     const {tab} = yield loadTab(TEST_PAGE_URI);
     const hud = yield openConsole(tab);
 
     hud.jsterm.execute(TEST_EVAL_STRING);
diff --git a/browser/devtools/webconsole/test/browser_webconsole_output_copy_newlines.js b/browser/devtools/webconsole/test/browser_webconsole_output_copy_newlines.js
--- a/browser/devtools/webconsole/test/browser_webconsole_output_copy_newlines.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_output_copy_newlines.js
@@ -1,77 +1,67 @@
 /* Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/ */
 
 // Test that multiple messages are copied into the clipboard and that they are
 // separated by new lines. See bug 916997.
 
-function test()
-{
+"use strict";
+
+let test = asyncTest(function*() {
   const TEST_URI = "data:text/html;charset=utf8,<p>hello world, bug 916997";
   let clipboardValue = "";
 
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, consoleOpened);
-  }, true);
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
+  hud.jsterm.clearOutput();
 
-  function consoleOpened(hud)
-  {
-    hud.jsterm.clearOutput();
+  let controller = top.document.commandDispatcher.
+                   getControllerForCommand("cmd_copy");
+  is(controller.isCommandEnabled("cmd_copy"), false, "cmd_copy is disabled");
 
-    let controller = top.document.commandDispatcher.
-                     getControllerForCommand("cmd_copy");
-    is(controller.isCommandEnabled("cmd_copy"), false, "cmd_copy is disabled");
+  content.console.log("Hello world! bug916997a");
+  content.console.log("Hello world 2! bug916997b");
 
-    content.console.log("Hello world! bug916997a");
-    content.console.log("Hello world 2! bug916997b");
+  yield waitForMessages({
+    webconsole: hud,
+    messages: [{
+      text: "Hello world! bug916997a",
+      category: CATEGORY_WEBDEV,
+      severity: SEVERITY_LOG,
+    }, {
+      text: "Hello world 2! bug916997b",
+      category: CATEGORY_WEBDEV,
+      severity: SEVERITY_LOG,
+    }],
+  });
 
-    waitForMessages({
-      webconsole: hud,
-      messages: [{
-        text: "Hello world! bug916997a",
-        category: CATEGORY_WEBDEV,
-        severity: SEVERITY_LOG,
-      }, {
-        text: "Hello world 2! bug916997b",
-        category: CATEGORY_WEBDEV,
-        severity: SEVERITY_LOG,
-      }],
-    }).then(() => {
-      hud.ui.output.selectAllMessages();
-      hud.outputNode.focus();
+  hud.ui.output.selectAllMessages();
+  hud.outputNode.focus();
 
-      goUpdateCommand("cmd_copy");
-      controller = top.document.commandDispatcher.getControllerForCommand("cmd_copy");
-      is(controller.isCommandEnabled("cmd_copy"), true, "cmd_copy is enabled");
+  goUpdateCommand("cmd_copy");
+  controller = top.document.commandDispatcher.getControllerForCommand("cmd_copy");
+  is(controller.isCommandEnabled("cmd_copy"), true, "cmd_copy is enabled");
 
-      let selection = hud.iframeWindow.getSelection() + "";
-      info("selection '" + selection + "'");
-      waitForClipboard((str) => {
-          clipboardValue = str;
-          return str.indexOf("bug916997a") > -1 && str.indexOf("bug916997b") > -1;
-        },
-        () => { goDoCommand("cmd_copy"); },
-        checkClipboard.bind(null, hud),
-        () => {
-          info("last clipboard value: '" + clipboardValue + "'");
-          finishTest();
-        });
+  let selection = hud.iframeWindow.getSelection() + "";
+  info("selection '" + selection + "'");
+
+  waitForClipboard((str) => {
+      clipboardValue = str;
+      return str.indexOf("bug916997a") > -1 && str.indexOf("bug916997b") > -1;
+    },
+    () => { goDoCommand("cmd_copy"); },
+    () => {
+      info("clipboard value '" + clipboardValue + "'");
+      let lines = clipboardValue.trim().split("\n");
+      is(hud.outputNode.children.length, 2, "number of messages");
+      is(lines.length, hud.outputNode.children.length, "number of lines");
+      isnot(lines[0].indexOf("bug916997a"), -1,
+            "first message text includes 'bug916997a'");
+      isnot(lines[1].indexOf("bug916997b"), -1,
+            "second message text includes 'bug916997b'");
+      is(lines[0].indexOf("bug916997b"), -1,
+         "first message text does not include 'bug916997b'");
+    },
+    () => {
+      info("last clipboard value: '" + clipboardValue + "'");
     });
-  }
-
-  function checkClipboard(hud)
-  {
-    info("clipboard value '" + clipboardValue + "'");
-    let lines = clipboardValue.trim().split("\n");
-    is(hud.outputNode.children.length, 2, "number of messages");
-    is(lines.length, hud.outputNode.children.length, "number of lines");
-    isnot(lines[0].indexOf("bug916997a"), -1,
-          "first message text includes 'bug916997a'");
-    isnot(lines[1].indexOf("bug916997b"), -1,
-          "second message text includes 'bug916997b'");
-    is(lines[0].indexOf("bug916997b"), -1,
-       "first message text does not include 'bug916997b'");
-    finishTest();
-  }
-}
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_output_dom_elements_02.js b/browser/devtools/webconsole/test/browser_webconsole_output_dom_elements_02.js
--- a/browser/devtools/webconsole/test/browser_webconsole_output_dom_elements_02.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_output_dom_elements_02.js
@@ -9,29 +9,37 @@
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console-output-dom-elements.html";
 
 const TEST_DATA = [
   {
     // The first test shouldn't be returning the body element as this is the
     // default selected node, so re-selecting it won't fire the inspector-updated
     // event
     input: "testNode()",
-    output: '<p some-attribute="some-value">'
+    output: '<p some-attribute="some-value">',
+    tagName: 'P',
+    attrs: [{name: "some-attribute", value: "some-value"}]
   },
   {
     input: "testBodyNode()",
-    output: '<body id="body-id" class="body-class">'
+    output: '<body id="body-id" class="body-class">',
+    tagName: 'BODY',
+    attrs: [{name: "id", value: "body-id"}, {name: "class", value: "body-class"}]
   },
   {
     input: "testNodeInIframe()",
-    output: '<p>'
+    output: '<p>',
+    tagName: 'P',
+    attrs: []
   },
   {
     input: "testDocumentElement()",
-    output: '<html lang="en-US" dir="ltr">'
+    output: '<html lang="en-US" dir="ltr">',
+    tagName: 'HTML',
+    attrs: [{name: "lang", value: "en-US"}, {name: "dir", value: "ltr"}]
   }
 ];
 
 function test() {
   Task.spawn(function*() {
     let {tab} = yield loadTab(TEST_URI);
     let hud = yield openConsole(tab);
     let toolbox = gDevTools.getToolbox(hud.target);
@@ -48,28 +56,33 @@ function test() {
       let {widget, msg} = yield getWidgetAndMessage(result);
 
       let inspectorIcon = msg.querySelector(".open-inspector");
       ok(inspectorIcon, "Inspector icon found in the ElementNode widget");
 
       info("Clicking on the inspector icon and waiting for the inspector to be selected");
       let onInspectorSelected = toolbox.once("inspector-selected");
       let onInspectorUpdated = inspector.once("inspector-updated");
-      let onNewNode = toolbox.selection.once("new-node");
+      let onNewNode = toolbox.selection.once("new-node-front");
 
       EventUtils.synthesizeMouseAtCenter(inspectorIcon, {},
         inspectorIcon.ownerDocument.defaultView);
       yield onInspectorSelected;
       yield onInspectorUpdated;
-      yield onNewNode;
+      let nodeFront = yield onNewNode;
+
       ok(true, "Inspector selected and new node got selected");
 
-      let rawNode = content.wrappedJSObject[data.input.replace(/\(\)/g, "")]();
-      is(inspector.selection.node.wrappedJSObject, rawNode,
-         "The current inspector selection is correct");
+      is(nodeFront.tagName, data.tagName, "The correct node was highlighted");
+
+      let attrs = nodeFront.attributes;
+      for (let i in data.attrs) {
+        is(attrs[i].name, data.attrs[i].name, "The correct node was highlighted");
+        is(attrs[i].value, data.attrs[i].value, "The correct node was highlighted");
+      }
 
       info("Switching back to the console");
       yield toolbox.selectTool("webconsole");
     }
   }).then(finishTest);
 }
 
 function jsEval(input, hud, message) {
diff --git a/browser/devtools/webconsole/test/browser_webconsole_output_events.js b/browser/devtools/webconsole/test/browser_webconsole_output_events.js
--- a/browser/devtools/webconsole/test/browser_webconsole_output_events.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_output_events.js
@@ -2,59 +2,47 @@
  * Any copyright is dedicated to the Public Domain.
  * http://creativecommons.org/publicdomain/zero/1.0/
  */
 
 // Test the webconsole output for DOM events.
 
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console-output-events.html";
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    Task.spawn(runner);
-  }, true);
+"use strict";
 
-  function* runner()
-  {
-    let hud = yield openConsole();
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
 
-    hud.jsterm.clearOutput();
-    hud.jsterm.execute("testDOMEvents()");
+  hud.jsterm.clearOutput();
+  hud.jsterm.execute("testDOMEvents()");
 
-    yield waitForMessages({
-      webconsole: hud,
-      messages: [{
-        name: "testDOMEvents() output",
-        text: "undefined",
-        category: CATEGORY_OUTPUT,
-      }],
-    });
+  yield waitForMessages({
+    webconsole: hud,
+    messages: [{
+      name: "testDOMEvents() output",
+      text: "undefined",
+      category: CATEGORY_OUTPUT,
+    }],
+  });
 
-    EventUtils.synthesizeMouse(content.document.body, 2, 2, {type: "mousemove"}, content);
+  yield waitForMessages({
+    webconsole: hud,
+    messages: [{
+      name: "console.log() output for mousemove",
+      text: /"eventLogger" mousemove { target: .+, buttons: 0, clientX: \d+, clientY: \d+, layerX: \d+, layerY: \d+ }/,
+      category: CATEGORY_WEBDEV,
+      severity: SEVERITY_LOG,
+    }],
+  });
 
-    yield waitForMessages({
-      webconsole: hud,
-      messages: [{
-        name: "console.log() output for mousemove",
-        text: /"eventLogger" mousemove { target: .+, buttons: 1, clientX: \d+, clientY: \d+, layerX: \d+, layerY: \d+ }/,
-        category: CATEGORY_WEBDEV,
-        severity: SEVERITY_LOG,
-      }],
-    });
+  yield waitForMessages({
+    webconsole: hud,
+    messages: [{
+      name: "console.log() output for keypress",
+      text: /"eventLogger" keypress Shift { target: .+, key: .+, charCode: \d+, keyCode: \d+ }/,
+      category: CATEGORY_WEBDEV,
+      severity: SEVERITY_LOG,
+    }],
+  });
+})
 
-    content.focus();
-    EventUtils.synthesizeKey("a", {shiftKey: true}, content);
-
-    yield waitForMessages({
-      webconsole: hud,
-      messages: [{
-        name: "console.log() output for keypress",
-        text: /"eventLogger" keypress Shift { target: .+, key: .+, charCode: \d+, keyCode: \d+ }/,
-        category: CATEGORY_WEBDEV,
-        severity: SEVERITY_LOG,
-      }],
-    });
-
-    finishTest();
-  }
-}
diff --git a/browser/devtools/webconsole/test/browser_webconsole_output_order.js b/browser/devtools/webconsole/test/browser_webconsole_output_order.js
--- a/browser/devtools/webconsole/test/browser_webconsole_output_order.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_output_order.js
@@ -1,51 +1,47 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // Tests that any output created from calls to the console API comes after the
 // echoed JavaScript.
 
+"use strict";
+
 const TEST_URI = "http://example.com/browser/browser/devtools/webconsole/test/test-console.html";
 
-function test() {
-  addTab(TEST_URI);
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(null, testOutputOrder);
-  }, true);
-}
+let test = asyncTest(function*() {
+  yield loadTab(TEST_URI);
+  let hud = yield openConsole();
 
-function testOutputOrder(hud) {
   let jsterm = hud.jsterm;
   let outputNode = jsterm.outputNode;
 
   jsterm.clearOutput();
   jsterm.execute("console.log('foo', 'bar');");
 
-  waitForMessages({
+  let [function_call, result, console_message] = yield waitForMessages({
     webconsole: hud,
     messages: [{
       text: "console.log('foo', 'bar');",
       category: CATEGORY_INPUT,
     },
     {
       text: "undefined",
       category: CATEGORY_OUTPUT,
     },
     {
       text: '"foo" "bar"',
       category: CATEGORY_WEBDEV,
       severity: SEVERITY_LOG,
     }],
-  }).then(([function_call, result, console_message]) => {
-    let fncall_node = [...function_call.matched][0];
-    let result_node = [...result.matched][0];
-    let console_message_node = [...console_message.matched][0];
-    is(fncall_node.nextElementSibling, result_node,
-       "console.log() is followed by undefined");
-    is(result_node.nextElementSibling, console_message_node,
-       "undefined is followed by 'foo' 'bar'");
-    finishTest();
   });
-}
+
+  let fncall_node = [...function_call.matched][0];
+  let result_node = [...result.matched][0];
+  let console_message_node = [...console_message.matched][0];
+  is(fncall_node.nextElementSibling, result_node,
+     "console.log() is followed by undefined");
+  is(result_node.nextElementSibling, console_message_node,
+     "undefined is followed by 'foo' 'bar'");
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_reflow.js b/browser/devtools/webconsole/test/browser_webconsole_reflow.js
--- a/browser/devtools/webconsole/test/browser_webconsole_reflow.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_reflow.js
@@ -1,35 +1,32 @@
 /* vim:set ts=2 sw=2 sts=2 et: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-function test()
-{
-  addTab("data:text/html;charset=utf-8,Web Console test for reflow activity");
+"use strict";
 
-  browser.addEventListener("load", function onLoad() {
-    browser.removeEventListener("load", onLoad, true);
-    openConsole(gBrowser.selectedTab, function(hud) {
+const TEST_URI = "data:text/html;charset=utf-8,Web Console test for reflow activity";
 
-      function onReflowListenersReady(aType, aPacket) {
-        browser.contentDocument.body.style.display = "none";
-        browser.contentDocument.body.clientTop;
-      }
+let test = asyncTest(function* () {
+  let { browser } = yield loadTab(TEST_URI);
 
-      Services.prefs.setBoolPref("devtools.webconsole.filter.csslog", true);
-      hud.ui._updateReflowActivityListener(onReflowListenersReady);
-      Services.prefs.clearUserPref("devtools.webconsole.filter.csslog");
+  let hud = yield openConsole();
 
-      waitForMessages({
-        webconsole: hud,
-        messages: [{
-          text: /reflow: /,
-          category: CATEGORY_CSS,
-          severity: SEVERITY_LOG,
-        }],
-      }).then(() => {
-        finishTest();
-      });
-    });
-  }, true);
-}
+  function onReflowListenersReady(aType, aPacket) {
+    browser.contentDocument.body.style.display = "none";
+    browser.contentDocument.body.clientTop;
+  }
+
+  Services.prefs.setBoolPref("devtools.webconsole.filter.csslog", true);
+  hud.ui._updateReflowActivityListener(onReflowListenersReady);
+  Services.prefs.clearUserPref("devtools.webconsole.filter.csslog");
+
+  yield waitForMessages({
+    webconsole: hud,
+    messages: [{
+      text: /reflow: /,
+      category: CATEGORY_CSS,
+      severity: SEVERITY_LOG,
+    }],
+  })
+});
diff --git a/browser/devtools/webconsole/test/browser_webconsole_scratchpad_panel_link.js b/browser/devtools/webconsole/test/browser_webconsole_scratchpad_panel_link.js
--- a/browser/devtools/webconsole/test/browser_webconsole_scratchpad_panel_link.js
+++ b/browser/devtools/webconsole/test/browser_webconsole_scratchpad_panel_link.js
@@ -5,34 +5,28 @@
 const TEST_URI = "data:text/html;charset=utf8,<p>test Scratchpad panel linking</p>";
 
 let { Task } = Cu.import("resource://gre/modules/Task.jsm", {});
 let { Tools } = require("main");
 let { isTargetSupported } = Tools.scratchpad;
 
 Tools.scratchpad.isTargetSupported = () => true;
 
+let test = asyncTest(function* () {
+  yield loadTab(TEST_URI);
 
-function test()
-{
-  waitForExplicitFinish();
+  info("Opening toolbox with Scratchpad panel");
 
-  addTab(TEST_URI);
-  gBrowser.selectedBrowser.addEventListener("load", function onTabLoad() {
-    gBrowser.selectedBrowser.removeEventListener("load", onTabLoad, true);
-    info("Opening toolbox with Scratchpad panel");
-
-    let target = TargetFactory.forTab(gBrowser.selectedTab);
-    gDevTools.showToolbox(target, "scratchpad", "window").then(runTests);
-  }, true);
-}
+  let target = TargetFactory.forTab(gBrowser.selectedTab);
+  yield gDevTools.showToolbox(target, "scratchpad", "window").then(runTests);
+});
 
 function runTests(aToolbox)
 {
-  Task.spawn(function*() {
+  return Task.spawn(function*() {
     let scratchpadPanel = aToolbox.getPanel("scratchpad");
     let { scratchpad } = scratchpadPanel;
     is(aToolbox.getCurrentPanel(), scratchpadPanel,
       "Scratchpad is currently selected panel");
 
     info("Switching to webconsole panel");
 
     let webconsolePanel = yield aToolbox.selectTool("webconsole");
@@ -50,24 +44,23 @@ function runTests(aToolbox)
     });
 
     info("Clicking link to switch to and focus Scratchpad");
 
     let [matched] = [...messages[0].matched];
     ok(matched, "Found logged message from Scratchpad");
     let anchor = matched.querySelector("a.message-location");
 
-    aToolbox.on("scratchpad-selected", function selected() {
-      aToolbox.off("scratchpad-selected", selected);
-
-      is(aToolbox.getCurrentPanel(), scratchpadPanel,
-        "Clicking link switches to Scratchpad panel");
-      
-      is(Services.ww.activeWindow, aToolbox.frame.ownerGlobal,
-         "Scratchpad's toolbox is focused");
-
-      Tools.scratchpad.isTargetSupported = isTargetSupported;
-      finish();
-    });
+    let selected = aToolbox.once("scratchpad-selected");
 
     EventUtils.synthesizeMouse(anchor, 2, 2, {}, hud.iframeWindow);
+
+    yield selected;
+
+    is(aToolbox.getCurrentPanel(), scratchpadPanel,
+      "Clicking link switches to Scratchpad panel");
+
+    is(Services.ww.activeWindow, aToolbox.frame.ownerGlobal,
+       "Scratchpad's toolbox is focused");
+
+    Tools.scratchpad.isTargetSupported = isTargetSupported;
   });
 }
diff --git a/browser/devtools/webconsole/test/head.js b/browser/devtools/webconsole/test/head.js
--- a/browser/devtools/webconsole/test/head.js
+++ b/browser/devtools/webconsole/test/head.js
@@ -10,16 +10,17 @@ let {console} = Cu.import("resource://gr
 let {Promise: promise} = Cu.import("resource://gre/modules/Promise.jsm", {});
 let {Task} = Cu.import("resource://gre/modules/Task.jsm", {});
 let {devtools} = Cu.import("resource://gre/modules/devtools/Loader.jsm", {});
 let {require, TargetFactory} = devtools;
 let {Utils: WebConsoleUtils} = require("devtools/toolkit/webconsole/utils");
 let {Messages} = require("devtools/webconsole/console-output");
 
 // promise._reportErrors = true; // please never leave me.
+//Services.prefs.setBoolPref("devtools.debugger.log", true);
 
 let gPendingOutputTest = 0;
 
 // The various categories of messages.
 const CATEGORY_NETWORK = 0;
 const CATEGORY_CSS = 1;
 const CATEGORY_JS = 2;
 const CATEGORY_WEBDEV = 3;
@@ -35,51 +36,24 @@ const SEVERITY_LOG = 3;
 
 // The indent of a console group in pixels.
 const GROUP_INDENT = 12;
 
 const WEBCONSOLE_STRINGS_URI = "chrome://browser/locale/devtools/webconsole.properties";
 let WCU_l10n = new WebConsoleUtils.l10n(WEBCONSOLE_STRINGS_URI);
 
 gDevTools.testing = true;
-SimpleTest.registerCleanupFunction(() => {
-  gDevTools.testing = false;
-});
 
 /**
  * Define an async test based on a generator function
  */
 function asyncTest(generator) {
-  return () => Task.spawn(generator).then(null, ok.bind(null, false)).then(finishTest);
-}
-
-function log(aMsg)
-{
-  dump("*** WebConsoleTest: " + aMsg + "\n");
-}
-
-function pprint(aObj)
-{
-  for (let prop in aObj) {
-    if (typeof aObj[prop] == "function") {
-      log("function " + prop);
-    }
-    else {
-      log(prop + ": " + aObj[prop]);
-    }
-  }
-}
-
-let tab, browser, hudId, hud, hudBox, filterBox, outputNode, cs;
-
-function addTab(aURL)
-{
-  gBrowser.selectedTab = gBrowser.addTab(aURL);
-  tab = gBrowser.selectedTab;
-  browser = gBrowser.getBrowserForTab(tab);
+  return () => {
+    Task.spawn(generator).then(finishTest);
+  };
 }
 
 function loadTab(url) {
   let deferred = promise.defer();
 
   let tab = gBrowser.selectedTab = gBrowser.addTab(url);
   let browser = gBrowser.getBrowserForTab(tab);
 
@@ -91,17 +65,17 @@ function loadTab(url) {
   return deferred.promise;
 }
 
 function loadBrowser(browser) {
   let deferred = promise.defer();
 
   browser.addEventListener("load", function onLoad() {
     browser.removeEventListener("load", onLoad, true);
-    deferred.resolve(null)
+    deferred.resolve(null);
   }, true);
 
   return deferred.promise;
 }
 
 function closeTab(tab) {
   let deferred = promise.defer();
 
@@ -200,95 +174,92 @@ function findLogEntry(aString)
  *        Optional tab element for which you want open the Web Console. The
  *        default tab is taken from the global variable |tab|.
  * @param function [aCallback]
  *        Optional function to invoke after the Web Console completes
  *        initialization (web-console-created).
  * @return object
  *         A promise that is resolved once the web console is open.
  */
-function openConsole(aTab, aCallback = function() { })
-{
-  let deferred = promise.defer();
-  let target = TargetFactory.forTab(aTab || tab);
-  gDevTools.showToolbox(target, "webconsole").then(function(toolbox) {
+let openConsole = function(aTab) {
+  let webconsoleOpened = promise.defer();
+  let target = TargetFactory.forTab(aTab || gBrowser.selectedTab);
+  gDevTools.showToolbox(target, "webconsole").then(toolbox => {
     let hud = toolbox.getCurrentPanel().hud;
     hud.jsterm._lazyVariablesView = false;
-    aCallback(hud);
-    deferred.resolve(hud);
+    webconsoleOpened.resolve(hud);
   });
-  return deferred.promise;
-}
+  return webconsoleOpened.promise;
+};
 
 /**
  * Close the Web Console for the given tab.
  *
  * @param nsIDOMElement [aTab]
  *        Optional tab element for which you want close the Web Console. The
  *        default tab is taken from the global variable |tab|.
  * @param function [aCallback]
  *        Optional function to invoke after the Web Console completes
  *        closing (web-console-destroyed).
  * @return object
  *         A promise that is resolved once the web console is closed.
  */
-function closeConsole(aTab, aCallback = function() { })
-{
-  let target = TargetFactory.forTab(aTab || tab);
+let closeConsole = Task.async(function* (aTab) {
+  let target = TargetFactory.forTab(aTab || gBrowser.selectedTab);
   let toolbox = gDevTools.getToolbox(target);
   if (toolbox) {
-    let panel = toolbox.getPanel("webconsole");
-    if (panel) {
-      let hudId = panel.hud.hudId;
-      return toolbox.destroy().then(aCallback.bind(null, hudId)).then(null, console.debug);
-    }
-    return toolbox.destroy().then(aCallback.bind(null));
+    yield toolbox.destroy();
   }
-
-  aCallback();
-  return promise.resolve(null);
-}
+});
 
 /**
  * Wait for a context menu popup to open.
  *
  * @param nsIDOMElement aPopup
  *        The XUL popup you expect to open.
  * @param nsIDOMElement aButton
  *        The button/element that receives the contextmenu event. This is
  *        expected to open the popup.
  * @param function aOnShown
  *        Function to invoke on popupshown event.
  * @param function aOnHidden
  *        Function to invoke on popuphidden event.
+ * @return object
+ *         A Promise object that is resolved after the popuphidden event
+ *         callback is invoked.
  */
 function waitForContextMenu(aPopup, aButton, aOnShown, aOnHidden)
 {
   function onPopupShown() {
     info("onPopupShown");
     aPopup.removeEventListener("popupshown", onPopupShown);
 
-    aOnShown();
+    aOnShown && aOnShown();
 
     // Use executeSoon() to get out of the popupshown event.
     aPopup.addEventListener("popuphidden", onPopupHidden);
     executeSoon(() => aPopup.hidePopup());
   }
   function onPopupHidden() {
     info("onPopupHidden");
     aPopup.removeEventListener("popuphidden", onPopupHidden);
-    aOnHidden();
+
+    aOnHidden && aOnHidden();
+
+    deferred.resolve(aPopup);
   }
 
+  let deferred = promise.defer();
   aPopup.addEventListener("popupshown", onPopupShown);
 
   info("wait for the context menu to open");
   let eventDetails = { type: "contextmenu", button: 2};
   EventUtils.synthesizeMouse(aButton, 2, 2, eventDetails,
                              aButton.ownerDocument.defaultView);
+  return deferred.promise;
 }
 
 /**
  * Dump the output of all open Web Consoles - used only for debugging purposes.
  */
 function dumpConsoles()
 {
   if (gPendingOutputTest) {
@@ -328,120 +299,109 @@ function dumpMessageElement(aMessage)
                 "class", aMessage.className,
                 "category", aMessage.category,
                 "severity", aMessage.severity,
                 "repeats", repeats,
                 "clipboardText", aMessage.clipboardText,
                 "text", text);
 }
 
-function finishTest()
-{
-  browser = hudId = hud = filterBox = outputNode = cs = hudBox = null;
-
+let finishTest = Task.async(function* () {
   dumpConsoles();
 
   let browserConsole = HUDService.getBrowserConsole();
   if (browserConsole) {
     if (browserConsole.jsterm) {
       browserConsole.jsterm.clearOutput(true);
     }
-    HUDService.toggleBrowserConsole().then(finishTest);
-    return;
+    yield HUDService.toggleBrowserConsole();
   }
 
-  let hud = HUDService.getHudByWindow(content);
-  if (!hud) {
-    finish();
-    return;
-  }
+  let target = TargetFactory.forTab(gBrowser.selectedTab);
+  yield gDevTools.closeToolbox(target);
 
-  if (hud.jsterm) {
-    hud.jsterm.clearOutput(true);
-  }
-
-  closeConsole(hud.target.tab, finish);
-
-  hud = null;
-}
+  finish();
+});
 
 function tearDown()
 {
+  gDevTools.testing = false;
+
   dumpConsoles();
 
   if (HUDService.getBrowserConsole()) {
     HUDService.toggleBrowserConsole();
   }
 
   let target = TargetFactory.forTab(gBrowser.selectedTab);
   gDevTools.closeToolbox(target);
+
   while (gBrowser.tabs.length > 1) {
     gBrowser.removeCurrentTab();
   }
-  WCU_l10n = tab = browser = hudId = hud = filterBox = outputNode = cs = null;
 }
 
 registerCleanupFunction(tearDown);
 
 waitForExplicitFinish();
 
 /**
  * Polls a given function waiting for it to become true.
  *
  * @param object aOptions
  *        Options object with the following properties:
- *        - validatorFn
+ *        - validator
  *        A validator function that returns a boolean. This is called every few
- *        milliseconds to check if the result is true. When it is true, succesFn
- *        is called and polling stops. If validatorFn never returns true, then
- *        polling timeouts after several tries and a failure is recorded.
- *        - successFn
- *        A function called when the validator function returns true.
- *        - failureFn
- *        A function called if the validator function timeouts - fails to return
- *        true in the given time.
+ *        milliseconds to check if the result is true. When it is true, the
+ *        promise is resolved and polling stops. If validator never returns
+ *        true, then polling timeouts after several tries and the promise is
+ *        rejected.
  *        - name
  *        Name of test. This is used to generate the success and failure
  *        messages.
  *        - timeout
  *        Timeout for validator function, in milliseconds. Default is 5000.
+ * @return object
+ *         A Promise object that is resolved based on the validator function.
  */
 function waitForSuccess(aOptions)
 {
+  let deferred = promise.defer();
   let start = Date.now();
   let timeout = aOptions.timeout || 5000;
+  let {validator} = aOptions;
 
-  function wait(validatorFn, successFn, failureFn)
+  function wait()
   {
     if ((Date.now() - start) > timeout) {
       // Log the failure.
       ok(false, "Timed out while waiting for: " + aOptions.name);
-      failureFn(aOptions);
+      deferred.reject(null);
       return;
     }
 
-    if (validatorFn(aOptions)) {
+    if (validator(aOptions)) {
       ok(true, aOptions.name);
-      successFn();
+      deferred.resolve(null);
     }
     else {
-      setTimeout(function() wait(validatorFn, successFn, failureFn), 100);
+      setTimeout(wait, 100);
     }
   }
 
-  wait(aOptions.validatorFn, aOptions.successFn, aOptions.failureFn);
+  setTimeout(wait, 100);
+
+  return deferred.promise;
 }
 
-function openInspector(aCallback, aTab = gBrowser.selectedTab)
-{
+let openInspector = Task.async(function* (aTab = gBrowser.selectedTab) {
   let target = TargetFactory.forTab(aTab);
-  gDevTools.showToolbox(target, "inspector").then(function(toolbox) {
-    aCallback(toolbox.getCurrentPanel());
-  });
-}
+  let toolbox = yield gDevTools.showToolbox(target, "inspector");
+  return toolbox.getCurrentPanel();
+});
 
 /**
  * Find variables or properties in a VariablesView instance.
  *
  * @param object aView
  *        The VariablesView instance.
  * @param array aRules
  *        The array of rules you want to match. Each rule is an object with:
@@ -775,54 +735,61 @@ function variablesViewExpandTo(aOptions)
  * @param object aOptions
  *        Options for the property update:
  *        - property: the property you want to change.
  *        - field: string that tells what you want to change:
  *          - use "name" to change the property name,
  *          - or "value" to change the property value.
  *        - string: the new string to write into the field.
  *        - webconsole: reference to the Web Console instance we work with.
- *        - callback: function to invoke after the property is updated.
+ * @return object
+ *         A Promise object that is resolved once the property is updated.
  */
-function updateVariablesViewProperty(aOptions)
-{
+let updateVariablesViewProperty = Task.async(function* (aOptions) {
   let view = aOptions.property._variablesView;
   view.window.focus();
   aOptions.property.focus();
 
   switch (aOptions.field) {
     case "name":
       EventUtils.synthesizeKey("VK_RETURN", { shiftKey: true }, view.window);
       break;
     case "value":
       EventUtils.synthesizeKey("VK_RETURN", {}, view.window);
       break;
     default:
       throw new Error("options.field is incorrect");
-      return;
   }
 
+  let deferred = promise.defer();
+
   executeSoon(() => {
     EventUtils.synthesizeKey("A", { accelKey: true }, view.window);
 
     for (let c of aOptions.string) {
-      EventUtils.synthesizeKey(c, {}, gVariablesView.window);
+      EventUtils.synthesizeKey(c, {}, view.window);
     }
 
     if (aOptions.webconsole) {
-      aOptions.webconsole.jsterm.once("variablesview-fetched", aOptions.callback);
+      aOptions.webconsole.jsterm.once("variablesview-fetched").then((varView) => {
+        deferred.resolve(varView);
+      });
     }
 
     EventUtils.synthesizeKey("VK_RETURN", {}, view.window);
 
     if (!aOptions.webconsole) {
-      executeSoon(aOptions.callback);
+      executeSoon(() => {
+        deferred.resolve(null);
+      });
     }
   });
-}
+
+  return deferred.promise;
+});
 
 /**
  * Open the JavaScript debugger.
  *
  * @param object aOptions
  *        Options for opening the debugger:
  *        - tab: the tab you want to open the debugger for.
  * @return object
diff --git a/browser/devtools/webconsole/test/test-console-assert.html b/browser/devtools/webconsole/test/test-console-assert.html
--- a/browser/devtools/webconsole/test/test-console-assert.html
+++ b/browser/devtools/webconsole/test/test-console-assert.html
@@ -14,11 +14,10 @@
         console.assert(0, "falsy assert");
         console.assert(true, "true assert");
         console.log("end");
       }
     </script>
   </head>
   <body>
     <p>test console.assert()</p>
-    <button onclick="test();">test console.assert()</button>
   </body>
 </html>
diff --git a/browser/devtools/webconsole/test/test-console-output-events.html b/browser/devtools/webconsole/test/test-console-output-events.html
--- a/browser/devtools/webconsole/test/test-console-output-events.html
+++ b/browser/devtools/webconsole/test/test-console-output-events.html
@@ -5,19 +5,39 @@
   <title>Test the web console output for DOM events</title>
   <!--
   - Any copyright is dedicated to the Public Domain.
   - http://creativecommons.org/publicdomain/zero/1.0/
   -->
 </head>
 <body>
   <p>hello world!</p>
+
   <script type="text/javascript">
 function testDOMEvents() {
   function eventLogger(ev) {
     console.log("eventLogger", ev);
   }
   document.addEventListener("mousemove", eventLogger);
   document.addEventListener("keypress", eventLogger);
+
+  synthesizeKeyPress("a", {shiftKey: true});
+  synthesizeMouseMove();
 }
+
+function synthesizeKeyPress(key, options) {
+  var keyboardEvent = document.createEvent("KeyboardEvent");
+  keyboardEvent.initKeyEvent("keypress", true, true, window, false, false,
+                             options.shiftKey, false, key.charCodeAt(0), 0);
+  document.dispatchEvent(keyboardEvent);
+}
+
+function synthesizeMouseMove(element) {
+  var mouseEvent = document.createEvent("MouseEvent");
+  mouseEvent.initMouseEvent("mousemove", true, true, window, 0, 0, 0, 0, 0,
+                            false, false, false, false, 0, null);
+
+  document.dispatchEvent(mouseEvent);
+}
+
   </script>
 </body>
 </html>
