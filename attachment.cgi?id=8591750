From: Jordan Santell <jsantell@gmail.com>
Date: Tue, 24 Feb 2015 17:16:17 -0800
Subject: Bug 1149634 - Modularize the components of Netmonitor into
 several views and modules. r=vp

diff --git a/browser/devtools/jar.mn b/browser/devtools/jar.mn
index 9436334..f497982 100644
--- a/browser/devtools/jar.mn
+++ b/browser/devtools/jar.mn
@@ -11,16 +11,21 @@ browser.jar:
     content/browser/devtools/readdir.js                                (projecteditor/lib/helpers/readdir.js)
     content/browser/devtools/projecteditor-loader.xul                        (projecteditor/chrome/content/projecteditor-loader.xul)
     content/browser/devtools/projecteditor-test.xul                          (projecteditor/chrome/content/projecteditor-test.xul)
     content/browser/devtools/projecteditor-loader.js                         (projecteditor/chrome/content/projecteditor-loader.js)
     content/browser/devtools/netmonitor.xul                            (netmonitor/netmonitor.xul)
     content/browser/devtools/netmonitor.css                            (netmonitor/netmonitor.css)
     content/browser/devtools/netmonitor-controller.js                  (netmonitor/netmonitor-controller.js)
     content/browser/devtools/netmonitor-view.js                        (netmonitor/netmonitor-view.js)
+    content/browser/devtools/netmonitor/details-view.js                (netmonitor/views/details-view.js)
+    content/browser/devtools/netmonitor/requests-view.js               (netmonitor/views/requests-view.js)
+    content/browser/devtools/netmonitor/sidebar-view.js                (netmonitor/views/sidebar-view.js)
+    content/browser/devtools/netmonitor/custom-request-view.js         (netmonitor/views/custom-request-view.js)
+    content/browser/devtools/netmonitor/request-context-view.js        (netmonitor/views/request-context-view.js)
     content/browser/devtools/NetworkPanel.xhtml                        (webconsole/NetworkPanel.xhtml)
     content/browser/devtools/webconsole.xul                            (webconsole/webconsole.xul)
 *   content/browser/devtools/scratchpad.xul                            (scratchpad/scratchpad.xul)
     content/browser/devtools/scratchpad.js                             (scratchpad/scratchpad.js)
     content/browser/devtools/scratchpad-commands.js                    (scratchpad/scratchpad-commands.js)
     content/browser/devtools/splitview.css                             (shared/splitview.css)
     content/browser/devtools/theme-switching.js                        (shared/theme-switching.js)
     content/browser/devtools/frame-script-utils.js                     (shared/frame-script-utils.js)
diff --git a/browser/devtools/netmonitor/modules/request-collection.js b/browser/devtools/netmonitor/modules/request-collection.js
new file mode 100644
index 0000000..1fd3093
--- /dev/null
+++ b/browser/devtools/netmonitor/modules/request-collection.js
@@ -0,0 +1,377 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+"use strict";
+
+const { Class } = require("sdk/core/heritage");
+const { EventTarget } = require("sdk/event/target");
+const { emit } = require("sdk/event/core");
+const { RequestModel } = require("devtools/netmonitor/request-model");
+const types = require("devtools/netmonitor/types");
+const utils = require("devtools/netmonitor/utils");
+const { remove, unique, has } = require("sdk/util/array");
+
+/**
+ * Predicates used when sorting items.
+ *
+ * @param object aFirst
+ *        The first item used in the comparison.
+ * @param object aSecond
+ *        The second item used in the comparison.
+ * @return number
+ *         -1 to sort aFirst to a lower index than aSecond
+ *          0 to leave aFirst and aSecond unchanged with respect to each other
+ *          1 to sort aSecond to a lower index than aFirst
+ */
+const SORTING = {
+  waterfall: (first, second) => first.startedMillis > second.startedMillis,
+  status: (first, second) => first.status == second.status ?
+                             first.startedMillis > second.startedMillis :
+                             first.status > second.status,
+  method: (first, second) => first.method == second.method ?
+                             first.startedMillis > second.startedMillis :
+                             first.method > second.method,
+  file: (first, second) => {
+    let firstUrl = utils.getUriNameWithQuery(first.url).toLowerCase();
+    let secondUrl = utils.getUriNameWithQuery(second.url).toLowerCase();
+    return firstUrl == secondUrl
+      ? first.startedMillis > second.startedMillis
+      : firstUrl > secondUrl;
+  },
+  domain: (first, second) => {
+    let firstDomain = utils.getUriHostPort(first.url).toLowerCase();
+    let secondDomain = utils.getUriHostPort(second.url).toLowerCase();
+    return firstDomain == secondDomain ?
+           first.startedMillis > second.startedMillis :
+           firstDomain > secondDomain;
+  },
+  type: (first, second) => {
+    let firstType = utils.getAbbreviatedMimeType(first.mimeType).toLowerCase();
+    let secondType = utils.getAbbreviatedMimeType(second.mimeType).toLowerCase();
+    return firstType == secondType ?
+      first.startedMillis > second.startedMillis :
+      firstType > secondType;
+  },
+  transferred: (first, second) => first.transferredSize > second.transferredSize,
+  size: (first, second) => first.contentSize > second.contentSize
+};
+
+const FILTERS = {
+  all: () => true,
+  html: types.isHtml,
+  css: types.isCss,
+  js: types.isJs,
+  xhr: types.isXHR,
+  fonts: types.isFont,
+  images: types.isImage,
+  media: types.isMedia,
+  flash: types.isFlash,
+  other: types.isOther
+};
+
+/**
+ * Model representing a request. Adding and destroying Requests
+ * should be performed through the Request collection.
+ *
+ * Events:
+ * - `change`: Emitted when a property changes. Args: `this, prop, value`
+ * - `sort`: Emitted when the collection is sorted.
+ * - `filtered`: Emitted when a filter is added or removed.
+ * - `reset`: Emitted when all models are cleared.
+ */
+const RequestCollection = exports.RequestCollection = Class({
+  extends: EventTarget,
+  model: RequestModel,
+
+  firstRequestStartedMillis: -1,
+  lastRequestEndedMillis: -1,
+
+  initialize: function (models) {
+    this.models = [];
+    this._filters = ["all"];
+    this._onModelEvent = this._onModelEvent.bind(this);
+    this._comparator = SORTING.waterfall;
+
+    // Wrap the emit function to not emit events if
+    // the collection becomes disabled.
+    this.emit = (...args) => {
+      if (!this._disabled) {
+        emit.apply(null, [this, ...args]);
+      }
+    };
+  },
+
+  /**
+   * Takes a type and checks to see if it's a valid filter type, like
+   * "js", "html", "all", etc.
+   */
+  isValidFilterType: (type) => has(Object.keys(FILTERS), type),
+
+  /**
+   * Get the total duration from the start of the first request
+   * to the end of the last request for all requests in the collection.
+   */
+  getDuration: function () {
+    return this.lastRequestEndedMillis - this.firstRequestStartedMillis;
+  },
+
+  /**
+   * Disables the collection, preventing all events from being
+   * emitted.
+   */
+  disable: function () {
+    this._disabled = true;
+  },
+
+  /**
+   * Set a text filter for all requests, matching requests whose URL contains the query.
+   */
+  setURLFilter: function (query) {
+    this._urlFilter = query;
+    this._invalidateFilterCache();
+    this.emit("filtered");
+  },
+
+  /**
+   * Overwrite all other filters and set filters only
+   * described in `filters`. See @addFilter for filter options. Takes
+   * a string or an array.
+   */
+  setFilter: function (filters, options={}) {
+    this._filters = [].concat(filters);
+    this._normalizeFilters();
+    this._invalidateFilterCache();
+    if (!options.silent) {
+      this.emit("filtered");
+    }
+  },
+
+  /**
+   * Adds a filter type to the collection. Takes a string, or an array of strings
+   * of types "all", "html", "css", "js", "xhr", "fonts", "images",
+   * "media", "flash" or "other".
+   */
+  addFilter: function (filters, options={}) {
+    // Special case of adding "all" filter, remove all other filters
+    if (filters === "all") {
+      return this.setFilter("all", options);
+    }
+    this._filters = unique(this._filters.concat(filters));
+    this._normalizeFilters();
+    this._invalidateFilterCache();
+    if (!options.silent) {
+      this.emit("filtered");
+    }
+  },
+
+  /**
+   * Removes a filter from stored filters. Takes a string or an array of strings.
+   * See @addFilter for valid filter types.
+   */
+  removeFilter: function (filters, options={}) {
+    [].concat(filters).forEach(remove.bind(null, this._filters));
+    this._normalizeFilters();
+    this._invalidateFilterCache();
+    if (!options.silent) {
+      this.emit("filtered");
+    }
+  },
+
+  /**
+   * Ensures that if we have no filters left, add an "all" filter,
+   * and if we have other filters, ensure that no "all" filter is on.
+   */
+  _normalizeFilters: function () {
+    // If no filters left, ensure the "all" filter is on.
+    if (this._filters.length === 0) {
+      this._filters.push("all");
+    }
+    // If we have non-all filters, remove the "all" filter.
+    else if (has(this._filters, "all") && this._filters.length > 1) {
+      remove(this._filters, "all");
+    }
+  },
+
+  /**
+   * Returns an array of the currently active filters.
+   */
+  getFilters: function () {
+    return this._filters;
+  },
+
+  /**
+   * Returns a boolean indicating whether this collection
+   * has the applied filter or not.
+   */
+  hasFilter: function (filter) {
+    return !!~this._filters.indexOf(filter);
+  },
+
+  /**
+   * Returns a filtered, new array of the collection based off of set filters.
+   * Takes advantage of caching.
+   */
+  getFiltered: function () {
+    if (this._cachedFilteredModels) {
+      return this._cachedFilteredModels;
+    }
+    return this._cachedFilteredModels = this.models.filter(this.getFilterPredicate());
+  },
+
+  /**
+   * Gets the function used to determine if models are valid within the current filter.
+   * Takes advantage of caching.
+   */
+  getFilterPredicate: function () {
+    if (this._cachedFilterPredicate) {
+      return this._cachedFilterPredicate;
+    }
+
+    return this._cachedFilterPredicate = (model) => {
+      return model.matchesQuery(this._urlFilter) &&
+             this._filters.some(filterName => FILTERS[filterName](model));
+    };
+  },
+
+  _invalidateFilterCache: function () {
+    this._cachedFilteredModels = this._cachedFilterPredicate = null;
+  },
+
+  update: function (id, data) {
+    let model = this.findWhere({ id: id });
+    if (model) {
+      model.set(data);
+    }
+  },
+
+  add: function (data) {
+    let request = new this.model(data);
+    request.collection = this;
+
+    this.models.push(request);
+
+    request.on("*", this._onModelEvent);
+    this.emit("add", request);
+
+    this._updateMaxima(request.startedMillis);
+
+    // After adding the model, add `startedDeltaMillis` to normalize it
+    // with other models in the collection, based off of `firstRequestStartedMillis`.
+    request.startedDeltaMillis = request.startedMillis - this.firstRequestStartedMillis;
+
+    // Sort with new model added. Wonder if this will be costly.
+    this.sort({ silent: true });
+
+    // Delete cached filter as we don't know if this new model is in the filter group
+    // or not yet. Will be refreshed on next getFiltered() call.
+    this._invalidateFilterCache();
+
+    return request;
+  },
+
+  /**
+   * Updates the times of the first or last request based on time for
+   * all models in the collection.
+   *
+   * @params number unixTime
+   *         The time in milliseconds to check if this is the first or last time of the collection.
+   */
+  _updateMaxima: function (unixTime) {
+    if (unixTime > this.lastRequestEndedMillis) {
+      this.lastRequestEndedMillis = unixTime;
+    }
+    if (this.firstRequestStartedMillis === -1) {
+      this.firstRequestStartedMillis = unixTime;
+    }
+  },
+
+  reset: function () {
+    this.firstRequestStartedMillis = this.lastRequestEndedMillis = -1;
+    this.models = [];
+    this._invalidateFilterCache();
+    this.emit("reset");
+  },
+
+  remove: function (request) {
+    remove(this.models, request);
+    this.emit("remove", request);
+  },
+
+  /**
+   * Set the sort for this collection. Takes a `sortName`, like the functions
+   * in `SORTING`, like "status", "method", "file", "domain", "type", "transferred",
+   * "size" or "waterfall". Second argument is whether or not this is descending. Defaults
+   * to ascending.
+   */
+  sortBy: function (sortName, isDescending) {
+    let sorter = SORTING[sortName] || SORTING.waterfall;
+    this._comparator = isDescending ? ((a, b) => !sorter(a, b)) : sorter;
+    this.sort();
+  },
+
+  sort: function (options={}) {
+    this.models = this.models.sort(this._comparator);
+    if (!options.silent) {
+      this.emit("sort");
+    }
+  },
+
+  /**
+   * Retrieve a model from the collection via `id`.
+   */
+  get: function (id) {
+    return this.findWhere({ id: id });
+  },
+
+  /**
+   * Retrieve a model from the collection via an `index`. Ordered by creation time,
+   * and does not consider filtered views.
+   */
+  at: function (index) {
+    return this.models[index];
+  },
+
+  /**
+   * Takes a hash. Return the first object in the
+   * collection that matches the values in the hash.
+   * From Backbone.Collection#findWhere
+   * http://backbonejs.org/#Collection-findWhere
+   */
+  findWhere: function (attrs) {
+    let keys = Object.keys(attrs);
+    for (let model of this.models) {
+      if (keys.every(key => model[key] === attrs[key])) {
+        return model;
+      }
+    }
+    return void 0;
+  },
+
+  _onModelEvent: function (eventName, model, ...args) {
+    if (eventName === "change" && args[0] === "totalTime") {
+      this._updateMaxima(model.endedMillis);
+    }
+    this.emit(eventName, model, ...args);
+  },
+
+  get length() {
+    return this.models.length;
+  },
+
+  // TODO
+  // Exposed functions that interface with widget attachments (filter, sorting) assume
+  // that the model is stored under the `attachment` property. This just exposes
+  // a mapping so you can wrap the filterPredicate or comparator in this to get the
+  // real model, not the widget item. Once removing the widget item list in TableRenderer,
+  // this can be removed.
+  //
+  // Example in TableRenderer:
+  // this.filterContents(widgetify(RequestCollection.getFilterPredicate()));
+  // this.sortContents(widgetify(RequestCollection._comparator));
+  widgetify: function (fn) {
+    return function (...args) {
+      return fn.apply(null, args.map(({ attachment }) => attachment));
+    }
+  }
+});
diff --git a/browser/devtools/netmonitor/modules/request-model.js b/browser/devtools/netmonitor/modules/request-model.js
new file mode 100644
index 0000000..cfdff87
--- /dev/null
+++ b/browser/devtools/netmonitor/modules/request-model.js
@@ -0,0 +1,193 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+"use strict";
+const { Class } = require("sdk/core/heritage");
+const { EventTarget } = require("sdk/event/target");
+const { emit } = require("sdk/event/core");
+const { XPCOMUtils } = require("resource://gre/modules/XPCOMUtils.jsm");
+const CLONE_PROPERTIES = [
+  "requestHeaders", "requestCookies", "requestPostData", "securityState", "securityInfo",
+  "responseHeaders", "httpVersion", "status", "statusText", "headersSize", "contentSize",
+  "transferredSize", "mimeType", "responseContent", "totalTime", "eventTimings"
+];
+
+XPCOMUtils.defineLazyModuleGetter(this, "Curl", "resource:///modules/devtools/Curl.jsm");
+XPCOMUtils.defineLazyModuleGetter(this, "CurlUtils", "resource:///modules/devtools/Curl.jsm");
+
+/**
+ * Model representing a request. Adding and destroying Requests
+ * should be performed through the Request collection.
+ *
+ * Events:
+ * - `change`: Emitted when a property changes. Args: `this, prop, value`
+ * - `change:ATTRIBUTE`: Emitted when ATTRIBUTE changes. Args: `this, prop, value`
+ */
+const RequestModel = exports.RequestModel = Class({
+  extends: EventTarget,
+  requestHeaders: null,
+  requestCookies: null,
+  requestPostData: null,
+  securityState: null,
+  securityInfo: null,
+  responseHeaders: null,
+  httpVersion: null,
+  status: null,
+  statusText: null,
+  headersSize: null,
+  contentSize: null,
+  transferredSize: null,
+  mimeType: null,
+  responseContent: null,
+  totalTime: null,
+  eventTimings: null,
+  isCustom: null,
+  cloned: null,
+
+  /**
+   * Creates a new Request instance.
+   *
+   * @options object
+   * - @param object gNetwork
+   * - @param string id
+   * - @param string method
+   * - @param string url
+   * - @param boolean isXhr
+   * - @param number startedMillis
+   */
+  initialize: function ({ gNetwork, id, method, url, isXHR, startedMillis, cloned }) {
+    this.gNetwork = gNetwork;
+    this.id = id;
+    this.url = url;
+    this.method = method;
+    this.isXHR = isXHR;
+    this.startedMillis = startedMillis;
+    this.cloned = !!cloned;
+  },
+
+  /**
+   * Sets a property on this Request instance. Can either pass in two arguments
+   * for `prop` and `value`, or the first argument can be an object with key-value
+   * pairings that get set.
+   */
+  set: function (prop, value) {
+    // If first argument is an object, use that
+    // to set properties.
+    if (typeof prop === "object") {
+      for (let attr in prop) {
+        this.set(attr, prop[attr]);
+      }
+      return;
+    }
+
+    // The information in the packet is empty, it can be safely ignored.
+    if (value === undefined) {
+      return void 0;
+    }
+
+    switch (prop) {
+      case "responseContent":
+        // If there's no mime type available when the response content
+        // is received, assume text/plain as a fallback.
+        if (!this.mimeType) {
+          this.set("mimeType", "text/plain");
+        }
+        break;
+      case "totalTime":
+        this.endedMillis = this.startedMillis + value;
+        break;
+      case "requestPostData":
+        return this._setRequestPostData(value);
+    }
+
+    this[prop] = value;
+    emit(this, "change", this, prop, value);
+  },
+
+  _setRequestPostData: function (value) {
+    let store = { headers: [], headersSize: 0 };
+    let model = this;
+
+    this.requestPostData = value;
+    this.requestHeadersFromUploadStream = store;
+    emit(this, "change", this, "requestPostData", value);
+
+    // Search the POST data upload stream for request headers and add
+    // them to a separate store, different from the classic headers.
+    return Task.spawn(function*() {
+      let postData = yield model.gNetwork.getString(value.postData.text);
+      let payloadHeaders = CurlUtils.getHeadersFromMultipartText(postData);
+
+      store.headers = payloadHeaders;
+      store.headersSize = payloadHeaders.reduce(
+        (acc, { name, value }) => acc + name.length + value.length + 2, 0);
+
+      // Emit events for `requestHeadersFromUploadStream` here, as it's
+      // done asynchronously and not set directly.
+      emit(model, "change", model, "requestHeadersFromUploadStream", store);
+    });
+  },
+
+  /**
+   * Returns a promise that resolves to a Curl string that
+   * can be used to recreate this request.
+   */
+  toCurlString: Task.async(function*() {
+    // Create a sanitized object for the Curl command generator.
+    let data = {
+      url: this.url,
+      method: this.method,
+      headers: [],
+      httpVersion: this.httpVersion,
+      postDataText: null
+    };
+
+    // Fetch header values.
+    for (let { name, value } of this.requestHeaders.headers) {
+      let text = yield this.gNetwork.getString(value);
+      data.headers.push({ name: name, value: text });
+    }
+
+    // Fetch the request payload.
+    if (this.requestPostData) {
+      let postData = this.requestPostData.postData.text;
+      data.postDataText = yield this.gNetwork.getString(postData);
+    }
+
+    return Curl.generateCommand(data);
+  }),
+
+  /**
+   * Returns a promise that resolves to a data URI string for this request.
+   */
+  toDataURI: Task.async(function*() {
+    let { mimeType, text, encoding } = this.responseContent.content;
+
+    let decoded = yield this.gNetwork.getString(text);
+    return `data:${mimeType};${encoding},${decoded}`;
+  }),
+
+  /**
+   * Used to see if passed in string matches the request's URL.
+   */
+  matchesQuery: function (query) {
+    return !query || this.url.contains(query);
+  },
+
+  /**
+   * Clone the selected request model.
+   */
+  clone: function () {
+    let clone = new RequestModel({
+      gNetwork: this.gNetwork,
+      method: this.method,
+      url: this.url,
+      isXHR: this.isXHR,
+      id: this.id,
+      startedMillis: this.startedMillis,
+      cloned: true
+    });
+    CLONE_PROPERTIES.forEach(prop => clone[prop] = this[prop]);
+    return clone;
+  },
+});
diff --git a/browser/devtools/netmonitor/modules/summary-renderer.js b/browser/devtools/netmonitor/modules/summary-renderer.js
new file mode 100644
index 0000000..6409088
--- /dev/null
+++ b/browser/devtools/netmonitor/modules/summary-renderer.js
@@ -0,0 +1,73 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+"use strict";
+
+const { ViewHelpers } = require("resource:///modules/devtools/ViewHelpers.jsm");
+const { SideMenuWidget } = require("resource:///modules/devtools/SideMenuWidget.jsm");
+const { PluralForm } = require("resource://gre/modules/PluralForm.jsm");
+const { EventTarget } = require("sdk/event/target");
+const { debounce } = require("sdk/lang/functional");
+const { Class } = require("sdk/core/heritage");
+const utils = require("devtools/netmonitor/utils");
+const NET_STRINGS_URI = "chrome://browser/locale/devtools/netmonitor.properties";
+
+const L10N = new ViewHelpers.L10N(NET_STRINGS_URI);
+const SUMMARY_REFRESH_RATE = 100;
+const CONTENT_SIZE_DECIMALS = 2;
+const REQUEST_TIME_DECIMALS = 2;
+
+/**
+ * Summary Renderer for displaying total information on requests.
+ */
+const SummaryRenderer = exports.SummaryRenderer = Class({
+  extends: EventTarget,
+
+  /**
+   * Binds RequestCollection events to the `refresh` method.
+   */
+  initialize: function (el, requests) {
+    this.el = el;
+    this.requests = requests;
+
+    el.setAttribute("value", L10N.getStr("networkMenu.empty"));
+
+    this.refresh = debounce(this.refresh.bind(this), SUMMARY_REFRESH_RATE);
+    requests.on("add", this.refresh);
+    requests.on("change", this.refresh);
+    requests.on("filtered", this.refresh);
+    requests.on("reset", this.refresh);
+  },
+
+  /**
+   * Cleans up the renderer.
+   */
+  destroy: function () {
+    requests.off("add", this.refresh);
+    requests.off("change", this.refresh);
+    requests.off("filtered", this.refresh);
+    requests.off("reset", this.refresh);
+  },
+
+  /**
+   * Summarizes and renders the requests.
+   */
+  refresh: function () {
+    let filtered = this.requests.getFiltered();
+    if (!filtered.length) {
+      this.el.setAttribute("value", L10N.getStr("networkMenu.empty"));
+      return;
+    }
+
+    let totalBytes = utils.getTotalBytesOfRequests(filtered);
+    let totalMillis =
+      utils.getNewestRequest(filtered).endedMillis -
+      utils.getOldestRequest(filtered).startedMillis;
+    let str = PluralForm.get(filtered.length, L10N.getStr("networkMenu.summary"));
+
+    this.el.setAttribute("value", str
+        .replace("#1", filtered.length)
+        .replace("#2", L10N.numberWithDecimals((totalBytes || 0) / 1024, CONTENT_SIZE_DECIMALS))
+        .replace("#3", L10N.numberWithDecimals((totalMillis || 0) / 1024, REQUEST_TIME_DECIMALS)));
+  }
+});
diff --git a/browser/devtools/netmonitor/modules/table-renderer.js b/browser/devtools/netmonitor/modules/table-renderer.js
new file mode 100644
index 0000000..30c7998
--- /dev/null
+++ b/browser/devtools/netmonitor/modules/table-renderer.js
@@ -0,0 +1,733 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+"use strict";
+
+const { ViewHelpers, WidgetMethods } = require("resource:///modules/devtools/ViewHelpers.jsm");
+const { SideMenuWidget } = require("resource:///modules/devtools/SideMenuWidget.jsm");
+const { EventTarget } = require("sdk/event/target");
+const { emit } = require("sdk/event/core");
+const { PluralForm } = require("resource://gre/modules/PluralForm.jsm");
+const { debounce } = require("sdk/lang/functional");
+const { Class } = require("sdk/core/heritage");
+const utils = require("devtools/netmonitor/utils");
+const types = require("devtools/netmonitor/types");
+
+const NET_STRINGS_URI = "chrome://browser/locale/devtools/netmonitor.properties";
+
+const L10N = new ViewHelpers.L10N(NET_STRINGS_URI);
+const SUMMARY_REFRESH_RATE = 100;
+const CONTENT_SIZE_DECIMALS = 2;
+const HTML_NS = "http://www.w3.org/1999/xhtml";
+const EPSILON = 0.001;
+const RESIZE_REFRESH_RATE = 50; // ms
+const REQUESTS_REFRESH_RATE = 50; // ms
+const REQUESTS_HEADERS_SAFE_BOUNDS = 30; // px
+const REQUESTS_TOOLTIP_POSITION = "topcenter bottomleft";
+const REQUESTS_TOOLTIP_IMAGE_MAX_DIM = 400; // px
+const REQUESTS_WATERFALL_SAFE_BOUNDS = 90; // px
+const REQUESTS_WATERFALL_HEADER_TICKS_MULTIPLE = 5; // ms
+const REQUESTS_WATERFALL_HEADER_TICKS_SPACING_MIN = 60; // px
+const REQUESTS_WATERFALL_BACKGROUND_TICKS_MULTIPLE = 5; // ms
+const REQUESTS_WATERFALL_BACKGROUND_TICKS_SCALES = 3;
+const REQUESTS_WATERFALL_BACKGROUND_TICKS_SPACING_MIN = 10; // px
+const REQUESTS_WATERFALL_BACKGROUND_TICKS_COLOR_RGB = [128, 136, 144];
+const REQUESTS_WATERFALL_BACKGROUND_TICKS_OPACITY_MIN = 32; // byte
+const REQUESTS_WATERFALL_BACKGROUND_TICKS_OPACITY_ADD = 32; // byte
+const REQUEST_TIME_DECIMALS = 2;
+const HEADERS_SIZE_DECIMALS = 3;
+const RENDER_IF_UPDATED_PROPERTIES = [
+  "securityState", "status", "statusText", "contentSize", "transferredSize",
+  "responseContent", "mimeType", "totalTime"
+];
+
+/**
+ * Exposed API
+ * To refactor this renderer, or replace with something else, the following methods and events
+ * must be implemented.
+ * Many of these methods are remenants of using ViewHelper widgets, and can probably be removed if
+ * tests are updated to just use the request model.
+ *
+ * destroy() - May return a promise upon destruction complete. Must be sure to handle that after calling
+ * destroy, no further action should come from here (drawing to canvas, etc)
+ * refreshWaterfall(boolean) - Called from main view when timing data or a resize has occurred. Debounced here.
+ * selectFirstRequest() - Selects the first visible request.
+ * unselectRequest() - Unselects a request.
+ * selectRequest(id) - Selects a request by ID.
+ * selectRequestByIndex(i) - Selects a request by index.
+ * getSelectedIndex() - Returns the currently selected index.
+ * getSelected() - Returns the currently selected request (NOT the widget "item", but the attachment)
+ *
+ * Events:
+ * - 'select' Emits the selected model.
+ */
+const TableRenderer = exports.TableRenderer = Class({
+  implements: [WidgetMethods, EventTarget],
+  initialize: function (el, requests, gNetwork) {
+    this.gNetwork = gNetwork;
+    this.el = el;
+    this.document = this.el.ownerDocument;
+    this.window = this.el.ownerDocument.defaultView;
+    // Ideally, this $ would be scoped to the table, but that's not possible
+    // right now due to XUL templating used around. Will have to be worked on
+    // in a renderer refactor.
+    this.$ = (selector, target=this.document) => target.querySelector(selector);
+    this.requests = requests;
+
+    // Lazy updating is disabled in some tests.
+    if (this.lazyUpdate) {
+      this._flushChanged = debounce(this._flushChanged.bind(this), REQUESTS_REFRESH_RATE);
+    } else {
+      this._flushChanged = this._flushChanged.bind(this);
+    }
+    this._onSelect = this._onSelect.bind(this);
+
+    // Bind and set up debounced renderings
+    this.refreshWaterfall = debounce(this.refreshWaterfall.bind(this), RESIZE_REFRESH_RATE);
+
+    // Bind to collection events
+    this._onRequestAdd = this._onRequestAdd.bind(this);
+    this._onRequestUpdate = this._onRequestUpdate.bind(this);
+    this._onRequestSort = this._onRequestSort.bind(this);
+    this._onRequestFilter = this._onRequestFilter.bind(this);
+    this._onRequestReset = this._onRequestReset.bind(this);
+
+    // Set up widget
+    this.widget = new SideMenuWidget(this.el);
+    requests.on("add", this._onRequestAdd);
+    requests.on("change", this._onRequestUpdate);
+    requests.on("sort", this._onRequestSort);
+    requests.on("filtered", this._onRequestFilter);
+    requests.on("reset", this._onRequestReset);
+
+    // Look at RequestCollection#widgetify for use of RequestCollection
+    // functions with this widget view.
+    this.sortContents(requests.widgetify(requests._comparator));
+
+    this.allowFocusOnRightClick = true;
+    this.maintainSelectionVisible = true;
+    this.widget.autoscrollWithAppendedItems = true;
+
+    this.widget.addEventListener("select", this._onSelect, false);
+  },
+
+  /**
+   * Destruction function, called when the network monitor is closed.
+   */
+  destroy: function() {
+    this.requests.off("add", this._onRequestAdd);
+    this.requests.off("change", this._onRequestUpdate);
+    this.requests.off("sort", this._onRequestSort);
+    this.requests.off("filtered", this._onRequestFilter);
+    this.requests.off("reset", this._onRequestReset);
+    this.widget.removeEventListener("select", this._onSelect, false);
+  },
+
+  /**
+   * Specifies if this view may be updated lazily. Should be controlled via
+   * parent RequestsMenu.
+   */
+  lazyUpdate: true,
+
+  _onRequestSort: function () {
+    // Look at RequestCollection#widgetify for use of RequestCollection
+    // functions with this widget view.
+    this.sortContents(this.requests.widgetify(this.requests._comparator));
+    this.refreshZebra();
+  },
+
+  _onRequestFilter: function () {
+    // As this is using SideBarWidget, use the filter predicate the collection
+    // is using for now.
+    // Look at RequestCollection#widgetify for use of RequestCollection
+    // functions with this widget view.
+    this.filterContents(this.requests.widgetify(this.requests.getFilterPredicate()));
+    this.refreshZebra();
+  },
+
+  /**
+   * When requests are reset, empty out our update queue and table.
+   */
+  _onRequestReset: function () {
+    this._updateQueue.length = 0;
+    this.empty();
+  },
+
+  /**
+   * Called when a new Request instance is added to RequestCollection.
+   */
+  _onRequestAdd: function (model) {
+    let menuView = this._createMenuView(model.method, model.url);
+    let requestItem = this.push([menuView, model.id], {
+      attachment: model
+    });
+
+    // Look at RequestCollection#widgetify for use of RequestCollection
+    // functions with this widget view.
+    this.sortContents(this.requests.widgetify(this.requests._comparator));
+    // Look at RequestCollection#widgetify for use of RequestCollection
+    // functions with this widget view.
+    this.filterContents(this.requests.widgetify(this.requests.getFilterPredicate()));
+    this.refreshZebra();
+
+    // Rescale all the waterfalls so that everything is visible at once.
+    this.refreshWaterfall();
+  },
+
+  /**
+   * Returns the currently selected index.
+   */
+  getSelectedIndex: function () {
+    return this.selectedIndex;
+  },
+
+  /**
+   * Returns the currently selected request model.
+   */
+  getSelected: function () {
+    return this.selectedItem && this.selectedItem.attachment;
+  },
+
+  /**
+   * Selects the first visible request.
+   */
+  selectFirstRequest: function () {
+    this.selectedIndex = 0;
+  },
+  
+  /**
+   * Unselects a request.
+   */
+  unselectRequest: function () {
+    this.selectedIndex = -1;
+  },
+
+  /**
+   * Selects a request by ID.
+   */
+  selectRequest: function (id) {
+    this.selectedValue = id;
+  },
+
+  /**
+   * Selects a request by index.
+   */
+  selectRequestByIndex: function (i) {
+    this.selectedIndex = i;
+  },
+
+  /**
+   * Adds odd/even attributes to all the visible items in this container.
+   */
+  refreshZebra: function() {
+    let visibleItems = this.visibleItems;
+
+    for (let i = 0, len = visibleItems.length; i < len; i++) {
+      let requestItem = visibleItems[i];
+      let requestTarget = requestItem.target;
+
+      if (i % 2 == 0) {
+        requestTarget.setAttribute("even", "");
+        requestTarget.removeAttribute("odd");
+      } else {
+        requestTarget.setAttribute("odd", "");
+        requestTarget.removeAttribute("even");
+      }
+    }
+  },
+
+  /**
+   * Called when a Request instance's property is updated.
+   */
+  _onRequestUpdate: function (model, prop, value) {
+    var data = {};
+    data[prop] = value;
+    this._updateQueue.push([model.id, data]);
+
+    let requestItem = this.getItemByValue(model.id);
+
+    this._flushChanged();
+  },
+
+  /**
+   * Starts adding all queued additional information about network requests.
+   */
+  _flushChanged: function() {
+    // For each queued additional information packet, get the corresponding
+    // request item in the view and update it based on the specified data.
+    for (let [id, data] of this._updateQueue) {
+      let requestItem = this.getItemByValue(id);
+      if (!requestItem) {
+        // Packet corresponds to a dead request item, target navigated.
+        continue;
+      }
+
+      // Each information packet may contain several { key: value } tuples of
+      // network info, so update the view based on each one.
+      for (let key in data) {
+        let value = data[key];
+        if (~RENDER_IF_UPDATED_PROPERTIES.indexOf(key)) {
+          this.updateMenuView(requestItem, key, value);
+        }
+        if (key === "eventTimings") {
+          this._createWaterfallView(requestItem, value.timings);
+        }
+      }
+    }
+
+    // We're done flushing all the requests, clear the update queue.
+    this._updateQueue.length = 0;
+
+    // Make sure all the requests are sorted and filtered.
+    // Freshly added requests may not yet contain all the information required
+    // for sorting and filtering predicates, so this is done each time the
+    // network requests table is flushed (don't worry, events are drained first
+    // so this doesn't happen once per network event update).
+
+    // Look at RequestCollection#widgetify for use of RequestCollection
+    // functions with this widget view.
+    this.sortContents(this.requests.widgetify(this.requests._comparator));
+    // Look at RequestCollection#widgetify for use of RequestCollection
+    // functions with this widget view.
+    this.filterContents(this.requests.widgetify(this.requests.getFilterPredicate()));
+    this.refreshZebra();
+
+    // Rescale all the waterfalls so that everything is visible at once.
+    this.refreshWaterfall();
+  },
+
+  /**
+   * Adds odd/even attributes to all the visible items in this container.
+   */
+  refreshZebra: function() {
+    let visibleItems = this.visibleItems;
+
+    for (let i = 0, len = visibleItems.length; i < len; i++) {
+      let requestItem = visibleItems[i];
+      let requestTarget = requestItem.target;
+
+      if (i % 2 == 0) {
+        requestTarget.setAttribute("even", "");
+        requestTarget.removeAttribute("odd");
+      } else {
+        requestTarget.setAttribute("odd", "");
+        requestTarget.removeAttribute("even");
+      }
+    }
+  },
+
+  /**
+   * Customization function for creating an item's UI.
+   *
+   * @param string aMethod
+   *        Specifies the request method (e.g. "GET", "POST", etc.)
+   * @param string aUrl
+   *        Specifies the request's url.
+   * @return nsIDOMNode
+   *         The network request view.
+   */
+  _createMenuView: function(aMethod, aUrl) {
+    let template = this.document.querySelector("#requests-menu-item-template");
+    let fragment = this.document.createDocumentFragment();
+
+    this.updateMenuView(template, "method", aMethod);
+    this.updateMenuView(template, "url", aUrl);
+
+    // Flatten the DOM by removing one redundant box (the template container).
+    for (let node of template.childNodes) {
+      fragment.appendChild(node.cloneNode(true));
+    }
+
+    return fragment;
+  },
+
+  /**
+   * Updates the information displayed in a network request item view.
+   *
+   * @param object aItem
+   *        The network request item in this container.
+   * @param string aKey
+   *        The type of information that is to be updated.
+   * @param any aValue
+   *        The new value to be shown.
+   * @return object
+   *         A promise that is resolved once the information is displayed.
+   */
+  updateMenuView: Task.async(function*(aItem, aKey, aValue) {
+    let target = aItem.target || aItem;
+
+    switch (aKey) {
+      case "method": {
+        let node = this.$(".requests-menu-method", target);
+        node.setAttribute("value", aValue);
+        break;
+      }
+      case "url": {
+        let uri;
+        try {
+          uri = utils.nsIURL(aValue);
+        } catch(e) {
+          break; // User input may not make a well-formed url yet.
+        }
+        let nameWithQuery = utils.getUriNameWithQuery(uri);
+        let hostPort = utils.getUriHostPort(uri);
+
+        let file = this.$(".requests-menu-file", target);
+        file.setAttribute("value", nameWithQuery);
+        file.setAttribute("tooltiptext", nameWithQuery);
+
+        let domain = this.$(".requests-menu-domain", target);
+        domain.setAttribute("value", hostPort);
+        domain.setAttribute("tooltiptext", hostPort);
+        break;
+      }
+      case "securityState": {
+        let tooltip = L10N.getStr("netmonitor.security.state." + aValue);
+        let icon = this.$(".requests-security-state-icon", target);
+        icon.classList.add("security-state-" + aValue);
+        icon.setAttribute("tooltiptext", tooltip);
+        break;
+      }
+      case "status": {
+        let node = this.$(".requests-menu-status", target);
+        let codeNode = this.$(".requests-menu-status-code", target);
+        codeNode.setAttribute("value", aValue);
+        node.setAttribute("code", aValue);
+        break;
+      }
+      case "statusText": {
+        let node = this.$(".requests-menu-status-and-method", target);
+        node.setAttribute("tooltiptext", aValue);
+        break;
+      }
+      case "contentSize": {
+        let kb = aValue / 1024;
+        let size = L10N.numberWithDecimals(kb, CONTENT_SIZE_DECIMALS);
+        let node = this.$(".requests-menu-size", target);
+        let text = L10N.getFormatStr("networkMenu.sizeKB", size);
+        node.setAttribute("value", text);
+        node.setAttribute("tooltiptext", text);
+        break;
+      }
+      case "transferredSize": {
+        let text;
+        if (aValue === null) {
+          text = L10N.getStr("networkMenu.sizeUnavailable");
+        } else {
+          let kb = aValue / 1024;
+          let size = L10N.numberWithDecimals(kb, CONTENT_SIZE_DECIMALS);
+          text = L10N.getFormatStr("networkMenu.sizeKB", size);
+        }
+        let node = this.$(".requests-menu-transferred", target);
+        node.setAttribute("value", text);
+        node.setAttribute("tooltiptext", text);
+        break;
+      }
+      case "mimeType": {
+        let type = utils.getAbbreviatedMimeType(aValue);
+        let node = this.$(".requests-menu-type", target);
+        let text = types.abbreviateMimeType(type);
+        node.setAttribute("value", text);
+        node.setAttribute("tooltiptext", aValue);
+        break;
+      }
+      case "responseContent": {
+        let { mimeType } = aItem.attachment;
+        let { text, encoding } = aValue.content;
+
+        if (mimeType.contains("image/")) {
+          let responseBody = yield this.gNetwork.getString(text);
+          let node = this.$(".requests-menu-icon", aItem.target);
+          node.src = "data:" + mimeType + ";" + encoding + "," + responseBody;
+          node.setAttribute("type", "thumbnail");
+          node.removeAttribute("hidden");
+
+          //window.emit(EVENTS.RESPONSE_IMAGE_THUMBNAIL_DISPLAYED);
+        }
+        break;
+      }
+      case "totalTime": {
+        let node = this.$(".requests-menu-timings-total", target);
+        let text = L10N.getFormatStr("networkMenu.totalMS", aValue); // integer
+        node.setAttribute("value", text);
+        node.setAttribute("tooltiptext", text);
+        break;
+      }
+    }
+  }),
+
+  /**
+   * Creates a waterfall representing timing information in a network request item view.
+   *
+   * @param object aItem
+   *        The network request item in this container.
+   * @param object aTimings
+   *        An object containing timing information.
+   */
+  _createWaterfallView: function(aItem, aTimings) {
+    let { target, attachment } = aItem;
+    let sections = ["dns", "connect", "send", "wait", "receive"];
+    // Skipping "blocked" because it doesn't work yet.
+
+    let timingsNode = this.$(".requests-menu-timings", target);
+    let timingsTotal = this.$(".requests-menu-timings-total", timingsNode);
+
+    // Add a set of boxes representing timing information.
+    for (let key of sections) {
+      let width = aTimings[key];
+
+      // Don't render anything if it surely won't be visible.
+      // One millisecond == one unscaled pixel.
+      if (width > 0) {
+        let timingBox = this.document.createElement("hbox");
+        timingBox.className = "requests-menu-timings-box " + key;
+        timingBox.setAttribute("width", width);
+        timingsNode.insertBefore(timingBox, timingsTotal);
+      }
+    }
+  },
+
+  /**
+   * Rescales and redraws all the waterfall views in this container.
+   *
+   * @param boolean aReset
+   *        True if this container's width was changed.
+   */
+  refreshWaterfall: function(aReset) {
+    // Don't paint waterfall if there are no items in the container.
+    if (!this.itemCount) {
+      return;
+    }
+
+    // To avoid expensive operations like getBoundingClientRect() and
+    // rebuilding the waterfall background each time a new request comes in,
+    // stuff is cached. However, in certain scenarios like when the window
+    // is resized, this needs to be invalidated.
+    if (aReset) {
+      this._cachedWaterfallWidth = 0;
+    }
+
+    // Determine the scaling to be applied to all the waterfalls so that
+    // everything is visible at once. One millisecond == one unscaled pixel.
+    let availableWidth = this._waterfallWidth - REQUESTS_WATERFALL_SAFE_BOUNDS;
+    let longestWidth = this.requests.getDuration();
+    let scale = Math.min(Math.max(availableWidth / longestWidth, EPSILON), 1);
+
+    // Redraw and set the canvas background for each waterfall view.
+    this._showWaterfallDivisionLabels(scale);
+    this._drawWaterfallBackground(scale);
+
+    // Apply CSS transforms to each waterfall in this container totalTime
+    // accurately translate and resize as needed.
+    for (let { target, attachment } of this) {
+      let timingsNode = this.$(".requests-menu-timings", target);
+      let totalNode = this.$(".requests-menu-timings-total", target);
+      let direction = this.window.isRTL ? -1 : 1;
+
+      // Render the timing information at a specific horizontal translation
+      // based on the delta to the first monitored event network.
+      let translateX = "translateX(" + (direction * attachment.startedDeltaMillis) + "px)";
+
+      // Based on the total time passed until the last request, rescale
+      // all the waterfalls to a reasonable size.
+      let scaleX = "scaleX(" + scale + ")";
+
+      // Certain nodes should not be scaled, even if they're children of
+      // another scaled node. In this case, apply a reversed transformation.
+      let revScaleX = "scaleX(" + (1 / scale) + ")";
+
+      timingsNode.style.transform = scaleX + " " + translateX;
+      totalNode.style.transform = revScaleX;
+    }
+  },
+
+  /**
+   * Creates the labels displayed on the waterfall header in this container.
+   *
+   * @param number aScale
+   *        The current waterfall scale.
+   */
+  _showWaterfallDivisionLabels: function(aScale) {
+    let container = this.$("#requests-menu-waterfall-button");
+    let availableWidth = this._waterfallWidth - REQUESTS_WATERFALL_SAFE_BOUNDS;
+
+    // Nuke all existing labels.
+    while (container.hasChildNodes()) {
+      container.firstChild.remove();
+    }
+
+    // Build new millisecond tick labels...
+    let timingStep = REQUESTS_WATERFALL_HEADER_TICKS_MULTIPLE;
+    let optimalTickIntervalFound = false;
+
+    while (!optimalTickIntervalFound) {
+      // Ignore any divisions that would end up being too close to each other.
+      let scaledStep = aScale * timingStep;
+      if (scaledStep < REQUESTS_WATERFALL_HEADER_TICKS_SPACING_MIN) {
+        timingStep <<= 1;
+        continue;
+      }
+      optimalTickIntervalFound = true;
+
+      // Insert one label for each division on the current scale.
+      let fragment = this.document.createDocumentFragment();
+      let direction = this.window.isRTL ? -1 : 1;
+
+      for (let x = 0; x < availableWidth; x += scaledStep) {
+        let translateX = "translateX(" + ((direction * x) | 0) + "px)";
+        let millisecondTime = x / aScale;
+
+        let normalizedTime = millisecondTime;
+        let divisionScale = "millisecond";
+
+        // If the division is greater than 1 minute.
+        if (normalizedTime > 60000) {
+          normalizedTime /= 60000;
+          divisionScale = "minute";
+        }
+        // If the division is greater than 1 second.
+        else if (normalizedTime > 1000) {
+          normalizedTime /= 1000;
+          divisionScale = "second";
+        }
+
+        // Showing too many decimals is bad UX.
+        if (divisionScale == "millisecond") {
+          normalizedTime |= 0;
+        } else {
+          normalizedTime = L10N.numberWithDecimals(normalizedTime, REQUEST_TIME_DECIMALS);
+        }
+
+        let node = this.document.createElement("label");
+        let text = L10N.getFormatStr("networkMenu." + divisionScale, normalizedTime);
+        node.className = "plain requests-menu-timings-division";
+        node.setAttribute("division-scale", divisionScale);
+        node.style.transform = translateX;
+
+        node.setAttribute("value", text);
+        fragment.appendChild(node);
+      }
+      container.appendChild(fragment);
+    }
+  },
+
+  /**
+   * Creates the background displayed on each waterfall view in this container.
+   *
+   * @param number aScale
+   *        The current waterfall scale.
+   */
+  _drawWaterfallBackground: function(aScale) {
+    if (!this._canvas || !this._ctx) {
+      this._canvas = this.document.createElementNS(HTML_NS, "canvas");
+      this._ctx = this._canvas.getContext("2d");
+    }
+    let canvas = this._canvas;
+    let ctx = this._ctx;
+
+    // Nuke the context.
+    let canvasWidth = canvas.width = this._waterfallWidth;
+    let canvasHeight = canvas.height = 1; // Awww yeah, 1px, repeats on Y axis.
+
+    // Start over.
+    let imageData = ctx.createImageData(canvasWidth, canvasHeight);
+    let pixelArray = imageData.data;
+
+    let buf = new ArrayBuffer(pixelArray.length);
+    let view8bit = new Uint8ClampedArray(buf);
+    let view32bit = new Uint32Array(buf);
+
+    // Build new millisecond tick lines...
+    let timingStep = REQUESTS_WATERFALL_BACKGROUND_TICKS_MULTIPLE;
+    let [r, g, b] = REQUESTS_WATERFALL_BACKGROUND_TICKS_COLOR_RGB;
+    let alphaComponent = REQUESTS_WATERFALL_BACKGROUND_TICKS_OPACITY_MIN;
+    let optimalTickIntervalFound = false;
+
+    while (!optimalTickIntervalFound) {
+      // Ignore any divisions that would end up being too close to each other.
+      let scaledStep = aScale * timingStep;
+      if (scaledStep < REQUESTS_WATERFALL_BACKGROUND_TICKS_SPACING_MIN) {
+        timingStep <<= 1;
+        continue;
+      }
+      optimalTickIntervalFound = true;
+
+      // Insert one pixel for each division on each scale.
+      for (let i = 1; i <= REQUESTS_WATERFALL_BACKGROUND_TICKS_SCALES; i++) {
+        let increment = scaledStep * Math.pow(2, i);
+        for (let x = 0; x < canvasWidth; x += increment) {
+          let position = (this.window.isRTL ? canvasWidth - x : x) | 0;
+          view32bit[position] = (alphaComponent << 24) | (b << 16) | (g << 8) | r;
+        }
+        alphaComponent += REQUESTS_WATERFALL_BACKGROUND_TICKS_OPACITY_ADD;
+      }
+    }
+
+    // Flush the image data and cache the waterfall background.
+    pixelArray.set(view8bit);
+    ctx.putImageData(imageData, 0, 0);
+    this.document.mozSetImageElement("waterfall-background", canvas);
+  },
+
+  /**
+   * The selection listener for this container.
+   */
+  _onSelect: function({ detail: item }) {
+    console.log("ON SELECT", item);
+    emit(this, "select", item ? item.attachment : null);
+  },
+
+  /**
+   * Handle the context menu opening. Hide items if no request is selected.
+   */
+  _onContextShowing: function() {
+    let selectedItem = this.selectedItem;
+
+    let resendElement = this.$("#request-menu-context-resend");
+    resendElement.hidden = !NetMonitorController.supportsCustomRequest ||
+      !selectedItem || selectedItem.attachment.isCustom;
+
+    let copyUrlElement = this.$("#request-menu-context-copy-url");
+    copyUrlElement.hidden = !selectedItem;
+
+    let copyAsCurlElement = this.$("#request-menu-context-copy-as-curl");
+    copyAsCurlElement.hidden = !selectedItem || !selectedItem.attachment.responseContent;
+
+    let copyImageAsDataUriElement = this.$("#request-menu-context-copy-image-as-data-uri");
+    copyImageAsDataUriElement.hidden = !selectedItem ||
+      !selectedItem.attachment.responseContent ||
+      !selectedItem.attachment.responseContent.content.mimeType.contains("image/");
+
+    let separator = this.$("#request-menu-context-separator");
+    separator.hidden = !selectedItem;
+
+    let newTabElement = this.$("#request-menu-context-newtab");
+    newTabElement.hidden = !selectedItem;
+  },
+
+  /**
+   * Gets the available waterfall width in this container.
+   * @return number
+   */
+  get _waterfallWidth() {
+    if (this._cachedWaterfallWidth == 0) {
+      // Use the full document scope to select the outside container area.
+      // Stopgap until this renderer can be better refactored.
+      let container = this.document.querySelector("#requests-menu-toolbar");
+      let waterfall = this.document.querySelector("#requests-menu-waterfall-header-box");
+      let containerBounds = container.getBoundingClientRect();
+      let waterfallBounds = waterfall.getBoundingClientRect();
+      if (!this.window.isRTL) {
+        this._cachedWaterfallWidth = containerBounds.width - waterfallBounds.left;
+      } else {
+        this._cachedWaterfallWidth = waterfallBounds.right;
+      }
+    }
+    return this._cachedWaterfallWidth;
+  },
+
+  _canvas: null,
+  _ctx: null,
+  _cachedWaterfallWidth: 0,
+  _updateQueue: []
+});
diff --git a/browser/devtools/netmonitor/modules/types.js b/browser/devtools/netmonitor/modules/types.js
new file mode 100644
index 0000000..457d491
--- /dev/null
+++ b/browser/devtools/netmonitor/modules/types.js
@@ -0,0 +1,130 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+"use strict";
+
+const Editor = require("devtools/sourceeditor/editor");
+
+const CONTENT_MIME_TYPE_ABBREVIATIONS = {
+  "ecmascript": "js",
+  "javascript": "js",
+  "x-javascript": "js"
+};
+
+const CONTENT_MIME_TYPE_MAPPINGS = {
+  "/ecmascript": Editor.modes.js,
+  "/javascript": Editor.modes.js,
+  "/x-javascript": Editor.modes.js,
+  "/html": Editor.modes.html,
+  "/xhtml": Editor.modes.html,
+  "/xml": Editor.modes.html,
+  "/atom": Editor.modes.html,
+  "/soap": Editor.modes.html,
+  "/rdf": Editor.modes.css,
+  "/rss": Editor.modes.css,
+  "/css": Editor.modes.css
+};
+
+/**
+ * Predicates used when filtering items.
+ *
+ * @param object aItem
+ *        The filtered item.
+ * @return boolean
+ *         True if the item should be visible, false otherwise.
+ */
+let isHtml   = exports.isHtml = ({ mimeType }) =>
+               mimeType && mimeType.contains("/html");
+let isCss    = exports.isCss = ({ mimeType }) =>
+               mimeType && mimeType.contains("/css");
+let isJs     = exports.isJs = ({ mimeType }) =>
+               mimeType && (
+                 mimeType.contains("/ecmascript") ||
+                 mimeType.contains("/javascript") ||
+                 mimeType.contains("/x-javascript"));
+let isXHR    = exports.isXHR = ({ isXHR }) => isXHR;
+let isFont   = exports.isFont = ({ url, mimeType }) => // Fonts are a mess.
+               (mimeType && (
+                 mimeType.contains("font/") ||
+                 mimeType.contains("/font"))) ||
+               url.contains(".eot") ||
+               url.contains(".ttf") ||
+               url.contains(".otf") ||
+               url.contains(".woff");
+let isImage  = exports.isImage = ({ mimeType }) =>
+               mimeType && mimeType.contains("image/");
+let isMedia  = exports.isMedia = ({ mimeType }) => // Not including images.
+               mimeType && (
+                 mimeType.contains("audio/") ||
+                 mimeType.contains("video/") ||
+                 mimeType.contains("model/"));
+let isFlash  = exports.isFlash = ({ url, mimeType }) => // Flash is a mess.
+               (mimeType && (
+                 mimeType.contains("/x-flv") ||
+                 mimeType.contains("/x-shockwave-flash"))) ||
+               url.contains(".swf") ||
+               url.contains(".flv");
+let isOther  = exports.isOther = (e) =>
+               !isHtml(e) && !isCss(e) && !isJs(e) && !isXHR(e) &&
+               !isFont(e) && !isImage(e) && !isMedia(e) && !isFlash(e);
+
+
+/**
+ * Return an abbreviated form of the provided mime type, if it exists. Otherwise,
+ * just return the type.
+ *
+ * @param string type
+ *        The mimetype string.
+ * @return string
+ *         The abbreviated or original mimetype.
+ */
+exports.abbreviateMimeType = function (type) {
+  return CONTENT_MIME_TYPE_ABBREVIATIONS[type] || type;
+};
+
+/**
+ * Takes an `Editor` instance and a mimeType string. If an appropriate
+ * editor mode is found for the mime type, set the editor instance to use it.
+ *
+ * @param object editor
+ *        The editor instance to set mode.
+ * @param string mimeType
+ *        The mime type string.
+ */
+exports.setEditorMode = function (editor, mimeType) {
+  let mapping = Object.keys(CONTENT_MIME_TYPE_MAPPINGS).find(key => mimeType.contains(key));
+  if (mapping) {
+    editor.setMode(CONTENT_MIME_TYPE_MAPPINGS[mapping]);
+  }
+};
+
+/**
+ * Takes a model and returns the numeric form Charts.jsm expects.
+ *
+ * @param object model
+ *        The request.
+ * @return number
+ *         The Charts.jsm type.
+ */
+exports.typeToChartType = function (model) {
+  if (isHtml(model)) {
+    return 0; // "html"
+  } else if (isCss(model)) {
+    return 1; // "css"
+  } else if (isJs(model)) {
+    return 2; // "js"
+  } else if (isFont(model)) {
+    return 4; // "fonts"
+  } else if (isImage(model)) {
+    return 5; // "images"
+  } else if (isMedia(model)) {
+    return 6; // "media"
+  } else if (isFlash(model)) {
+    return 7; // "flash"
+  } else if (isXHR(model)) {
+    // Verify XHR last, to categorize other mime types in their own blobs.
+    return 3; // "xhr"
+  }
+  return 8; // "other"
+};
+
diff --git a/browser/devtools/netmonitor/modules/utils.js b/browser/devtools/netmonitor/modules/utils.js
new file mode 100644
index 0000000..5faa2bc
--- /dev/null
+++ b/browser/devtools/netmonitor/modules/utils.js
@@ -0,0 +1,318 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+"use strict";
+
+const { Ci } = require("chrome");
+const { Services } = require("resource://gre/modules/Services.jsm");
+const types = require("devtools/netmonitor/types");
+
+var NetworkHelper = {};
+Object.defineProperty(NetworkHelper, "convertToUnicode", {
+  get: function() {
+    return require("devtools/toolkit/webconsole/network-helper").convertToUnicode;
+  },
+  configurable: true,
+  enumerable: true
+});
+
+/**
+ * Object defining the network monitor controller components.
+
+/**
+ * Helpers for getting details about an nsIURL.
+ *
+ * @param nsIURL | string aUrl
+ * @return string
+ */
+exports.getUriNameWithQuery = function(aUrl) {
+  if (!(aUrl instanceof Ci.nsIURL)) {
+    aUrl = nsIURL(aUrl);
+  }
+  let name = NetworkHelper.convertToUnicode(unescape(aUrl.fileName)) || "/";
+  let query = NetworkHelper.convertToUnicode(unescape(aUrl.query));
+  return name + (query ? "?" + query : "");
+};
+
+exports.getUriHostPort =  function(aUrl) {
+  if (!(aUrl instanceof Ci.nsIURL)) {
+    aUrl = nsIURL(aUrl);
+  }
+  return NetworkHelper.convertToUnicode(unescape(aUrl.hostPort));
+};
+
+/**
+ * Helper for getting an abbreviated string for a mime type.
+ *
+ * @param string aMimeType
+ * @return string
+ */
+exports.getAbbreviatedMimeType = function(aMimeType) {
+  if (!aMimeType) {
+    return "";
+  }
+  return (aMimeType.split(";")[0].split("/")[1] || "").split("+")[0];
+};
+
+/**
+ * Gets the total number of bytes representing the cumulated content size of
+ * a set of requests. Returns 0 for an empty set.
+ *
+ * @param array aItemsArray
+ * @return number
+ */
+exports.getTotalBytesOfRequests = function(aItemsArray) {
+  if (!aItemsArray.length) {
+    return 0;
+  }
+  return aItemsArray.reduce((prev, curr) => prev + curr.contentSize || 0, 0);
+};
+
+/**
+ * Gets the oldest (first performed) request in a set. Returns null for an
+ * empty set.
+ *
+ * @param array aItemsArray
+ * @return object
+ */
+exports.getOldestRequest = function(aItemsArray) {
+  if (!aItemsArray.length) {
+    return null;
+  }
+  return aItemsArray.reduce((prev, curr) =>
+    prev.startedMillis < curr.startedMillis ? prev : curr);
+};
+
+/**
+ * Gets the newest (latest performed) request in a set. Returns null for an
+ * empty set.
+ *
+ * @param array aItemsArray
+ * @return object
+ */
+exports.getNewestRequest = function(aItemsArray) {
+  if (!aItemsArray.length) {
+    return null;
+  }
+  return aItemsArray.reduce((prev, curr) =>
+    prev.startedMillis > curr.startedMillis ? prev : curr);
+};
+
+/**
+ * Helper for getting an nsIURL instance out of a string.
+ */
+function nsIURL(aUrl, aStore = nsIURL.store) {
+  if (aStore.has(aUrl)) {
+    return aStore.get(aUrl);
+  }
+  let uri = Services.io.newURI(aUrl, null, null).QueryInterface(Ci.nsIURL);
+  aStore.set(aUrl, uri);
+  return uri;
+}
+nsIURL.store = new Map();
+exports.nsIURL = nsIURL;
+
+/**
+ * Parse a url's query string into its components
+ *
+ * @param string aQueryString
+ *        The query part of a url
+ * @return array
+ *         Array of query params {name, value}
+ */
+function parseQueryString(aQueryString) {
+  // Make sure there's at least one param available.
+  // Be careful here, params don't necessarily need to have values, so
+  // no need to verify the existence of a "=".
+  if (!aQueryString) {
+    return;
+  }
+  // Turn the params string into an array containing { name: value } tuples.
+  let paramsArray = aQueryString.replace(/^[?&]/, "").split("&").map(e => {
+    let param = e.split("=");
+    return {
+      name: param[0] ? NetworkHelper.convertToUnicode(unescape(param[0])) : "",
+      value: param[1] ? NetworkHelper.convertToUnicode(unescape(param[1])) : ""
+    }});
+  return paramsArray;
+}
+exports.parseQueryString = parseQueryString;
+
+/**
+ * Parse text representation of multiple HTTP headers.
+ *
+ * @param string aText
+ *        Text of headers
+ * @return array
+ *         Array of headers info {name, value}
+ */
+function parseHeadersText(aText) {
+  return parseRequestText(aText, "\\S+?", ":");
+}
+exports.parseHeadersText = parseHeadersText;
+
+/**
+ * Parse readable text list of a query string.
+ *
+ * @param string aText
+ *        Text of query string represetation
+ * @return array
+ *         Array of query params {name, value}
+ */
+function parseQueryText(aText) {
+  return parseRequestText(aText, ".+?", "=");
+}
+exports.parseQueryText = parseQueryText;
+
+/**
+ * Parse a text representation of a name[divider]value list with
+ * the given name regex and divider character.
+ *
+ * @param string aText
+ *        Text of list
+ * @return array
+ *         Array of headers info {name, value}
+ */
+function parseRequestText(aText, aName, aDivider) {
+  let regex = new RegExp("(" + aName + ")\\" + aDivider + "\\s*(.+)");
+  let pairs = [];
+  for (let line of aText.split("\n")) {
+    let matches;
+    if (matches = regex.exec(line)) {
+      let [, name, value] = matches;
+      pairs.push({name: name, value: value});
+    }
+  }
+  return pairs;
+}
+exports.parseRequestText = parseRequestText;
+
+/**
+ * Write out a list of headers into a chunk of text
+ *
+ * @param array aHeaders
+ *        Array of headers info {name, value}
+ * @return string aText
+ *         List of headers in text format
+ */
+function writeHeaderText(aHeaders) {
+  return [(name + ": " + value) for ({name, value} of aHeaders)].join("\n");
+}
+exports.writeHeaderText = writeHeaderText;
+
+/**
+ * Write out a list of query params into a chunk of text
+ *
+ * @param array aParams
+ *        Array of query params {name, value}
+ * @return string
+ *         List of query params in text format
+ */
+function writeQueryText(aParams) {
+  return [(name + "=" + value) for ({name, value} of aParams)].join("\n");
+}
+exports.writeQueryText = writeQueryText;
+
+/**
+ * Write out a list of query params into a query string
+ *
+ * @param array aParams
+ *        Array of query  params {name, value}
+ * @return string
+ *         Query string that can be appended to a url.
+ */
+function writeQueryString(aParams) {
+  return [(name + "=" + value) for ({name, value} of aParams)].join("&");
+}
+exports.writeQueryString = writeQueryString;
+
+/**
+ * Checks if the "Expiration Calculations" defined in section 13.2.4 of the
+ * "HTTP/1.1: Caching in HTTP" spec holds true for a collection of headers.
+ *
+ * @param object
+ *        An object containing the { responseHeaders, status } properties.
+ * @return boolean
+ *         True if the response is fresh and loaded from cache.
+ */
+function responseIsFresh({ responseHeaders, status }) {
+  // Check for a "304 Not Modified" status and response headers availability.
+  if (status != 304 || !responseHeaders) {
+    return false;
+  }
+
+  let list = responseHeaders.headers;
+  let cacheControl = list.filter(e => e.name.toLowerCase() == "cache-control")[0];
+  let expires = list.filter(e => e.name.toLowerCase() == "expires")[0];
+
+  // Check the "Cache-Control" header for a maximum age value.
+  if (cacheControl) {
+    let maxAgeMatch =
+      cacheControl.value.match(/s-maxage\s*=\s*(\d+)/) ||
+      cacheControl.value.match(/max-age\s*=\s*(\d+)/);
+
+    if (maxAgeMatch && maxAgeMatch.pop() > 0) {
+      return true;
+    }
+  }
+
+  // Check the "Expires" header for a valid date.
+  if (expires && Date.parse(expires.value)) {
+    return true;
+  }
+
+  return false;
+}
+exports.responseIsFresh = responseIsFresh;
+
+/**
+ * Helper method to get a wrapped function which can be bound to as an event listener directly and is executed only when data-key is present in event.target.
+ *
+ * @param function callback
+ *          Function to execute execute when data-key is present in event.target.
+ * @return function
+ *          Wrapped function with the target data-key as the first argument.
+ */
+function getKeyWithEvent(callback) {
+  return function(event) {
+    var key = event.target.getAttribute("data-key");
+    if (key) {
+      callback.call(null, key);
+    }
+  };
+}
+exports.getKeyWithEvent = getKeyWithEvent;
+
+/**
+ * Sanitizes the data source used for creating charts, to follow the
+ * data format spec defined in Chart.jsm.
+ *
+ * @param array models
+ *        A collection of request items used as the data source for the chart.
+ * @param boolean aEmptyCache
+ *        True if the cache is considered enabled, false for disabled.
+ */
+exports.sanitizeChartDataSource = function (models, aEmptyCache) {
+  let data = [
+    "html", "css", "js", "xhr", "fonts", "images", "media", "flash", "other"
+  ].map(e => ({
+    cached: 0,
+    count: 0,
+    label: e,
+    size: 0,
+    time: 0
+  }));
+
+  for (let model of models) {
+    let type = types.typeToChartType(model);
+    if (aEmptyCache || !responseIsFresh(model)) {
+      data[type].time += model.totalTime || 0;
+      data[type].size += model.contentSize || 0;
+    } else {
+      data[type].cached++;
+    }
+    data[type].count++;
+  }
+
+  return data.filter(e => e.count > 0);
+};
diff --git a/browser/devtools/netmonitor/moz.build b/browser/devtools/netmonitor/moz.build
index addaa6f..615a22f 100644
--- a/browser/devtools/netmonitor/moz.build
+++ b/browser/devtools/netmonitor/moz.build
@@ -1,10 +1,16 @@
 # vim: set filetype=python:
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 EXTRA_JS_MODULES.devtools.netmonitor += [
+    'modules/request-collection.js',
+    'modules/request-model.js',
+    'modules/summary-renderer.js',
+    'modules/table-renderer.js',
+    'modules/types.js',
+    'modules/utils.js',
     'panel.js'
 ]
 
 BROWSER_CHROME_MANIFESTS += ['test/browser.ini']
diff --git a/browser/devtools/netmonitor/netmonitor-controller.js b/browser/devtools/netmonitor/netmonitor-controller.js
index 7619280..771bad4 100644
--- a/browser/devtools/netmonitor/netmonitor-controller.js
+++ b/browser/devtools/netmonitor/netmonitor-controller.js
@@ -66,25 +66,31 @@ const EVENTS = {
   RESPONSE_HTML_PREVIEW_DISPLAYED: "NetMonitor:ResponseHtmlPreviewAvailable",
 
   // When the image response thumbnail is displayed in the UI.
   RESPONSE_IMAGE_THUMBNAIL_DISPLAYED: "NetMonitor:ResponseImageThumbnailAvailable",
 
   // When a tab is selected in the NetworkDetailsView and subsequently rendered.
   TAB_UPDATED: "NetMonitor:TabUpdated",
 
+  // Fired when Sidebar is toggled to display or hide.
+  SIDEBAR_TOGGLED: "NetMonitor:SidebarToggled",
+
   // Fired when Sidebar has finished being populated.
   SIDEBAR_POPULATED: "NetMonitor:SidebarPopulated",
 
   // Fired when NetworkDetailsView has finished being populated.
   NETWORKDETAILSVIEW_POPULATED: "NetMonitor:NetworkDetailsViewPopulated",
 
   // Fired when CustomRequestView has finished being populated.
   CUSTOMREQUESTVIEW_POPULATED: "NetMonitor:CustomRequestViewPopulated",
 
+  // Fired when a custom HTTP request is sent.
+  CUSTOM_REQUEST_SENT: "NetMonitor:CustomRequestSent",
+
   // Fired when charts have been displayed in the PerformanceStatisticsView.
   PLACEHOLDER_CHARTS_DISPLAYED: "NetMonitor:PlaceholderChartsDisplayed",
   PRIMED_CACHE_CHART_DISPLAYED: "NetMonitor:PrimedChartsDisplayed",
   EMPTY_CACHE_CHART_DISPLAYED: "NetMonitor:EmptyChartsDisplayed",
 
   // Fired once the NetMonitorController establishes a connection to the debug
   // target.
   CONNECTED: "connected",
@@ -112,29 +118,26 @@ Cu.import("resource://gre/modules/XPCOMUtils.jsm");
 Cu.import("resource:///modules/devtools/SideMenuWidget.jsm");
 Cu.import("resource:///modules/devtools/VariablesView.jsm");
 Cu.import("resource:///modules/devtools/VariablesViewController.jsm");
 Cu.import("resource:///modules/devtools/ViewHelpers.jsm");
 
 const require = Cu.import("resource://gre/modules/devtools/Loader.jsm", {}).devtools.require;
 const promise = Cu.import("resource://gre/modules/Promise.jsm", {}).Promise;
 const EventEmitter = require("devtools/toolkit/event-emitter");
+const utils = require("devtools/netmonitor/utils");
+const types = require("devtools/netmonitor/types");
 const Editor = require("devtools/sourceeditor/editor");
-const {Tooltip} = require("devtools/shared/widgets/Tooltip");
 const {ToolSidebar} = require("devtools/framework/sidebar");
+const RequestCollection = new require("devtools/netmonitor/request-collection").RequestCollection();
+let { console } = Cu.import("resource://gre/modules/devtools/Console.jsm", {});
 
 XPCOMUtils.defineLazyModuleGetter(this, "Chart",
   "resource:///modules/devtools/Chart.jsm");
 
-XPCOMUtils.defineLazyModuleGetter(this, "Curl",
-  "resource:///modules/devtools/Curl.jsm");
-
-XPCOMUtils.defineLazyModuleGetter(this, "CurlUtils",
-  "resource:///modules/devtools/Curl.jsm");
-
 XPCOMUtils.defineLazyModuleGetter(this, "Task",
   "resource://gre/modules/Task.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "PluralForm",
   "resource://gre/modules/PluralForm.jsm");
 
 XPCOMUtils.defineLazyModuleGetter(this, "DevToolsUtils",
   "resource://gre/modules/devtools/DevToolsUtils.jsm");
@@ -158,46 +161,45 @@ Object.defineProperty(this, "NetworkHelper", {
  */
 let NetMonitorController = {
   /**
    * Initializes the view.
    *
    * @return object
    *         A promise that is resolved when the monitor finishes startup.
    */
-  startupNetMonitor: function() {
+  startupNetMonitor: Task.async(function*() {
     if (this._startup) {
       return this._startup;
     }
 
-    NetMonitorView.initialize();
-
-    // Startup is synchronous, for now.
+    yield NetMonitorView.initialize();
     return this._startup = promise.resolve();
-  },
+  }),
 
   /**
    * Destroys the view and disconnects the monitor client from the server.
    *
    * @return object
    *         A promise that is resolved when the monitor finishes shutdown.
    */
-  shutdownNetMonitor: function() {
+  shutdownNetMonitor: Task.async(function*() {
     if (this._shutdown) {
       return this._shutdown;
     }
 
-    NetMonitorView.destroy();
+    RequestCollection.disable();
+    yield NetMonitorView.destroy();
     this.TargetEventsHandler.disconnect();
     this.NetworkEventsHandler.disconnect();
     this.disconnect();
 
     // Shutdown is synchronous, for now.
     return this._shutdown = promise.resolve();
-  },
+  }),
 
   /**
    * Initiates remote or chrome network monitoring based on the current target,
    * wiring event handlers as necessary.
    *
    * @return object
    *         A promise that is resolved when the monitor finishes connecting.
    */
@@ -239,16 +241,23 @@ let NetMonitorController = {
    * Checks whether the netmonitor connection is active.
    * @return boolean
    */
   isConnected: function() {
     return !!this.client;
   },
 
   /**
+   * Resets the requests collection. Views listen to this event and will update appropriately.
+   */
+  reset: function () {
+    RequestCollection.reset();
+  },
+
+  /**
    * Sets up a monitoring session.
    *
    * @param DebuggerClient aClient
    *        The debugger client.
    * @param object aTabGrip
    *        The remote protocol grip of the tab.
    * @param function aCallback
    *        A function to invoke once the client attached to the console client.
@@ -473,18 +482,17 @@ TargetEventsHandler.prototype = {
    * @param object aPacket
    *        Packet received from the server.
    */
   _onTabNavigated: function(aType, aPacket) {
     switch (aType) {
       case "will-navigate": {
         // Reset UI.
         if (!Services.prefs.getBoolPref("devtools.webconsole.persistlog")) {
-          NetMonitorView.RequestsMenu.reset();
-          NetMonitorView.Sidebar.toggle(false);
+          NetMonitorController.reset();
         }
         // Switch to the default network traffic inspector view.
         if (NetMonitorController.getCurrentActivity() == ACTIVITY_TYPE.NONE) {
           NetMonitorView.showNetworkInspectorView();
         }
 
         window.emit(EVENTS.TARGET_WILL_NAVIGATE);
         break;
@@ -554,31 +562,35 @@ NetworkEventsHandler.prototype = {
    */
   _onNetworkEvent: function(aType, aPacket) {
     if (aPacket.from != this.webConsoleClient.actor) {
       // Skip events from different console actors.
       return;
     }
 
     let { actor, startedDateTime, method, url, isXHR } = aPacket.eventActor;
-    NetMonitorView.RequestsMenu.addRequest(actor, startedDateTime, method, url, isXHR);
+    let unixTime = Date.parse(startedDateTime);
+
+    RequestCollection.add({
+      gNetwork, isXHR, url, method, id: actor, startedMillis: unixTime
+    });
     window.emit(EVENTS.NETWORK_EVENT, actor);
   },
 
   /**
    * The "networkEventUpdate" message type handler.
    *
    * @param string aType
    *        Message type.
    * @param object aPacket
    *        The message received from the server.
    */
   _onNetworkEventUpdate: function(aType, aPacket) {
     let actor = aPacket.from;
-    if (!NetMonitorView.RequestsMenu.getItemByValue(actor)) {
+    if (!RequestCollection.get(actor)) {
       // Skip events from unknown actors.
       return;
     }
 
     switch (aPacket.updateType) {
       case "requestHeaders":
         this.webConsoleClient.getRequestHeaders(actor, this._onRequestHeaders);
         window.emit(EVENTS.UPDATING_REQUEST_HEADERS, actor);
@@ -587,160 +599,160 @@ NetworkEventsHandler.prototype = {
         this.webConsoleClient.getRequestCookies(actor, this._onRequestCookies);
         window.emit(EVENTS.UPDATING_REQUEST_COOKIES, actor);
         break;
       case "requestPostData":
         this.webConsoleClient.getRequestPostData(actor, this._onRequestPostData);
         window.emit(EVENTS.UPDATING_REQUEST_POST_DATA, actor);
         break;
       case "securityInfo":
-        NetMonitorView.RequestsMenu.updateRequest(aPacket.from, {
+        RequestCollection.update(aPacket.from, {
           securityState: aPacket.state,
         });
         this.webConsoleClient.getSecurityInfo(actor, this._onSecurityInfo);
         window.emit(EVENTS.UPDATING_SECURITY_INFO, actor);
         break;
       case "responseHeaders":
         this.webConsoleClient.getResponseHeaders(actor, this._onResponseHeaders);
         window.emit(EVENTS.UPDATING_RESPONSE_HEADERS, actor);
         break;
       case "responseCookies":
         this.webConsoleClient.getResponseCookies(actor, this._onResponseCookies);
         window.emit(EVENTS.UPDATING_RESPONSE_COOKIES, actor);
         break;
       case "responseStart":
-        NetMonitorView.RequestsMenu.updateRequest(aPacket.from, {
+        RequestCollection.update(aPacket.from, {
           httpVersion: aPacket.response.httpVersion,
           remoteAddress: aPacket.response.remoteAddress,
           remotePort: aPacket.response.remotePort,
           status: aPacket.response.status,
           statusText: aPacket.response.statusText,
           headersSize: aPacket.response.headersSize
         });
         window.emit(EVENTS.STARTED_RECEIVING_RESPONSE, actor);
         break;
       case "responseContent":
-        NetMonitorView.RequestsMenu.updateRequest(aPacket.from, {
+        RequestCollection.update(aPacket.from, {
           contentSize: aPacket.contentSize,
           transferredSize: aPacket.transferredSize,
           mimeType: aPacket.mimeType
         });
         this.webConsoleClient.getResponseContent(actor, this._onResponseContent);
         window.emit(EVENTS.UPDATING_RESPONSE_CONTENT, actor);
         break;
       case "eventTimings":
-        NetMonitorView.RequestsMenu.updateRequest(aPacket.from, {
+        RequestCollection.update(aPacket.from, {
           totalTime: aPacket.totalTime
         });
         this.webConsoleClient.getEventTimings(actor, this._onEventTimings);
         window.emit(EVENTS.UPDATING_EVENT_TIMINGS, actor);
         break;
     }
   },
 
   /**
    * Handles additional information received for a "requestHeaders" packet.
    *
    * @param object aResponse
    *        The message received from the server.
    */
   _onRequestHeaders: function(aResponse) {
-    NetMonitorView.RequestsMenu.updateRequest(aResponse.from, {
+    RequestCollection.update(aResponse.from, {
       requestHeaders: aResponse
     });
     window.emit(EVENTS.RECEIVED_REQUEST_HEADERS, aResponse.from);
   },
 
   /**
    * Handles additional information received for a "requestCookies" packet.
    *
    * @param object aResponse
    *        The message received from the server.
    */
   _onRequestCookies: function(aResponse) {
-    NetMonitorView.RequestsMenu.updateRequest(aResponse.from, {
+    RequestCollection.update(aResponse.from, {
       requestCookies: aResponse
     });
     window.emit(EVENTS.RECEIVED_REQUEST_COOKIES, aResponse.from);
   },
 
   /**
    * Handles additional information received for a "requestPostData" packet.
    *
    * @param object aResponse
    *        The message received from the server.
    */
   _onRequestPostData: function(aResponse) {
-    NetMonitorView.RequestsMenu.updateRequest(aResponse.from, {
+    RequestCollection.update(aResponse.from, {
       requestPostData: aResponse
     });
     window.emit(EVENTS.RECEIVED_REQUEST_POST_DATA, aResponse.from);
   },
 
   /**
    * Handles additional information received for a "securityInfo" packet.
    *
    * @param object aResponse
    *        The message received from the server.
    */
    _onSecurityInfo: function(aResponse) {
-     NetMonitorView.RequestsMenu.updateRequest(aResponse.from, {
+     RequestCollection.update(aResponse.from, {
        securityInfo: aResponse.securityInfo
      });
 
      window.emit(EVENTS.RECEIVED_SECURITY_INFO, aResponse.from);
    },
 
   /**
    * Handles additional information received for a "responseHeaders" packet.
    *
    * @param object aResponse
    *        The message received from the server.
    */
   _onResponseHeaders: function(aResponse) {
-    NetMonitorView.RequestsMenu.updateRequest(aResponse.from, {
+    RequestCollection.update(aResponse.from, {
       responseHeaders: aResponse
     });
     window.emit(EVENTS.RECEIVED_RESPONSE_HEADERS, aResponse.from);
   },
 
   /**
    * Handles additional information received for a "responseCookies" packet.
    *
    * @param object aResponse
    *        The message received from the server.
    */
   _onResponseCookies: function(aResponse) {
-    NetMonitorView.RequestsMenu.updateRequest(aResponse.from, {
+    RequestCollection.update(aResponse.from, {
       responseCookies: aResponse
     });
     window.emit(EVENTS.RECEIVED_RESPONSE_COOKIES, aResponse.from);
   },
 
   /**
    * Handles additional information received for a "responseContent" packet.
    *
    * @param object aResponse
    *        The message received from the server.
    */
   _onResponseContent: function(aResponse) {
-    NetMonitorView.RequestsMenu.updateRequest(aResponse.from, {
+    RequestCollection.update(aResponse.from, {
       responseContent: aResponse
     });
     window.emit(EVENTS.RECEIVED_RESPONSE_CONTENT, aResponse.from);
   },
 
   /**
    * Handles additional information received for a "eventTimings" packet.
    *
    * @param object aResponse
    *        The message received from the server.
    */
   _onEventTimings: function(aResponse) {
-    NetMonitorView.RequestsMenu.updateRequest(aResponse.from, {
+    RequestCollection.update(aResponse.from, {
       eventTimings: aResponse
     });
     window.emit(EVENTS.RECEIVED_EVENT_TIMINGS, aResponse.from);
   },
 
   /**
    * Fetches the full text of a LongString.
    *
@@ -771,17 +783,17 @@ NetworkEventsHandler.prototype = {
         Cu.reportError(aResponse.error + ": " + aResponse.message);
         deferred.reject(aResponse);
         return;
       }
       deferred.resolve(initial + aResponse.substring);
     });
 
     return deferred.promise;
-  }
+  },
 };
 
 /**
  * Localization convenience methods.
  */
 let L10N = new ViewHelpers.L10N(NET_STRINGS_URI);
 let PKI_L10N = new ViewHelpers.L10N(PKI_STRINGS_URI);
 
@@ -863,8 +875,15 @@ const WDA_DEFAULT_GIVE_UP_TIMEOUT = 2000; // ms
  */
 function dumpn(str) {
   if (wantLogging) {
     dump("NET-FRONTEND: " + str + "\n");
   }
 }
 
 let wantLogging = Services.prefs.getBoolPref("devtools.debugger.log");
+
+/**
+ * DOM query helper.
+ */
+function $(aSelector, aTarget = document) aTarget.querySelector(aSelector);
+function $$(aSelector, aTarget = document) aTarget.querySelectorAll(aSelector);
+
diff --git a/browser/devtools/netmonitor/netmonitor-view.js b/browser/devtools/netmonitor/netmonitor-view.js
index 996782c..04211d1 100644
--- a/browser/devtools/netmonitor/netmonitor-view.js
+++ b/browser/devtools/netmonitor/netmonitor-view.js
@@ -1,183 +1,108 @@
 /* -*- indent-tabs-mode: nil; js-indent-level: 2 -*- */
 /* vim: set ft=javascript ts=2 et sw=2 tw=80: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 "use strict";
 
-const HTML_NS = "http://www.w3.org/1999/xhtml";
-const EPSILON = 0.001;
-const SOURCE_SYNTAX_HIGHLIGHT_MAX_FILE_SIZE = 102400; // 100 KB in bytes
-const RESIZE_REFRESH_RATE = 50; // ms
-const REQUESTS_REFRESH_RATE = 50; // ms
-const REQUESTS_HEADERS_SAFE_BOUNDS = 30; // px
-const REQUESTS_TOOLTIP_POSITION = "topcenter bottomleft";
-const REQUESTS_TOOLTIP_IMAGE_MAX_DIM = 400; // px
-const REQUESTS_WATERFALL_SAFE_BOUNDS = 90; // px
-const REQUESTS_WATERFALL_HEADER_TICKS_MULTIPLE = 5; // ms
-const REQUESTS_WATERFALL_HEADER_TICKS_SPACING_MIN = 60; // px
-const REQUESTS_WATERFALL_BACKGROUND_TICKS_MULTIPLE = 5; // ms
-const REQUESTS_WATERFALL_BACKGROUND_TICKS_SCALES = 3;
-const REQUESTS_WATERFALL_BACKGROUND_TICKS_SPACING_MIN = 10; // px
-const REQUESTS_WATERFALL_BACKGROUND_TICKS_COLOR_RGB = [128, 136, 144];
-const REQUESTS_WATERFALL_BACKGROUND_TICKS_OPACITY_MIN = 32; // byte
-const REQUESTS_WATERFALL_BACKGROUND_TICKS_OPACITY_ADD = 32; // byte
-const DEFAULT_HTTP_VERSION = "HTTP/1.1";
-const REQUEST_TIME_DECIMALS = 2;
-const HEADERS_SIZE_DECIMALS = 3;
-const CONTENT_SIZE_DECIMALS = 2;
-const CONTENT_MIME_TYPE_ABBREVIATIONS = {
-  "ecmascript": "js",
-  "javascript": "js",
-  "x-javascript": "js"
-};
-const CONTENT_MIME_TYPE_MAPPINGS = {
-  "/ecmascript": Editor.modes.js,
-  "/javascript": Editor.modes.js,
-  "/x-javascript": Editor.modes.js,
-  "/html": Editor.modes.html,
-  "/xhtml": Editor.modes.html,
-  "/xml": Editor.modes.html,
-  "/atom": Editor.modes.html,
-  "/soap": Editor.modes.html,
-  "/rdf": Editor.modes.css,
-  "/rss": Editor.modes.css,
-  "/css": Editor.modes.css
-};
 const DEFAULT_EDITOR_CONFIG = {
   mode: Editor.modes.text,
   readOnly: true,
   lineNumbers: true
 };
-const GENERIC_VARIABLES_VIEW_SETTINGS = {
-  lazyEmpty: true,
-  lazyEmptyDelay: 10, // ms
-  searchEnabled: true,
-  editableValueTooltip: "",
-  editableNameTooltip: "",
-  preventDisableOnChange: true,
-  preventDescriptorModifiers: true,
-  eval: () => {}
-};
 const NETWORK_ANALYSIS_PIE_CHART_DIAMETER = 200; // px
-const FREETEXT_FILTER_SEARCH_DELAY = 200; // ms
 
 /**
  * Object defining the network monitor view components.
  */
 let NetMonitorView = {
   /**
    * Initializes the network monitor view.
    */
-  initialize: function() {
+  initialize: Task.async(function*() {
+    this._body = $("#body");
+    this.clearButton = $("#requests-menu-clear-button");
+    this.reloadButton = $("#requests-menu-reload-notice-button");
+
+    this._onClear = this._onClear.bind(this);
+    this._onConnect = this._onConnect.bind(this);
+    this.reloadPage = this.reloadPage.bind(this);
+
+    this.clearButton.addEventListener("click", this._onClear, false);
     this._initializePanes();
+    window.once(EVENTS.CONNECTED, this._onConnect);
 
-    this.Toolbar.initialize();
-    this.RequestsMenu.initialize();
-    this.NetworkDetails.initialize();
-    this.CustomRequest.initialize();
-  },
+    if (NetMonitorController.supportsCustomRequest) {
+      yield NetMonitorView.CustomRequest.destroy();
+    }
+
+    yield NetMonitorView.RequestsMenu.initialize();
+    yield NetMonitorView.Sidebar.initialize();
+  }),
 
   /**
    * Destroys the network monitor view.
    */
-  destroy: function() {
-    this.Toolbar.destroy();
-    this.RequestsMenu.destroy();
-    this.NetworkDetails.destroy();
-    this.CustomRequest.destroy();
+  destroy: Task.async(function*() {
+    this.clearButton.removeEventListener("click", this._onClear, false);
+    this.reloadButton.removeEventListener("command", this.reloadPage, false);
+    yield this._destroyPanes();
 
-    this._destroyPanes();
-  },
+    if (NetMonitorController.supportsCustomRequest) {
+      yield NetMonitorView.CustomRequest.destroy();
+    }
+
+    yield NetMonitorView.RequestsMenu.destroy();
+    yield NetMonitorView.Sidebar.destroy();
+  }),
 
   /**
    * Initializes the UI for all the displayed panes.
    */
   _initializePanes: function() {
     dumpn("Initializing the NetMonitorView panes");
 
-    this._body = $("#body");
-    this._detailsPane = $("#details-pane");
-    this._detailsPaneToggleButton = $("#details-pane-toggle");
-
-    this._collapsePaneString = L10N.getStr("collapseDetailsPane");
-    this._expandPaneString = L10N.getStr("expandDetailsPane");
-
-    this._detailsPane.setAttribute("width", Prefs.networkDetailsWidth);
-    this._detailsPane.setAttribute("height", Prefs.networkDetailsHeight);
-    this.toggleDetailsPane({ visible: false });
-
     // Disable the performance statistics mode.
     if (!Prefs.statistics) {
       $("#request-menu-context-perf").hidden = true;
       $("#notice-perf-message").hidden = true;
       $("#requests-menu-network-summary-button").hidden = true;
       $("#requests-menu-network-summary-label").hidden = true;
     }
   },
 
   /**
    * Destroys the UI for all the displayed panes.
    */
   _destroyPanes: Task.async(function*() {
     dumpn("Destroying the NetMonitorView panes");
-
-    Prefs.networkDetailsWidth = this._detailsPane.getAttribute("width");
-    Prefs.networkDetailsHeight = this._detailsPane.getAttribute("height");
-
-    this._detailsPane = null;
-    this._detailsPaneToggleButton = null;
-
     for (let p of this._editorPromises.values()) {
       let editor = yield p;
       editor.destroy();
     }
   }),
 
   /**
-   * Gets the visibility state of the network details pane.
-   * @return boolean
+   * Fired when connection made with server side. Sets up the global tool.
    */
-  get detailsPaneHidden() {
-    return this._detailsPane.hasAttribute("pane-collapsed");
+  _onConnect: function () {
+    this.reloadButton.addEventListener("command", this.reloadPage, false);
+    if (NetMonitorController.supportsCustomRequest) {
+      NetMonitorView.CustomRequest.initialize();
+    }
   },
 
   /**
-   * Sets the network details pane hidden or visible.
-   *
-   * @param object aFlags
-   *        An object containing some of the following properties:
-   *        - visible: true if the pane should be shown, false to hide
-   *        - animated: true to display an animation on toggle
-   *        - delayed: true to wait a few cycles before toggle
-   *        - callback: a function to invoke when the toggle finishes
-   * @param number aTabIndex [optional]
-   *        The index of the intended selected tab in the details pane.
+   * Removes all network requests. Views handle this themselves on the RequestCollection 'reset'
+   * event.
    */
-  toggleDetailsPane: function(aFlags, aTabIndex) {
-    let pane = this._detailsPane;
-    let button = this._detailsPaneToggleButton;
-
-    ViewHelpers.togglePane(aFlags, pane);
-
-    if (aFlags.visible) {
-      this._body.removeAttribute("pane-collapsed");
-      button.removeAttribute("pane-collapsed");
-      button.setAttribute("tooltiptext", this._collapsePaneString);
-    } else {
-      this._body.setAttribute("pane-collapsed", "");
-      button.setAttribute("pane-collapsed", "");
-      button.setAttribute("tooltiptext", this._expandPaneString);
-    }
-
-    if (aTabIndex !== undefined) {
-      $("#event-details-pane").selectedIndex = aTabIndex;
-    }
+  _onClear: function() {
+    RequestCollection.reset();
   },
 
   /**
    * Gets the current mode for this tool.
    * @return string (e.g, "network-inspector-view" or "network-statistics-view")
    */
   get currentFrontendMode() {
     return this._body.selectedPanel.id;
@@ -194,17 +119,17 @@ let NetMonitorView = {
     }
   },
 
   /**
    * Switches to the "Inspector" frontend view mode.
    */
   showNetworkInspectorView: function() {
     this._body.selectedPanel = $("#network-inspector-view");
-    this.RequestsMenu._flushWaterfallViews(true);
+    this.RequestsMenu.refreshWaterfall(true);
   },
 
   /**
    * Switches to the "Statistics" frontend view mode.
    */
   showNetworkStatisticsView: function() {
     this._body.selectedPanel = $("#network-statistics-view");
 
@@ -217,26 +142,26 @@ let NetMonitorView = {
       yield controller.triggerActivity(ACTIVITY_TYPE.RELOAD.WITH_CACHE_ENABLED);
 
       try {
         //  The response headers and status code are required for determining
         // whether a response is "fresh" (cacheable).
         //  The response content size and request total time are necessary for
         // populating the statistics view.
         //  The response mime type is used for categorization.
-        yield whenDataAvailable(requestsView.attachments, [
+        yield whenDataAvailable(RequestCollection.models, [
           "responseHeaders", "status", "contentSize", "mimeType", "totalTime"
         ]);
       } catch (ex) {
         // Timed out while waiting for data. Continue with what we have.
         DevToolsUtils.reportException("showNetworkStatisticsView", ex);
       }
 
-      statisticsView.createPrimedCacheChart(requestsView.items);
-      statisticsView.createEmptyCacheChart(requestsView.items);
+      statisticsView.createPrimedCacheChart(RequestCollection.models);
+      statisticsView.createEmptyCacheChart(RequestCollection.models);
     });
   },
 
   reloadPage: function() {
     NetMonitorController.triggerActivity(ACTIVITY_TYPE.RELOAD.WITH_CACHE_DEFAULT);
   },
 
   /**
@@ -261,3008 +186,138 @@ let NetMonitorView = {
     // in the ether of a resolved promise's value.
     let editor = new Editor(DEFAULT_EDITOR_CONFIG);
     editor.appendTo($(aId)).then(() => deferred.resolve(editor));
 
     return deferred.promise;
   },
 
   _body: null,
-  _detailsPane: null,
-  _detailsPaneToggleButton: null,
-  _collapsePaneString: "",
-  _expandPaneString: "",
   _editorPromises: new Map()
 };
 
-/**
- * Functions handling the toolbar view: expand/collapse button etc.
- */
-function ToolbarView() {
-  dumpn("ToolbarView was instantiated");
-
-  this._onTogglePanesPressed = this._onTogglePanesPressed.bind(this);
-}
-
-ToolbarView.prototype = {
-  /**
-   * Initialization function, called when the debugger is started.
-   */
-  initialize: function() {
-    dumpn("Initializing the ToolbarView");
-
-    this._detailsPaneToggleButton = $("#details-pane-toggle");
-    this._detailsPaneToggleButton.addEventListener("mousedown", this._onTogglePanesPressed, false);
-  },
-
-  /**
-   * Destruction function, called when the debugger is closed.
-   */
-  destroy: function() {
-    dumpn("Destroying the ToolbarView");
-
-    this._detailsPaneToggleButton.removeEventListener("mousedown", this._onTogglePanesPressed, false);
-  },
-
-  /**
-   * Listener handling the toggle button click event.
-   */
-  _onTogglePanesPressed: function() {
-    let requestsMenu = NetMonitorView.RequestsMenu;
-    let selectedIndex = requestsMenu.selectedIndex;
-
-    // Make sure there's a selection if the button is pressed, to avoid
-    // showing an empty network details pane.
-    if (selectedIndex == -1 && requestsMenu.itemCount) {
-      requestsMenu.selectedIndex = 0;
-    } else {
-      requestsMenu.selectedIndex = -1;
-    }
-  },
-
-  _detailsPaneToggleButton: null
-};
-
-/**
- * Functions handling the requests menu (containing details about each request,
- * like status, method, file, domain, as well as a waterfall representing
- * timing imformation).
- */
-function RequestsMenuView() {
-  dumpn("RequestsMenuView was instantiated");
-
-  this._flushRequests = this._flushRequests.bind(this);
-  this._onHover = this._onHover.bind(this);
-  this._onSelect = this._onSelect.bind(this);
-  this._onSwap = this._onSwap.bind(this);
-  this._onResize = this._onResize.bind(this);
-  this._byFile = this._byFile.bind(this);
-  this._byDomain = this._byDomain.bind(this);
-  this._byType = this._byType.bind(this);
-  this._onSecurityIconClick = this._onSecurityIconClick.bind(this);
+function PerformanceStatisticsView() {
 }
 
-RequestsMenuView.prototype = Heritage.extend(WidgetMethods, {
-  /**
-   * Initialization function, called when the network monitor is started.
-   */
-  initialize: function() {
-    dumpn("Initializing the RequestsMenuView");
-
-    this.widget = new SideMenuWidget($("#requests-menu-contents"));
-    this._splitter = $("#network-inspector-view-splitter");
-    this._summary = $("#requests-menu-network-summary-label");
-    this._summary.setAttribute("value", L10N.getStr("networkMenu.empty"));
-    this.userInputTimer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
-
-    Prefs.filters.forEach(type => this.filterOn(type));
-    this.sortContents(this._byTiming);
-
-    this.allowFocusOnRightClick = true;
-    this.maintainSelectionVisible = true;
-    this.widget.autoscrollWithAppendedItems = true;
-
-    this.widget.addEventListener("select", this._onSelect, false);
-    this.widget.addEventListener("swap", this._onSwap, false);
-    this._splitter.addEventListener("mousemove", this._onResize, false);
-    window.addEventListener("resize", this._onResize, false);
-
-    this.requestsMenuSortEvent = getKeyWithEvent(this.sortBy.bind(this));
-    this.requestsMenuFilterEvent = getKeyWithEvent(this.filterOn.bind(this));
-    this.reqeustsMenuClearEvent = this.clear.bind(this);
-    this._onContextShowing = this._onContextShowing.bind(this);
-    this._onContextNewTabCommand = this.openRequestInTab.bind(this);
-    this._onContextCopyUrlCommand = this.copyUrl.bind(this);
-    this._onContextCopyImageAsDataUriCommand = this.copyImageAsDataUri.bind(this);
-    this._onContextResendCommand = this.cloneSelectedRequest.bind(this);
-    this._onContextToggleRawHeadersCommand = this.toggleRawHeaders.bind(this);
-    this._onContextPerfCommand = () => NetMonitorView.toggleFrontendMode();
-    this._onReloadCommand = () => NetMonitorView.reloadPage();
-
-    this.sendCustomRequestEvent = this.sendCustomRequest.bind(this);
-    this.closeCustomRequestEvent = this.closeCustomRequest.bind(this);
-    this.cloneSelectedRequestEvent = this.cloneSelectedRequest.bind(this);
-    this.toggleRawHeadersEvent = this.toggleRawHeaders.bind(this);
-
-    this.requestsFreetextFilterEvent = this.requestsFreetextFilterEvent.bind(this);
-    this.reFilterRequests = this.reFilterRequests.bind(this);
-
-    this.freetextFilterBox = $("#requests-menu-filter-freetext-text");
-    this.freetextFilterBox.addEventListener("input", this.requestsFreetextFilterEvent, false);
-    this.freetextFilterBox.addEventListener("command", this.requestsFreetextFilterEvent, false);
-
-    $("#toolbar-labels").addEventListener("click", this.requestsMenuSortEvent, false);
-    $("#requests-menu-footer").addEventListener("click", this.requestsMenuFilterEvent, false);
-    $("#requests-menu-clear-button").addEventListener("click", this.reqeustsMenuClearEvent, false);
-    $("#network-request-popup").addEventListener("popupshowing", this._onContextShowing, false);
-    $("#request-menu-context-newtab").addEventListener("command", this._onContextNewTabCommand, false);
-    $("#request-menu-context-copy-url").addEventListener("command", this._onContextCopyUrlCommand, false);
-    $("#request-menu-context-copy-image-as-data-uri").addEventListener("command", this._onContextCopyImageAsDataUriCommand, false);
-    $("#toggle-raw-headers").addEventListener("click", this.toggleRawHeadersEvent, false);
-
-    window.once("connected", this._onConnect.bind(this));
-  },
-
-  _onConnect: function() {
-    $("#requests-menu-reload-notice-button").addEventListener("command", this._onReloadCommand, false);
-
-    if (NetMonitorController.supportsCustomRequest) {
-      $("#request-menu-context-resend").addEventListener("command", this._onContextResendCommand, false);
-      $("#custom-request-send-button").addEventListener("click", this.sendCustomRequestEvent, false);
-      $("#custom-request-close-button").addEventListener("click", this.closeCustomRequestEvent, false);
-      $("#headers-summary-resend").addEventListener("click", this.cloneSelectedRequestEvent, false);
-    } else {
-      $("#request-menu-context-resend").hidden = true;
-      $("#headers-summary-resend").hidden = true;
-    }
-
-    if (NetMonitorController.supportsPerfStats) {
-      $("#request-menu-context-perf").addEventListener("command", this._onContextPerfCommand, false);
-      $("#requests-menu-perf-notice-button").addEventListener("command", this._onContextPerfCommand, false);
-      $("#requests-menu-network-summary-button").addEventListener("command", this._onContextPerfCommand, false);
-      $("#requests-menu-network-summary-label").addEventListener("click", this._onContextPerfCommand, false);
-      $("#network-statistics-back-button").addEventListener("command", this._onContextPerfCommand, false);
-    } else {
-      $("#notice-perf-message").hidden = true;
-      $("#request-menu-context-perf").hidden = true;
-      $("#requests-menu-network-summary-button").hidden = true;
-      $("#requests-menu-network-summary-label").hidden = true;
-    }
-
-    if (!NetMonitorController.supportsTransferredResponseSize) {
-      $("#requests-menu-transferred-header-box").hidden = true;
-      $("#requests-menu-item-template .requests-menu-transferred").hidden = true;
-    }
-  },
-
-  /**
-   * Destruction function, called when the network monitor is closed.
-   */
-  destroy: function() {
-    dumpn("Destroying the SourcesView");
-
-    Prefs.filters = this._activeFilters;
-
-    this.widget.removeEventListener("select", this._onSelect, false);
-    this.widget.removeEventListener("swap", this._onSwap, false);
-    this._splitter.removeEventListener("mousemove", this._onResize, false);
-    window.removeEventListener("resize", this._onResize, false);
-
-    $("#toolbar-labels").removeEventListener("click", this.requestsMenuSortEvent, false);
-    $("#requests-menu-footer").removeEventListener("click", this.requestsMenuFilterEvent, false);
-    $("#requests-menu-clear-button").removeEventListener("click", this.reqeustsMenuClearEvent, false);
-    this.freetextFilterBox.removeEventListener("input", this.requestsFreetextFilterEvent, false);
-    this.freetextFilterBox.removeEventListener("command", this.requestsFreetextFilterEvent, false);
-    this.userInputTimer.cancel();
-    $("#network-request-popup").removeEventListener("popupshowing", this._onContextShowing, false);
-    $("#request-menu-context-newtab").removeEventListener("command", this._onContextNewTabCommand, false);
-    $("#request-menu-context-copy-url").removeEventListener("command", this._onContextCopyUrlCommand, false);
-    $("#request-menu-context-copy-image-as-data-uri").removeEventListener("command", this._onContextCopyImageAsDataUriCommand, false);
-    $("#request-menu-context-resend").removeEventListener("command", this._onContextResendCommand, false);
-    $("#request-menu-context-perf").removeEventListener("command", this._onContextPerfCommand, false);
-
-    $("#requests-menu-reload-notice-button").removeEventListener("command", this._onReloadCommand, false);
-    $("#requests-menu-perf-notice-button").removeEventListener("command", this._onContextPerfCommand, false);
-    $("#requests-menu-network-summary-button").removeEventListener("command", this._onContextPerfCommand, false);
-    $("#requests-menu-network-summary-label").removeEventListener("click", this._onContextPerfCommand, false);
-    $("#network-statistics-back-button").removeEventListener("command", this._onContextPerfCommand, false);
-
-    $("#custom-request-send-button").removeEventListener("click", this.sendCustomRequestEvent, false);
-    $("#custom-request-close-button").removeEventListener("click", this.closeCustomRequestEvent, false);
-    $("#headers-summary-resend").removeEventListener("click", this.cloneSelectedRequestEvent, false);
-    $("#toggle-raw-headers").removeEventListener("click", this.toggleRawHeadersEvent, false);
-  },
-
-  /**
-   * Resets this container (removes all the networking information).
-   */
-  reset: function() {
-    this.empty();
-    this._firstRequestStartedMillis = -1;
-    this._lastRequestEndedMillis = -1;
-  },
-
-  /**
-   * Specifies if this view may be updated lazily.
-   */
-  lazyUpdate: true,
-
-  /**
-   * Adds a network request to this container.
-   *
-   * @param string aId
-   *        An identifier coming from the network monitor controller.
-   * @param string aStartedDateTime
-   *        A string representation of when the request was started, which
-   *        can be parsed by Date (for example "2012-09-17T19:50:03.699Z").
-   * @param string aMethod
-   *        Specifies the request method (e.g. "GET", "POST", etc.)
-   * @param string aUrl
-   *        Specifies the request's url.
-   * @param boolean aIsXHR
-   *        True if this request was initiated via XHR.
-   */
-  addRequest: function(aId, aStartedDateTime, aMethod, aUrl, aIsXHR) {
-    // Convert the received date/time string to a unix timestamp.
-    let unixTime = Date.parse(aStartedDateTime);
-
-    // Create the element node for the network request item.
-    let menuView = this._createMenuView(aMethod, aUrl);
-
-    // Remember the first and last event boundaries.
-    this._registerFirstRequestStart(unixTime);
-    this._registerLastRequestEnd(unixTime);
-
-    // Append a network request item to this container.
-    let requestItem = this.push([menuView, aId], {
-      attachment: {
-        startedDeltaMillis: unixTime - this._firstRequestStartedMillis,
-        startedMillis: unixTime,
-        method: aMethod,
-        url: aUrl,
-        isXHR: aIsXHR
-      }
-    });
-
-    // Create a tooltip for the newly appended network request item.
-    let requestTooltip = requestItem.attachment.tooltip = new Tooltip(document, {
-      closeOnEvents: [{
-        emitter: $("#requests-menu-contents"),
-        event: "scroll",
-        useCapture: true
-      }]
-    });
-
-    $("#details-pane-toggle").disabled = false;
-    $("#requests-menu-empty-notice").hidden = true;
-
-    this.refreshSummary();
-    this.refreshZebra();
-    this.refreshTooltip(requestItem);
-
-    if (aId == this._preferredItemId) {
-      this.selectedItem = requestItem;
-    }
-  },
-
-  /**
-   * Opens selected item in a new tab.
-   */
-  openRequestInTab: function() {
-    let win = Services.wm.getMostRecentWindow("navigator:browser");
-    let selected = this.selectedItem.attachment;
-    win.openUILinkIn(selected.url, "tab", { relatedToCurrent: true });
-  },
-
-  /**
-   * Copy the request url from the currently selected item.
-   */
-  copyUrl: function() {
-    let selected = this.selectedItem.attachment;
-    clipboardHelper.copyString(selected.url, document);
-  },
-
+PerformanceStatisticsView.prototype = {
   /**
-   * Copy a cURL command from the currently selected item.
+   * Initializes and displays empty charts in this container.
    */
-  copyAsCurl: function() {
-    let selected = this.selectedItem.attachment;
-
-    Task.spawn(function*() {
-      // Create a sanitized object for the Curl command generator.
-      let data = {
-        url: selected.url,
-        method: selected.method,
-        headers: [],
-        httpVersion: selected.httpVersion,
-        postDataText: null
-      };
-
-      // Fetch header values.
-      for (let { name, value } of selected.requestHeaders.headers) {
-        let text = yield gNetwork.getString(value);
-        data.headers.push({ name: name, value: text });
-      }
-
-      // Fetch the request payload.
-      if (selected.requestPostData) {
-        let postData = selected.requestPostData.postData.text;
-        data.postDataText = yield gNetwork.getString(postData);
-      }
-
-      clipboardHelper.copyString(Curl.generateCommand(data), document);
+  displayPlaceholderCharts: function() {
+    this._createChart({
+      id: "#primed-cache-chart",
+      title: "charts.cacheEnabled"
     });
-  },
-
-  /**
-   * Copy image as data uri.
-   */
-  copyImageAsDataUri: function() {
-    let selected = this.selectedItem.attachment;
-    let { mimeType, text, encoding } = selected.responseContent.content;
-
-    gNetwork.getString(text).then(aString => {
-      let data = "data:" + mimeType + ";" + encoding + "," + aString;
-      clipboardHelper.copyString(data, document);
+    this._createChart({
+      id: "#empty-cache-chart",
+      title: "charts.cacheDisabled"
     });
+    window.emit(EVENTS.PLACEHOLDER_CHARTS_DISPLAYED);
   },
 
   /**
-   * Create a new custom request form populated with the data from
-   * the currently selected request.
+   * Populates and displays the primed cache chart in this container.
+   *
+   * @param array aItems
+   *        @see utils.sanitizeChartDataSource
    */
-  cloneSelectedRequest: function() {
-    let selected = this.selectedItem.attachment;
-
-    // Create the element node for the network request item.
-    let menuView = this._createMenuView(selected.method, selected.url);
-
-    // Append a network request item to this container.
-    let newItem = this.push([menuView], {
-      attachment: Object.create(selected, {
-        isCustom: { value: true }
-      })
+  createPrimedCacheChart: function(aItems) {
+    this._createChart({
+      id: "#primed-cache-chart",
+      title: "charts.cacheEnabled",
+      data: utils.sanitizeChartDataSource(aItems),
+      strings: this._commonChartStrings,
+      totals: this._commonChartTotals,
+      sorted: true
     });
-
-    // Immediately switch to new request pane.
-    this.selectedItem = newItem;
+    window.emit(EVENTS.PRIMED_CACHE_CHART_DISPLAYED);
   },
 
   /**
-   * Send a new HTTP request using the data in the custom request form.
+   * Populates and displays the empty cache chart in this container.
+   *
+   * @param array aItems
+   *        @see utils.sanitizeChartDataSource
    */
-  sendCustomRequest: function() {
-    let selected = this.selectedItem.attachment;
-
-    let data = {
-      url: selected.url,
-      method: selected.method,
-      httpVersion: selected.httpVersion,
-    };
-    if (selected.requestHeaders) {
-      data.headers = selected.requestHeaders.headers;
-    }
-    if (selected.requestPostData) {
-      data.body = selected.requestPostData.postData.text;
-    }
-
-    NetMonitorController.webConsoleClient.sendHTTPRequest(data, aResponse => {
-      let id = aResponse.eventActor.actor;
-      this._preferredItemId = id;
+  createEmptyCacheChart: function(aItems) {
+    this._createChart({
+      id: "#empty-cache-chart",
+      title: "charts.cacheDisabled",
+      data: utils.sanitizeChartDataSource(aItems, true),
+      strings: this._commonChartStrings,
+      totals: this._commonChartTotals,
+      sorted: true
     });
-
-    this.closeCustomRequest();
-  },
-
-  /**
-   * Remove the currently selected custom request.
-   */
-  closeCustomRequest: function() {
-    this.remove(this.selectedItem);
-    NetMonitorView.Sidebar.toggle(false);
+    window.emit(EVENTS.EMPTY_CACHE_CHART_DISPLAYED);
   },
 
   /**
-   * Shows raw request/response headers in textboxes.
+   * Common stringifier predicates used for items and totals in both the
+   * "primed" and "empty" cache charts.
    */
-  toggleRawHeaders: function() {
-    let requestTextarea = $("#raw-request-headers-textarea");
-    let responseTextare = $("#raw-response-headers-textarea");
-    let rawHeadersHidden = $("#raw-headers").getAttribute("hidden");
-
-    if (rawHeadersHidden) {
-      let selected = this.selectedItem.attachment;
-      let selectedRequestHeaders = selected.requestHeaders.headers;
-      let selectedResponseHeaders = selected.responseHeaders.headers;
-      requestTextarea.value = writeHeaderText(selectedRequestHeaders);
-      responseTextare.value = writeHeaderText(selectedResponseHeaders);
-      $("#raw-headers").hidden = false;
-    } else {
-      requestTextarea.value = null;
-      responseTextare.value = null;
-      $("#raw-headers").hidden = true;
+  _commonChartStrings: {
+    size: value => {
+      let string = L10N.numberWithDecimals(value / 1024, CONTENT_SIZE_DECIMALS);
+      return L10N.getFormatStr("charts.sizeKB", string);
+    },
+    time: value => {
+      let string = L10N.numberWithDecimals(value / 1000, REQUEST_TIME_DECIMALS);
+      return L10N.getFormatStr("charts.totalS", string);
     }
   },
 
-  /**
-   * Handles the timeout on the freetext filter textbox
-   */
-  requestsFreetextFilterEvent: function() {
-    this.userInputTimer.cancel();
-    this._currentFreetextFilter = this.freetextFilterBox.value || "";
-
-    if (this._currentFreetextFilter.length === 0) {
-      this.freetextFilterBox.removeAttribute("filled");
-    } else {
-      this.freetextFilterBox.setAttribute("filled", true);
+  _commonChartTotals: {
+    size: total => {
+      let string = L10N.numberWithDecimals(total / 1024, CONTENT_SIZE_DECIMALS);
+      return L10N.getFormatStr("charts.totalSize", string);
+    },
+    time: total => {
+      let seconds = total / 1000;
+      let string = L10N.numberWithDecimals(seconds, REQUEST_TIME_DECIMALS);
+      return PluralForm.get(seconds, L10N.getStr("charts.totalSeconds")).replace("#1", string);
+    },
+    cached: total => {
+      return L10N.getFormatStr("charts.totalCached", total);
+    },
+    count: total => {
+      return L10N.getFormatStr("charts.totalCount", total);
     }
-
-    this.userInputTimer.initWithCallback(this.reFilterRequests, FREETEXT_FILTER_SEARCH_DELAY, Ci.nsITimer.TYPE_ONE_SHOT);
-  },
-
-  /**
-   * Refreshes the view contents with the newly selected filters
-   */
-  reFilterRequests: function() {
-    this.filterContents(this._filterPredicate);
-    this.refreshSummary();
-    this.refreshZebra();
   },
 
   /**
-   * Filters all network requests in this container by a specified type.
+   * Adds a specific chart to this container.
    *
-   * @param string aType
-   *        Either "all", "html", "css", "js", "xhr", "fonts", "images", "media"
-   *        "flash" or "other".
+   * @param object
+   *        An object containing all or some the following properties:
+   *          - id: either "#primed-cache-chart" or "#empty-cache-chart"
+   *          - title/data/strings/totals/sorted: @see Chart.jsm for details
    */
-  filterOn: function(aType = "all") {
-    if (aType === "all") {
-      // The filter "all" is special as it doesn't toggle.
-      // - If some filters are selected and 'all' is clicked, the previously
-      //   selected filters will be disabled and 'all' is the only active one.
-      // - If 'all' is already selected, do nothing.
-      if (this._activeFilters.indexOf("all") !== -1) {
-        return;
-      }
+  _createChart: function({ id, title, data, strings, totals, sorted }) {
+    let container = $(id);
 
-      // Uncheck all other filters and select 'all'. Must create a copy as
-      // _disableFilter removes the filters from the list while it's being
-      // iterated. 'all' will be enabled automatically by _disableFilter once
-      // the last filter is disabled.
-      this._activeFilters.slice().forEach(this._disableFilter, this);
-    }
-    else if (this._activeFilters.indexOf(aType) === -1) {
-      this._enableFilter(aType);
-    }
-    else {
-      this._disableFilter(aType);
+    // Nuke all existing charts of the specified type.
+    while (container.hasChildNodes()) {
+      container.firstChild.remove();
     }
 
-    this.reFilterRequests();
-  },
+    // Create a new chart.
+    let chart = Chart.PieTable(document, {
+      diameter: NETWORK_ANALYSIS_PIE_CHART_DIAMETER,
+      title: L10N.getStr(title),
+      data: data,
+      strings: strings,
+      totals: totals,
+      sorted: sorted
+    });
 
-  /**
-   * Same as `filterOn`, except that it only allows a single type exclusively.
-   *
-   * @param string aType
-   *        @see RequestsMenuView.prototype.fitlerOn
-   */
-  filterOnlyOn: function(aType = "all") {
-    this._activeFilters.slice().forEach(this._disableFilter, this);
-    this.filterOn(aType);
-  },
-
-  /**
-   * Disables the given filter, its button and toggles 'all' on if the filter to
-   * be disabled is the last one active.
-   *
-   * @param string aType
-   *        Either "all", "html", "css", "js", "xhr", "fonts", "images", "media"
-   *        "flash" or "other".
-   */
-  _disableFilter: function (aType) {
-    // Remove the filter from list of active filters.
-    this._activeFilters.splice(this._activeFilters.indexOf(aType), 1);
-
-    // Remove the checked status from the filter.
-    let target = $("#requests-menu-filter-" + aType + "-button");
-    target.removeAttribute("checked");
-
-    // Check if the filter disabled was the last one. If so, toggle all on.
-    if (this._activeFilters.length === 0) {
-      this._enableFilter("all");
-    }
-  },
-
-  /**
-   * Enables the given filter, its button and toggles 'all' off if the filter to
-   * be enabled is the first one active.
-   *
-   * @param string aType
-   *        Either "all", "html", "css", "js", "xhr", "fonts", "images", "media"
-   *        "flash" or "other".
-   */
-  _enableFilter: function (aType) {
-    // Make sure this is a valid filter type.
-    if (Object.keys(this._allFilterPredicates).indexOf(aType) == -1) {
-      return;
-    }
-
-    // Add the filter to the list of active filters.
-    this._activeFilters.push(aType);
-
-    // Add the checked status to the filter button.
-    let target = $("#requests-menu-filter-" + aType + "-button");
-    target.setAttribute("checked", true);
-
-    // Check if 'all' was selected before. If so, disable it.
-    if (aType !== "all" && this._activeFilters.indexOf("all") !== -1) {
-      this._disableFilter("all");
-    }
-  },
-
-  /**
-   * Returns a predicate that can be used to test if a request matches any of
-   * the active filters.
-   */
-  get _filterPredicate() {
-    let filterPredicates = this._allFilterPredicates;
-    let currentFreetextFilter = this._currentFreetextFilter;
-
-    return requestItem => {
-      return this._activeFilters.some(filterName => {
-        return filterPredicates[filterName].call(this, requestItem) &&
-                filterPredicates["freetext"].call(this, requestItem, currentFreetextFilter);
-      });
-    };
-  },
-
-  /**
-   * Returns an object with all the filter predicates as [key: function] pairs.
-   */
-  get _allFilterPredicates() ({
-    all: () => true,
-    html: this.isHtml,
-    css: this.isCss,
-    js: this.isJs,
-    xhr: this.isXHR,
-    fonts: this.isFont,
-    images: this.isImage,
-    media: this.isMedia,
-    flash: this.isFlash,
-    other: this.isOther,
-    freetext: this.isFreetextMatch
-  }),
-
-  /**
-   * Sorts all network requests in this container by a specified detail.
-   *
-   * @param string aType
-   *        Either "status", "method", "file", "domain", "type", "transferred",
-   *        "size" or "waterfall".
-   */
-  sortBy: function(aType = "waterfall") {
-    let target = $("#requests-menu-" + aType + "-button");
-    let headers = document.querySelectorAll(".requests-menu-header-button");
-
-    for (let header of headers) {
-      if (header != target) {
-        header.removeAttribute("sorted");
-        header.removeAttribute("tooltiptext");
-      }
-    }
-
-    let direction = "";
-    if (target) {
-      if (target.getAttribute("sorted") == "ascending") {
-        target.setAttribute("sorted", direction = "descending");
-        target.setAttribute("tooltiptext", L10N.getStr("networkMenu.sortedDesc"));
-      } else {
-        target.setAttribute("sorted", direction = "ascending");
-        target.setAttribute("tooltiptext", L10N.getStr("networkMenu.sortedAsc"));
-      }
-    }
-
-    // Sort by whatever was requested.
-    switch (aType) {
-      case "status":
-        if (direction == "ascending") {
-          this.sortContents(this._byStatus);
-        } else {
-          this.sortContents((a, b) => !this._byStatus(a, b));
-        }
-        break;
-      case "method":
-        if (direction == "ascending") {
-          this.sortContents(this._byMethod);
-        } else {
-          this.sortContents((a, b) => !this._byMethod(a, b));
-        }
-        break;
-      case "file":
-        if (direction == "ascending") {
-          this.sortContents(this._byFile);
-        } else {
-          this.sortContents((a, b) => !this._byFile(a, b));
-        }
-        break;
-      case "domain":
-        if (direction == "ascending") {
-          this.sortContents(this._byDomain);
-        } else {
-          this.sortContents((a, b) => !this._byDomain(a, b));
-        }
-        break;
-      case "type":
-        if (direction == "ascending") {
-          this.sortContents(this._byType);
-        } else {
-          this.sortContents((a, b) => !this._byType(a, b));
-        }
-        break;
-      case "transferred":
-        if (direction == "ascending") {
-          this.sortContents(this._byTransferred);
-        } else {
-          this.sortContents((a, b) => !this._byTransferred(a, b));
-        }
-        break;
-      case "size":
-        if (direction == "ascending") {
-          this.sortContents(this._bySize);
-        } else {
-          this.sortContents((a, b) => !this._bySize(a, b));
-        }
-        break;
-      case "waterfall":
-        if (direction == "ascending") {
-          this.sortContents(this._byTiming);
-        } else {
-          this.sortContents((a, b) => !this._byTiming(a, b));
-        }
-        break;
-    }
-
-    this.refreshSummary();
-    this.refreshZebra();
-  },
-
-  /**
-   * Removes all network requests and closes the sidebar if open.
-   */
-  clear: function() {
-    NetMonitorView.Sidebar.toggle(false);
-    $("#details-pane-toggle").disabled = true;
-
-    this.empty();
-    this.refreshSummary();
-  },
-
-  /**
-   * Predicates used when filtering items.
-   *
-   * @param object aItem
-   *        The filtered item.
-   * @return boolean
-   *         True if the item should be visible, false otherwise.
-   */
-  isHtml: function({ attachment: { mimeType } })
-    mimeType && mimeType.contains("/html"),
-
-  isCss: function({ attachment: { mimeType } })
-    mimeType && mimeType.contains("/css"),
-
-  isJs: function({ attachment: { mimeType } })
-    mimeType && (
-      mimeType.contains("/ecmascript") ||
-      mimeType.contains("/javascript") ||
-      mimeType.contains("/x-javascript")),
-
-  isXHR: function({ attachment: { isXHR } })
-    isXHR,
-
-  isFont: function({ attachment: { url, mimeType } }) // Fonts are a mess.
-    (mimeType && (
-      mimeType.contains("font/") ||
-      mimeType.contains("/font"))) ||
-    url.contains(".eot") ||
-    url.contains(".ttf") ||
-    url.contains(".otf") ||
-    url.contains(".woff"),
-
-  isImage: function({ attachment: { mimeType } })
-    mimeType && mimeType.contains("image/"),
-
-  isMedia: function({ attachment: { mimeType } }) // Not including images.
-    mimeType && (
-      mimeType.contains("audio/") ||
-      mimeType.contains("video/") ||
-      mimeType.contains("model/")),
-
-  isFlash: function({ attachment: { url, mimeType } }) // Flash is a mess.
-    (mimeType && (
-      mimeType.contains("/x-flv") ||
-      mimeType.contains("/x-shockwave-flash"))) ||
-    url.contains(".swf") ||
-    url.contains(".flv"),
-
-  isOther: function(e)
-    !this.isHtml(e) && !this.isCss(e) && !this.isJs(e) && !this.isXHR(e) &&
-    !this.isFont(e) && !this.isImage(e) && !this.isMedia(e) && !this.isFlash(e),
-
-  isFreetextMatch: function({ attachment: { url } }, text) //no text is a positive match
-    !text || url.contains(text),
-
-  /**
-   * Predicates used when sorting items.
-   *
-   * @param object aFirst
-   *        The first item used in the comparison.
-   * @param object aSecond
-   *        The second item used in the comparison.
-   * @return number
-   *         -1 to sort aFirst to a lower index than aSecond
-   *          0 to leave aFirst and aSecond unchanged with respect to each other
-   *          1 to sort aSecond to a lower index than aFirst
-   */
-  _byTiming: function({ attachment: first }, { attachment: second })
-    first.startedMillis > second.startedMillis,
-
-  _byStatus: function({ attachment: first }, { attachment: second })
-    first.status == second.status
-      ? first.startedMillis > second.startedMillis
-      : first.status > second.status,
-
-  _byMethod: function({ attachment: first }, { attachment: second })
-    first.method == second.method
-      ? first.startedMillis > second.startedMillis
-      : first.method > second.method,
-
-  _byFile: function({ attachment: first }, { attachment: second }) {
-    let firstUrl = this._getUriNameWithQuery(first.url).toLowerCase();
-    let secondUrl = this._getUriNameWithQuery(second.url).toLowerCase();
-    return firstUrl == secondUrl
-      ? first.startedMillis > second.startedMillis
-      : firstUrl > secondUrl;
-  },
-
-  _byDomain: function({ attachment: first }, { attachment: second }) {
-    let firstDomain = this._getUriHostPort(first.url).toLowerCase();
-    let secondDomain = this._getUriHostPort(second.url).toLowerCase();
-    return firstDomain == secondDomain
-      ? first.startedMillis > second.startedMillis
-      : firstDomain > secondDomain;
-  },
-
-  _byType: function({ attachment: first }, { attachment: second }) {
-    let firstType = this._getAbbreviatedMimeType(first.mimeType).toLowerCase();
-    let secondType = this._getAbbreviatedMimeType(second.mimeType).toLowerCase();
-    return firstType == secondType
-      ? first.startedMillis > second.startedMillis
-      : firstType > secondType;
-  },
-
-  _byTransferred: function({ attachment: first }, { attachment: second }) {
-    return first.transferredSize > second.transferredSize;
-  },
-
-  _bySize: function({ attachment: first }, { attachment: second }) {
-    return first.contentSize > second.contentSize;
-  },
-
-  /**
-   * Refreshes the status displayed in this container's footer, providing
-   * concise information about all requests.
-   */
-  refreshSummary: function() {
-    let visibleItems = this.visibleItems;
-    let visibleRequestsCount = visibleItems.length;
-    if (!visibleRequestsCount) {
-      this._summary.setAttribute("value", L10N.getStr("networkMenu.empty"));
-      return;
-    }
-
-    let totalBytes = this._getTotalBytesOfRequests(visibleItems);
-    let totalMillis =
-      this._getNewestRequest(visibleItems).attachment.endedMillis -
-      this._getOldestRequest(visibleItems).attachment.startedMillis;
-
-    // https://developer.mozilla.org/en-US/docs/Localization_and_Plurals
-    let str = PluralForm.get(visibleRequestsCount, L10N.getStr("networkMenu.summary"));
-    this._summary.setAttribute("value", str
-      .replace("#1", visibleRequestsCount)
-      .replace("#2", L10N.numberWithDecimals((totalBytes || 0) / 1024, CONTENT_SIZE_DECIMALS))
-      .replace("#3", L10N.numberWithDecimals((totalMillis || 0) / 1000, REQUEST_TIME_DECIMALS))
-    );
-  },
-
-  /**
-   * Adds odd/even attributes to all the visible items in this container.
-   */
-  refreshZebra: function() {
-    let visibleItems = this.visibleItems;
-
-    for (let i = 0, len = visibleItems.length; i < len; i++) {
-      let requestItem = visibleItems[i];
-      let requestTarget = requestItem.target;
-
-      if (i % 2 == 0) {
-        requestTarget.setAttribute("even", "");
-        requestTarget.removeAttribute("odd");
-      } else {
-        requestTarget.setAttribute("odd", "");
-        requestTarget.removeAttribute("even");
-      }
-    }
-  },
-
-  /**
-   * Refreshes the toggling anchor for the specified item's tooltip.
-   *
-   * @param object aItem
-   *        The network request item in this container.
-   */
-  refreshTooltip: function(aItem) {
-    let tooltip = aItem.attachment.tooltip;
-    tooltip.hide();
-    tooltip.startTogglingOnHover(aItem.target, this._onHover);
-    tooltip.defaultPosition = REQUESTS_TOOLTIP_POSITION;
-  },
-
-  /**
-   * Attaches security icon click listener for the given request menu item.
-   *
-   * @param object item
-   *        The network request item to attach the listener to.
-   */
-  attachSecurityIconClickListener: function ({ target }) {
-    let icon = $(".requests-security-state-icon", target);
-    icon.addEventListener("click", this._onSecurityIconClick);
-  },
-
-  /**
-   * Schedules adding additional information to a network request.
-   *
-   * @param string aId
-   *        An identifier coming from the network monitor controller.
-   * @param object aData
-   *        An object containing several { key: value } tuples of network info.
-   *        Supported keys are "httpVersion", "status", "statusText" etc.
-   */
-  updateRequest: function(aId, aData) {
-    // Prevent interference from zombie updates received after target closed.
-    if (NetMonitorView._isDestroyed) {
-      return;
-    }
-    this._updateQueue.push([aId, aData]);
-
-    // Lazy updating is disabled in some tests.
-    if (!this.lazyUpdate) {
-      return void this._flushRequests();
-    }
-    // Allow requests to settle down first.
-    setNamedTimeout(
-      "update-requests", REQUESTS_REFRESH_RATE, () => this._flushRequests());
-  },
-
-  /**
-   * Starts adding all queued additional information about network requests.
-   */
-  _flushRequests: function() {
-    // For each queued additional information packet, get the corresponding
-    // request item in the view and update it based on the specified data.
-    for (let [id, data] of this._updateQueue) {
-      let requestItem = this.getItemByValue(id);
-      if (!requestItem) {
-        // Packet corresponds to a dead request item, target navigated.
-        continue;
-      }
-
-      // Each information packet may contain several { key: value } tuples of
-      // network info, so update the view based on each one.
-      for (let key in data) {
-        let value = data[key];
-        if (value === undefined) {
-          // The information in the packet is empty, it can be safely ignored.
-          continue;
-        }
-
-        switch (key) {
-          case "requestHeaders":
-            requestItem.attachment.requestHeaders = value;
-            break;
-          case "requestCookies":
-            requestItem.attachment.requestCookies = value;
-            break;
-          case "requestPostData":
-            // Search the POST data upload stream for request headers and add
-            // them to a separate store, different from the classic headers.
-            // XXX: Be really careful here! We're creating a function inside
-            // a loop, so remember the actual request item we want to modify.
-            let currentItem = requestItem;
-            let currentStore = { headers: [], headersSize: 0 };
-
-            Task.spawn(function*() {
-              let postData = yield gNetwork.getString(value.postData.text);
-              let payloadHeaders = CurlUtils.getHeadersFromMultipartText(postData);
-
-              currentStore.headers = payloadHeaders;
-              currentStore.headersSize = payloadHeaders.reduce(
-                (acc, { name, value }) => acc + name.length + value.length + 2, 0);
-
-              // The `getString` promise is async, so we need to refresh the
-              // information displayed in the network details pane again here.
-              refreshNetworkDetailsPaneIfNecessary(currentItem);
-            });
-
-            requestItem.attachment.requestPostData = value;
-            requestItem.attachment.requestHeadersFromUploadStream = currentStore;
-            break;
-          case "securityState":
-            requestItem.attachment.securityState = value;
-            this.updateMenuView(requestItem, key, value);
-            break;
-          case "securityInfo":
-            requestItem.attachment.securityInfo = value;
-            break;
-          case "responseHeaders":
-            requestItem.attachment.responseHeaders = value;
-            break;
-          case "responseCookies":
-            requestItem.attachment.responseCookies = value;
-            break;
-          case "httpVersion":
-            requestItem.attachment.httpVersion = value;
-            break;
-          case "remoteAddress":
-            requestItem.attachment.remoteAddress = value;
-            break;
-          case "remotePort":
-            requestItem.attachment.remotePort = value;
-            break;
-          case "status":
-            requestItem.attachment.status = value;
-            this.updateMenuView(requestItem, key, value);
-            break;
-          case "statusText":
-            requestItem.attachment.statusText = value;
-            this.updateMenuView(requestItem, key,
-              requestItem.attachment.status + " " +
-              requestItem.attachment.statusText);
-            break;
-          case "headersSize":
-            requestItem.attachment.headersSize = value;
-            break;
-          case "contentSize":
-            requestItem.attachment.contentSize = value;
-            this.updateMenuView(requestItem, key, value);
-            break;
-          case "transferredSize":
-            requestItem.attachment.transferredSize = value;
-            this.updateMenuView(requestItem, key, value);
-            break;
-          case "mimeType":
-            requestItem.attachment.mimeType = value;
-            this.updateMenuView(requestItem, key, value);
-            break;
-          case "responseContent":
-            // If there's no mime type available when the response content
-            // is received, assume text/plain as a fallback.
-            if (!requestItem.attachment.mimeType) {
-              requestItem.attachment.mimeType = "text/plain";
-              this.updateMenuView(requestItem, "mimeType", "text/plain");
-            }
-            requestItem.attachment.responseContent = value;
-            this.updateMenuView(requestItem, key, value);
-            break;
-          case "totalTime":
-            requestItem.attachment.totalTime = value;
-            requestItem.attachment.endedMillis = requestItem.attachment.startedMillis + value;
-            this.updateMenuView(requestItem, key, value);
-            this._registerLastRequestEnd(requestItem.attachment.endedMillis);
-            break;
-          case "eventTimings":
-            requestItem.attachment.eventTimings = value;
-            this._createWaterfallView(requestItem, value.timings);
-            break;
-        }
-      }
-      refreshNetworkDetailsPaneIfNecessary(requestItem);
-    }
-
-    /**
-     * Refreshes the information displayed in the sidebar, in case this update
-     * may have additional information about a request which isn't shown yet
-     * in the network details pane.
-     *
-     * @param object aRequestItem
-     *        The item to repopulate the sidebar with in case it's selected in
-     *        this requests menu.
-     */
-    function refreshNetworkDetailsPaneIfNecessary(aRequestItem) {
-      let selectedItem = NetMonitorView.RequestsMenu.selectedItem;
-      if (selectedItem == aRequestItem) {
-        NetMonitorView.NetworkDetails.populate(selectedItem.attachment);
-      }
-    }
-
-    // We're done flushing all the requests, clear the update queue.
-    this._updateQueue = [];
-
-    // Make sure all the requests are sorted and filtered.
-    // Freshly added requests may not yet contain all the information required
-    // for sorting and filtering predicates, so this is done each time the
-    // network requests table is flushed (don't worry, events are drained first
-    // so this doesn't happen once per network event update).
-    this.sortContents();
-    this.filterContents();
-    this.refreshSummary();
-    this.refreshZebra();
-
-    // Rescale all the waterfalls so that everything is visible at once.
-    this._flushWaterfallViews();
-  },
-
-  /**
-   * Customization function for creating an item's UI.
-   *
-   * @param string aMethod
-   *        Specifies the request method (e.g. "GET", "POST", etc.)
-   * @param string aUrl
-   *        Specifies the request's url.
-   * @return nsIDOMNode
-   *         The network request view.
-   */
-  _createMenuView: function(aMethod, aUrl) {
-    let template = $("#requests-menu-item-template");
-    let fragment = document.createDocumentFragment();
-
-    this.updateMenuView(template, 'method', aMethod);
-    this.updateMenuView(template, 'url', aUrl);
-
-    // Flatten the DOM by removing one redundant box (the template container).
-    for (let node of template.childNodes) {
-      fragment.appendChild(node.cloneNode(true));
-    }
-
-    return fragment;
-  },
-
-  /**
-   * Updates the information displayed in a network request item view.
-   *
-   * @param object aItem
-   *        The network request item in this container.
-   * @param string aKey
-   *        The type of information that is to be updated.
-   * @param any aValue
-   *        The new value to be shown.
-   * @return object
-   *         A promise that is resolved once the information is displayed.
-   */
-  updateMenuView: Task.async(function*(aItem, aKey, aValue) {
-    let target = aItem.target || aItem;
-
-    switch (aKey) {
-      case "method": {
-        let node = $(".requests-menu-method", target);
-        node.setAttribute("value", aValue);
-        break;
-      }
-      case "url": {
-        let uri;
-        try {
-          uri = nsIURL(aValue);
-        } catch(e) {
-          break; // User input may not make a well-formed url yet.
-        }
-        let nameWithQuery = this._getUriNameWithQuery(uri);
-        let hostPort = this._getUriHostPort(uri);
-
-        let file = $(".requests-menu-file", target);
-        file.setAttribute("value", nameWithQuery);
-        file.setAttribute("tooltiptext", nameWithQuery);
-
-        let domain = $(".requests-menu-domain", target);
-        domain.setAttribute("value", hostPort);
-        domain.setAttribute("tooltiptext", hostPort);
-        break;
-      }
-      case "securityState": {
-        let tooltip = L10N.getStr("netmonitor.security.state." + aValue);
-        let icon = $(".requests-security-state-icon", target);
-        icon.classList.add("security-state-" + aValue);
-        icon.setAttribute("tooltiptext", tooltip);
-
-        this.attachSecurityIconClickListener(aItem);
-        break;
-      }
-      case "status": {
-        let node = $(".requests-menu-status", target);
-        let codeNode = $(".requests-menu-status-code", target);
-        codeNode.setAttribute("value", aValue);
-        node.setAttribute("code", aValue);
-        break;
-      }
-      case "statusText": {
-        let node = $(".requests-menu-status-and-method", target);
-        node.setAttribute("tooltiptext", aValue);
-        break;
-      }
-      case "contentSize": {
-        let kb = aValue / 1024;
-        let size = L10N.numberWithDecimals(kb, CONTENT_SIZE_DECIMALS);
-        let node = $(".requests-menu-size", target);
-        let text = L10N.getFormatStr("networkMenu.sizeKB", size);
-        node.setAttribute("value", text);
-        node.setAttribute("tooltiptext", text);
-        break;
-      }
-      case "transferredSize": {
-        let text;
-        if (aValue === null) {
-          text = L10N.getStr("networkMenu.sizeUnavailable");
-        } else {
-          let kb = aValue / 1024;
-          let size = L10N.numberWithDecimals(kb, CONTENT_SIZE_DECIMALS);
-          text = L10N.getFormatStr("networkMenu.sizeKB", size);
-        }
-        let node = $(".requests-menu-transferred", target);
-        node.setAttribute("value", text);
-        node.setAttribute("tooltiptext", text);
-        break;
-      }
-      case "mimeType": {
-        let type = this._getAbbreviatedMimeType(aValue);
-        let node = $(".requests-menu-type", target);
-        let text = CONTENT_MIME_TYPE_ABBREVIATIONS[type] || type;
-        node.setAttribute("value", text);
-        node.setAttribute("tooltiptext", aValue);
-        break;
-      }
-      case "responseContent": {
-        let { mimeType } = aItem.attachment;
-        let { text, encoding } = aValue.content;
-
-        if (mimeType.contains("image/")) {
-          let responseBody = yield gNetwork.getString(text);
-          let node = $(".requests-menu-icon", aItem.target);
-          node.src = "data:" + mimeType + ";" + encoding + "," + responseBody;
-          node.setAttribute("type", "thumbnail");
-          node.removeAttribute("hidden");
-
-          window.emit(EVENTS.RESPONSE_IMAGE_THUMBNAIL_DISPLAYED);
-        }
-        break;
-      }
-      case "totalTime": {
-        let node = $(".requests-menu-timings-total", target);
-        let text = L10N.getFormatStr("networkMenu.totalMS", aValue); // integer
-        node.setAttribute("value", text);
-        node.setAttribute("tooltiptext", text);
-        break;
-      }
-    }
-  }),
-
-  /**
-   * Creates a waterfall representing timing information in a network request item view.
-   *
-   * @param object aItem
-   *        The network request item in this container.
-   * @param object aTimings
-   *        An object containing timing information.
-   */
-  _createWaterfallView: function(aItem, aTimings) {
-    let { target, attachment } = aItem;
-    let sections = ["dns", "connect", "send", "wait", "receive"];
-    // Skipping "blocked" because it doesn't work yet.
-
-    let timingsNode = $(".requests-menu-timings", target);
-    let timingsTotal = $(".requests-menu-timings-total", timingsNode);
-
-    // Add a set of boxes representing timing information.
-    for (let key of sections) {
-      let width = aTimings[key];
-
-      // Don't render anything if it surely won't be visible.
-      // One millisecond == one unscaled pixel.
-      if (width > 0) {
-        let timingBox = document.createElement("hbox");
-        timingBox.className = "requests-menu-timings-box " + key;
-        timingBox.setAttribute("width", width);
-        timingsNode.insertBefore(timingBox, timingsTotal);
-      }
-    }
-  },
-
-  /**
-   * Rescales and redraws all the waterfall views in this container.
-   *
-   * @param boolean aReset
-   *        True if this container's width was changed.
-   */
-  _flushWaterfallViews: function(aReset) {
-    // Don't paint things while the waterfall view isn't even visible,
-    // or there are no items added to this container.
-    if (NetMonitorView.currentFrontendMode != "network-inspector-view" || !this.itemCount) {
-      return;
-    }
-
-    // To avoid expensive operations like getBoundingClientRect() and
-    // rebuilding the waterfall background each time a new request comes in,
-    // stuff is cached. However, in certain scenarios like when the window
-    // is resized, this needs to be invalidated.
-    if (aReset) {
-      this._cachedWaterfallWidth = 0;
-    }
-
-    // Determine the scaling to be applied to all the waterfalls so that
-    // everything is visible at once. One millisecond == one unscaled pixel.
-    let availableWidth = this._waterfallWidth - REQUESTS_WATERFALL_SAFE_BOUNDS;
-    let longestWidth = this._lastRequestEndedMillis - this._firstRequestStartedMillis;
-    let scale = Math.min(Math.max(availableWidth / longestWidth, EPSILON), 1);
-
-    // Redraw and set the canvas background for each waterfall view.
-    this._showWaterfallDivisionLabels(scale);
-    this._drawWaterfallBackground(scale);
-
-    // Apply CSS transforms to each waterfall in this container totalTime
-    // accurately translate and resize as needed.
-    for (let { target, attachment } of this) {
-      let timingsNode = $(".requests-menu-timings", target);
-      let totalNode = $(".requests-menu-timings-total", target);
-      let direction = window.isRTL ? -1 : 1;
-
-      // Render the timing information at a specific horizontal translation
-      // based on the delta to the first monitored event network.
-      let translateX = "translateX(" + (direction * attachment.startedDeltaMillis) + "px)";
-
-      // Based on the total time passed until the last request, rescale
-      // all the waterfalls to a reasonable size.
-      let scaleX = "scaleX(" + scale + ")";
-
-      // Certain nodes should not be scaled, even if they're children of
-      // another scaled node. In this case, apply a reversed transformation.
-      let revScaleX = "scaleX(" + (1 / scale) + ")";
-
-      timingsNode.style.transform = scaleX + " " + translateX;
-      totalNode.style.transform = revScaleX;
-    }
-  },
-
-  /**
-   * Creates the labels displayed on the waterfall header in this container.
-   *
-   * @param number aScale
-   *        The current waterfall scale.
-   */
-  _showWaterfallDivisionLabels: function(aScale) {
-    let container = $("#requests-menu-waterfall-button");
-    let availableWidth = this._waterfallWidth - REQUESTS_WATERFALL_SAFE_BOUNDS;
-
-    // Nuke all existing labels.
-    while (container.hasChildNodes()) {
-      container.firstChild.remove();
-    }
-
-    // Build new millisecond tick labels...
-    let timingStep = REQUESTS_WATERFALL_HEADER_TICKS_MULTIPLE;
-    let optimalTickIntervalFound = false;
-
-    while (!optimalTickIntervalFound) {
-      // Ignore any divisions that would end up being too close to each other.
-      let scaledStep = aScale * timingStep;
-      if (scaledStep < REQUESTS_WATERFALL_HEADER_TICKS_SPACING_MIN) {
-        timingStep <<= 1;
-        continue;
-      }
-      optimalTickIntervalFound = true;
-
-      // Insert one label for each division on the current scale.
-      let fragment = document.createDocumentFragment();
-      let direction = window.isRTL ? -1 : 1;
-
-      for (let x = 0; x < availableWidth; x += scaledStep) {
-        let translateX = "translateX(" + ((direction * x) | 0) + "px)";
-        let millisecondTime = x / aScale;
-
-        let normalizedTime = millisecondTime;
-        let divisionScale = "millisecond";
-
-        // If the division is greater than 1 minute.
-        if (normalizedTime > 60000) {
-          normalizedTime /= 60000;
-          divisionScale = "minute";
-        }
-        // If the division is greater than 1 second.
-        else if (normalizedTime > 1000) {
-          normalizedTime /= 1000;
-          divisionScale = "second";
-        }
-
-        // Showing too many decimals is bad UX.
-        if (divisionScale == "millisecond") {
-          normalizedTime |= 0;
-        } else {
-          normalizedTime = L10N.numberWithDecimals(normalizedTime, REQUEST_TIME_DECIMALS);
-        }
-
-        let node = document.createElement("label");
-        let text = L10N.getFormatStr("networkMenu." + divisionScale, normalizedTime);
-        node.className = "plain requests-menu-timings-division";
-        node.setAttribute("division-scale", divisionScale);
-        node.style.transform = translateX;
-
-        node.setAttribute("value", text);
-        fragment.appendChild(node);
-      }
-      container.appendChild(fragment);
-    }
-  },
-
-  /**
-   * Creates the background displayed on each waterfall view in this container.
-   *
-   * @param number aScale
-   *        The current waterfall scale.
-   */
-  _drawWaterfallBackground: function(aScale) {
-    if (!this._canvas || !this._ctx) {
-      this._canvas = document.createElementNS(HTML_NS, "canvas");
-      this._ctx = this._canvas.getContext("2d");
-    }
-    let canvas = this._canvas;
-    let ctx = this._ctx;
-
-    // Nuke the context.
-    let canvasWidth = canvas.width = this._waterfallWidth;
-    let canvasHeight = canvas.height = 1; // Awww yeah, 1px, repeats on Y axis.
-
-    // Start over.
-    let imageData = ctx.createImageData(canvasWidth, canvasHeight);
-    let pixelArray = imageData.data;
-
-    let buf = new ArrayBuffer(pixelArray.length);
-    let view8bit = new Uint8ClampedArray(buf);
-    let view32bit = new Uint32Array(buf);
-
-    // Build new millisecond tick lines...
-    let timingStep = REQUESTS_WATERFALL_BACKGROUND_TICKS_MULTIPLE;
-    let [r, g, b] = REQUESTS_WATERFALL_BACKGROUND_TICKS_COLOR_RGB;
-    let alphaComponent = REQUESTS_WATERFALL_BACKGROUND_TICKS_OPACITY_MIN;
-    let optimalTickIntervalFound = false;
-
-    while (!optimalTickIntervalFound) {
-      // Ignore any divisions that would end up being too close to each other.
-      let scaledStep = aScale * timingStep;
-      if (scaledStep < REQUESTS_WATERFALL_BACKGROUND_TICKS_SPACING_MIN) {
-        timingStep <<= 1;
-        continue;
-      }
-      optimalTickIntervalFound = true;
-
-      // Insert one pixel for each division on each scale.
-      for (let i = 1; i <= REQUESTS_WATERFALL_BACKGROUND_TICKS_SCALES; i++) {
-        let increment = scaledStep * Math.pow(2, i);
-        for (let x = 0; x < canvasWidth; x += increment) {
-          let position = (window.isRTL ? canvasWidth - x : x) | 0;
-          view32bit[position] = (alphaComponent << 24) | (b << 16) | (g << 8) | r;
-        }
-        alphaComponent += REQUESTS_WATERFALL_BACKGROUND_TICKS_OPACITY_ADD;
-      }
-    }
-
-    // Flush the image data and cache the waterfall background.
-    pixelArray.set(view8bit);
-    ctx.putImageData(imageData, 0, 0);
-    document.mozSetImageElement("waterfall-background", canvas);
-  },
-
-  /**
-   * The selection listener for this container.
-   */
-  _onSelect: function({ detail: item }) {
-    if (item) {
-      NetMonitorView.Sidebar.populate(item.attachment);
-      NetMonitorView.Sidebar.toggle(true);
-    } else {
-      NetMonitorView.Sidebar.toggle(false);
-    }
-  },
-
-  /**
-   * The swap listener for this container.
-   * Called when two items switch places, when the contents are sorted.
-   */
-  _onSwap: function({ detail: [firstItem, secondItem] }) {
-    // Sorting will create new anchor nodes for all the swapped request items
-    // in this container, so it's necessary to refresh the Tooltip instances.
-    this.refreshTooltip(firstItem);
-    this.refreshTooltip(secondItem);
-
-    // Reattach click listener to the security icons
-    this.attachSecurityIconClickListener(firstItem);
-    this.attachSecurityIconClickListener(secondItem);
-
-  },
-
-  /**
-   * The predicate used when deciding whether a popup should be shown
-   * over a request item or not.
-   *
-   * @param nsIDOMNode aTarget
-   *        The element node currently being hovered.
-   * @param object aTooltip
-   *        The current tooltip instance.
-   */
-  _onHover: function(aTarget, aTooltip) {
-    let requestItem = this.getItemForElement(aTarget);
-    if (!requestItem || !requestItem.attachment.responseContent) {
-      return;
-    }
-
-    let hovered = requestItem.attachment;
-    let { url } = hovered;
-    let { mimeType, text, encoding } = hovered.responseContent.content;
-
-    if (mimeType && mimeType.contains("image/") && (
-      aTarget.classList.contains("requests-menu-icon") ||
-      aTarget.classList.contains("requests-menu-file")))
-    {
-      return gNetwork.getString(text).then(aString => {
-        let anchor = $(".requests-menu-icon", requestItem.target);
-        let src = "data:" + mimeType + ";" + encoding + "," + aString;
-        aTooltip.setImageContent(src, { maxDim: REQUESTS_TOOLTIP_IMAGE_MAX_DIM });
-        return anchor;
-      });
-    }
-  },
-
-  /**
-   * A handler that opens the security tab in the details view if secure or
-   * broken security indicator is clicked.
-   */
-  _onSecurityIconClick: function(e) {
-    let state = this.selectedItem.attachment.securityState;
-    if (state !== "insecure") {
-      // Choose the security tab.
-      NetMonitorView.NetworkDetails.widget.selectedIndex = 5;
-    }
-  },
-
-  /**
-   * The resize listener for this container's window.
-   */
-  _onResize: function(e) {
-    // Allow requests to settle down first.
-    setNamedTimeout(
-      "resize-events", RESIZE_REFRESH_RATE, () => this._flushWaterfallViews(true));
-  },
-
-  /**
-   * Handle the context menu opening. Hide items if no request is selected.
-   */
-  _onContextShowing: function() {
-    let selectedItem = this.selectedItem;
-
-    let resendElement = $("#request-menu-context-resend");
-    resendElement.hidden = !NetMonitorController.supportsCustomRequest ||
-      !selectedItem || selectedItem.attachment.isCustom;
-
-    let copyUrlElement = $("#request-menu-context-copy-url");
-    copyUrlElement.hidden = !selectedItem;
-
-    let copyAsCurlElement = $("#request-menu-context-copy-as-curl");
-    copyAsCurlElement.hidden = !selectedItem || !selectedItem.attachment.responseContent;
-
-    let copyImageAsDataUriElement = $("#request-menu-context-copy-image-as-data-uri");
-    copyImageAsDataUriElement.hidden = !selectedItem ||
-      !selectedItem.attachment.responseContent ||
-      !selectedItem.attachment.responseContent.content.mimeType.contains("image/");
-
-    let separator = $("#request-menu-context-separator");
-    separator.hidden = !selectedItem;
-
-    let newTabElement = $("#request-menu-context-newtab");
-    newTabElement.hidden = !selectedItem;
-  },
-
-  /**
-   * Checks if the specified unix time is the first one to be known of,
-   * and saves it if so.
-   *
-   * @param number aUnixTime
-   *        The milliseconds to check and save.
-   */
-  _registerFirstRequestStart: function(aUnixTime) {
-    if (this._firstRequestStartedMillis == -1) {
-      this._firstRequestStartedMillis = aUnixTime;
-    }
-  },
-
-  /**
-   * Checks if the specified unix time is the last one to be known of,
-   * and saves it if so.
-   *
-   * @param number aUnixTime
-   *        The milliseconds to check and save.
-   */
-  _registerLastRequestEnd: function(aUnixTime) {
-    if (this._lastRequestEndedMillis < aUnixTime) {
-      this._lastRequestEndedMillis = aUnixTime;
-    }
-  },
-
-  /**
-   * Helpers for getting details about an nsIURL.
-   *
-   * @param nsIURL | string aUrl
-   * @return string
-   */
-  _getUriNameWithQuery: function(aUrl) {
-    if (!(aUrl instanceof Ci.nsIURL)) {
-      aUrl = nsIURL(aUrl);
-    }
-    let name = NetworkHelper.convertToUnicode(unescape(aUrl.fileName)) || "/";
-    let query = NetworkHelper.convertToUnicode(unescape(aUrl.query));
-    return name + (query ? "?" + query : "");
-  },
-  _getUriHostPort: function(aUrl) {
-    if (!(aUrl instanceof Ci.nsIURL)) {
-      aUrl = nsIURL(aUrl);
-    }
-    return NetworkHelper.convertToUnicode(unescape(aUrl.hostPort));
-  },
-
-  /**
-   * Helper for getting an abbreviated string for a mime type.
-   *
-   * @param string aMimeType
-   * @return string
-   */
-  _getAbbreviatedMimeType: function(aMimeType) {
-    if (!aMimeType) {
-      return "";
-    }
-    return (aMimeType.split(";")[0].split("/")[1] || "").split("+")[0];
-  },
-
-  /**
-   * Gets the total number of bytes representing the cumulated content size of
-   * a set of requests. Returns 0 for an empty set.
-   *
-   * @param array aItemsArray
-   * @return number
-   */
-  _getTotalBytesOfRequests: function(aItemsArray) {
-    if (!aItemsArray.length) {
-      return 0;
-    }
-    return aItemsArray.reduce((prev, curr) => prev + curr.attachment.contentSize || 0, 0);
-  },
-
-  /**
-   * Gets the oldest (first performed) request in a set. Returns null for an
-   * empty set.
-   *
-   * @param array aItemsArray
-   * @return object
-   */
-  _getOldestRequest: function(aItemsArray) {
-    if (!aItemsArray.length) {
-      return null;
-    }
-    return aItemsArray.reduce((prev, curr) =>
-      prev.attachment.startedMillis < curr.attachment.startedMillis ? prev : curr);
-  },
-
-  /**
-   * Gets the newest (latest performed) request in a set. Returns null for an
-   * empty set.
-   *
-   * @param array aItemsArray
-   * @return object
-   */
-  _getNewestRequest: function(aItemsArray) {
-    if (!aItemsArray.length) {
-      return null;
-    }
-    return aItemsArray.reduce((prev, curr) =>
-      prev.attachment.startedMillis > curr.attachment.startedMillis ? prev : curr);
-  },
-
-  /**
-   * Gets the available waterfall width in this container.
-   * @return number
-   */
-  get _waterfallWidth() {
-    if (this._cachedWaterfallWidth == 0) {
-      let container = $("#requests-menu-toolbar");
-      let waterfall = $("#requests-menu-waterfall-header-box");
-      let containerBounds = container.getBoundingClientRect();
-      let waterfallBounds = waterfall.getBoundingClientRect();
-      if (!window.isRTL) {
-        this._cachedWaterfallWidth = containerBounds.width - waterfallBounds.left;
-      } else {
-        this._cachedWaterfallWidth = waterfallBounds.right;
-      }
-    }
-    return this._cachedWaterfallWidth;
-  },
-
-  _splitter: null,
-  _summary: null,
-  _canvas: null,
-  _ctx: null,
-  _cachedWaterfallWidth: 0,
-  _firstRequestStartedMillis: -1,
-  _lastRequestEndedMillis: -1,
-  _updateQueue: [],
-  _updateTimeout: null,
-  _resizeTimeout: null,
-  _activeFilters: ["all"],
-  _currentFreetextFilter: ""
-});
-
-/**
- * Functions handling the sidebar details view.
- */
-function SidebarView() {
-  dumpn("SidebarView was instantiated");
-}
-
-SidebarView.prototype = {
-  /**
-   * Sets this view hidden or visible. It's visible by default.
-   *
-   * @param boolean aVisibleFlag
-   *        Specifies the intended visibility.
-   */
-  toggle: function(aVisibleFlag) {
-    NetMonitorView.toggleDetailsPane({ visible: aVisibleFlag });
-    NetMonitorView.RequestsMenu._flushWaterfallViews(true);
-  },
-
-  /**
-   * Populates this view with the specified data.
-   *
-   * @param object aData
-   *        The data source (this should be the attachment of a request item).
-   * @return object
-   *        Returns a promise that resolves upon population of the subview.
-   */
-  populate: Task.async(function*(aData) {
-    let isCustom = aData.isCustom;
-    let view = isCustom ?
-      NetMonitorView.CustomRequest :
-      NetMonitorView.NetworkDetails;
-
-    yield view.populate(aData);
-    $("#details-pane").selectedIndex = isCustom ? 0 : 1;
-
-    window.emit(EVENTS.SIDEBAR_POPULATED);
-  })
-}
-
-/**
- * Functions handling the custom request view.
- */
-function CustomRequestView() {
-  dumpn("CustomRequestView was instantiated");
-}
-
-CustomRequestView.prototype = {
-  /**
-   * Initialization function, called when the network monitor is started.
-   */
-  initialize: function() {
-    dumpn("Initializing the CustomRequestView");
-
-    this.updateCustomRequestEvent = getKeyWithEvent(this.onUpdate.bind(this));
-    $("#custom-pane").addEventListener("input", this.updateCustomRequestEvent, false);
-  },
-
-  /**
-   * Destruction function, called when the network monitor is closed.
-   */
-  destroy: function() {
-    dumpn("Destroying the CustomRequestView");
-
-    $("#custom-pane").removeEventListener("input", this.updateCustomRequestEvent, false);
-  },
-
-  /**
-   * Populates this view with the specified data.
-   *
-   * @param object aData
-   *        The data source (this should be the attachment of a request item).
-   * @return object
-   *        Returns a promise that resolves upon population the view.
-   */
-  populate: Task.async(function*(aData) {
-    $("#custom-url-value").value = aData.url;
-    $("#custom-method-value").value = aData.method;
-    this.updateCustomQuery(aData.url);
-
-    if (aData.requestHeaders) {
-      let headers = aData.requestHeaders.headers;
-      $("#custom-headers-value").value = writeHeaderText(headers);
-    }
-    if (aData.requestPostData) {
-      let postData = aData.requestPostData.postData.text;
-      $("#custom-postdata-value").value = yield gNetwork.getString(postData);
-    }
-
-    window.emit(EVENTS.CUSTOMREQUESTVIEW_POPULATED);
-  }),
-
-  /**
-   * Handle user input in the custom request form.
-   *
-   * @param object aField
-   *        the field that the user updated.
-   */
-  onUpdate: function(aField) {
-    let selectedItem = NetMonitorView.RequestsMenu.selectedItem;
-    let field = aField;
-    let value;
-
-    switch(aField) {
-      case 'method':
-        value = $("#custom-method-value").value.trim();
-        selectedItem.attachment.method = value;
-        break;
-      case 'url':
-        value = $("#custom-url-value").value;
-        this.updateCustomQuery(value);
-        selectedItem.attachment.url = value;
-        break;
-      case 'query':
-        let query = $("#custom-query-value").value;
-        this.updateCustomUrl(query);
-        field = 'url';
-        value = $("#custom-url-value").value
-        selectedItem.attachment.url = value;
-        break;
-      case 'body':
-        value = $("#custom-postdata-value").value;
-        selectedItem.attachment.requestPostData = { postData: { text: value } };
-        break;
-      case 'headers':
-        let headersText = $("#custom-headers-value").value;
-        value = parseHeadersText(headersText);
-        selectedItem.attachment.requestHeaders = { headers: value };
-        break;
-    }
-
-    NetMonitorView.RequestsMenu.updateMenuView(selectedItem, field, value);
-  },
-
-  /**
-   * Update the query string field based on the url.
-   *
-   * @param object aUrl
-   *        The URL to extract query string from.
-   */
-  updateCustomQuery: function(aUrl) {
-    let paramsArray = parseQueryString(nsIURL(aUrl).query);
-    if (!paramsArray) {
-      $("#custom-query").hidden = true;
-      return;
-    }
-    $("#custom-query").hidden = false;
-    $("#custom-query-value").value = writeQueryText(paramsArray);
-  },
-
-  /**
-   * Update the url based on the query string field.
-   *
-   * @param object aQueryText
-   *        The contents of the query string field.
-   */
-  updateCustomUrl: function(aQueryText) {
-    let params = parseQueryText(aQueryText);
-    let queryString = writeQueryString(params);
-
-    let url = $("#custom-url-value").value;
-    let oldQuery = nsIURL(url).query;
-    let path = url.replace(oldQuery, queryString);
-
-    $("#custom-url-value").value = path;
-  }
-}
-
-/**
- * Functions handling the requests details view.
- */
-function NetworkDetailsView() {
-  dumpn("NetworkDetailsView was instantiated");
-
-  // The ToolSidebar requires the panel object to be able to emit events.
-  EventEmitter.decorate(this);
-
-  this._onTabSelect = this._onTabSelect.bind(this);
-};
-
-NetworkDetailsView.prototype = {
-  /**
-   * An object containing the state of tabs.
-   */
-  _viewState: {
-    // if updating[tab] is true a task is currently updating the given tab.
-    updating: [],
-    // if dirty[tab] is true, the tab needs to be repopulated once current
-    // update task finishes
-    dirty: [],
-    // the most recently received attachment data for the request
-    latestData: null,
-  },
-
-  /**
-   * Initialization function, called when the network monitor is started.
-   */
-  initialize: function() {
-    dumpn("Initializing the NetworkDetailsView");
-
-    this.widget = $("#event-details-pane");
-    this.sidebar = new ToolSidebar(this.widget, this, "netmonitor", {
-      disableTelemetry: true,
-      showAllTabsMenu: true
-    });
-
-    this._headers = new VariablesView($("#all-headers"),
-      Heritage.extend(GENERIC_VARIABLES_VIEW_SETTINGS, {
-        emptyText: L10N.getStr("headersEmptyText"),
-        searchPlaceholder: L10N.getStr("headersFilterText")
-      }));
-    this._cookies = new VariablesView($("#all-cookies"),
-      Heritage.extend(GENERIC_VARIABLES_VIEW_SETTINGS, {
-        emptyText: L10N.getStr("cookiesEmptyText"),
-        searchPlaceholder: L10N.getStr("cookiesFilterText")
-      }));
-    this._params = new VariablesView($("#request-params"),
-      Heritage.extend(GENERIC_VARIABLES_VIEW_SETTINGS, {
-        emptyText: L10N.getStr("paramsEmptyText"),
-        searchPlaceholder: L10N.getStr("paramsFilterText")
-      }));
-    this._json = new VariablesView($("#response-content-json"),
-      Heritage.extend(GENERIC_VARIABLES_VIEW_SETTINGS, {
-        onlyEnumVisible: true,
-        searchPlaceholder: L10N.getStr("jsonFilterText")
-      }));
-    VariablesViewController.attach(this._json);
-
-    this._paramsQueryString = L10N.getStr("paramsQueryString");
-    this._paramsFormData = L10N.getStr("paramsFormData");
-    this._paramsPostPayload = L10N.getStr("paramsPostPayload");
-    this._requestHeaders = L10N.getStr("requestHeaders");
-    this._requestHeadersFromUpload = L10N.getStr("requestHeadersFromUpload");
-    this._responseHeaders = L10N.getStr("responseHeaders");
-    this._requestCookies = L10N.getStr("requestCookies");
-    this._responseCookies = L10N.getStr("responseCookies");
-
-    $("tabpanels", this.widget).addEventListener("select", this._onTabSelect);
-  },
-
-  /**
-   * Destruction function, called when the network monitor is closed.
-   */
-  destroy: function() {
-    dumpn("Destroying the NetworkDetailsView");
-    this.sidebar.destroy();
-    $("tabpanels", this.widget).removeEventListener("select", this._onTabSelect);
-  },
-
-  /**
-   * Populates this view with the specified data.
-   *
-   * @param object aData
-   *        The data source (this should be the attachment of a request item).
-   * @return object
-   *        Returns a promise that resolves upon population the view.
-   */
-  populate: function(aData) {
-    $("#request-params-box").setAttribute("flex", "1");
-    $("#request-params-box").hidden = false;
-    $("#request-post-data-textarea-box").hidden = true;
-    $("#response-content-info-header").hidden = true;
-    $("#response-content-json-box").hidden = true;
-    $("#response-content-textarea-box").hidden = true;
-    $("#raw-headers").hidden = true;
-    $("#response-content-image-box").hidden = true;
-
-    let isHtml = RequestsMenuView.prototype.isHtml({ attachment: aData });
-
-    // Show the "Preview" tabpanel only for plain HTML responses.
-    this.sidebar.toggleTab(isHtml, "preview-tab", "preview-tabpanel");
-
-    // Show the "Security" tab only for requests that
-    //   1) are https (state != insecure)
-    //   2) come from a target that provides security information.
-    let hasSecurityInfo = aData.securityState &&
-                          aData.securityState !== "insecure";
-    this.sidebar.toggleTab(hasSecurityInfo, "security-tab", "security-tabpanel");
-
-    // Switch to the "Headers" tabpanel if the "Preview" previously selected
-    // and this is not an HTML response or "Security" was selected but this
-    // request has no security information.
-
-    if (!isHtml && this.widget.selectedPanel === $("#preview-tabpanel") ||
-        !hasSecurityInfo && this.widget.selectedPanel === $("#security-tabpanel")) {
-      this.widget.selectedIndex = 0;
-    }
-
-    this._headers.empty();
-    this._cookies.empty();
-    this._params.empty();
-    this._json.empty();
-
-    this._dataSrc = { src: aData, populated: [] };
-    this._onTabSelect();
-    window.emit(EVENTS.NETWORKDETAILSVIEW_POPULATED);
-
-    return promise.resolve();
-  },
-
-  /**
-   * Listener handling the tab selection event.
-   */
-  _onTabSelect: function() {
-    let { src, populated } = this._dataSrc || {};
-    let tab = this.widget.selectedIndex;
-    let view = this;
-
-    // Make sure the data source is valid and don't populate the same tab twice.
-    if (!src || populated[tab]) {
-      return;
-    }
-
-    let viewState = this._viewState;
-    if (viewState.updating[tab]) {
-      // A task is currently updating this tab. If we started another update
-      // task now it would result in a duplicated content as described in bugs
-      // 997065 and 984687. As there's no way to stop the current task mark the
-      // tab dirty and refresh the panel once the current task finishes.
-      viewState.dirty[tab] = true;
-      viewState.latestData = src;
-      return;
-    }
-
-    Task.spawn(function*() {
-      viewState.updating[tab] = true;
-      switch (tab) {
-        case 0: // "Headers"
-          yield view._setSummary(src);
-          yield view._setResponseHeaders(src.responseHeaders);
-          yield view._setRequestHeaders(
-            src.requestHeaders,
-            src.requestHeadersFromUploadStream);
-          break;
-        case 1: // "Cookies"
-          yield view._setResponseCookies(src.responseCookies);
-          yield view._setRequestCookies(src.requestCookies);
-          break;
-        case 2: // "Params"
-          yield view._setRequestGetParams(src.url);
-          yield view._setRequestPostParams(
-            src.requestHeaders,
-            src.requestHeadersFromUploadStream,
-            src.requestPostData);
-          break;
-        case 3: // "Response"
-          yield view._setResponseBody(src.url, src.responseContent);
-          break;
-        case 4: // "Timings"
-          yield view._setTimingsInformation(src.eventTimings);
-          break;
-        case 5: // "Security"
-          yield view._setSecurityInfo(src.securityInfo, src.url);
-          break;
-        case 6: // "Preview"
-          yield view._setHtmlPreview(src.responseContent);
-          break;
-      }
-      viewState.updating[tab] = false;
-    }).then(() => {
-      if (tab == this.widget.selectedIndex) {
-        if (viewState.dirty[tab]) {
-          // The request information was updated while the task was running.
-          viewState.dirty[tab] = false;
-          view.populate(viewState.latestData);
-        }
-        else {
-          // Tab is selected but not dirty. We're done here.
-          populated[tab] = true;
-          window.emit(EVENTS.TAB_UPDATED);
-
-          if (NetMonitorController.isConnected()) {
-            NetMonitorView.RequestsMenu.ensureSelectedItemIsVisible();
-          }
-        }
-      }
-      else {
-        if (viewState.dirty[tab]) {
-          // Tab is dirty but no longer selected. Don't refresh it now, it'll be
-          // done if the tab is shown again.
-          viewState.dirty[tab] = false;
-        }
-      }
-    }, Cu.reportError);
-  },
-
-  /**
-   * Sets the network request summary shown in this view.
-   *
-   * @param object aData
-   *        The data source (this should be the attachment of a request item).
-   */
-  _setSummary: function(aData) {
-    if (aData.url) {
-      let unicodeUrl = NetworkHelper.convertToUnicode(unescape(aData.url));
-      $("#headers-summary-url-value").setAttribute("value", unicodeUrl);
-      $("#headers-summary-url-value").setAttribute("tooltiptext", unicodeUrl);
-      $("#headers-summary-url").removeAttribute("hidden");
-    } else {
-      $("#headers-summary-url").setAttribute("hidden", "true");
-    }
-
-    if (aData.method) {
-      $("#headers-summary-method-value").setAttribute("value", aData.method);
-      $("#headers-summary-method").removeAttribute("hidden");
-    } else {
-      $("#headers-summary-method").setAttribute("hidden", "true");
-    }
-
-    if (aData.remoteAddress) {
-      let address = aData.remoteAddress;
-      if (address.indexOf(":") != -1) {
-        address = `[${address}]`;
-      }
-      if(aData.remotePort) {
-        address += `:${aData.remotePort}`;
-      }
-      $("#headers-summary-address-value").setAttribute("value", address);
-      $("#headers-summary-address-value").setAttribute("tooltiptext", address);
-      $("#headers-summary-address").removeAttribute("hidden");
-    } else {
-      $("#headers-summary-address").setAttribute("hidden", "true");
-    }
-
-    if (aData.status) {
-      $("#headers-summary-status-circle").setAttribute("code", aData.status);
-      $("#headers-summary-status-value").setAttribute("value", aData.status + " " + aData.statusText);
-      $("#headers-summary-status").removeAttribute("hidden");
-    } else {
-      $("#headers-summary-status").setAttribute("hidden", "true");
-    }
-
-    if (aData.httpVersion && aData.httpVersion != DEFAULT_HTTP_VERSION) {
-      $("#headers-summary-version-value").setAttribute("value", aData.httpVersion);
-      $("#headers-summary-version").removeAttribute("hidden");
-    } else {
-      $("#headers-summary-version").setAttribute("hidden", "true");
-    }
-  },
-
-  /**
-   * Sets the network request headers shown in this view.
-   *
-   * @param object aHeadersResponse
-   *        The "requestHeaders" message received from the server.
-   * @param object aHeadersFromUploadStream
-   *        The "requestHeadersFromUploadStream" inferred from the POST payload.
-   * @return object
-   *        A promise that resolves when request headers are set.
-   */
-  _setRequestHeaders: Task.async(function*(aHeadersResponse, aHeadersFromUploadStream) {
-    if (aHeadersResponse && aHeadersResponse.headers.length) {
-      yield this._addHeaders(this._requestHeaders, aHeadersResponse);
-    }
-    if (aHeadersFromUploadStream && aHeadersFromUploadStream.headers.length) {
-      yield this._addHeaders(this._requestHeadersFromUpload, aHeadersFromUploadStream);
-    }
-  }),
-
-  /**
-   * Sets the network response headers shown in this view.
-   *
-   * @param object aResponse
-   *        The message received from the server.
-   * @return object
-   *        A promise that resolves when response headers are set.
-   */
-  _setResponseHeaders: Task.async(function*(aResponse) {
-    if (aResponse && aResponse.headers.length) {
-      aResponse.headers.sort((a, b) => a.name > b.name);
-      yield this._addHeaders(this._responseHeaders, aResponse);
-    }
-  }),
-
-  /**
-   * Populates the headers container in this view with the specified data.
-   *
-   * @param string aName
-   *        The type of headers to populate (request or response).
-   * @param object aResponse
-   *        The message received from the server.
-   * @return object
-   *        A promise that resolves when headers are added.
-   */
-  _addHeaders: Task.async(function*(aName, aResponse) {
-    let kb = aResponse.headersSize / 1024;
-    let size = L10N.numberWithDecimals(kb, HEADERS_SIZE_DECIMALS);
-    let text = L10N.getFormatStr("networkMenu.sizeKB", size);
-
-    let headersScope = this._headers.addScope(aName + " (" + text + ")");
-    headersScope.expanded = true;
-
-    for (let header of aResponse.headers) {
-      let headerVar = headersScope.addItem(header.name, {}, true);
-      let headerValue = yield gNetwork.getString(header.value);
-      headerVar.setGrip(headerValue);
-    }
-  }),
-
-  /**
-   * Sets the network request cookies shown in this view.
-   *
-   * @param object aResponse
-   *        The message received from the server.
-   * @return object
-   *        A promise that is resolved when the request cookies are set.
-   */
-  _setRequestCookies: Task.async(function*(aResponse) {
-    if (aResponse && aResponse.cookies.length) {
-      aResponse.cookies.sort((a, b) => a.name > b.name);
-      yield this._addCookies(this._requestCookies, aResponse);
-    }
-  }),
-
-  /**
-   * Sets the network response cookies shown in this view.
-   *
-   * @param object aResponse
-   *        The message received from the server.
-   * @return object
-   *        A promise that is resolved when the response cookies are set.
-   */
-  _setResponseCookies: Task.async(function*(aResponse) {
-    if (aResponse && aResponse.cookies.length) {
-      yield this._addCookies(this._responseCookies, aResponse);
-    }
-  }),
-
-  /**
-   * Populates the cookies container in this view with the specified data.
-   *
-   * @param string aName
-   *        The type of cookies to populate (request or response).
-   * @param object aResponse
-   *        The message received from the server.
-   * @return object
-   *        Returns a promise that resolves upon the adding of cookies.
-   */
-  _addCookies: Task.async(function*(aName, aResponse) {
-    let cookiesScope = this._cookies.addScope(aName);
-    cookiesScope.expanded = true;
-
-    for (let cookie of aResponse.cookies) {
-      let cookieVar = cookiesScope.addItem(cookie.name, {}, true);
-      let cookieValue = yield gNetwork.getString(cookie.value);
-      cookieVar.setGrip(cookieValue);
-
-      // By default the cookie name and value are shown. If this is the only
-      // information available, then nothing else is to be displayed.
-      let cookieProps = Object.keys(cookie);
-      if (cookieProps.length == 2) {
-        continue;
-      }
-
-      // Display any other information other than the cookie name and value
-      // which may be available.
-      let rawObject = Object.create(null);
-      let otherProps = cookieProps.filter(e => e != "name" && e != "value");
-      for (let prop of otherProps) {
-        rawObject[prop] = cookie[prop];
-      }
-      cookieVar.populate(rawObject);
-      cookieVar.twisty = true;
-      cookieVar.expanded = true;
-    }
-  }),
-
-  /**
-   * Sets the network request get params shown in this view.
-   *
-   * @param string aUrl
-   *        The request's url.
-   */
-  _setRequestGetParams: function(aUrl) {
-    let query = nsIURL(aUrl).query;
-    if (query) {
-      this._addParams(this._paramsQueryString, query);
-    }
-  },
-
-  /**
-   * Sets the network request post params shown in this view.
-   *
-   * @param object aHeadersResponse
-   *        The "requestHeaders" message received from the server.
-   * @param object aHeadersFromUploadStream
-   *        The "requestHeadersFromUploadStream" inferred from the POST payload.
-   * @param object aPostDataResponse
-   *        The "requestPostData" message received from the server.
-   * @return object
-   *        A promise that is resolved when the request post params are set.
-   */
-  _setRequestPostParams: Task.async(function*(aHeadersResponse, aHeadersFromUploadStream, aPostDataResponse) {
-    if (!aHeadersResponse || !aHeadersFromUploadStream || !aPostDataResponse) {
-      return;
-    }
-
-    let { headers: requestHeaders } = aHeadersResponse;
-    let { headers: payloadHeaders } = aHeadersFromUploadStream;
-    let allHeaders = [...payloadHeaders, ...requestHeaders];
-
-    let contentTypeHeader = allHeaders.find(e => e.name.toLowerCase() == "content-type");
-    let contentTypeLongString = contentTypeHeader ? contentTypeHeader.value : "";
-    let postDataLongString = aPostDataResponse.postData.text;
-
-    let postData = yield gNetwork.getString(postDataLongString);
-    let contentType = yield gNetwork.getString(contentTypeLongString);
-
-    // Handle query strings (e.g. "?foo=bar&baz=42").
-    if (contentType.contains("x-www-form-urlencoded")) {
-      for (let section of postData.split(/\r\n|\r|\n/)) {
-        // Before displaying it, make sure this section of the POST data
-        // isn't a line containing upload stream headers.
-        if (payloadHeaders.every(header => !section.startsWith(header.name))) {
-          this._addParams(this._paramsFormData, section);
-        }
-      }
-    }
-    // Handle actual forms ("multipart/form-data" content type).
-    else {
-      // This is really awkward, but hey, it works. Let's show an empty
-      // scope in the params view and place the source editor containing
-      // the raw post data directly underneath.
-      $("#request-params-box").removeAttribute("flex");
-      let paramsScope = this._params.addScope(this._paramsPostPayload);
-      paramsScope.expanded = true;
-      paramsScope.locked = true;
-
-      $("#request-post-data-textarea-box").hidden = false;
-      let editor = yield NetMonitorView.editor("#request-post-data-textarea");
-      // Most POST bodies are usually JSON, so they can be neatly
-      // syntax highlighted as JS. Otheriwse, fall back to plain text.
-      try {
-        JSON.parse(postData);
-        editor.setMode(Editor.modes.js);
-      } catch (e) {
-        editor.setMode(Editor.modes.text);
-      } finally {
-        editor.setText(postData);
-      }
-    }
-
-    window.emit(EVENTS.REQUEST_POST_PARAMS_DISPLAYED);
-  }),
-
-  /**
-   * Populates the params container in this view with the specified data.
-   *
-   * @param string aName
-   *        The type of params to populate (get or post).
-   * @param string aQueryString
-   *        A query string of params (e.g. "?foo=bar&baz=42").
-   */
-  _addParams: function(aName, aQueryString) {
-    let paramsArray = parseQueryString(aQueryString);
-    if (!paramsArray) {
-      return;
-    }
-    let paramsScope = this._params.addScope(aName);
-    paramsScope.expanded = true;
-
-    for (let param of paramsArray) {
-      let paramVar = paramsScope.addItem(param.name, {}, true);
-      paramVar.setGrip(param.value);
-    }
-  },
-
-  /**
-   * Sets the network response body shown in this view.
-   *
-   * @param string aUrl
-   *        The request's url.
-   * @param object aResponse
-   *        The message received from the server.
-   * @return object
-   *         A promise that is resolved when the response body is set.
-   */
-  _setResponseBody: Task.async(function*(aUrl, aResponse) {
-    if (!aResponse) {
-      return;
-    }
-    let { mimeType, text, encoding } = aResponse.content;
-    let responseBody = yield gNetwork.getString(text);
-
-    // Handle json, which we tentatively identify by checking the MIME type
-    // for "json" after any word boundary. This works for the standard
-    // "application/json", and also for custom types like "x-bigcorp-json".
-    // Additionally, we also directly parse the response text content to
-    // verify whether it's json or not, to handle responses incorrectly
-    // labeled as text/plain instead.
-    let jsonMimeType, jsonObject, jsonObjectParseError;
-    try {
-      jsonMimeType = /\bjson/.test(mimeType);
-      jsonObject = JSON.parse(responseBody);
-    } catch (e) {
-      jsonObjectParseError = e;
-    }
-    if (jsonMimeType || jsonObject) {
-      // Extract the actual json substring in case this might be a "JSONP".
-      // This regex basically parses a function call and captures the
-      // function name and arguments in two separate groups.
-      let jsonpRegex = /^\s*([\w$]+)\s*\(\s*([^]*)\s*\)\s*;?\s*$/;
-      let [_, callbackPadding, jsonpString] = responseBody.match(jsonpRegex) || [];
-
-      // Make sure this is a valid JSON object first. If so, nicely display
-      // the parsing results in a variables view. Otherwise, simply show
-      // the contents as plain text.
-      if (callbackPadding && jsonpString) {
-        try {
-          jsonObject = JSON.parse(jsonpString);
-        } catch (e) {
-          jsonObjectParseError = e;
-        }
-      }
-
-      // Valid JSON or JSONP.
-      if (jsonObject) {
-        $("#response-content-json-box").hidden = false;
-        let jsonScopeName = callbackPadding
-          ? L10N.getFormatStr("jsonpScopeName", callbackPadding)
-          : L10N.getStr("jsonScopeName");
-
-        let jsonVar = { label: jsonScopeName, rawObject: jsonObject };
-        yield this._json.controller.setSingleVariable(jsonVar).expanded;
-      }
-      // Malformed JSON.
-      else {
-        $("#response-content-textarea-box").hidden = false;
-        let infoHeader = $("#response-content-info-header");
-        infoHeader.setAttribute("value", jsonObjectParseError);
-        infoHeader.setAttribute("tooltiptext", jsonObjectParseError);
-        infoHeader.hidden = false;
-
-        let editor = yield NetMonitorView.editor("#response-content-textarea");
-        editor.setMode(Editor.modes.js);
-        editor.setText(responseBody);
-      }
-    }
-    // Handle images.
-    else if (mimeType.contains("image/")) {
-      $("#response-content-image-box").setAttribute("align", "center");
-      $("#response-content-image-box").setAttribute("pack", "center");
-      $("#response-content-image-box").hidden = false;
-      $("#response-content-image").src =
-        "data:" + mimeType + ";" + encoding + "," + responseBody;
-
-      // Immediately display additional information about the image:
-      // file name, mime type and encoding.
-      $("#response-content-image-name-value").setAttribute("value", nsIURL(aUrl).fileName);
-      $("#response-content-image-mime-value").setAttribute("value", mimeType);
-      $("#response-content-image-encoding-value").setAttribute("value", encoding);
-
-      // Wait for the image to load in order to display the width and height.
-      $("#response-content-image").onload = e => {
-        // XUL images are majestic so they don't bother storing their dimensions
-        // in width and height attributes like the rest of the folk. Hack around
-        // this by getting the bounding client rect and subtracting the margins.
-        let { width, height } = e.target.getBoundingClientRect();
-        let dimensions = (width - 2) + " \u00D7 " + (height - 2);
-        $("#response-content-image-dimensions-value").setAttribute("value", dimensions);
-      };
-    }
-    // Handle anything else.
-    else {
-      $("#response-content-textarea-box").hidden = false;
-      let editor = yield NetMonitorView.editor("#response-content-textarea");
-      editor.setMode(Editor.modes.text);
-      editor.setText(responseBody);
-
-      // Maybe set a more appropriate mode in the Source Editor if possible,
-      // but avoid doing this for very large files.
-      if (responseBody.length < SOURCE_SYNTAX_HIGHLIGHT_MAX_FILE_SIZE) {
-        let mapping = Object.keys(CONTENT_MIME_TYPE_MAPPINGS).find(key => mimeType.contains(key));
-        if (mapping) {
-          editor.setMode(CONTENT_MIME_TYPE_MAPPINGS[mapping]);
-        }
-      }
-    }
-
-    window.emit(EVENTS.RESPONSE_BODY_DISPLAYED);
-  }),
-
-  /**
-   * Sets the timings information shown in this view.
-   *
-   * @param object aResponse
-   *        The message received from the server.
-   */
-  _setTimingsInformation: function(aResponse) {
-    if (!aResponse) {
-      return;
-    }
-    let { blocked, dns, connect, send, wait, receive } = aResponse.timings;
-
-    let tabboxWidth = $("#details-pane").getAttribute("width");
-    let availableWidth = tabboxWidth / 2; // Other nodes also take some space.
-    let scale = Math.max(availableWidth / aResponse.totalTime, 0);
-
-    $("#timings-summary-blocked .requests-menu-timings-box")
-      .setAttribute("width", blocked * scale);
-    $("#timings-summary-blocked .requests-menu-timings-total")
-      .setAttribute("value", L10N.getFormatStr("networkMenu.totalMS", blocked));
-
-    $("#timings-summary-dns .requests-menu-timings-box")
-      .setAttribute("width", dns * scale);
-    $("#timings-summary-dns .requests-menu-timings-total")
-      .setAttribute("value", L10N.getFormatStr("networkMenu.totalMS", dns));
-
-    $("#timings-summary-connect .requests-menu-timings-box")
-      .setAttribute("width", connect * scale);
-    $("#timings-summary-connect .requests-menu-timings-total")
-      .setAttribute("value", L10N.getFormatStr("networkMenu.totalMS", connect));
-
-    $("#timings-summary-send .requests-menu-timings-box")
-      .setAttribute("width", send * scale);
-    $("#timings-summary-send .requests-menu-timings-total")
-      .setAttribute("value", L10N.getFormatStr("networkMenu.totalMS", send));
-
-    $("#timings-summary-wait .requests-menu-timings-box")
-      .setAttribute("width", wait * scale);
-    $("#timings-summary-wait .requests-menu-timings-total")
-      .setAttribute("value", L10N.getFormatStr("networkMenu.totalMS", wait));
-
-    $("#timings-summary-receive .requests-menu-timings-box")
-      .setAttribute("width", receive * scale);
-    $("#timings-summary-receive .requests-menu-timings-total")
-      .setAttribute("value", L10N.getFormatStr("networkMenu.totalMS", receive));
-
-    $("#timings-summary-dns .requests-menu-timings-box")
-      .style.transform = "translateX(" + (scale * blocked) + "px)";
-    $("#timings-summary-connect .requests-menu-timings-box")
-      .style.transform = "translateX(" + (scale * (blocked + dns)) + "px)";
-    $("#timings-summary-send .requests-menu-timings-box")
-      .style.transform = "translateX(" + (scale * (blocked + dns + connect)) + "px)";
-    $("#timings-summary-wait .requests-menu-timings-box")
-      .style.transform = "translateX(" + (scale * (blocked + dns + connect + send)) + "px)";
-    $("#timings-summary-receive .requests-menu-timings-box")
-      .style.transform = "translateX(" + (scale * (blocked + dns + connect + send + wait)) + "px)";
-
-    $("#timings-summary-dns .requests-menu-timings-total")
-      .style.transform = "translateX(" + (scale * blocked) + "px)";
-    $("#timings-summary-connect .requests-menu-timings-total")
-      .style.transform = "translateX(" + (scale * (blocked + dns)) + "px)";
-    $("#timings-summary-send .requests-menu-timings-total")
-      .style.transform = "translateX(" + (scale * (blocked + dns + connect)) + "px)";
-    $("#timings-summary-wait .requests-menu-timings-total")
-      .style.transform = "translateX(" + (scale * (blocked + dns + connect + send)) + "px)";
-    $("#timings-summary-receive .requests-menu-timings-total")
-      .style.transform = "translateX(" + (scale * (blocked + dns + connect + send + wait)) + "px)";
-  },
-
-  /**
-   * Sets the preview for HTML responses shown in this view.
-   *
-   * @param object aResponse
-   *        The message received from the server.
-   * @return object
-   *        A promise that is resolved when the html preview is rendered.
-   */
-  _setHtmlPreview: Task.async(function*(aResponse) {
-    if (!aResponse) {
-      return promise.resolve();
-    }
-    let { text } = aResponse.content;
-    let responseBody = yield gNetwork.getString(text);
-
-    // Always disable JS when previewing HTML responses.
-    let iframe = $("#response-preview");
-    iframe.contentDocument.docShell.allowJavascript = false;
-    iframe.contentDocument.documentElement.innerHTML = responseBody;
-
-    window.emit(EVENTS.RESPONSE_HTML_PREVIEW_DISPLAYED);
-  }),
-
-  /**
-   * Sets the security information shown in this view.
-   *
-   * @param object securityInfo
-   *        The data received from server
-   * @param string url
-   *        The URL of this request
-   * @return object
-   *        A promise that is resolved when the security info is rendered.
-   */
-  _setSecurityInfo: Task.async(function* (securityInfo, url) {
-    if (!securityInfo) {
-      // We don't have security info. This could mean one of two things:
-      // 1) This connection is not secure and this tab is not visible and thus
-      //    we shouldn't be here.
-      // 2) We have already received securityState and the tab is visible BUT
-      //    the rest of the information is still on its way. Once it arrives
-      //    this method is called again.
-      return;
-    }
-
-    /**
-     * A helper that sets value and tooltiptext attributes of an element to
-     * specified value.
-     *
-     * @param string selector
-     *        A selector for the element.
-     * @param string value
-     *        The value to set. If this evaluates to false a placeholder string
-     *        <Not Available> is used instead.
-     */
-    function setValue(selector, value) {
-      let label = $(selector);
-      if (!value) {
-        label.setAttribute("value", L10N.getStr("netmonitor.security.notAvailable"));
-        label.setAttribute("tooltiptext", label.getAttribute("value"));
-      } else {
-        label.setAttribute("value", value);
-        label.setAttribute("tooltiptext", value);
-      }
-    }
-
-    let errorbox = $("#security-error");
-    let infobox = $("#security-information");
-
-    if (securityInfo.state === "secure" || securityInfo.state === "weak") {
-      infobox.hidden = false;
-      errorbox.hidden = true;
-
-      // Warning icons
-      let cipher = $("#security-warning-cipher");
-
-      if (securityInfo.state === "weak") {
-        cipher.hidden = securityInfo.weaknessReasons.indexOf("cipher") === -1;
-      } else {
-        cipher.hidden = true;
-      }
-
-      let enabledLabel = L10N.getStr("netmonitor.security.enabled");
-      let disabledLabel = L10N.getStr("netmonitor.security.disabled");
-
-      // Connection parameters
-      setValue("#security-protocol-version-value", securityInfo.protocolVersion);
-      setValue("#security-ciphersuite-value", securityInfo.cipherSuite);
-
-      // Host header
-      let domain = NetMonitorView.RequestsMenu._getUriHostPort(url);
-      let hostHeader = L10N.getFormatStr("netmonitor.security.hostHeader", domain);
-      setValue("#security-info-host-header", hostHeader);
-
-      // Parameters related to the domain
-      setValue("#security-http-strict-transport-security-value",
-                securityInfo.hsts ? enabledLabel : disabledLabel);
-
-      setValue("#security-public-key-pinning-value",
-                securityInfo.hpkp ? enabledLabel : disabledLabel);
-
-      // Certificate parameters
-      let cert = securityInfo.cert;
-      setValue("#security-cert-subject-cn", cert.subject.commonName);
-      setValue("#security-cert-subject-o", cert.subject.organization);
-      setValue("#security-cert-subject-ou", cert.subject.organizationalUnit);
-
-      setValue("#security-cert-issuer-cn", cert.issuer.commonName);
-      setValue("#security-cert-issuer-o", cert.issuer.organization);
-      setValue("#security-cert-issuer-ou", cert.issuer.organizationalUnit);
-
-      setValue("#security-cert-validity-begins", cert.validity.start);
-      setValue("#security-cert-validity-expires", cert.validity.end);
-
-      setValue("#security-cert-sha1-fingerprint", cert.fingerprint.sha1);
-      setValue("#security-cert-sha256-fingerprint", cert.fingerprint.sha256);
-    } else {
-      infobox.hidden = true;
-      errorbox.hidden = false;
-
-      // Strip any HTML from the message.
-      let plain = DOMParser.parseFromString(securityInfo.errorMessage, "text/html");
-      setValue("#security-error-message", plain.body.textContent);
-    }
-  }),
-
-  _dataSrc: null,
-  _headers: null,
-  _cookies: null,
-  _params: null,
-  _json: null,
-  _paramsQueryString: "",
-  _paramsFormData: "",
-  _paramsPostPayload: "",
-  _requestHeaders: "",
-  _responseHeaders: "",
-  _requestCookies: "",
-  _responseCookies: ""
-};
-
-/**
- * Functions handling the performance statistics view.
- */
-function PerformanceStatisticsView() {
-}
-
-PerformanceStatisticsView.prototype = {
-  /**
-   * Initializes and displays empty charts in this container.
-   */
-  displayPlaceholderCharts: function() {
-    this._createChart({
-      id: "#primed-cache-chart",
-      title: "charts.cacheEnabled"
-    });
-    this._createChart({
-      id: "#empty-cache-chart",
-      title: "charts.cacheDisabled"
-    });
-    window.emit(EVENTS.PLACEHOLDER_CHARTS_DISPLAYED);
-  },
-
-  /**
-   * Populates and displays the primed cache chart in this container.
-   *
-   * @param array aItems
-   *        @see this._sanitizeChartDataSource
-   */
-  createPrimedCacheChart: function(aItems) {
-    this._createChart({
-      id: "#primed-cache-chart",
-      title: "charts.cacheEnabled",
-      data: this._sanitizeChartDataSource(aItems),
-      strings: this._commonChartStrings,
-      totals: this._commonChartTotals,
-      sorted: true
-    });
-    window.emit(EVENTS.PRIMED_CACHE_CHART_DISPLAYED);
-  },
-
-  /**
-   * Populates and displays the empty cache chart in this container.
-   *
-   * @param array aItems
-   *        @see this._sanitizeChartDataSource
-   */
-  createEmptyCacheChart: function(aItems) {
-    this._createChart({
-      id: "#empty-cache-chart",
-      title: "charts.cacheDisabled",
-      data: this._sanitizeChartDataSource(aItems, true),
-      strings: this._commonChartStrings,
-      totals: this._commonChartTotals,
-      sorted: true
-    });
-    window.emit(EVENTS.EMPTY_CACHE_CHART_DISPLAYED);
-  },
-
-  /**
-   * Common stringifier predicates used for items and totals in both the
-   * "primed" and "empty" cache charts.
-   */
-  _commonChartStrings: {
-    size: value => {
-      let string = L10N.numberWithDecimals(value / 1024, CONTENT_SIZE_DECIMALS);
-      return L10N.getFormatStr("charts.sizeKB", string);
-    },
-    time: value => {
-      let string = L10N.numberWithDecimals(value / 1000, REQUEST_TIME_DECIMALS);
-      return L10N.getFormatStr("charts.totalS", string);
-    }
-  },
-  _commonChartTotals: {
-    size: total => {
-      let string = L10N.numberWithDecimals(total / 1024, CONTENT_SIZE_DECIMALS);
-      return L10N.getFormatStr("charts.totalSize", string);
-    },
-    time: total => {
-      let seconds = total / 1000;
-      let string = L10N.numberWithDecimals(seconds, REQUEST_TIME_DECIMALS);
-      return PluralForm.get(seconds, L10N.getStr("charts.totalSeconds")).replace("#1", string);
-    },
-    cached: total => {
-      return L10N.getFormatStr("charts.totalCached", total);
-    },
-    count: total => {
-      return L10N.getFormatStr("charts.totalCount", total);
-    }
-  },
-
-  /**
-   * Adds a specific chart to this container.
-   *
-   * @param object
-   *        An object containing all or some the following properties:
-   *          - id: either "#primed-cache-chart" or "#empty-cache-chart"
-   *          - title/data/strings/totals/sorted: @see Chart.jsm for details
-   */
-  _createChart: function({ id, title, data, strings, totals, sorted }) {
-    let container = $(id);
-
-    // Nuke all existing charts of the specified type.
-    while (container.hasChildNodes()) {
-      container.firstChild.remove();
-    }
-
-    // Create a new chart.
-    let chart = Chart.PieTable(document, {
-      diameter: NETWORK_ANALYSIS_PIE_CHART_DIAMETER,
-      title: L10N.getStr(title),
-      data: data,
-      strings: strings,
-      totals: totals,
-      sorted: sorted
-    });
-
-    chart.on("click", (_, item) => {
-      NetMonitorView.RequestsMenu.filterOnlyOn(item.label);
-      NetMonitorView.showNetworkInspectorView();
-    });
+    chart.on("click", (_, item) => {
+      NetMonitorView.RequestsMenu.filterOnlyOn(item.label);
+      NetMonitorView.showNetworkInspectorView();
+    });
 
     container.appendChild(chart.node);
-  },
-
-  /**
-   * Sanitizes the data source used for creating charts, to follow the
-   * data format spec defined in Chart.jsm.
-   *
-   * @param array aItems
-   *        A collection of request items used as the data source for the chart.
-   * @param boolean aEmptyCache
-   *        True if the cache is considered enabled, false for disabled.
-   */
-  _sanitizeChartDataSource: function(aItems, aEmptyCache) {
-    let data = [
-      "html", "css", "js", "xhr", "fonts", "images", "media", "flash", "other"
-    ].map(e => ({
-      cached: 0,
-      count: 0,
-      label: e,
-      size: 0,
-      time: 0
-    }));
-
-    for (let requestItem of aItems) {
-      let details = requestItem.attachment;
-      let type;
-
-      if (RequestsMenuView.prototype.isHtml(requestItem)) {
-        type = 0; // "html"
-      } else if (RequestsMenuView.prototype.isCss(requestItem)) {
-        type = 1; // "css"
-      } else if (RequestsMenuView.prototype.isJs(requestItem)) {
-        type = 2; // "js"
-      } else if (RequestsMenuView.prototype.isFont(requestItem)) {
-        type = 4; // "fonts"
-      } else if (RequestsMenuView.prototype.isImage(requestItem)) {
-        type = 5; // "images"
-      } else if (RequestsMenuView.prototype.isMedia(requestItem)) {
-        type = 6; // "media"
-      } else if (RequestsMenuView.prototype.isFlash(requestItem)) {
-        type = 7; // "flash"
-      } else if (RequestsMenuView.prototype.isXHR(requestItem)) {
-        // Verify XHR last, to categorize other mime types in their own blobs.
-        type = 3; // "xhr"
-      } else {
-        type = 8; // "other"
-      }
-
-      if (aEmptyCache || !responseIsFresh(details)) {
-        data[type].time += details.totalTime || 0;
-        data[type].size += details.contentSize || 0;
-      } else {
-        data[type].cached++;
-      }
-      data[type].count++;
-    }
-
-    return data.filter(e => e.count > 0);
-  },
-};
-
-/**
- * DOM query helper.
- */
-function $(aSelector, aTarget = document) aTarget.querySelector(aSelector);
-function $all(aSelector, aTarget = document) aTarget.querySelectorAll(aSelector);
-
-/**
- * Helper for getting an nsIURL instance out of a string.
- */
-function nsIURL(aUrl, aStore = nsIURL.store) {
-  if (aStore.has(aUrl)) {
-    return aStore.get(aUrl);
-  }
-  let uri = Services.io.newURI(aUrl, null, null).QueryInterface(Ci.nsIURL);
-  aStore.set(aUrl, uri);
-  return uri;
-}
-nsIURL.store = new Map();
-
-/**
- * Parse a url's query string into its components
- *
- * @param string aQueryString
- *        The query part of a url
- * @return array
- *         Array of query params {name, value}
- */
-function parseQueryString(aQueryString) {
-  // Make sure there's at least one param available.
-  // Be careful here, params don't necessarily need to have values, so
-  // no need to verify the existence of a "=".
-  if (!aQueryString) {
-    return;
-  }
-  // Turn the params string into an array containing { name: value } tuples.
-  let paramsArray = aQueryString.replace(/^[?&]/, "").split("&").map(e => {
-    let param = e.split("=");
-    return {
-      name: param[0] ? NetworkHelper.convertToUnicode(unescape(param[0])) : "",
-      value: param[1] ? NetworkHelper.convertToUnicode(unescape(param[1])) : ""
-    }});
-  return paramsArray;
-}
-
-/**
- * Parse text representation of multiple HTTP headers.
- *
- * @param string aText
- *        Text of headers
- * @return array
- *         Array of headers info {name, value}
- */
-function parseHeadersText(aText) {
-  return parseRequestText(aText, "\\S+?", ":");
-}
-
-/**
- * Parse readable text list of a query string.
- *
- * @param string aText
- *        Text of query string represetation
- * @return array
- *         Array of query params {name, value}
- */
-function parseQueryText(aText) {
-  return parseRequestText(aText, ".+?", "=");
-}
-
-/**
- * Parse a text representation of a name[divider]value list with
- * the given name regex and divider character.
- *
- * @param string aText
- *        Text of list
- * @return array
- *         Array of headers info {name, value}
- */
-function parseRequestText(aText, aName, aDivider) {
-  let regex = new RegExp("(" + aName + ")\\" + aDivider + "\\s*(.+)");
-  let pairs = [];
-  for (let line of aText.split("\n")) {
-    let matches;
-    if (matches = regex.exec(line)) {
-      let [, name, value] = matches;
-      pairs.push({name: name, value: value});
-    }
   }
-  return pairs;
-}
-
-/**
- * Write out a list of headers into a chunk of text
- *
- * @param array aHeaders
- *        Array of headers info {name, value}
- * @return string aText
- *         List of headers in text format
- */
-function writeHeaderText(aHeaders) {
-  return [(name + ": " + value) for ({name, value} of aHeaders)].join("\n");
-}
-
-/**
- * Write out a list of query params into a chunk of text
- *
- * @param array aParams
- *        Array of query params {name, value}
- * @return string
- *         List of query params in text format
- */
-function writeQueryText(aParams) {
-  return [(name + "=" + value) for ({name, value} of aParams)].join("\n");
-}
-
-/**
- * Write out a list of query params into a query string
- *
- * @param array aParams
- *        Array of query  params {name, value}
- * @return string
- *         Query string that can be appended to a url.
- */
-function writeQueryString(aParams) {
-  return [(name + "=" + value) for ({name, value} of aParams)].join("&");
-}
-
-/**
- * Checks if the "Expiration Calculations" defined in section 13.2.4 of the
- * "HTTP/1.1: Caching in HTTP" spec holds true for a collection of headers.
- *
- * @param object
- *        An object containing the { responseHeaders, status } properties.
- * @return boolean
- *         True if the response is fresh and loaded from cache.
- */
-function responseIsFresh({ responseHeaders, status }) {
-  // Check for a "304 Not Modified" status and response headers availability.
-  if (status != 304 || !responseHeaders) {
-    return false;
-  }
-
-  let list = responseHeaders.headers;
-  let cacheControl = list.filter(e => e.name.toLowerCase() == "cache-control")[0];
-  let expires = list.filter(e => e.name.toLowerCase() == "expires")[0];
-
-  // Check the "Cache-Control" header for a maximum age value.
-  if (cacheControl) {
-    let maxAgeMatch =
-      cacheControl.value.match(/s-maxage\s*=\s*(\d+)/) ||
-      cacheControl.value.match(/max-age\s*=\s*(\d+)/);
-
-    if (maxAgeMatch && maxAgeMatch.pop() > 0) {
-      return true;
-    }
-  }
-
-  // Check the "Expires" header for a valid date.
-  if (expires && Date.parse(expires.value)) {
-    return true;
-  }
-
-  return false;
-}
-
-/**
- * Helper method to get a wrapped function which can be bound to as an event listener directly and is executed only when data-key is present in event.target.
- *
- * @param function callback
- *          Function to execute execute when data-key is present in event.target.
- * @return function
- *          Wrapped function with the target data-key as the first argument.
- */
-function getKeyWithEvent(callback) {
-  return function(event) {
-    var key = event.target.getAttribute("data-key");
-    if (key) {
-      callback.call(null, key);
-    }
-  };
-}
+};
 
 /**
  * Preliminary setup for the NetMonitorView object.
  */
-NetMonitorView.Toolbar = new ToolbarView();
-NetMonitorView.RequestsMenu = new RequestsMenuView();
-NetMonitorView.Sidebar = new SidebarView();
-NetMonitorView.CustomRequest = new CustomRequestView();
-NetMonitorView.NetworkDetails = new NetworkDetailsView();
 NetMonitorView.PerformanceStatistics = new PerformanceStatisticsView();
diff --git a/browser/devtools/netmonitor/netmonitor.xul b/browser/devtools/netmonitor/netmonitor.xul
index b3403a7..0252ff3 100644
--- a/browser/devtools/netmonitor/netmonitor.xul
+++ b/browser/devtools/netmonitor/netmonitor.xul
@@ -17,28 +17,32 @@
 
 <window xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
         xmlns:html="http://www.w3.org/1999/xhtml">
 
   <script type="application/javascript;version=1.8"
           src="chrome://browser/content/devtools/theme-switching.js"/>
   <script type="text/javascript" src="netmonitor-controller.js"/>
   <script type="text/javascript" src="netmonitor-view.js"/>
+  <script type="text/javascript" src="netmonitor/requests-view.js"/>
+  <script type="text/javascript" src="netmonitor/details-view.js"/>
+  <script type="text/javascript" src="netmonitor/sidebar-view.js"/>
+  <script type="text/javascript" src="netmonitor/custom-request-view.js"/>
+  <script type="text/javascript" src="netmonitor/request-context-view.js"/>
 
   <popupset id="networkPopupSet">
     <menupopup id="network-request-popup">
       <menuitem id="request-menu-context-newtab"
                 label="&netmonitorUI.context.newTab;"
                 accesskey="&netmonitorUI.context.newTab.accesskey;"/>
       <menuitem id="request-menu-context-copy-url"
                 label="&netmonitorUI.context.copyUrl;"
                 accesskey="&netmonitorUI.context.copyUrl.accesskey;"/>
       <menuitem id="request-menu-context-copy-as-curl"
-                label="&netmonitorUI.context.copyAsCurl;"
-                oncommand="NetMonitorView.RequestsMenu.copyAsCurl();"/>
+                label="&netmonitorUI.context.copyAsCurl;"/>
       <menuitem id="request-menu-context-copy-image-as-data-uri"
                 label="&netmonitorUI.context.copyImageAsDataUri;"
                 accesskey="&netmonitorUI.context.copyImageAsDataUri.accesskey;"/>
       <menuitem id="request-menu-context-resend"
                 label="&netmonitorUI.summary.editAndResend;"
                 accesskey="&netmonitorUI.summary.editAndResend.accesskey;"/>
       <menuseparator id="request-menu-context-separator"/>
       <menuitem id="request-menu-context-perf"
@@ -343,16 +347,17 @@
                            value="&netmonitorUI.summary.status;"/>
                     <box id="headers-summary-status-circle"
                          class="requests-menu-status"/>
                     <label id="headers-summary-status-value"
                            class="plain tabpanel-summary-value devtools-monospace"
                            crop="end"
                            flex="1"/>
                     <button id="headers-summary-resend"
+                            hidden="true"
                             class="devtools-toolbarbutton"
                             label="&netmonitorUI.summary.editAndResend;"/>
                     <button id="toggle-raw-headers"
                             class="devtools-toolbarbutton"
                             label="&netmonitorUI.summary.rawHeaders;"/>
                   </hbox>
                   <hbox id="headers-summary-version"
                         class="tabpanel-summary-container"
diff --git a/browser/devtools/netmonitor/test/browser_net_accessibility-01.js b/browser/devtools/netmonitor/test/browser_net_accessibility-01.js
index 39a210d..dd29a70 100644
--- a/browser/devtools/netmonitor/test/browser_net_accessibility-01.js
+++ b/browser/devtools/netmonitor/test/browser_net_accessibility-01.js
@@ -8,76 +8,76 @@
 function test() {
   initNetMonitor(CUSTOM_GET_URL).then(([aTab, aDebuggee, aMonitor]) => {
     info("Starting test... ");
 
     // It seems that this test may be slow on Ubuntu builds running on ec2.
     requestLongerTimeout(2);
 
     let { NetMonitorView } = aMonitor.panelWin;
-    let { RequestsMenu } = NetMonitorView;
+    let { Sidebar, RequestsMenu: { tableRenderer: Table }} = NetMonitorView;
 
-    RequestsMenu.lazyUpdate = false;
+    Table.lazyUpdate = false;
 
     waitForNetworkEvents(aMonitor, 2).then(() => {
       check(-1, false);
 
-      RequestsMenu.focusLastVisibleItem();
+      Table.focusLastVisibleItem();
       check(1, true);
-      RequestsMenu.focusFirstVisibleItem();
+      Table.focusFirstVisibleItem();
       check(0, true);
 
-      RequestsMenu.focusNextItem();
+      Table.focusNextItem();
       check(1, true);
-      RequestsMenu.focusPrevItem();
+      Table.focusPrevItem();
       check(0, true);
 
-      RequestsMenu.focusItemAtDelta(+1);
+      Table.focusItemAtDelta(+1);
       check(1, true);
-      RequestsMenu.focusItemAtDelta(-1);
+      Table.focusItemAtDelta(-1);
       check(0, true);
 
-      RequestsMenu.focusItemAtDelta(+10);
+      Table.focusItemAtDelta(+10);
       check(1, true);
-      RequestsMenu.focusItemAtDelta(-10);
+      Table.focusItemAtDelta(-10);
       check(0, true);
 
       aDebuggee.performRequests(18);
       return waitForNetworkEvents(aMonitor, 18);
     })
     .then(() => {
-      RequestsMenu.focusLastVisibleItem();
+      Table.focusLastVisibleItem();
       check(19, true);
-      RequestsMenu.focusFirstVisibleItem();
+      Table.focusFirstVisibleItem();
       check(0, true);
 
-      RequestsMenu.focusNextItem();
+      Table.focusNextItem();
       check(1, true);
-      RequestsMenu.focusPrevItem();
+      Table.focusPrevItem();
       check(0, true);
 
-      RequestsMenu.focusItemAtDelta(+10);
+      Table.focusItemAtDelta(+10);
       check(10, true);
-      RequestsMenu.focusItemAtDelta(-10);
+      Table.focusItemAtDelta(-10);
       check(0, true);
 
-      RequestsMenu.focusItemAtDelta(+100);
+      Table.focusItemAtDelta(+100);
       check(19, true);
-      RequestsMenu.focusItemAtDelta(-100);
+      Table.focusItemAtDelta(-100);
       check(0, true);
 
       teardown(aMonitor).then(finish);
     });
 
     let count = 0;
 
     function check(aSelectedIndex, aPaneVisibility) {
       info("Performing check " + (count++) + ".");
 
-      is(RequestsMenu.selectedIndex, aSelectedIndex,
+      is(Table.selectedIndex, aSelectedIndex,
         "The selected item in the requests menu was incorrect.");
-      is(NetMonitorView.detailsPaneHidden, !aPaneVisibility,
+      is(Sidebar.detailsPaneHidden, !aPaneVisibility,
         "The network requests details pane visibility state was incorrect.");
     }
 
     aDebuggee.performRequests(2);
   });
 }
diff --git a/browser/devtools/netmonitor/test/browser_net_accessibility-02.js b/browser/devtools/netmonitor/test/browser_net_accessibility-02.js
index 0ec5490..cea2492e 100644
--- a/browser/devtools/netmonitor/test/browser_net_accessibility-02.js
+++ b/browser/devtools/netmonitor/test/browser_net_accessibility-02.js
@@ -8,19 +8,19 @@
 function test() {
   initNetMonitor(CUSTOM_GET_URL).then(([aTab, aDebuggee, aMonitor]) => {
     info("Starting test... ");
 
     // It seems that this test may be slow on Ubuntu builds running on ec2.
     requestLongerTimeout(2);
 
     let { window, $, NetMonitorView } = aMonitor.panelWin;
-    let { RequestsMenu } = NetMonitorView;
+    let { Sidebar, RequestsMenu: { tableRenderer: Table }} = NetMonitorView;
 
-    RequestsMenu.lazyUpdate = false;
+    Table.lazyUpdate = false;
 
     waitForNetworkEvents(aMonitor, 2).then(() => {
       check(-1, false);
 
       EventUtils.sendKey("DOWN", window);
       check(0, true);
       EventUtils.sendKey("UP", window);
       check(0, true);
@@ -110,17 +110,17 @@ function test() {
       teardown(aMonitor).then(finish);
     });
 
     let count = 0;
 
     function check(aSelectedIndex, aPaneVisibility) {
       info("Performing check " + (count++) + ".");
 
-      is(RequestsMenu.selectedIndex, aSelectedIndex,
+      is(Table.getSelectedIndex(), aSelectedIndex,
         "The selected item in the requests menu was incorrect.");
-      is(NetMonitorView.detailsPaneHidden, !aPaneVisibility,
+      is(Sidebar.detailsPaneHidden, !aPaneVisibility,
         "The network requests details pane visibility state was incorrect.");
     }
 
     aDebuggee.performRequests(2);
   });
 }
diff --git a/browser/devtools/netmonitor/test/browser_net_clear.js b/browser/devtools/netmonitor/test/browser_net_clear.js
index a78492c..387e1ee 100644
--- a/browser/devtools/netmonitor/test/browser_net_clear.js
+++ b/browser/devtools/netmonitor/test/browser_net_clear.js
@@ -4,73 +4,73 @@
 /**
  * Tests if the clear button empties the request menu.
  */
 
 function test() {
   initNetMonitor(SIMPLE_URL).then(([aTab, aDebuggee, aMonitor]) => {
     info("Starting test... ");
 
-    let { document, $, NetMonitorView } = aMonitor.panelWin;
-    let { RequestsMenu } = NetMonitorView;
+    let { document, $, NetMonitorView, RequestCollection } = aMonitor.panelWin;
+    let { RequestsMenu, Sidebar } = NetMonitorView;
     let detailsPane = $("#details-pane");
     let detailsPaneToggleButton = $('#details-pane-toggle');
     let clearButton = $('#requests-menu-clear-button');
 
     RequestsMenu.lazyUpdate = false;
 
     // Make sure we start in a sane state
-    assertNoRequestState(RequestsMenu, detailsPaneToggleButton);
+    assertNoRequestState(RequestCollection, detailsPaneToggleButton);
 
     // Load one request and assert it shows up in the lis
     aMonitor.panelWin.once(aMonitor.panelWin.EVENTS.NETWORK_EVENT, () => {
-      assertSingleRequestState(RequestsMenu, detailsPaneToggleButton);
+      assertSingleRequestState(RequestCollection, detailsPaneToggleButton);
 
       // Click clear and make sure the requests are gone
       EventUtils.sendMouseEvent({ type: "click" }, clearButton);
-      assertNoRequestState(RequestsMenu, detailsPaneToggleButton);
+      assertNoRequestState(RequestCollection, detailsPaneToggleButton);
 
       // Load a second request and make sure they still show up
       aMonitor.panelWin.once(aMonitor.panelWin.EVENTS.NETWORK_EVENT, () => {
-        assertSingleRequestState(RequestsMenu, detailsPaneToggleButton);
+        assertSingleRequestState(RequestCollection, detailsPaneToggleButton);
 
         // Make sure we can now open the details pane
-        NetMonitorView.toggleDetailsPane({ visible: true, animated: false });
+        Sidebar.toggle(true);
         ok(!detailsPane.hasAttribute("pane-collapsed") &&
           !detailsPaneToggleButton.hasAttribute("pane-collapsed"),
           "The details pane should be visible after clicking the toggle button.");
 
         // Click clear and make sure the details pane closes
         EventUtils.sendMouseEvent({ type: "click" }, clearButton);
-        assertNoRequestState(RequestsMenu, detailsPaneToggleButton);
+        assertNoRequestState(RequestCollection, detailsPaneToggleButton);
         ok(detailsPane.hasAttribute("pane-collapsed") &&
           detailsPaneToggleButton.hasAttribute("pane-collapsed"),
           "The details pane should not be visible clicking 'clear'.");
 
         teardown(aMonitor).then(finish);
       });
 
       aDebuggee.location.reload();
     });
 
     aDebuggee.location.reload();
   });
 
   /**
    * Asserts the state of the network monitor when one request has loaded
    */
-  function assertSingleRequestState(RequestsMenu, detailsPaneToggleButton) {
-    is(RequestsMenu.itemCount, 1,
+  function assertSingleRequestState(RequestCollection, detailsPaneToggleButton) {
+    is(RequestCollection.length, 1,
       "The request menu should have one item at this point.");
     is(detailsPaneToggleButton.hasAttribute("disabled"), false,
       "The pane toggle button should be enabled after a request is made.");
   }
 
   /**
    * Asserts the state of the network monitor when no requests have loaded
    */
-  function assertNoRequestState(RequestsMenu, detailsPaneToggleButton) {
-    is(RequestsMenu.itemCount, 0,
+  function assertNoRequestState(RequestCollection, detailsPaneToggleButton) {
+    is(RequestCollection.length, 0,
       "The request menu should be empty at this point.");
     is(detailsPaneToggleButton.hasAttribute("disabled"), true,
       "The pane toggle button should be disabled when the request menu is cleared.");
   }
 }
diff --git a/browser/devtools/netmonitor/test/browser_net_complex-params.js b/browser/devtools/netmonitor/test/browser_net_complex-params.js
index 7db80ca..a49ab6a 100644
--- a/browser/devtools/netmonitor/test/browser_net_complex-params.js
+++ b/browser/devtools/netmonitor/test/browser_net_complex-params.js
@@ -19,16 +19,17 @@ function test() {
     Task.spawn(function () {
       yield waitForNetworkEvents(aMonitor, 0, 6);
 
       EventUtils.sendMouseEvent({ type: "mousedown" },
         document.getElementById("details-pane-toggle"));
       EventUtils.sendMouseEvent({ type: "mousedown" },
         document.querySelectorAll("#details-pane tab")[2]);
 
+      RequestsMenu.selectedIndex = 0;
       yield waitFor(aMonitor.panelWin, EVENTS.REQUEST_POST_PARAMS_DISPLAYED);
       yield testParamsTab1('a', '""', '{ "foo": "bar" }', '""');
 
       RequestsMenu.selectedIndex = 1;
       yield waitFor(aMonitor.panelWin, EVENTS.REQUEST_POST_PARAMS_DISPLAYED);
       yield testParamsTab1('a', '"b"', '{ "foo": "bar" }', '""');
 
       RequestsMenu.selectedIndex = 2;
diff --git a/browser/devtools/netmonitor/test/browser_net_copy_as_curl.js b/browser/devtools/netmonitor/test/browser_net_copy_as_curl.js
index a5b1adb..2a62842 100644
--- a/browser/devtools/netmonitor/test/browser_net_copy_as_curl.js
+++ b/browser/devtools/netmonitor/test/browser_net_copy_as_curl.js
@@ -39,26 +39,24 @@ function test() {
       '-H "Connection: keep-alive"'
     ].join(" ");
 
     const EXPECTED_RESULT = Services.appinfo.OS == "WINNT"
       ? EXPECTED_WIN_RESULT
       : EXPECTED_POSIX_RESULT;
 
     let { NetMonitorView } = aMonitor.panelWin;
-    let { RequestsMenu } = NetMonitorView;
+    let { RequestsMenu, ContextMenu } = NetMonitorView;
 
     RequestsMenu.lazyUpdate = false;
 
     waitForNetworkEvents(aMonitor, 1).then(() => {
-      let requestItem = RequestsMenu.getItemAtIndex(0);
-      RequestsMenu.selectedItem = requestItem;
-
+      RequestsMenu.selectedIndex = 0;
       waitForClipboard(EXPECTED_RESULT, function setup() {
-        RequestsMenu.copyAsCurl();
+        ContextMenu._onCopyCurl();
       }, function onSuccess() {
         ok(true, "Clipboard contains a cURL command for the currently selected item's url.");
         cleanUp();
       }, function onFailure() {
         ok(false, "Creating a cURL command for the currently selected item was unsuccessful.");
         cleanUp();
       });
 
diff --git a/browser/devtools/netmonitor/test/browser_net_copy_image_as_data_uri.js b/browser/devtools/netmonitor/test/browser_net_copy_image_as_data_uri.js
index f82fa22..3fc44ad 100644
--- a/browser/devtools/netmonitor/test/browser_net_copy_image_as_data_uri.js
+++ b/browser/devtools/netmonitor/test/browser_net_copy_image_as_data_uri.js
@@ -5,26 +5,25 @@
  * Tests if copying an image as data uri works.
  */
 
 function test() {
   initNetMonitor(CONTENT_TYPE_WITHOUT_CACHE_URL).then(([aTab, aDebuggee, aMonitor]) => {
     info("Starting test... ");
 
     let { NetMonitorView } = aMonitor.panelWin;
-    let { RequestsMenu } = NetMonitorView;
+    let { ContextMenu, RequestsMenu } = NetMonitorView;
 
     RequestsMenu.lazyUpdate = false;
 
     waitForNetworkEvents(aMonitor, 6).then(() => {
-      let requestItem = RequestsMenu.getItemAtIndex(5);
-      RequestsMenu.selectedItem = requestItem;
+      RequestsMenu.selectedIndex = 5;
 
       waitForClipboard(TEST_IMAGE_DATA_URI, function setup() {
-        RequestsMenu.copyImageAsDataUri();
+        ContextMenu._onCopyImage();
       }, function onSuccess() {
         ok(true, "Clipboard contains the currently selected image as data uri.");
         cleanUp();
       }, function onFailure() {
         ok(false, "Copying the currently selected image as data uri was unsuccessful.");
         cleanUp();
       });
     });
diff --git a/browser/devtools/netmonitor/test/browser_net_copy_url.js b/browser/devtools/netmonitor/test/browser_net_copy_url.js
index d2e54f1..0d24685 100644
--- a/browser/devtools/netmonitor/test/browser_net_copy_url.js
+++ b/browser/devtools/netmonitor/test/browser_net_copy_url.js
@@ -5,24 +5,23 @@
  * Tests if copying a request's url works.
  */
 
 function test() {
   initNetMonitor(CUSTOM_GET_URL).then(([aTab, aDebuggee, aMonitor]) => {
     info("Starting test... ");
 
     let { NetMonitorView } = aMonitor.panelWin;
-    let { RequestsMenu } = NetMonitorView;
+    let { RequestsMenu, ContextMenu } = NetMonitorView;
 
     waitForNetworkEvents(aMonitor, 1).then(() => {
-      let requestItem = RequestsMenu.getItemAtIndex(0);
-      RequestsMenu.selectedItem = requestItem;
-
-      waitForClipboard(requestItem.attachment.url, function setup() {
-        RequestsMenu.copyUrl();
+      RequestsMenu.selectRequestByIndex(0);
+      let model = RequestsMenu.getSelected(); 
+      waitForClipboard(model.url, function setup() {
+        ContextMenu._onCopyURL();
       }, function onSuccess() {
         ok(true, "Clipboard contains the currently selected item's url.");
         cleanUp();
       }, function onFailure() {
         ok(false, "Copying the currently selected item's url was unsuccessful.");
         cleanUp();
       });
     });
diff --git a/browser/devtools/netmonitor/test/browser_net_details-no-duplicated-content.js b/browser/devtools/netmonitor/test/browser_net_details-no-duplicated-content.js
index 343f806..c7414ac 100644
--- a/browser/devtools/netmonitor/test/browser_net_details-no-duplicated-content.js
+++ b/browser/devtools/netmonitor/test/browser_net_details-no-duplicated-content.js
@@ -4,17 +4,17 @@
 "use strict";
 
 // A test to ensure that the content in details pane is not duplicated.
 
 let test = Task.async(function* () {
   info("Initializing test");
   let [tab, debuggee, monitor] = yield initNetMonitor(CUSTOM_GET_URL);
   let panel = monitor.panelWin;
-  let { NetMonitorView, EVENTS } = panel;
+  let { RequestCollection, NetMonitorView, EVENTS } = panel;
   let { RequestsMenu, NetworkDetails } = NetMonitorView;
 
   const COOKIE_UNIQUE_PATH = "/do-not-use-in-other-tests-using-cookies";
 
   let TEST_CASES = [
     {
       desc: "Test headers tab",
       pageURI: CUSTOM_GET_URL,
@@ -64,17 +64,17 @@ let test = Task.async(function* () {
   /**
    * A helper that handles the execution of each case.
    */
   function* runTestCase(spec) {
     info("Running case: " + spec.desc);
     debuggee.content.location = spec.pageURI;
 
     yield waitForNetworkEvents(monitor, 1);
-    RequestsMenu.clear();
+    RequestCollection.reset();
     yield waitForFinalDetailTabUpdate(spec.tabIndex, spec.isPost, spec.requestURI);
 
     is(spec.variablesView._store.length, spec.expectedScopeLength,
        "View contains " + spec.expectedScopeLength + " scope headers");
   }
 
   /**
    * A helper that prepares the variables view for the actual testing. It
@@ -91,18 +91,18 @@ let test = Task.async(function* () {
 
     info("Performing a request");
     debuggee.performRequests(1, uri);
 
     info("Waiting for NETWORK_EVENT");
     yield onNetworkEvent;
 
     ok(true, "Received NETWORK_EVENT. Selecting the item.");
-    let item = RequestsMenu.getItemAtIndex(0);
-    RequestsMenu.selectedItem = item;
+    let model = RequestCollection.at(0);
+    RequestsMenu.selectRequest(model);
 
     info("Item selected. Waiting for NETWORKDETAILSVIEW_POPULATED");
     yield onDetailsPopulated;
 
     info("Received populated event. Selecting tab at index " + tabIndex);
     NetworkDetails.widget.selectedIndex = tabIndex;
 
     info("Waiting for request to finish.");
@@ -125,17 +125,17 @@ let test = Task.async(function* () {
      *   TAB_UPDATED event is emitted.
      * - case #3 the running update is the final update that'll emit one
      *   TAB_UPDATED event.
      *
      * For case #4 we must wait for the updates to be flushed before we can
      * start waiting for TAB_UPDATED event or we'll continue the test right
      * after the pending update finishes.
      */
-    let hasQueuedUpdates = RequestsMenu._updateQueue.length !== 0;
+    let hasQueuedUpdates = RequestsMenu.tableRenderer._updateQueue.length !== 0;
     let hasRunningTabUpdate = NetworkDetails._viewState.updating[tabIndex];
 
     if (hasQueuedUpdates || hasRunningTabUpdate) {
       info("There's pending updates - waiting for them to finish.");
       info("  hasQueuedUpdates: " + hasQueuedUpdates);
       info("  hasRunningTabUpdate: " + hasRunningTabUpdate);
 
       if (hasQueuedUpdates && hasRunningTabUpdate) {
diff --git a/browser/devtools/netmonitor/test/browser_net_footer-summary.js b/browser/devtools/netmonitor/test/browser_net_footer-summary.js
index 9677afa..1d5e246 100644
--- a/browser/devtools/netmonitor/test/browser_net_footer-summary.js
+++ b/browser/devtools/netmonitor/test/browser_net_footer-summary.js
@@ -8,17 +8,17 @@
 
 function test() {
   requestLongerTimeout(2);
   let { PluralForm } = Cu.import("resource://gre/modules/PluralForm.jsm", {});
 
   initNetMonitor(FILTERING_URL).then(([aTab, aDebuggee, aMonitor]) => {
     info("Starting test... ");
 
-    let { $, L10N, NetMonitorView } = aMonitor.panelWin;
+    let { $, L10N, NetMonitorView, utils } = aMonitor.panelWin;
     let { RequestsMenu } = NetMonitorView;
 
     RequestsMenu.lazyUpdate = false;
     testStatus();
 
     waitForNetworkEvents(aMonitor, 8).then(() => {
       testStatus();
 
@@ -91,20 +91,20 @@ function test() {
       info("Current requests: " + visibleRequestsCount + " of " + totalRequestsCount + ".");
 
       if (!totalRequestsCount || !visibleRequestsCount) {
         is(value, L10N.getStr("networkMenu.empty"),
           "The current summary text is incorrect, expected an 'empty' label.");
         return;
       }
 
-      let totalBytes = RequestsMenu._getTotalBytesOfRequests(visibleItems);
+      let totalBytes = utils.getTotalBytesOfRequests(visibleItems);
       let totalMillis =
-        RequestsMenu._getNewestRequest(visibleItems).attachment.endedMillis -
-        RequestsMenu._getOldestRequest(visibleItems).attachment.startedMillis;
+        utils.getNewestRequest(visibleItems).attachment.endedMillis -
+        utils.getOldestRequest(visibleItems).attachment.startedMillis;
 
       info("Computed total bytes: " + totalBytes);
       info("Computed total millis: " + totalMillis);
 
       is(value, PluralForm.get(visibleRequestsCount, L10N.getStr("networkMenu.summary"))
         .replace("#1", visibleRequestsCount)
         .replace("#2", L10N.numberWithDecimals((totalBytes || 0) / 1024, 2))
         .replace("#3", L10N.numberWithDecimals((totalMillis || 0) / 1000, 2))
diff --git a/browser/devtools/netmonitor/test/browser_net_html-preview.js b/browser/devtools/netmonitor/test/browser_net_html-preview.js
index b9d6146..2938505 100644
--- a/browser/devtools/netmonitor/test/browser_net_html-preview.js
+++ b/browser/devtools/netmonitor/test/browser_net_html-preview.js
@@ -5,33 +5,33 @@
  * Tests if html responses show and properly populate a "Preview" tab.
  */
 
 function test() {
   initNetMonitor(CONTENT_TYPE_URL).then(([aTab, aDebuggee, aMonitor]) => {
     info("Starting test... ");
 
     let { $, document, EVENTS, NetMonitorView } = aMonitor.panelWin;
-    let { RequestsMenu } = NetMonitorView;
+    let { Sidebar, RequestsMenu } = NetMonitorView;
 
     RequestsMenu.lazyUpdate = false;
 
     waitForNetworkEvents(aMonitor, 6).then(() => {
       EventUtils.sendMouseEvent({ type: "mousedown" },
         document.getElementById("details-pane-toggle"));
 
       is($("#event-details-pane").selectedIndex, 0,
         "The first tab in the details pane should be selected.");
       is($("#preview-tab").hidden, true,
         "The preview tab should be hidden for non html responses.");
       is($("#preview-tabpanel").hidden, true,
         "The preview tabpanel should be hidden for non html responses.");
 
       RequestsMenu.selectedIndex = 4;
-      NetMonitorView.toggleDetailsPane({ visible: true, animated: false }, 6);
+      Sidebar.toggle(true, 6);
 
       is($("#event-details-pane").selectedIndex, 6,
         "The sixth tab in the details pane should be selected.");
       is($("#preview-tab").hidden, false,
         "The preview tab should be visible now.");
       is($("#preview-tabpanel").hidden, false,
         "The preview tabpanel should be visible now.");
 
diff --git a/browser/devtools/netmonitor/test/browser_net_icon-preview.js b/browser/devtools/netmonitor/test/browser_net_icon-preview.js
index 19b4c4c..d3d8f35 100644
--- a/browser/devtools/netmonitor/test/browser_net_icon-preview.js
+++ b/browser/devtools/netmonitor/test/browser_net_icon-preview.js
@@ -4,17 +4,17 @@
 /**
  * Tests if image responses show a thumbnail in the requests menu.
  */
 
 function test() {
   initNetMonitor(CONTENT_TYPE_WITHOUT_CACHE_URL).then(([aTab, aDebuggee, aMonitor]) => {
     info("Starting test... ");
 
-    let { $, $all, EVENTS, ACTIVITY_TYPE, NetMonitorView, NetMonitorController } = aMonitor.panelWin;
+    let { $, $$, EVENTS, ACTIVITY_TYPE, NetMonitorView, NetMonitorController } = aMonitor.panelWin;
     let { RequestsMenu } = NetMonitorView;
 
     promise.all([
       waitForNetworkEvents(aMonitor, 6),
       waitFor(aMonitor.panelWin, EVENTS.RESPONSE_IMAGE_THUMBNAIL_DISPLAYED)
     ]).then(() => {
       info("Checking the image thumbnail when all items are shown.");
       checkImageThumbnail();
@@ -43,17 +43,17 @@ function test() {
 
     function reloadAndPerformRequests() {
       NetMonitorController.triggerActivity(ACTIVITY_TYPE.RELOAD.WITH_CACHE_ENABLED).then(() => {
         aDebuggee.performRequests();
       });
     }
 
     function checkImageThumbnail() {
-      is($all(".requests-menu-icon[type=thumbnail]").length, 1,
+      is($$(".requests-menu-icon[type=thumbnail]").length, 1,
         "There should be only one image request with a thumbnail displayed.");
       is($(".requests-menu-icon[type=thumbnail]").src, TEST_IMAGE_DATA_URI,
         "The image requests-menu-icon thumbnail is displayed correctly.");
       is($(".requests-menu-icon[type=thumbnail]").hidden, false,
         "The image requests-menu-icon thumbnail should not be hidden.");
     }
 
     aDebuggee.performRequests();
diff --git a/browser/devtools/netmonitor/test/browser_net_pane-collapse.js b/browser/devtools/netmonitor/test/browser_net_pane-collapse.js
index 6434aa2..d465058 100644
--- a/browser/devtools/netmonitor/test/browser_net_pane-collapse.js
+++ b/browser/devtools/netmonitor/test/browser_net_pane-collapse.js
@@ -5,54 +5,55 @@
  * Tests if the network monitor panes collapse properly.
  */
 
 function test() {
   initNetMonitor(SIMPLE_URL).then(([aTab, aDebuggee, aMonitor]) => {
     info("Starting test... ");
 
     let { document, Prefs, NetMonitorView } = aMonitor.panelWin;
+    let { Sidebar } = NetMonitorView;
     let detailsPane = document.getElementById("details-pane");
     let detailsPaneToggleButton = document.getElementById("details-pane-toggle");
 
     ok(detailsPane.hasAttribute("pane-collapsed") &&
        detailsPaneToggleButton.hasAttribute("pane-collapsed"),
       "The details pane should initially be hidden.");
 
-    NetMonitorView.toggleDetailsPane({ visible: true, animated: false });
+    Sidebar.toggle(true);
 
     let width = ~~(detailsPane.getAttribute("width"));
     is(width, Prefs.networkDetailsWidth,
       "The details pane has an incorrect width.");
     is(detailsPane.style.marginLeft, "0px",
       "The details pane has an incorrect left margin.");
     is(detailsPane.style.marginRight, "0px",
       "The details pane has an incorrect right margin.");
     ok(!detailsPane.hasAttribute("animated"),
       "The details pane has an incorrect animated attribute.");
     ok(!detailsPane.hasAttribute("pane-collapsed") &&
        !detailsPaneToggleButton.hasAttribute("pane-collapsed"),
       "The details pane should at this point be visible.");
 
-    NetMonitorView.toggleDetailsPane({ visible: false, animated: true });
+    Sidebar.toggle(false);
 
     let margin = -(width + 1) + "px";
     is(width, Prefs.networkDetailsWidth,
       "The details pane has an incorrect width after collapsing.");
     is(detailsPane.style.marginLeft, margin,
       "The details pane has an incorrect left margin after collapsing.");
     is(detailsPane.style.marginRight, margin,
       "The details pane has an incorrect right margin after collapsing.");
     ok(detailsPane.hasAttribute("animated"),
       "The details pane has an incorrect attribute after an animated collapsing.");
     ok(detailsPane.hasAttribute("pane-collapsed") &&
        detailsPaneToggleButton.hasAttribute("pane-collapsed"),
       "The details pane should not be visible after collapsing.");
 
-    NetMonitorView.toggleDetailsPane({ visible: true, animated: false });
+    Sidebar.toggle(true);
 
     is(width, Prefs.networkDetailsWidth,
       "The details pane has an incorrect width after uncollapsing.");
     is(detailsPane.style.marginLeft, "0px",
       "The details pane has an incorrect left margin after uncollapsing.");
     is(detailsPane.style.marginRight, "0px",
       "The details pane has an incorrect right margin after uncollapsing.");
     ok(!detailsPane.hasAttribute("animated"),
diff --git a/browser/devtools/netmonitor/test/browser_net_post-data-02.js b/browser/devtools/netmonitor/test/browser_net_post-data-02.js
index 7799bef..a9c7213 100644
--- a/browser/devtools/netmonitor/test/browser_net_post-data-02.js
+++ b/browser/devtools/netmonitor/test/browser_net_post-data-02.js
@@ -6,23 +6,23 @@
  * for raw payloads with attached content-type headers.
  */
 
 function test() {
   initNetMonitor(POST_RAW_URL).then(([aTab, aDebuggee, aMonitor]) => {
     info("Starting test... ");
 
     let { document, L10N, NetMonitorView } = aMonitor.panelWin;
-    let { RequestsMenu, NetworkDetails } = NetMonitorView;
+    let { RequestsMenu, NetworkDetails, Sidebar } = NetMonitorView;
 
     RequestsMenu.lazyUpdate = false;
     NetworkDetails._params.lazyEmpty = false;
 
     waitForNetworkEvents(aMonitor, 0, 1).then(() => {
-      NetMonitorView.toggleDetailsPane({ visible: true }, 2)
+      Sidebar.toggle(true, 2);
       RequestsMenu.selectedIndex = 0;
 
       let TAB_UPDATED = aMonitor.panelWin.EVENTS.TAB_UPDATED;
       waitFor(aMonitor.panelWin, TAB_UPDATED).then(() => {
         let tab = document.querySelectorAll("#event-details-pane tab")[2];
         let tabpanel = document.querySelectorAll("#event-details-pane tabpanel")[2];
 
         is(tab.getAttribute("selected"), "true",
diff --git a/browser/devtools/netmonitor/test/browser_net_post-data-03.js b/browser/devtools/netmonitor/test/browser_net_post-data-03.js
index 620111a..b0ca0f6 100644
--- a/browser/devtools/netmonitor/test/browser_net_post-data-03.js
+++ b/browser/devtools/netmonitor/test/browser_net_post-data-03.js
@@ -6,24 +6,24 @@
  * for raw payloads with content-type headers attached to the upload stream.
  */
 
 function test() {
   initNetMonitor(POST_RAW_WITH_HEADERS_URL).then(([aTab, aDebuggee, aMonitor]) => {
     info("Starting test... ");
 
     let { document, L10N, NetMonitorView } = aMonitor.panelWin;
-    let { RequestsMenu, NetworkDetails } = NetMonitorView;
+    let { Sidebar, RequestsMenu, NetworkDetails } = NetMonitorView;
     let TAB_UPDATED = aMonitor.panelWin.EVENTS.TAB_UPDATED;
     RequestsMenu.lazyUpdate = false;
 
     Task.spawn(function*() {
       yield waitForNetworkEvents(aMonitor, 0, 1);
 
-      NetMonitorView.toggleDetailsPane({ visible: true });
+      Sidebar.toggle(true);
       RequestsMenu.selectedIndex = 0;
 
       yield waitFor(aMonitor.panelWin, TAB_UPDATED);
 
       let tab = document.querySelectorAll("#details-pane tab")[0];
       let tabpanel = document.querySelectorAll("#details-pane tabpanel")[0];
       let requestFromUploadScope = tabpanel.querySelectorAll(".variables-view-scope")[2];
 
diff --git a/browser/devtools/netmonitor/test/browser_net_resend.js b/browser/devtools/netmonitor/test/browser_net_resend.js
index cb3f196..b457a90 100644
--- a/browser/devtools/netmonitor/test/browser_net_resend.js
+++ b/browser/devtools/netmonitor/test/browser_net_resend.js
@@ -22,66 +22,69 @@ function test() {
     let { NetMonitorView } = gPanelWin;
     let { RequestsMenu } = NetMonitorView;
     let TAB_UPDATED = aMonitor.panelWin.EVENTS.TAB_UPDATED;
     let CUSTOMREQUESTVIEW_POPULATED = aMonitor.panelWin.EVENTS.CUSTOMREQUESTVIEW_POPULATED;
 
     RequestsMenu.lazyUpdate = false;
 
     waitForNetworkEvents(aMonitor, 0, 2).then(() => {
-      let origItem = RequestsMenu.getItemAtIndex(0);
-      RequestsMenu.selectedItem = origItem;
+      RequestsMenu.selectedIndex = 0;
+      let origReq = RequestsMenu.getSelected();
 
       waitFor(aMonitor.panelWin, TAB_UPDATED).then(() => {
         // add a new custom request cloned from selected request
-        RequestsMenu.cloneSelectedRequest();
+        NetMonitorView.CustomRequest.populate(origReq);
         return waitFor(aMonitor.panelWin, CUSTOMREQUESTVIEW_POPULATED);
       }).then(() => {
-        testCustomForm(origItem.attachment);
+        testCustomForm(origReq);
 
-        let customItem = RequestsMenu.selectedItem;
-        testCustomItem(customItem, origItem);
+        testCustomItem(2, 0);
 
         // edit the custom request
         editCustomForm(() => {
-          testCustomItemChanged(customItem, origItem);
+          testCustomItemChanged(2, 0);
 
           waitForNetworkEvents(aMonitor, 0, 1).then(() => {
-            let sentItem = RequestsMenu.selectedItem;
-            testSentRequest(sentItem.attachment, origItem.attachment);
+            let sentItem = RequestsMenu.getSelected();
+            testSentRequest(sentItem, origReq);
             finishUp(aMonitor);
           });
           // send the new request
-          RequestsMenu.sendCustomRequest();
+          NetMonitorView.CustomRequest.populate(origReq);
         });
       });
     });
 
     aDebuggee.performRequests();
   });
 }
 
-function testCustomItem(aItem, aOrigItem) {
-  let method = aItem.target.querySelector(".requests-menu-method").value;
-  let origMethod = aOrigItem.target.querySelector(".requests-menu-method").value;
+function testCustomItem(aItemIndex, aOrigItemIndex) {
+  let menu = gPanelDoc.getElementById("requests-menu-contents");
+  let method = menu.querySelectorAll(".requests-menu-method")[aItemIndex].value;
+  let origMethod = menu.querySelectorAll(".requests-menu-method")[aOrigItemIndex].value;
+  ok(method && origMethod, "Found a method for both items");
   is(method, origMethod, "menu item is showing the same method as original request");
 
-  let file = aItem.target.querySelector(".requests-menu-file").value;
-  let origFile = aOrigItem.target.querySelector(".requests-menu-file").value;
+  let file = menu.querySelectorAll(".requests-menu-file")[aItemIndex].value;
+  let origFile = menu.querySelectorAll(".requests-menu-file")[aOrigItemIndex].value;
+  ok(file && origFile, "Found a file for both items");
   is(file, origFile, "menu item is showing the same file name as original request");
 
-  let domain = aItem.target.querySelector(".requests-menu-domain").value;
-  let origDomain = aOrigItem.target.querySelector(".requests-menu-domain").value;
+  let domain = menu.querySelectorAll(".requests-menu-domain")[aItemIndex].value;
+  let origDomain = menu.querySelectorAll(".requests-menu-domain")[aOrigItemIndex].value;
+  ok(domain && origDomain, "Found a domain for both items");
   is(domain, origDomain, "menu item is showing the same domain as original request");
 }
 
-function testCustomItemChanged(aItem, aOrigItem) {
-  let file = aItem.target.querySelector(".requests-menu-file").value;
-  let expectedFile = aOrigItem.target.querySelector(".requests-menu-file").value + "&" + ADD_QUERY;
-
+function testCustomItemChanged(aItemIndex, aOrigItemIndex) {
+  let menu = gPanelDoc.getElementById("requests-menu-contents");
+  let file = menu.querySelectorAll(".requests-menu-file")[aItemIndex].value;
+  let expectedFile = menu.querySelectorAll(".requests-menu-file")[aOrigItemIndex].value + "&" + ADD_QUERY;
   is(file, expectedFile, "menu item is updated to reflect url entered in form");
 }
 
 /*
  * Test that the New Request form was populated correctly
  */
 function testCustomForm(aData) {
   is(gPanelDoc.getElementById("custom-method-value").value, aData.method,
diff --git a/browser/devtools/netmonitor/test/browser_net_simple-request-data.js b/browser/devtools/netmonitor/test/browser_net_simple-request-data.js
index 11da60e..04eb019 100644
--- a/browser/devtools/netmonitor/test/browser_net_simple-request-data.js
+++ b/browser/devtools/netmonitor/test/browser_net_simple-request-data.js
@@ -1,241 +1,242 @@
 /* Any copyright is dedicated to the Public Domain.
    http://creativecommons.org/publicdomain/zero/1.0/ */
 
 /**
  * Tests if requests render correct information in the menu UI.
  */
 
-function test() {
-  initNetMonitor(SIMPLE_SJS).then(([aTab, aDebuggee, aMonitor]) => {
-    info("Starting test... ");
-
-    let { L10N, NetMonitorView } = aMonitor.panelWin;
-    let { RequestsMenu } = NetMonitorView;
-
-    RequestsMenu.lazyUpdate = false;
-
-    waitForNetworkEvents(aMonitor, 1)
-      .then(() => teardown(aMonitor))
-      .then(finish);
-
-    aMonitor.panelWin.once(aMonitor.panelWin.EVENTS.NETWORK_EVENT, () => {
-      is(RequestsMenu.selectedItem, null,
-        "There shouldn't be any selected item in the requests menu.");
-      is(RequestsMenu.itemCount, 1,
-        "The requests menu should not be empty after the first request.");
-      is(NetMonitorView.detailsPaneHidden, true,
-        "The details pane should still be hidden after the first request.");
-
-      let requestItem = RequestsMenu.getItemAtIndex(0);
-      let target = requestItem.target;
-
-      is(typeof requestItem.value, "string",
-        "The attached request id is incorrect.");
-      isnot(requestItem.value, "",
-        "The attached request id should not be empty.");
-
-      is(typeof requestItem.attachment.startedDeltaMillis, "number",
-        "The attached startedDeltaMillis is incorrect.");
-      is(requestItem.attachment.startedDeltaMillis, 0,
-        "The attached startedDeltaMillis should be zero.");
-
-      is(typeof requestItem.attachment.startedMillis, "number",
-        "The attached startedMillis is incorrect.");
-      isnot(requestItem.attachment.startedMillis, 0,
-        "The attached startedMillis should not be zero.");
-
-      is(requestItem.attachment.requestHeaders, undefined,
-        "The requestHeaders should not yet be set.");
-      is(requestItem.attachment.requestCookies, undefined,
-        "The requestCookies should not yet be set.");
-      is(requestItem.attachment.requestPostData, undefined,
-        "The requestPostData should not yet be set.");
-
-      is(requestItem.attachment.responseHeaders, undefined,
-        "The responseHeaders should not yet be set.");
-      is(requestItem.attachment.responseCookies, undefined,
-        "The responseCookies should not yet be set.");
-
-      is(requestItem.attachment.httpVersion, undefined,
-        "The httpVersion should not yet be set.");
-      is(requestItem.attachment.status, undefined,
-        "The status should not yet be set.");
-      is(requestItem.attachment.statusText, undefined,
-        "The statusText should not yet be set.");
-
-      is(requestItem.attachment.headersSize, undefined,
-        "The headersSize should not yet be set.");
-      is(requestItem.attachment.transferredSize, undefined,
-        "The transferredSize should not yet be set.");
-      is(requestItem.attachment.contentSize, undefined,
-        "The contentSize should not yet be set.");
-
-      is(requestItem.attachment.mimeType, undefined,
-        "The mimeType should not yet be set.");
-      is(requestItem.attachment.responseContent, undefined,
-        "The responseContent should not yet be set.");
-
-      is(requestItem.attachment.totalTime, undefined,
-        "The totalTime should not yet be set.");
-      is(requestItem.attachment.eventTimings, undefined,
-        "The eventTimings should not yet be set.");
-
-      verifyRequestItemTarget(requestItem, "GET", SIMPLE_SJS);
-    });
-
-    aMonitor.panelWin.once(aMonitor.panelWin.EVENTS.RECEIVED_REQUEST_HEADERS, () => {
-      let requestItem = RequestsMenu.getItemAtIndex(0);
-
-      ok(requestItem.attachment.requestHeaders,
-        "There should be a requestHeaders attachment available.");
-      is(requestItem.attachment.requestHeaders.headers.length, 9,
-        "The requestHeaders attachment has an incorrect |headers| property.");
-      isnot(requestItem.attachment.requestHeaders.headersSize, 0,
-        "The requestHeaders attachment has an incorrect |headersSize| property.");
-      // Can't test for the exact request headers size because the value may
-      // vary across platforms ("User-Agent" header differs).
-
-      verifyRequestItemTarget(requestItem, "GET", SIMPLE_SJS);
-    });
-
-    aMonitor.panelWin.once(aMonitor.panelWin.EVENTS.RECEIVED_REQUEST_COOKIES, () => {
-      let requestItem = RequestsMenu.getItemAtIndex(0);
-
-      ok(requestItem.attachment.requestCookies,
-        "There should be a requestCookies attachment available.");
-      is(requestItem.attachment.requestCookies.cookies.length, 2,
-        "The requestCookies attachment has an incorrect |cookies| property.");
-
-      verifyRequestItemTarget(requestItem, "GET", SIMPLE_SJS);
-    });
-
-    aMonitor.panelWin.once(aMonitor.panelWin.EVENTS.RECEIVED_REQUEST_POST_DATA, () => {
-      ok(false, "Trap listener: this request doesn't have any post data.")
-    });
-
-    aMonitor.panelWin.once(aMonitor.panelWin.EVENTS.RECEIVED_RESPONSE_HEADERS, () => {
-      let requestItem = RequestsMenu.getItemAtIndex(0);
-
-      ok(requestItem.attachment.responseHeaders,
-        "There should be a responseHeaders attachment available.");
-      is(requestItem.attachment.responseHeaders.headers.length, 10,
-        "The responseHeaders attachment has an incorrect |headers| property.");
-      is(requestItem.attachment.responseHeaders.headersSize, 330,
-        "The responseHeaders attachment has an incorrect |headersSize| property.");
-
-      verifyRequestItemTarget(requestItem, "GET", SIMPLE_SJS);
-    });
-
-    aMonitor.panelWin.once(aMonitor.panelWin.EVENTS.RECEIVED_RESPONSE_COOKIES, () => {
-      let requestItem = RequestsMenu.getItemAtIndex(0);
-
-      ok(requestItem.attachment.responseCookies,
-        "There should be a responseCookies attachment available.");
-      is(requestItem.attachment.responseCookies.cookies.length, 2,
-        "The responseCookies attachment has an incorrect |cookies| property.");
-
-      verifyRequestItemTarget(requestItem, "GET", SIMPLE_SJS);
-    });
-
-    aMonitor.panelWin.once(aMonitor.panelWin.EVENTS.STARTED_RECEIVING_RESPONSE, () => {
-      let requestItem = RequestsMenu.getItemAtIndex(0);
-
-      is(requestItem.attachment.httpVersion, "HTTP/1.1",
-        "The httpVersion attachment has an incorrect value.");
-      is(requestItem.attachment.status, "200",
-        "The status attachment has an incorrect value.");
-      is(requestItem.attachment.statusText, "Och Aye",
-        "The statusText attachment has an incorrect value.");
-      is(requestItem.attachment.headersSize, 330,
-        "The headersSize attachment has an incorrect value.");
-
-      verifyRequestItemTarget(requestItem, "GET", SIMPLE_SJS, {
-        status: "200",
-        statusText: "Och Aye"
-      });
-    });
-
-    aMonitor.panelWin.once(aMonitor.panelWin.EVENTS.UPDATING_RESPONSE_CONTENT, () => {
-      let requestItem = RequestsMenu.getItemAtIndex(0);
-
-      is(requestItem.attachment.transferredSize, "12",
-        "The transferredSize attachment has an incorrect value.");
-      is(requestItem.attachment.contentSize, "12",
-        "The contentSize attachment has an incorrect value.");
-      is(requestItem.attachment.mimeType, "text/plain; charset=utf-8",
-        "The mimeType attachment has an incorrect value.");
-
-      verifyRequestItemTarget(requestItem, "GET", SIMPLE_SJS, {
-        type: "plain",
-        fullMimeType: "text/plain; charset=utf-8",
-        transferred: L10N.getFormatStrWithNumbers("networkMenu.sizeKB", 0.01),
-        size: L10N.getFormatStrWithNumbers("networkMenu.sizeKB", 0.01),
-      });
-    });
-
-    aMonitor.panelWin.once(aMonitor.panelWin.EVENTS.RECEIVED_RESPONSE_CONTENT, () => {
-      let requestItem = RequestsMenu.getItemAtIndex(0);
-
-      ok(requestItem.attachment.responseContent,
-        "There should be a responseContent attachment available.");
-      is(requestItem.attachment.responseContent.content.mimeType, "text/plain; charset=utf-8",
-        "The responseContent attachment has an incorrect |content.mimeType| property.");
-      is(requestItem.attachment.responseContent.content.text, "Hello world!",
-        "The responseContent attachment has an incorrect |content.text| property.");
-      is(requestItem.attachment.responseContent.content.size, 12,
-        "The responseContent attachment has an incorrect |content.size| property.");
-
-      verifyRequestItemTarget(requestItem, "GET", SIMPLE_SJS, {
-        type: "plain",
-        fullMimeType: "text/plain; charset=utf-8",
-        transferred: L10N.getFormatStrWithNumbers("networkMenu.sizeKB", 0.01),
-        size: L10N.getFormatStrWithNumbers("networkMenu.sizeKB", 0.01),
-      });
-    });
-
-    aMonitor.panelWin.once(aMonitor.panelWin.EVENTS.UPDATING_EVENT_TIMINGS, () => {
-      let requestItem = RequestsMenu.getItemAtIndex(0);
-
-      is(typeof requestItem.attachment.totalTime, "number",
-        "The attached totalTime is incorrect.");
-      ok(requestItem.attachment.totalTime >= 0,
-        "The attached totalTime should be positive.");
-
-      is(typeof requestItem.attachment.endedMillis, "number",
-        "The attached endedMillis is incorrect.");
-      ok(requestItem.attachment.endedMillis >= 0,
-        "The attached endedMillis should be positive.");
-
-      verifyRequestItemTarget(requestItem, "GET", SIMPLE_SJS, {
-        time: true
-      });
-    });
-
-    aMonitor.panelWin.once(aMonitor.panelWin.EVENTS.RECEIVED_EVENT_TIMINGS, () => {
-      let requestItem = RequestsMenu.getItemAtIndex(0);
-
-      ok(requestItem.attachment.eventTimings,
-        "There should be a eventTimings attachment available.");
-      is(typeof requestItem.attachment.eventTimings.timings.blocked, "number",
-        "The eventTimings attachment has an incorrect |timings.blocked| property.");
-      is(typeof requestItem.attachment.eventTimings.timings.dns, "number",
-        "The eventTimings attachment has an incorrect |timings.dns| property.");
-      is(typeof requestItem.attachment.eventTimings.timings.connect, "number",
-        "The eventTimings attachment has an incorrect |timings.connect| property.");
-      is(typeof requestItem.attachment.eventTimings.timings.send, "number",
-        "The eventTimings attachment has an incorrect |timings.send| property.");
-      is(typeof requestItem.attachment.eventTimings.timings.wait, "number",
-        "The eventTimings attachment has an incorrect |timings.wait| property.");
-      is(typeof requestItem.attachment.eventTimings.timings.receive, "number",
-        "The eventTimings attachment has an incorrect |timings.receive| property.");
-      is(typeof requestItem.attachment.eventTimings.totalTime, "number",
-        "The eventTimings attachment has an incorrect |totalTime| property.");
-
-      verifyRequestItemTarget(requestItem, "GET", SIMPLE_SJS, {
-        time: true
-      });
-    });
-
-    aDebuggee.location.reload();
+function spawnTest () {
+  let [aTab, aDebuggee, aMonitor] = yield initNetMonitor(SIMPLE_SJS);
+  info("Starting test... ");
+
+  let { L10N, NetMonitorView, EVENTS, window } = aMonitor.panelWin;
+  let { RequestsMenu, RequestCollection } = NetMonitorView;
+
+  RequestsMenu.lazyUpdate = false;
+
+  waitForNetworkEvents(aMonitor, 1)
+    .then(() => teardown(aMonitor))
+    .then(finish);
+
+  let networkEvent = waitFor(window, EVENTS.NETWORK_EVENT);
+  let updatingResponseContent = waitFor(window, EVENTS.UPDATING_RESPONSE_CONTENT);
+  let receivedRequestHeaders = waitFor(window, EVENTS.RECEIVED_REQUEST_HEADERS);
+  let receivedRequestCookies = waitFor(window, EVENTS.RECEIVED_REQUEST_COOKIES);
+  let receivedResponseHeaders = waitFor(window, EVENTS.RECEIVED_RESPONSE_HEADERS);
+  let receivedResponseCookies = waitFor(window, EVENTS.RECEIVED_RESPONSE_COOKIES);
+  let startedReceivingResponse = waitFor(window, EVENTS.STARTED_RECEIVING_RESPONSE);
+  let receivedResponseContent = waitFor(window, EVENTS.RECEIVED_RESPONSE_CONTENT);
+  let updatingEventTimings = waitFor(window, EVENTS.UPDATING_EVENT_TIMINGS);
+  let receivedEventTimings = waitFor(window, EVENTS.RECEIVED_EVENT_TIMINGS);
+
+  info(1)
+  yield networkEvent;
+  info(2)
+  is(RequestsMenu.selectedItem, null,
+    "There shouldn't be any selected item in the requests menu.");
+  is(RequestCollection.length, 1,
+    "The requests menu should not be empty after the first request.");
+  is(NetMonitorView.detailsPaneHidden, true,
+    "The details pane should still be hidden after the first request.");
+
+  let requestItem = RequestCollection.get(0);
+
+  is(typeof requestItem.value, "string",
+    "The attached request id is incorrect.");
+  isnot(requestItem.value, "",
+    "The attached request id should not be empty.");
+
+  is(typeof requestItem.startedDeltaMillis, "number",
+    "The attached startedDeltaMillis is incorrect.");
+  is(requestItem.startedDeltaMillis, 0,
+    "The attached startedDeltaMillis should be zero.");
+
+  is(typeof requestItem.startedMillis, "number",
+    "The attached startedMillis is incorrect.");
+  isnot(requestItem.startedMillis, 0,
+    "The attached startedMillis should not be zero.");
+
+  is(requestItem.requestHeaders, undefined,
+    "The requestHeaders should not yet be set.");
+  is(requestItem.requestCookies, undefined,
+    "The requestCookies should not yet be set.");
+  is(requestItem.requestPostData, undefined,
+    "The requestPostData should not yet be set.");
+
+  is(requestItem.responseHeaders, undefined,
+    "The responseHeaders should not yet be set.");
+  is(requestItem.responseCookies, undefined,
+    "The responseCookies should not yet be set.");
+
+  is(requestItem.httpVersion, undefined,
+    "The httpVersion should not yet be set.");
+  is(requestItem.status, undefined,
+    "The status should not yet be set.");
+  is(requestItem.statusText, undefined,
+    "The statusText should not yet be set.");
+
+  is(requestItem.headersSize, undefined,
+    "The headersSize should not yet be set.");
+  is(requestItem.transferredSize, undefined,
+    "The transferredSize should not yet be set.");
+  is(requestItem.contentSize, undefined,
+    "The contentSize should not yet be set.");
+
+  is(requestItem.mimeType, undefined,
+    "The mimeType should not yet be set.");
+  is(requestItem.responseContent, undefined,
+    "The responseContent should not yet be set.");
+
+  is(requestItem.totalTime, undefined,
+    "The totalTime should not yet be set.");
+  is(requestItem.eventTimings, undefined,
+    "The eventTimings should not yet be set.");
+
+  verifyRequestItemTarget(requestItem, "GET", SIMPLE_SJS);
+
+  yield receivedRequestHeaders;
+  requestItem = RequestCollection.get(0);
+
+  ok(requestItem.requestHeaders,
+    "There should be a requestHeaders attachment available.");
+  is(requestItem.requestHeaders.headers.length, 9,
+    "The requestHeaders attachment has an incorrect |headers| property.");
+  isnot(requestItem.requestHeaders.headersSize, 0,
+    "The requestHeaders attachment has an incorrect |headersSize| property.");
+  // Can't test for the exact request headers size because the value may
+  // vary across platforms ("User-Agent" header differs).
+
+  verifyRequestItemTarget(requestItem, "GET", SIMPLE_SJS);
+
+  yield receivedRequestCookies;
+  requestItem = RequestCollection.get(0);
+
+  ok(requestItem.requestCookies,
+    "There should be a requestCookies attachment available.");
+  is(requestItem.requestCookies.cookies.length, 2,
+    "The requestCookies attachment has an incorrect |cookies| property.");
+
+  verifyRequestItemTarget(requestItem, "GET", SIMPLE_SJS);
+
+  window.once(EVENTS.RECEIVED_REQUEST_POST_DATA, () => {
+    ok(false, "Trap listener: this request doesn't have any post data.")
   });
-}
+
+  yield receivedResponseHeaders;
+  requestItem = RequestCollection.get(0);
+
+  ok(requestItem.responseHeaders,
+    "There should be a responseHeaders attachment available.");
+  is(requestItem.responseHeaders.headers.length, 10,
+    "The responseHeaders attachment has an incorrect |headers| property.");
+  is(requestItem.responseHeaders.headersSize, 330,
+    "The responseHeaders attachment has an incorrect |headersSize| property.");
+
+  verifyRequestItemTarget(requestItem, "GET", SIMPLE_SJS);
+
+  yield receivedResponseCookies;
+  requestItem = RequestCollection.get(0);
+
+  ok(requestItem.responseCookies,
+    "There should be a responseCookies attachment available.");
+  is(requestItem.responseCookies.cookies.length, 2,
+    "The responseCookies attachment has an incorrect |cookies| property.");
+
+  verifyRequestItemTarget(requestItem, "GET", SIMPLE_SJS);
+
+  yield startedReceivingResponse;
+  requestItem = RequestCollection.get(0);
+
+  is(requestItem.httpVersion, "HTTP/1.1",
+    "The httpVersion attachment has an incorrect value.");
+  is(requestItem.status, "200",
+    "The status attachment has an incorrect value.");
+  is(requestItem.statusText, "Och Aye",
+    "The statusText attachment has an incorrect value.");
+  is(requestItem.headersSize, 330,
+    "The headersSize attachment has an incorrect value.");
+
+  verifyRequestItemTarget(requestItem, "GET", SIMPLE_SJS, {
+    status: "200",
+    statusText: "Och Aye"
+  });
+
+  yield updatingResponseContent;
+  requestItem = RequestCollection.get(0);
+
+  is(requestItem.transferredSize, "12",
+    "The transferredSize attachment has an incorrect value.");
+  is(requestItem.contentSize, "12",
+    "The contentSize attachment has an incorrect value.");
+  is(requestItem.mimeType, "text/plain; charset=utf-8",
+    "The mimeType attachment has an incorrect value.");
+
+  verifyRequestItemTarget(requestItem, "GET", SIMPLE_SJS, {
+    type: "plain",
+    fullMimeType: "text/plain; charset=utf-8",
+    transferred: L10N.getFormatStrWithNumbers("networkMenu.sizeKB", 0.01),
+    size: L10N.getFormatStrWithNumbers("networkMenu.sizeKB", 0.01),
+  });
+
+  yield receivedResponseContent;
+  requestItem = RequestCollection.get(0);
+
+  ok(requestItem.responseContent,
+    "There should be a responseContent attachment available.");
+  is(requestItem.responseContent.content.mimeType, "text/plain; charset=utf-8",
+    "The responseContent attachment has an incorrect |content.mimeType| property.");
+  is(requestItem.responseContent.content.text, "Hello world!",
+    "The responseContent attachment has an incorrect |content.text| property.");
+  is(requestItem.responseContent.content.size, 12,
+    "The responseContent attachment has an incorrect |content.size| property.");
+
+  verifyRequestItemTarget(requestItem, "GET", SIMPLE_SJS, {
+    type: "plain",
+    fullMimeType: "text/plain; charset=utf-8",
+    transferred: L10N.getFormatStrWithNumbers("networkMenu.sizeKB", 0.01),
+    size: L10N.getFormatStrWithNumbers("networkMenu.sizeKB", 0.01),
+  });
+
+  yield updatingEventTimings;
+  requestItem = RequestCollection.get(0);
+
+  is(typeof requestItem.totalTime, "number",
+    "The attached totalTime is incorrect.");
+  ok(requestItem.totalTime >= 0,
+    "The attached totalTime should be positive.");
+
+  is(typeof requestItem.endedMillis, "number",
+    "The attached endedMillis is incorrect.");
+  ok(requestItem.endedMillis >= 0,
+    "The attached endedMillis should be positive.");
+
+  verifyRequestItemTarget(requestItem, "GET", SIMPLE_SJS, {
+    time: true
+  });
+
+  yield receivedEventTimings;
+  requestItem = RequestCollection.get(0);
+
+  ok(requestItem.eventTimings,
+    "There should be a eventTimings attachment available.");
+  is(typeof requestItem.eventTimings.timings.blocked, "number",
+    "The eventTimings attachment has an incorrect |timings.blocked| property.");
+  is(typeof requestItem.eventTimings.timings.dns, "number",
+    "The eventTimings attachment has an incorrect |timings.dns| property.");
+  is(typeof requestItem.eventTimings.timings.connect, "number",
+    "The eventTimings attachment has an incorrect |timings.connect| property.");
+  is(typeof requestItem.eventTimings.timings.send, "number",
+    "The eventTimings attachment has an incorrect |timings.send| property.");
+  is(typeof requestItem.eventTimings.timings.wait, "number",
+    "The eventTimings attachment has an incorrect |timings.wait| property.");
+  is(typeof requestItem.eventTimings.timings.receive, "number",
+    "The eventTimings attachment has an incorrect |timings.receive| property.");
+  is(typeof requestItem.eventTimings.totalTime, "number",
+    "The eventTimings attachment has an incorrect |totalTime| property.");
+
+  verifyRequestItemTarget(requestItem, "GET", SIMPLE_SJS, {
+    time: true
+  });
+
+  aDebuggee.location.reload();
+};
diff --git a/browser/devtools/netmonitor/test/browser_net_sort-01.js b/browser/devtools/netmonitor/test/browser_net_sort-01.js
index ed8f2b8..581f63c 100644
--- a/browser/devtools/netmonitor/test/browser_net_sort-01.js
+++ b/browser/devtools/netmonitor/test/browser_net_sort-01.js
@@ -4,17 +4,17 @@
 /**
  * Test if the sorting mechanism works correctly.
  */
 
 function test() {
   initNetMonitor(STATUS_CODES_URL).then(([aTab, aDebuggee, aMonitor]) => {
     info("Starting test... ");
 
-    let { $all, L10N, NetMonitorView } = aMonitor.panelWin;
+    let { $$, L10N, NetMonitorView } = aMonitor.panelWin;
     let { RequestsMenu } = NetMonitorView;
 
     RequestsMenu.lazyUpdate = false;
 
     waitForNetworkEvents(aMonitor, 5).then(() => {
       testContents([0, 1, 2, 3, 4])
         .then(() => {
           info("Testing swap(0, 0)");
@@ -177,17 +177,17 @@ function test() {
         .then(finish);
     });
 
     function testContents([a, b, c, d, e]) {
       is(RequestsMenu.items.length, 5,
         "There should be a total of 5 items in the requests menu.");
       is(RequestsMenu.visibleItems.length, 5,
         "There should be a total of 5 visbile items in the requests menu.");
-      is($all(".side-menu-widget-item").length, 5,
+      is($$(".side-menu-widget-item").length, 5,
         "The visible items in the requests menu are, in fact, visible!");
 
       is(RequestsMenu.getItemAtIndex(0), RequestsMenu.items[0],
         "The requests menu items aren't ordered correctly. First item is misplaced.");
       is(RequestsMenu.getItemAtIndex(1), RequestsMenu.items[1],
         "The requests menu items aren't ordered correctly. Second item is misplaced.");
       is(RequestsMenu.getItemAtIndex(2), RequestsMenu.items[2],
         "The requests menu items aren't ordered correctly. Third item is misplaced.");
diff --git a/browser/devtools/netmonitor/test/browser_net_sort-02.js b/browser/devtools/netmonitor/test/browser_net_sort-02.js
index 49046d2..983d833 100644
--- a/browser/devtools/netmonitor/test/browser_net_sort-02.js
+++ b/browser/devtools/netmonitor/test/browser_net_sort-02.js
@@ -8,17 +8,17 @@
 function test() {
   initNetMonitor(SORTING_URL).then(([aTab, aDebuggee, aMonitor]) => {
     info("Starting test... ");
 
     // It seems that this test may be slow on debug builds. This could be because
     // of the heavy dom manipulation associated with sorting.
     requestLongerTimeout(2);
 
-    let { $, $all, L10N, NetMonitorView } = aMonitor.panelWin;
+    let { $, $$, L10N, NetMonitorView } = aMonitor.panelWin;
     let { RequestsMenu } = NetMonitorView;
 
     // Loading the frame script and preparing the xhr request URLs so we can
     // generate some requests later.
     loadCommonFrameScript();
     let requests = [{
       url: "sjs_sorting-test-server.sjs?index=1&" + Math.random(),
       method: "GET1"
@@ -211,17 +211,17 @@ function test() {
         "The first item should be still selected after sorting.");
       is(NetMonitorView.detailsPaneHidden, false,
         "The details pane should still be visible after sorting.");
 
       is(RequestsMenu.items.length, 5,
         "There should be a total of 5 items in the requests menu.");
       is(RequestsMenu.visibleItems.length, 5,
         "There should be a total of 5 visbile items in the requests menu.");
-      is($all(".side-menu-widget-item").length, 5,
+      is($$(".side-menu-widget-item").length, 5,
         "The visible items in the requests menu are, in fact, visible!");
 
       is(RequestsMenu.getItemAtIndex(0), RequestsMenu.items[0],
         "The requests menu items aren't ordered correctly. First item is misplaced.");
       is(RequestsMenu.getItemAtIndex(1), RequestsMenu.items[1],
         "The requests menu items aren't ordered correctly. Second item is misplaced.");
       is(RequestsMenu.getItemAtIndex(2), RequestsMenu.items[2],
         "The requests menu items aren't ordered correctly. Third item is misplaced.");
diff --git a/browser/devtools/netmonitor/test/browser_net_sort-03.js b/browser/devtools/netmonitor/test/browser_net_sort-03.js
index 5e5560c..ec0589d 100644
--- a/browser/devtools/netmonitor/test/browser_net_sort-03.js
+++ b/browser/devtools/netmonitor/test/browser_net_sort-03.js
@@ -8,17 +8,17 @@
 function test() {
   initNetMonitor(SORTING_URL).then(([aTab, aDebuggee, aMonitor]) => {
     info("Starting test... ");
 
     // It seems that this test may be slow on debug builds. This could be because
     // of the heavy dom manipulation associated with sorting.
     requestLongerTimeout(2);
 
-    let { $, $all, L10N, NetMonitorView } = aMonitor.panelWin;
+    let { $, $$, L10N, NetMonitorView } = aMonitor.panelWin;
     let { RequestsMenu } = NetMonitorView;
 
     // Loading the frame script and preparing the xhr request URLs so we can
     // generate some requests later.
     loadCommonFrameScript();
     let requests = [{
       url: "sjs_sorting-test-server.sjs?index=1&" + Math.random(),
       method: "GET1"
@@ -133,17 +133,17 @@ function test() {
         "The first item should be still selected after sorting.");
       is(NetMonitorView.detailsPaneHidden, false,
         "The details pane should still be visible after sorting.");
 
       is(RequestsMenu.items.length, aOrder.length,
         "There should be a specific number of items in the requests menu.");
       is(RequestsMenu.visibleItems.length, aOrder.length,
         "There should be a specific number of visbile items in the requests menu.");
-      is($all(".side-menu-widget-item").length, aOrder.length,
+      is($$(".side-menu-widget-item").length, aOrder.length,
         "The visible items in the requests menu are, in fact, visible!");
 
       for (let i = 0; i < aOrder.length; i++) {
         is(RequestsMenu.getItemAtIndex(i), RequestsMenu.items[i],
           "The requests menu items aren't ordered correctly. Misplaced item " + i + ".");
       }
 
       for (let i = 0, len = aOrder.length / 5; i < len; i++) {
diff --git a/browser/devtools/netmonitor/test/browser_net_statistics-01.js b/browser/devtools/netmonitor/test/browser_net_statistics-01.js
index f73b6a2..490d072 100644
--- a/browser/devtools/netmonitor/test/browser_net_statistics-01.js
+++ b/browser/devtools/netmonitor/test/browser_net_statistics-01.js
@@ -5,51 +5,51 @@
  * Tests if the statistics view is populated correctly.
  */
 
 function test() {
   initNetMonitor(STATISTICS_URL).then(([aTab, aDebuggee, aMonitor]) => {
     info("Starting test... ");
 
     let panel = aMonitor.panelWin;
-    let { document, $, $all, EVENTS, NetMonitorView } = panel;
+    let { document, $, $$, EVENTS, NetMonitorView } = panel;
 
     is(NetMonitorView.currentFrontendMode, "network-inspector-view",
       "The initial frontend mode is correct.");
 
     is($("#primed-cache-chart").childNodes.length, 0,
       "There should be no primed cache chart created yet.");
     is($("#empty-cache-chart").childNodes.length, 0,
       "There should be no empty cache chart created yet.");
 
     waitFor(panel, EVENTS.PLACEHOLDER_CHARTS_DISPLAYED).then(() => {
       is($("#primed-cache-chart").childNodes.length, 1,
         "There should be a placeholder primed cache chart created now.");
       is($("#empty-cache-chart").childNodes.length, 1,
         "There should be a placeholder empty cache chart created now.");
 
-      is($all(".pie-chart-container[placeholder=true]").length, 2,
+      is($$(".pie-chart-container[placeholder=true]").length, 2,
         "Two placeholder pie chart appear to be rendered correctly.");
-      is($all(".table-chart-container[placeholder=true]").length, 2,
+      is($$(".table-chart-container[placeholder=true]").length, 2,
         "Two placeholder table chart appear to be rendered correctly.");
 
       promise.all([
         waitFor(panel, EVENTS.PRIMED_CACHE_CHART_DISPLAYED),
         waitFor(panel, EVENTS.EMPTY_CACHE_CHART_DISPLAYED)
       ]).then(() => {
         is($("#primed-cache-chart").childNodes.length, 1,
           "There should be a real primed cache chart created now.");
         is($("#empty-cache-chart").childNodes.length, 1,
           "There should be a real empty cache chart created now.");
 
         Task.spawn(function*() {
-          yield until(() => $all(".pie-chart-container:not([placeholder=true])").length == 2);
+          yield until(() => $$(".pie-chart-container:not([placeholder=true])").length == 2);
           ok(true, "Two real pie charts appear to be rendered correctly.");
 
-          yield until(() => $all(".table-chart-container:not([placeholder=true])").length == 2);
+          yield until(() => $$(".table-chart-container:not([placeholder=true])").length == 2);
           ok(true, "Two real table charts appear to be rendered correctly.")
 
           teardown(aMonitor).then(finish);
         });
       });
     });
 
     NetMonitorView.toggleFrontendMode();
diff --git a/browser/devtools/netmonitor/test/browser_net_timing-division.js b/browser/devtools/netmonitor/test/browser_net_timing-division.js
index fa537dd..3383e65 100644
--- a/browser/devtools/netmonitor/test/browser_net_timing-division.js
+++ b/browser/devtools/netmonitor/test/browser_net_timing-division.js
@@ -4,25 +4,25 @@
 /**
  * Tests if timing intervals are divided againts seconds when appropriate.
  */
 
 function test() {
   initNetMonitor(CUSTOM_GET_URL).then(([aTab, aDebuggee, aMonitor]) => {
     info("Starting test... ");
 
-    let { $all, NetMonitorView } = aMonitor.panelWin;
+    let { $$, NetMonitorView } = aMonitor.panelWin;
     let { RequestsMenu } = NetMonitorView;
 
     RequestsMenu.lazyUpdate = false;
 
     waitForNetworkEvents(aMonitor, 2).then(() => {
-      let millisecondDivs = $all(".requests-menu-timings-division[division-scale=millisecond]");
-      let secondDivs = $all(".requests-menu-timings-division[division-scale=second]");
-      let minuteDivs = $all(".requests-menu-timings-division[division-scale=minute]");
+      let millisecondDivs = $$(".requests-menu-timings-division[division-scale=millisecond]");
+      let secondDivs = $$(".requests-menu-timings-division[division-scale=second]");
+      let minuteDivs = $$(".requests-menu-timings-division[division-scale=minute]");
 
       info("Number of millisecond divisions: " + millisecondDivs.length);
       info("Number of second divisions: " + secondDivs.length);
       info("Number of minute divisions: " + minuteDivs.length);
 
       for (let div of millisecondDivs) {
         info("Millisecond division: " + div.getAttribute("value"));
       }
diff --git a/browser/devtools/netmonitor/test/head.js b/browser/devtools/netmonitor/test/head.js
index 3f1b089..644069f 100644
--- a/browser/devtools/netmonitor/test/head.js
+++ b/browser/devtools/netmonitor/test/head.js
@@ -73,16 +73,26 @@ registerCleanupFunction(() => {
   info("finish() was called, cleaning up...");
 
   Services.prefs.setBoolPref("devtools.debugger.log", gEnableLogging);
   Services.prefs.setCharPref("devtools.netmonitor.filters", gDefaultFilters);
   Services.prefs.clearUserPref("devtools.cache.disabled");
   Services.prefs.clearUserPref("devtools.dump.emit");
 });
 
+function test () {
+  info("AHHHHHHHHHHHHHHHHH");
+  Task.spawn(spawnTest).then(finish, handleError);
+}
+
+function handleError(aError) {
+  ok(false, "Got an error: " + aError.message + "\n" + aError.stack);
+  finish();
+}
+
 function addTab(aUrl, aWindow) {
   info("Adding tab: " + aUrl);
 
   let deferred = promise.defer();
   let targetWindow = aWindow || window;
   let targetBrowser = targetWindow.gBrowser;
 
   targetWindow.focus();
@@ -95,20 +105,29 @@ function addTab(aUrl, aWindow) {
   }, true);
 
   return deferred.promise;
 }
 
 function removeTab(aTab, aWindow) {
   info("Removing tab.");
 
+  let deferred = promise.defer();
   let targetWindow = aWindow || window;
   let targetBrowser = targetWindow.gBrowser;
+  let tabContainer = targetBrowser.tabContainer;
+
+  tabContainer.addEventListener("TabClose", function onClose(aEvent) {
+    tabContainer.removeEventListener("TabClose", onClose, false);
+    info("Tab removed and finished closing.");
+    deferred.resolve();
+  }, false);
 
   targetBrowser.removeTab(aTab);
+  return deferred.promise;
 }
 
 function waitForNavigation(aTarget) {
   let deferred = promise.defer();
   aTarget.once("will-navigate", () => {
     aTarget.once("navigate", () => {
       deferred.resolve();
     });
@@ -165,33 +184,33 @@ function restartNetMonitor(aMonitor, aNewUrl) {
 
   aMonitor.once("destroyed", () => initNetMonitor(url).then(deferred.resolve));
   removeTab(tab);
 
   return deferred.promise;
 }
 
 function teardown(aMonitor) {
-  info("Destroying the specified network monitor.");
-
-  let deferred = promise.defer();
-  let tab = aMonitor.target.tab;
+  return Task.spawn(function*() {
+    info("Destroying the specified network monitor.");
 
-  aMonitor.once("destroyed", () => executeSoon(deferred.resolve));
-  removeTab(tab);
+    let deferred = promise.defer();
+    let tab = aMonitor.target.tab;
 
-  return deferred.promise;
+    yield aMonitor._toolbox.destroy();
+    yield removeTab(tab);
+  });
 }
 
 function waitForNetworkEvents(aMonitor, aGetRequests, aPostRequests = 0) {
   let deferred = promise.defer();
 
   let panel = aMonitor.panelWin;
   let events = panel.EVENTS;
-  let menu = panel.NetMonitorView.RequestsMenu;
+  let models = panel.RequestCollection;
 
   let progress = {};
   let genericEvents = 0;
   let postEvents = 0;
 
   let awaitedEventsToListeners = [
     ["UPDATING_REQUEST_HEADERS", onGenericEvent],
     ["RECEIVED_REQUEST_HEADERS", onGenericEvent],
@@ -232,17 +251,17 @@ function waitForNetworkEvents(aMonitor, aGetRequests, aPostRequests = 0) {
   }
 
   function maybeResolve(event, actor) {
     info("> Network events progress: " +
       genericEvents + "/" + ((aGetRequests + aPostRequests) * 13) + ", " +
       postEvents + "/" + (aPostRequests * 2) + ", " +
       "got " + event + " for " + actor);
 
-    let url = menu.getItemByValue(actor).attachment.url;
+    let url = models.get(actor).url;
     updateProgressForURL(url, event);
     info("> Current state: " + JSON.stringify(progress, null, 2));
 
     // There are 15 updates which need to be fired for a request to be
     // considered finished. The "requestPostData" packet isn't fired for
     // non-POST requests.
     if (genericEvents == (aGetRequests + aPostRequests) * 13 &&
         postEvents == aPostRequests * 2) {
@@ -371,17 +390,25 @@ function verifyRequestItemTarget(aRequestItem, aMethod, aUrl, aData = {}) {
  *        The event emitter object that is being listened to.
  * @param string eventName
  *        The name of the event to listen to.
  * @return object
  *        Returns a promise that resolves upon firing of the event.
  */
 function waitFor (subject, eventName) {
   let deferred = promise.defer();
-  subject.once(eventName, deferred.resolve);
+  info(`Waiting for ${eventName} on ${subject}...`);
+  if (subject.once) {
+    subject.once(eventName, deferred.resolve);
+  } else {
+    subject.on(eventName, function handler () {
+      subject.off(eventName, handler);
+      deferred.resolve(arguments);
+    });
+  }
   return deferred.promise;
 }
 
 /**
  * Tests if a button for a filter of given type is the only one checked.
  *
  * @param string aFilterType
  *        The type of the filter that should be the only one checked.
diff --git a/browser/devtools/netmonitor/views/custom-request-view.js b/browser/devtools/netmonitor/views/custom-request-view.js
new file mode 100644
index 0000000..7be5f0a
--- /dev/null
+++ b/browser/devtools/netmonitor/views/custom-request-view.js
@@ -0,0 +1,193 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+"use strict";
+
+/**
+ * Functions handling the custom request view.
+ */
+function CustomRequestView() {
+  dumpn("CustomRequestView was instantiated");
+}
+
+CustomRequestView.prototype = {
+  /**
+   * Initialization function, called when the network monitor is started.
+   */
+  initialize: function() {
+    dumpn("Initializing the CustomRequestView");
+
+    this.customPane = $("#custom-pane");
+    this.sendButton = $("#custom-request-send-button");
+    this.closeButton = $("#custom-request-close-button");
+    this.resendButton = $("#headers-summary-resend");
+    this.resendButton.hidden = false;
+
+    this._onClose = this._onClose.bind(this);
+    this._onSend = this._onSend.bind(this);
+    this._onOpen = this._onOpen.bind(this);
+
+    this.updateCustomRequestEvent = utils.getKeyWithEvent(this.onUpdate.bind(this));
+
+    this.closeButton.addEventListener("click", this._onClose, false);
+    this.sendButton.addEventListener("click", this._onSend, false);
+    this.resendButton.addEventListener("click", this._onOpen, false);
+    this.customPane.addEventListener("input", this.updateCustomRequest, false);
+  },
+
+  /**
+   * Destruction function, called when the network monitor is closed.
+   */
+  destroy: function() {
+    dumpn("Destroying the CustomRequestView");
+
+    this.closeButton.removeEventListener("click", this._onClose, false);
+    this.sendButton.removeEventListener("click", this._onSend, false);
+    this.resendButton.removeEventListener("click", this._onOpen, false);
+    this.customPane.removeEventListener("input", this.updateCustomRequest, false);
+  },
+
+  /**
+   * Populates this view with the specified data.
+   *
+   * @param object requestModel
+   *        The data source, a RequestModel instance.
+   * @return object
+   *        Returns a promise that resolves upon population the view.
+   */
+  populate: Task.async(function*(requestModel) {
+    this.model = requestModel.clone();
+
+    $("#custom-url-value").value = this.model.url;
+    $("#custom-method-value").value = this.model.method;
+    this.updateCustomQuery(this.model.url);
+
+    if (this.model.requestHeaders) {
+      let headers = this.model.requestHeaders.headers;
+      $("#custom-headers-value").value = utils.writeHeaderText(headers);
+    }
+    if (this.model.requestPostData) {
+      let postData = this.model.requestPostData.postData.text;
+      $("#custom-postdata-value").value = yield gNetwork.getString(postData);
+    }
+
+    // Only emit the ID -- we recreate this model anyway once it comes through
+    // the wire.
+    window.emit(EVENTS.CUSTOMREQUESTVIEW_POPULATED, this.model.id);
+  }),
+
+  /**
+   * Handle user input in the custom request form.
+   *
+   * @param object aField
+   *        the field that the user updated.
+   */
+  onUpdate: function(aField) {
+    let field = aField;
+    let value;
+
+    switch(aField) {
+      case 'method':
+        value = $("#custom-method-value").value.trim();
+        this.model.method = value;
+        break;
+      case 'url':
+        value = $("#custom-url-value").value;
+        this.updateCustomQuery(value);
+        this.model.url = value;
+        break;
+      case 'query':
+        let query = $("#custom-query-value").value;
+        this.updateCustomUrl(query);
+        field = 'url';
+        value = $("#custom-url-value").value
+        this.model.url = value;
+        break;
+      case 'body':
+        value = $("#custom-postdata-value").value;
+        this.model.requestPostData = { postData: { text: value } };
+        break;
+      case 'headers':
+        let headersText = $("#custom-headers-value").value;
+        value = utils.parseHeadersText(headersText);
+        this.model.requestHeaders = { headers: value };
+        break;
+    }
+  },
+
+  /**
+   * Update the query string field based on the url.
+   *
+   * @param object aUrl
+   *        The URL to extract query string from.
+   */
+  updateCustomQuery: function(aUrl) {
+    let paramsArray = utils.parseQueryString(utils.nsIURL(aUrl).query);
+    if (!paramsArray) {
+      $("#custom-query").hidden = true;
+      return;
+    }
+    $("#custom-query").hidden = false;
+    $("#custom-query-value").value = utils.writeQueryText(paramsArray);
+  },
+
+  /**
+   * Update the url based on the query string field.
+   *
+   * @param object aQueryText
+   *        The contents of the query string field.
+   */
+  updateCustomUrl: function(aQueryText) {
+    let params = utils.parseQueryText(aQueryText);
+    let queryString = utils.writeQueryString(params);
+
+    let url = $("#custom-url-value").value;
+    let oldQuery = utils.nsIURL(url).query;
+    let path = url.replace(oldQuery, queryString);
+
+    $("#custom-url-value").value = path;
+  },
+
+  /**
+   * Send a new HTTP request using the data in the custom request form.
+   */
+  _onSend: function() {
+    let data = {
+      url: this.model.url,
+      method: this.model.method,
+      httpVersion: this.model.httpVersion,
+    };
+    if (this.model.requestHeaders) {
+      data.headers = this.model.requestHeaders.headers;
+    }
+    if (this.model.requestPostData) {
+      data.body = this.model.requestPostData.postData.text;
+    }
+
+    console.log(data);
+    NetMonitorController.webConsoleClient.sendHTTPRequest(data, aResponse => {
+      let id = aResponse.eventActor.actor;
+      console.log("SENT", id);
+      window.emit(EVENTS.CUSTOM_REQUEST_SENT, this.model);
+      this._onClose();
+      NetMonitorView.Sidebar.toggle(false);
+    });
+  },
+
+  /**
+   * Switch back to details view.
+   */
+  _onClose: function() {
+    this.model = null;
+    NetMonitorView.Sidebar.showDetails();
+  },
+
+  /**
+   * Switch to the custom pane.
+   */
+  _onOpen: function() {
+    NetMonitorView.Sidebar.showCustom();
+  }
+};
+
+NetMonitorView.CustomRequest = new CustomRequestView();
diff --git a/browser/devtools/netmonitor/views/details-view.js b/browser/devtools/netmonitor/views/details-view.js
new file mode 100644
index 0000000..1d16f5e
--- /dev/null
+++ b/browser/devtools/netmonitor/views/details-view.js
@@ -0,0 +1,853 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+"use strict";
+
+const DEFAULT_HTTP_VERSION = "HTTP/1.1";
+const SOURCE_SYNTAX_HIGHLIGHT_MAX_FILE_SIZE = 102400; // 100 KB in bytes
+const GENERIC_VARIABLES_VIEW_SETTINGS = {
+  lazyEmpty: true,
+  lazyEmptyDelay: 10, // ms
+  searchEnabled: true,
+  editableValueTooltip: "",
+  editableNameTooltip: "",
+  preventDisableOnChange: true,
+  preventDescriptorModifiers: true,
+  eval: () => {}
+};
+
+
+/**
+ * Functions handling the requests details view.
+ */
+function NetworkDetailsView() {
+  dumpn("NetworkDetailsView was instantiated");
+
+  // The ToolSidebar requires the panel object to be able to emit events.
+  EventEmitter.decorate(this);
+
+  this._onTabSelect = this._onTabSelect.bind(this);
+};
+
+NetworkDetailsView.prototype = {
+  /**
+   * An object containing the state of tabs.
+   */
+  _viewState: {
+    // if updating[tab] is true a task is currently updating the given tab.
+    updating: [],
+    // if dirty[tab] is true, the tab needs to be repopulated once current
+    // update task finishes
+    dirty: [],
+    // the most recently received attachment data for the request
+    latestData: null,
+  },
+
+  /**
+   * Initialization function, called when the network monitor is started.
+   */
+  initialize: function() {
+    dumpn("Initializing the NetworkDetailsView");
+
+    this.widget = $("#event-details-pane");
+    this.toggleRawHeaders = this.toggleRawHeaders.bind(this);
+
+    this.sidebar = new ToolSidebar(this.widget, this, "netmonitor", {
+      disableTelemetry: true,
+      showAllTabsMenu: true
+    });
+
+    this._headers = new VariablesView($("#all-headers"),
+      Heritage.extend(GENERIC_VARIABLES_VIEW_SETTINGS, {
+        emptyText: L10N.getStr("headersEmptyText"),
+        searchPlaceholder: L10N.getStr("headersFilterText")
+      }));
+    this._cookies = new VariablesView($("#all-cookies"),
+      Heritage.extend(GENERIC_VARIABLES_VIEW_SETTINGS, {
+        emptyText: L10N.getStr("cookiesEmptyText"),
+        searchPlaceholder: L10N.getStr("cookiesFilterText")
+      }));
+    this._params = new VariablesView($("#request-params"),
+      Heritage.extend(GENERIC_VARIABLES_VIEW_SETTINGS, {
+        emptyText: L10N.getStr("paramsEmptyText"),
+        searchPlaceholder: L10N.getStr("paramsFilterText")
+      }));
+    this._json = new VariablesView($("#response-content-json"),
+      Heritage.extend(GENERIC_VARIABLES_VIEW_SETTINGS, {
+        onlyEnumVisible: true,
+        searchPlaceholder: L10N.getStr("jsonFilterText")
+      }));
+    VariablesViewController.attach(this._json);
+
+    this._paramsQueryString = L10N.getStr("paramsQueryString");
+    this._paramsFormData = L10N.getStr("paramsFormData");
+    this._paramsPostPayload = L10N.getStr("paramsPostPayload");
+    this._requestHeaders = L10N.getStr("requestHeaders");
+    this._requestHeadersFromUpload = L10N.getStr("requestHeadersFromUpload");
+    this._responseHeaders = L10N.getStr("responseHeaders");
+    this._requestCookies = L10N.getStr("requestCookies");
+    this._responseCookies = L10N.getStr("responseCookies");
+
+    $("tabpanels", this.widget).addEventListener("select", this._onTabSelect);
+    $("#toggle-raw-headers").addEventListener("click", this.toggleRawHeaders, false);
+  },
+
+  /**
+   * Destruction function, called when the network monitor is closed.
+   */
+  destroy: function() {
+    dumpn("Destroying the NetworkDetailsView");
+    $("tabpanels", this.widget).removeEventListener("select", this._onTabSelect);
+    $("#toggle-raw-headers").removeEventListener("click", this.toggleRawHeaders, false);
+    this.sidebar.destroy();
+  },
+
+  /**
+   * Populates this view with the specified data.
+   *
+   * @param object aData
+   *        The data source (this should be the attachment of a request item).
+   * @return object
+   *        Returns a promise that resolves upon population the view.
+   */
+  populate: function(aData) {
+    $("#request-params-box").setAttribute("flex", "1");
+    $("#request-params-box").hidden = false;
+    $("#request-post-data-textarea-box").hidden = true;
+    $("#response-content-info-header").hidden = true;
+    $("#response-content-json-box").hidden = true;
+    $("#response-content-textarea-box").hidden = true;
+    $("#raw-headers").hidden = true;
+    $("#response-content-image-box").hidden = true;
+
+    let isHtml = types.isHtml({ attachment: aData });
+
+    // Show the "Preview" tabpanel only for plain HTML responses.
+    this.sidebar.toggleTab(isHtml, "preview-tab", "preview-tabpanel");
+
+    // Show the "Security" tab only for requests that
+    //   1) are https (state != insecure)
+    //   2) come from a target that provides security information.
+    let hasSecurityInfo = aData.securityState &&
+                          aData.securityState !== "insecure";
+    this.sidebar.toggleTab(hasSecurityInfo, "security-tab", "security-tabpanel");
+
+    // Switch to the "Headers" tabpanel if the "Preview" previously selected
+    // and this is not an HTML response or "Security" was selected but this
+    // request has no security information.
+
+    if (!isHtml && this.widget.selectedPanel === $("#preview-tabpanel") ||
+        !hasSecurityInfo && this.widget.selectedPanel === $("#security-tabpanel")) {
+      this.widget.selectedIndex = 0;
+    }
+
+    this._headers.empty();
+    this._cookies.empty();
+    this._params.empty();
+    this._json.empty();
+
+    this._dataSrc = { src: aData, populated: [] };
+    this._onTabSelect();
+    window.emit(EVENTS.NETWORKDETAILSVIEW_POPULATED);
+
+    return promise.resolve();
+  },
+
+  /**
+   * Listener handling the tab selection event.
+   */
+  _onTabSelect: function() {
+    let { src, populated } = this._dataSrc || {};
+    let tab = this.widget.selectedIndex;
+    let view = this;
+
+    // Make sure the data source is valid and don't populate the same tab twice.
+    if (!src || populated[tab]) {
+      return;
+    }
+
+    let viewState = this._viewState;
+    if (viewState.updating[tab]) {
+      // A task is currently updating this tab. If we started another update
+      // task now it would result in a duplicated content as described in bugs
+      // 997065 and 984687. As there's no way to stop the current task mark the
+      // tab dirty and refresh the panel once the current task finishes.
+      viewState.dirty[tab] = true;
+      viewState.latestData = src;
+      return;
+    }
+
+    Task.spawn(function*() {
+      viewState.updating[tab] = true;
+      switch (tab) {
+        case 0: // "Headers"
+          yield view._setSummary(src);
+          yield view._setResponseHeaders(src.responseHeaders);
+          yield view._setRequestHeaders(
+            src.requestHeaders,
+            src.requestHeadersFromUploadStream);
+          break;
+        case 1: // "Cookies"
+          yield view._setResponseCookies(src.responseCookies);
+          yield view._setRequestCookies(src.requestCookies);
+          break;
+        case 2: // "Params"
+          yield view._setRequestGetParams(src.url);
+          yield view._setRequestPostParams(
+            src.requestHeaders,
+            src.requestHeadersFromUploadStream,
+            src.requestPostData);
+          break;
+        case 3: // "Response"
+          yield view._setResponseBody(src.url, src.responseContent);
+          break;
+        case 4: // "Timings"
+          yield view._setTimingsInformation(src.eventTimings);
+          break;
+        case 5: // "Security"
+          yield view._setSecurityInfo(src.securityInfo, src.url);
+          break;
+        case 6: // "Preview"
+          yield view._setHtmlPreview(src.responseContent);
+          break;
+      }
+      viewState.updating[tab] = false;
+    }).then(() => {
+      if (tab == this.widget.selectedIndex) {
+        if (viewState.dirty[tab]) {
+          // The request information was updated while the task was running.
+          viewState.dirty[tab] = false;
+          view.populate(viewState.latestData);
+        }
+        else {
+          console.log("TAB_UPDATED");
+          // Tab is selected but not dirty. We're done here.
+          populated[tab] = true;
+          window.emit(EVENTS.TAB_UPDATED);
+
+          // TODO do we need this?
+          // if (NetMonitorController.isConnected()) {
+          //  NetMonitorView.RequestsMenu.ensureSelectedItemIsVisible();
+          // }
+        }
+      }
+      else {
+        if (viewState.dirty[tab]) {
+          // Tab is dirty but no longer selected. Don't refresh it now, it'll be
+          // done if the tab is shown again.
+          viewState.dirty[tab] = false;
+        }
+      }
+    }, Cu.reportError);
+  },
+
+  /**
+   * Sets the network request summary shown in this view.
+   *
+   * @param object aData
+   *        The data source (this should be the attachment of a request item).
+   */
+  _setSummary: function(aData) {
+    if (aData.url) {
+      let unicodeUrl = NetworkHelper.convertToUnicode(unescape(aData.url));
+      $("#headers-summary-url-value").setAttribute("value", unicodeUrl);
+      $("#headers-summary-url-value").setAttribute("tooltiptext", unicodeUrl);
+      $("#headers-summary-url").removeAttribute("hidden");
+    } else {
+      $("#headers-summary-url").setAttribute("hidden", "true");
+    }
+
+    if (aData.method) {
+      $("#headers-summary-method-value").setAttribute("value", aData.method);
+      $("#headers-summary-method").removeAttribute("hidden");
+    } else {
+      $("#headers-summary-method").setAttribute("hidden", "true");
+    }
+
+    if (aData.status) {
+      $("#headers-summary-status-circle").setAttribute("code", aData.status);
+      $("#headers-summary-status-value").setAttribute("value", aData.status + " " + aData.statusText);
+      $("#headers-summary-status").removeAttribute("hidden");
+    } else {
+      $("#headers-summary-status").setAttribute("hidden", "true");
+    }
+
+    if (aData.httpVersion && aData.httpVersion != DEFAULT_HTTP_VERSION) {
+      $("#headers-summary-version-value").setAttribute("value", aData.httpVersion);
+      $("#headers-summary-version").removeAttribute("hidden");
+    } else {
+      $("#headers-summary-version").setAttribute("hidden", "true");
+    }
+  },
+
+  /**
+   * Sets the network request headers shown in this view.
+   *
+   * @param object aHeadersResponse
+   *        The "requestHeaders" message received from the server.
+   * @param object aHeadersFromUploadStream
+   *        The "requestHeadersFromUploadStream" inferred from the POST payload.
+   * @return object
+   *        A promise that resolves when request headers are set.
+   */
+  _setRequestHeaders: Task.async(function*(aHeadersResponse, aHeadersFromUploadStream) {
+    if (aHeadersResponse && aHeadersResponse.headers.length) {
+      yield this._addHeaders("request", this._requestHeaders, aHeadersResponse);
+    }
+    if (aHeadersFromUploadStream && aHeadersFromUploadStream.headers.length) {
+      yield this._addHeaders("request", this._requestHeadersFromUpload, aHeadersFromUploadStream);
+    }
+  }),
+
+  /**
+   * Sets the network response headers shown in this view.
+   *
+   * @param object aResponse
+   *        The message received from the server.
+   * @return object
+   *        A promise that resolves when response headers are set.
+   */
+  _setResponseHeaders: Task.async(function*(aResponse) {
+    if (aResponse && aResponse.headers.length) {
+      aResponse.headers.sort((a, b) => a.name > b.name);
+      yield this._addHeaders("response", this._responseHeaders, aResponse);
+    }
+  }),
+
+  /**
+   * Populates the headers container in this view with the specified data.
+   *
+   * @param string aType
+   *        The type of headers to populate (request or response).
+   * @param string aName
+   *        The string name of headers to populate
+   * @param object aResponse
+   *        The message received from the server.
+   * @return object
+   *        A promise that resolves when headers are added.
+   */
+  _addHeaders: Task.async(function*(aType, aName, aResponse) {
+    let kb = aResponse.headersSize / 1024;
+    let size = L10N.numberWithDecimals(kb, HEADERS_SIZE_DECIMALS);
+    let text = L10N.getFormatStr("networkMenu.sizeKB", size);
+
+    let headersScope = this._headers.addScope(aName + " (" + text + ")");
+    headersScope.expanded = true;
+
+    for (let header of aResponse.headers) {
+      let headerVar = headersScope.addItem(header.name, {}, true);
+      let headerValue = yield gNetwork.getString(header.value);
+      headerVar.setGrip(headerValue);
+    }
+
+    console.log("ADD HEADERS", aType, aName);
+    // Write the raw headers, which may or may not be visible.
+    let headerRawText = $(`#raw-${aType}-headers-textarea`);
+    headerRawText.value = utils.writeHeaderText(aResponse.headers);
+  }),
+
+  /**
+   * Sets the network request cookies shown in this view.
+   *
+   * @param object aResponse
+   *        The message received from the server.
+   * @return object
+   *        A promise that is resolved when the request cookies are set.
+   */
+  _setRequestCookies: Task.async(function*(aResponse) {
+    if (aResponse && aResponse.cookies.length) {
+      aResponse.cookies.sort((a, b) => a.name > b.name);
+      yield this._addCookies(this._requestCookies, aResponse);
+    }
+  }),
+
+  /**
+   * Sets the network response cookies shown in this view.
+   *
+   * @param object aResponse
+   *        The message received from the server.
+   * @return object
+   *        A promise that is resolved when the response cookies are set.
+   */
+  _setResponseCookies: Task.async(function*(aResponse) {
+    if (aResponse && aResponse.cookies.length) {
+      yield this._addCookies(this._responseCookies, aResponse);
+    }
+  }),
+
+  /**
+   * Populates the cookies container in this view with the specified data.
+   *
+   * @param string aName
+   *        The type of cookies to populate (request or response).
+   * @param object aResponse
+   *        The message received from the server.
+   * @return object
+   *        Returns a promise that resolves upon the adding of cookies.
+   */
+  _addCookies: Task.async(function*(aName, aResponse) {
+    let cookiesScope = this._cookies.addScope(aName);
+    cookiesScope.expanded = true;
+
+    for (let cookie of aResponse.cookies) {
+      let cookieVar = cookiesScope.addItem(cookie.name, {}, true);
+      let cookieValue = yield gNetwork.getString(cookie.value);
+      cookieVar.setGrip(cookieValue);
+
+      // By default the cookie name and value are shown. If this is the only
+      // information available, then nothing else is to be displayed.
+      let cookieProps = Object.keys(cookie);
+      if (cookieProps.length == 2) {
+        continue;
+      }
+
+      // Display any other information other than the cookie name and value
+      // which may be available.
+      let rawObject = Object.create(null);
+      let otherProps = cookieProps.filter(e => e != "name" && e != "value");
+      for (let prop of otherProps) {
+        rawObject[prop] = cookie[prop];
+      }
+      cookieVar.populate(rawObject);
+      cookieVar.twisty = true;
+      cookieVar.expanded = true;
+    }
+  }),
+
+  /**
+   * Sets the network request get params shown in this view.
+   *
+   * @param string aUrl
+   *        The request's url.
+   */
+  _setRequestGetParams: function(aUrl) {
+    let query = utils.nsIURL(aUrl).query;
+    if (query) {
+      this._addParams(this._paramsQueryString, query);
+    }
+  },
+
+  /**
+   * Sets the network request post params shown in this view.
+   *
+   * @param object aHeadersResponse
+   *        The "requestHeaders" message received from the server.
+   * @param object aHeadersFromUploadStream
+   *        The "requestHeadersFromUploadStream" inferred from the POST payload.
+   * @param object aPostDataResponse
+   *        The "requestPostData" message received from the server.
+   * @return object
+   *        A promise that is resolved when the request post params are set.
+   */
+  _setRequestPostParams: Task.async(function*(aHeadersResponse, aHeadersFromUploadStream, aPostDataResponse) {
+                           console.log("SET REQUEST POST PARAMS ** ** * ** * *");
+    if (!aHeadersResponse || !aHeadersFromUploadStream || !aPostDataResponse) {
+      return;
+    }
+
+    let { headers: requestHeaders } = aHeadersResponse;
+    let { headers: payloadHeaders } = aHeadersFromUploadStream;
+    let allHeaders = [...payloadHeaders, ...requestHeaders];
+
+    let contentTypeHeader = allHeaders.find(e => e.name.toLowerCase() == "content-type");
+    let contentTypeLongString = contentTypeHeader ? contentTypeHeader.value : "";
+    let postDataLongString = aPostDataResponse.postData.text;
+
+    let postData = yield gNetwork.getString(postDataLongString);
+    let contentType = yield gNetwork.getString(contentTypeLongString);
+
+    // Handle query strings (e.g. "?foo=bar&baz=42").
+    if (contentType.contains("x-www-form-urlencoded")) {
+      for (let section of postData.split(/\r\n|\r|\n/)) {
+        // Before displaying it, make sure this section of the POST data
+        // isn't a line containing upload stream headers.
+        if (payloadHeaders.every(header => !section.startsWith(header.name))) {
+          this._addParams(this._paramsFormData, section);
+        }
+      }
+    }
+    // Handle actual forms ("multipart/form-data" content type).
+    else {
+      // This is really awkward, but hey, it works. Let's show an empty
+      // scope in the params view and place the source editor containing
+      // the raw post data directly underneath.
+      $("#request-params-box").removeAttribute("flex");
+      let paramsScope = this._params.addScope(this._paramsPostPayload);
+      paramsScope.expanded = true;
+      paramsScope.locked = true;
+
+      $("#request-post-data-textarea-box").hidden = false;
+      let editor = yield NetMonitorView.editor("#request-post-data-textarea");
+      // Most POST bodies are usually JSON, so they can be neatly
+      // syntax highlighted as JS. Otheriwse, fall back to plain text.
+      try {
+        JSON.parse(postData);
+        editor.setMode(Editor.modes.js);
+      } catch (e) {
+        editor.setMode(Editor.modes.text);
+      } finally {
+        editor.setText(postData);
+      }
+    }
+
+    window.emit(EVENTS.REQUEST_POST_PARAMS_DISPLAYED);
+  }),
+
+  /**
+   * Populates the params container in this view with the specified data.
+   *
+   * @param string aName
+   *        The type of params to populate (get or post).
+   * @param string aQueryString
+   *        A query string of params (e.g. "?foo=bar&baz=42").
+   */
+  _addParams: function(aName, aQueryString) {
+    let paramsArray = utils.parseQueryString(aQueryString);
+    if (!paramsArray) {
+      return;
+    }
+    let paramsScope = this._params.addScope(aName);
+    paramsScope.expanded = true;
+
+    for (let param of paramsArray) {
+      let paramVar = paramsScope.addItem(param.name, {}, true);
+      paramVar.setGrip(param.value);
+    }
+  },
+
+  /**
+   * Sets the network response body shown in this view.
+   *
+   * @param string aUrl
+   *        The request's url.
+   * @param object aResponse
+   *        The message received from the server.
+   * @return object
+   *         A promise that is resolved when the response body is set.
+   */
+  _setResponseBody: Task.async(function*(aUrl, aResponse) {
+    if (!aResponse) {
+      return;
+    }
+    let { mimeType, text, encoding } = aResponse.content;
+    let responseBody = yield gNetwork.getString(text);
+
+    // Handle json, which we tentatively identify by checking the MIME type
+    // for "json" after any word boundary. This works for the standard
+    // "application/json", and also for custom types like "x-bigcorp-json".
+    // Additionally, we also directly parse the response text content to
+    // verify whether it's json or not, to handle responses incorrectly
+    // labeled as text/plain instead.
+    let jsonMimeType, jsonObject, jsonObjectParseError;
+    try {
+      jsonMimeType = /\bjson/.test(mimeType);
+      jsonObject = JSON.parse(responseBody);
+    } catch (e) {
+      jsonObjectParseError = e;
+    }
+    if (jsonMimeType || jsonObject) {
+      // Extract the actual json substring in case this might be a "JSONP".
+      // This regex basically parses a function call and captures the
+      // function name and arguments in two separate groups.
+      let jsonpRegex = /^\s*([\w$]+)\s*\(\s*([^]*)\s*\)\s*;?\s*$/;
+      let [_, callbackPadding, jsonpString] = responseBody.match(jsonpRegex) || [];
+
+      // Make sure this is a valid JSON object first. If so, nicely display
+      // the parsing results in a variables view. Otherwise, simply show
+      // the contents as plain text.
+      if (callbackPadding && jsonpString) {
+        try {
+          jsonObject = JSON.parse(jsonpString);
+        } catch (e) {
+          jsonObjectParseError = e;
+        }
+      }
+
+      // Valid JSON or JSONP.
+      if (jsonObject) {
+        $("#response-content-json-box").hidden = false;
+        let jsonScopeName = callbackPadding
+          ? L10N.getFormatStr("jsonpScopeName", callbackPadding)
+          : L10N.getStr("jsonScopeName");
+
+        let jsonVar = { label: jsonScopeName, rawObject: jsonObject };
+        yield this._json.controller.setSingleVariable(jsonVar).expanded;
+      }
+      // Malformed JSON.
+      else {
+        $("#response-content-textarea-box").hidden = false;
+        let infoHeader = $("#response-content-info-header");
+        infoHeader.setAttribute("value", jsonObjectParseError);
+        infoHeader.setAttribute("tooltiptext", jsonObjectParseError);
+        infoHeader.hidden = false;
+
+        let editor = yield NetMonitorView.editor("#response-content-textarea");
+        editor.setMode(Editor.modes.js);
+        editor.setText(responseBody);
+      }
+    }
+    // Handle images.
+    else if (mimeType.contains("image/")) {
+      $("#response-content-image-box").setAttribute("align", "center");
+      $("#response-content-image-box").setAttribute("pack", "center");
+      $("#response-content-image-box").hidden = false;
+      $("#response-content-image").src =
+        "data:" + mimeType + ";" + encoding + "," + responseBody;
+
+      // Immediately display additional information about the image:
+      // file name, mime type and encoding.
+      $("#response-content-image-name-value").setAttribute("value", utils.nsIURL(aUrl).fileName);
+      $("#response-content-image-mime-value").setAttribute("value", mimeType);
+      $("#response-content-image-encoding-value").setAttribute("value", encoding);
+
+      // Wait for the image to load in order to display the width and height.
+      $("#response-content-image").onload = e => {
+        // XUL images are majestic so they don't bother storing their dimensions
+        // in width and height attributes like the rest of the folk. Hack around
+        // this by getting the bounding client rect and subtracting the margins.
+        let { width, height } = e.target.getBoundingClientRect();
+        let dimensions = (width - 2) + " \u00D7 " + (height - 2);
+        $("#response-content-image-dimensions-value").setAttribute("value", dimensions);
+      };
+    }
+    // Handle anything else.
+    else {
+      $("#response-content-textarea-box").hidden = false;
+      let editor = yield NetMonitorView.editor("#response-content-textarea");
+      editor.setMode(Editor.modes.text);
+      editor.setText(responseBody);
+
+      // Maybe set a more appropriate mode in the Source Editor if possible,
+      // but avoid doing this for very large files.
+      if (responseBody.length < SOURCE_SYNTAX_HIGHLIGHT_MAX_FILE_SIZE) {
+        types.setEditorMode(editor, mimeType);
+      }
+    }
+
+    window.emit(EVENTS.RESPONSE_BODY_DISPLAYED);
+  }),
+
+  /**
+   * Sets the timings information shown in this view.
+   *
+   * @param object aResponse
+   *        The message received from the server.
+   */
+  _setTimingsInformation: function(aResponse) {
+    if (!aResponse) {
+      return;
+    }
+    let { blocked, dns, connect, send, wait, receive } = aResponse.timings;
+
+    let tabboxWidth = $("#details-pane").getAttribute("width");
+    let availableWidth = tabboxWidth / 2; // Other nodes also take some space.
+    let scale = Math.max(availableWidth / aResponse.totalTime, 0);
+
+    $("#timings-summary-blocked .requests-menu-timings-box")
+      .setAttribute("width", blocked * scale);
+    $("#timings-summary-blocked .requests-menu-timings-total")
+      .setAttribute("value", L10N.getFormatStr("networkMenu.totalMS", blocked));
+
+    $("#timings-summary-dns .requests-menu-timings-box")
+      .setAttribute("width", dns * scale);
+    $("#timings-summary-dns .requests-menu-timings-total")
+      .setAttribute("value", L10N.getFormatStr("networkMenu.totalMS", dns));
+
+    $("#timings-summary-connect .requests-menu-timings-box")
+      .setAttribute("width", connect * scale);
+    $("#timings-summary-connect .requests-menu-timings-total")
+      .setAttribute("value", L10N.getFormatStr("networkMenu.totalMS", connect));
+
+    $("#timings-summary-send .requests-menu-timings-box")
+      .setAttribute("width", send * scale);
+    $("#timings-summary-send .requests-menu-timings-total")
+      .setAttribute("value", L10N.getFormatStr("networkMenu.totalMS", send));
+
+    $("#timings-summary-wait .requests-menu-timings-box")
+      .setAttribute("width", wait * scale);
+    $("#timings-summary-wait .requests-menu-timings-total")
+      .setAttribute("value", L10N.getFormatStr("networkMenu.totalMS", wait));
+
+    $("#timings-summary-receive .requests-menu-timings-box")
+      .setAttribute("width", receive * scale);
+    $("#timings-summary-receive .requests-menu-timings-total")
+      .setAttribute("value", L10N.getFormatStr("networkMenu.totalMS", receive));
+
+    $("#timings-summary-dns .requests-menu-timings-box")
+      .style.transform = "translateX(" + (scale * blocked) + "px)";
+    $("#timings-summary-connect .requests-menu-timings-box")
+      .style.transform = "translateX(" + (scale * (blocked + dns)) + "px)";
+    $("#timings-summary-send .requests-menu-timings-box")
+      .style.transform = "translateX(" + (scale * (blocked + dns + connect)) + "px)";
+    $("#timings-summary-wait .requests-menu-timings-box")
+      .style.transform = "translateX(" + (scale * (blocked + dns + connect + send)) + "px)";
+    $("#timings-summary-receive .requests-menu-timings-box")
+      .style.transform = "translateX(" + (scale * (blocked + dns + connect + send + wait)) + "px)";
+
+    $("#timings-summary-dns .requests-menu-timings-total")
+      .style.transform = "translateX(" + (scale * blocked) + "px)";
+    $("#timings-summary-connect .requests-menu-timings-total")
+      .style.transform = "translateX(" + (scale * (blocked + dns)) + "px)";
+    $("#timings-summary-send .requests-menu-timings-total")
+      .style.transform = "translateX(" + (scale * (blocked + dns + connect)) + "px)";
+    $("#timings-summary-wait .requests-menu-timings-total")
+      .style.transform = "translateX(" + (scale * (blocked + dns + connect + send)) + "px)";
+    $("#timings-summary-receive .requests-menu-timings-total")
+      .style.transform = "translateX(" + (scale * (blocked + dns + connect + send + wait)) + "px)";
+  },
+
+  /**
+   * Sets the preview for HTML responses shown in this view.
+   *
+   * @param object aResponse
+   *        The message received from the server.
+   * @return object
+   *        A promise that is resolved when the html preview is rendered.
+   */
+  _setHtmlPreview: Task.async(function*(aResponse) {
+    if (!aResponse) {
+      return promise.resolve();
+    }
+    let { text } = aResponse.content;
+    let responseBody = yield gNetwork.getString(text);
+
+    // Always disable JS when previewing HTML responses.
+    let iframe = $("#response-preview");
+    iframe.contentDocument.docShell.allowJavascript = false;
+    iframe.contentDocument.documentElement.innerHTML = responseBody;
+
+    window.emit(EVENTS.RESPONSE_HTML_PREVIEW_DISPLAYED);
+  }),
+
+  /**
+   * Sets the security information shown in this view.
+   *
+   * @param object securityInfo
+   *        The data received from server
+   * @param string url
+   *        The URL of this request
+   * @return object
+   *        A promise that is resolved when the security info is rendered.
+   */
+  _setSecurityInfo: Task.async(function* (securityInfo, url) {
+    if (!securityInfo) {
+      // We don't have security info. This could mean one of two things:
+      // 1) This connection is not secure and this tab is not visible and thus
+      //    we shouldn't be here.
+      // 2) We have already received securityState and the tab is visible BUT
+      //    the rest of the information is still on its way. Once it arrives
+      //    this method is called again.
+      return;
+    }
+
+    /**
+     * A helper that sets value and tooltiptext attributes of an element to
+     * specified value.
+     *
+     * @param string selector
+     *        A selector for the element.
+     * @param string value
+     *        The value to set. If this evaluates to false a placeholder string
+     *        <Not Available> is used instead.
+     */
+    function setValue(selector, value) {
+      let label = $(selector);
+      if (!value) {
+        label.setAttribute("value", L10N.getStr("netmonitor.security.notAvailable"));
+        label.setAttribute("tooltiptext", label.getAttribute("value"));
+      } else {
+        label.setAttribute("value", value);
+        label.setAttribute("tooltiptext", value);
+      }
+    }
+
+    let errorbox = $("#security-error");
+    let infobox = $("#security-information");
+
+    if (securityInfo.state === "secure" || securityInfo.state === "weak") {
+      infobox.hidden = false;
+      errorbox.hidden = true;
+
+      // Warning icons
+      let cipher = $("#security-warning-cipher");
+
+      if (securityInfo.state === "weak") {
+        cipher.hidden = securityInfo.weaknessReasons.indexOf("cipher") === -1;
+      } else {
+        cipher.hidden = true;
+      }
+
+      let enabledLabel = L10N.getStr("netmonitor.security.enabled");
+      let disabledLabel = L10N.getStr("netmonitor.security.disabled");
+
+      // Connection parameters
+      setValue("#security-protocol-version-value", securityInfo.protocolVersion);
+      setValue("#security-ciphersuite-value", securityInfo.cipherSuite);
+
+      // Host header
+      let domain = utils.getUriHostPort(url);
+      let hostHeader = L10N.getFormatStr("netmonitor.security.hostHeader", domain);
+      setValue("#security-info-host-header", hostHeader);
+
+      // Parameters related to the domain
+      setValue("#security-http-strict-transport-security-value",
+                securityInfo.hsts ? enabledLabel : disabledLabel);
+
+      setValue("#security-public-key-pinning-value",
+                securityInfo.hpkp ? enabledLabel : disabledLabel);
+
+      // Certificate parameters
+      let cert = securityInfo.cert;
+      setValue("#security-cert-subject-cn", cert.subject.commonName);
+      setValue("#security-cert-subject-o", cert.subject.organization);
+      setValue("#security-cert-subject-ou", cert.subject.organizationalUnit);
+
+      setValue("#security-cert-issuer-cn", cert.issuer.commonName);
+      setValue("#security-cert-issuer-o", cert.issuer.organization);
+      setValue("#security-cert-issuer-ou", cert.issuer.organizationalUnit);
+
+      setValue("#security-cert-validity-begins", cert.validity.start);
+      setValue("#security-cert-validity-expires", cert.validity.end);
+
+      setValue("#security-cert-sha1-fingerprint", cert.fingerprint.sha1);
+      setValue("#security-cert-sha256-fingerprint", cert.fingerprint.sha256);
+    } else {
+      infobox.hidden = true;
+      errorbox.hidden = false;
+
+      // Strip any HTML from the message.
+      let plain = DOMParser.parseFromString(securityInfo.errorMessage, "text/html");
+      setValue("#security-error-message", plain.body.textContent);
+    }
+  }),
+
+  /**
+   * Shows raw request/response headers in textboxes.
+   */
+  toggleRawHeaders: function() {
+    let rawHeadersHidden = $("#raw-headers").getAttribute("hidden");
+
+    if (rawHeadersHidden) {
+      $("#raw-headers").hidden = false;
+    } else {
+      $("#raw-headers").hidden = true;
+    }
+  },
+
+  _dataSrc: null,
+  _headers: null,
+  _cookies: null,
+  _params: null,
+  _json: null,
+  _paramsQueryString: "",
+  _paramsFormData: "",
+  _paramsPostPayload: "",
+  _requestHeaders: "",
+  _responseHeaders: "",
+  _requestCookies: "",
+  _responseCookies: "",
+
+  toString: () => "[object NetworkDetailsView]"
+};
+
+NetMonitorView.NetworkDetails = new NetworkDetailsView();
diff --git a/browser/devtools/netmonitor/views/request-context-view.js b/browser/devtools/netmonitor/views/request-context-view.js
new file mode 100644
index 0000000..9632735
--- /dev/null
+++ b/browser/devtools/netmonitor/views/request-context-view.js
@@ -0,0 +1,105 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+"use strict";
+
+const RequestContextView = {
+  /**
+   * Sets up RequestMenu's Context view. Should be called after the EVENTS.CONNECTED
+   * event, so can be called from RequestMenu._onConnect, so we can get the
+   * actor's traits.
+   */
+  initialize: function () {
+    this._menu = $("#network-request-popup");
+    this._separator = $("#request-menu-context-separator");
+    this._cmdNewTab = $("#request-menu-context-newtab");
+    this._cmdCopyURL = $("#request-menu-context-copy-url");
+    this._cmdCopyCurl = $("#request-menu-context-copy-as-curl");
+    this._cmdCopyImage = $("#request-menu-context-copy-image-as-data-uri");
+    this._cmdResend = $("#request-menu-context-resend");
+
+    this._menu.addEventListener("popupshowing", this._onShow, false);
+    this._cmdNewTab.addEventListener("command", this._onNewTab, false);
+    this._cmdCopyURL.addEventListener("command", this._onCopyURL, false);
+    this._cmdCopyCurl.addEventListener("command", this._onCopyCurl, false);
+    this._cmdCopyImage.addEventListener("command", this._onCopyImage, false);
+
+    if (NetMonitorController.supportsCustomRequest) {
+      this._cmdResend.addEventListener("command", this._onResend, false);
+    } else {
+      this._cmdResend.hidden = true;
+    }
+  },
+
+  /**
+   * Cleans up events.
+   */
+  destroy: function () {
+    this._menu.removeEventListener("popupshowing", this._onShow, false);
+    this._cmdNewTab.removeEventListener("command", this._onNewTab, false);
+    this._cmdCopyURL.removeEventListener("command", this._onCopyURL, false);
+    this._cmdCopyCurl.removeEventListener("command", this._onCopyCurl, false);
+    this._cmdCopyImage.removeEventListener("command", this._onCopyImage, false);
+
+    if (NetMonitorController.supportsCustomRequest) {
+      this._cmdResend.removeEventListener("command", this._onResend, false);
+    }
+  },
+
+  /**
+   * Displays the appropriate options for the currently selected request
+   * in the context menu.
+   */
+  _onShow: function () {
+    let request = NetMonitorView.RequestsMenu.selectedRequest;
+
+    this._cmdNewTab.hidden = !request;
+    this._cmdCopyURL.hidden = !request;
+    this._cmdCopyCurl.hidden = !request || !request.responseContent;
+    this._cmdCopyImage.hidden = !request || !request.responseContent || !request.responseContent.content.mimeType.contains("image/");
+    this._cmdResend.hidden = !NetMonitorController.supportsCustomRequest || !request || request.isCustom;
+
+    this._separator.hidden = !request;
+  },
+
+  /**
+   * Opens selected request in new tab.
+   */
+  _onNewTab: function () {
+    let request = NetMonitorView.RequestsMenu.selectedRequest;
+    let win = Services.wm.getMostRecentWindow("navigator:browser");
+    win.openUILinkIn(request.url, "tab", { relatedToCurrent: true });
+  },
+
+  /**
+   * Copies the current request's URL to the clipboard.
+   */
+  _onCopyURL: function () {
+    let request = NetMonitorView.RequestsMenu.selectedRequest;
+    clipboardHelper.copyString(request.url, document);
+  },
+
+  /**
+   * Copies the request's cURL form to the clipboard.
+   */
+  _onCopyCurl: Task.async(function*() {
+    let request = NetMonitorView.RequestsMenu.selectedRequest;
+    let curlString = yield request.toCurlString();
+    clipboardHelper.copyString(curlString, document);
+  }),
+  
+  /**
+   * Copies the request's cURL form to the clipboard.
+   */
+  _onCopyImage: Task.async(function*() {
+    let request = NetMonitorView.RequestsMenu.selectedRequest;
+    let dataURIString = yield request.toDataURI();
+    clipboardHelper.copyString(dataURIString, document);
+  }),
+
+  _onResend: function () {
+    NetMonitorView.Sidebar.showCustom();
+  }
+};
+
+NetMonitorView.ContextMenu = RequestContextView;
diff --git a/browser/devtools/netmonitor/views/requests-view.js b/browser/devtools/netmonitor/views/requests-view.js
new file mode 100644
index 0000000..01150c6
--- /dev/null
+++ b/browser/devtools/netmonitor/views/requests-view.js
@@ -0,0 +1,427 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+"use strict";
+
+const { TableRenderer } = require("devtools/netmonitor/table-renderer");
+const { SummaryRenderer } = require("devtools/netmonitor/summary-renderer");
+const { Tooltip } = require("devtools/shared/widgets/Tooltip");
+const RESIZE_REFRESH_RATE = 50; // ms
+const REQUESTS_TOOLTIP_POSITION = "topcenter bottomleft";
+const REQUESTS_TOOLTIP_IMAGE_MAX_DIM = 400; // px
+const REQUEST_TIME_DECIMALS = 2;
+const HEADERS_SIZE_DECIMALS = 3;
+const CONTENT_SIZE_DECIMALS = 2;
+const FREETEXT_FILTER_SEARCH_DELAY = 200; // ms
+
+/**
+ * Functions handling the requests menu (containing details about each request,
+ * like status, method, file, domain, as well as a waterfall representing
+ * timing imformation).
+ */
+function RequestsMenuView() {
+  dumpn("RequestsMenuView was instantiated");
+
+  this._onSelect = this._onSelect.bind(this);
+  this._onFilterSelection = this._onFilterSelection.bind(this);
+  this._onRequestUpdate = this._onRequestUpdate.bind(this);
+  this._onRequestAdd = this._onRequestAdd.bind(this);
+  this._onResize = this._onResize.bind(this);
+  this._onSidebarToggled = this._onSidebarToggled.bind(this);
+  this._onSecurityIconClick = this._onSecurityIconClick.bind(this);
+  this._onURLFilter = this._onURLFilter.bind(this);
+  this.setURLFilter = this.setURLFilter.bind(this);
+
+  this.userInputTimer = Cc["@mozilla.org/timer;1"].createInstance(Ci.nsITimer);
+}
+
+RequestsMenuView.prototype = Heritage.extend(WidgetMethods, {
+  /**
+   * Initialization function, called when the network monitor is started.
+   */
+  initialize: function() {
+
+    dumpn("Initializing the RequestsMenuView");
+
+    this._splitter = $("#network-inspector-view-splitter");
+
+    // Create tooltip for hovering over an image request.
+    this.tooltip = new Tooltip(document, {
+      closeOnEvents: [{
+        emitter: $("#requests-menu-contents"),
+        event: "scroll",
+        useCapture: true
+      }]
+    });
+
+    this.freetextFilterBox = $("#requests-menu-filter-freetext-text");
+
+    this.tableRenderer = new TableRenderer($("#requests-menu-contents"), RequestCollection, gNetwork);
+    RequestCollection.on("change", this._onRequestUpdate);
+    RequestCollection.on("add", this._onRequestAdd);
+    RequestCollection.on("filtered", this._onFilterUpdate);
+    this.tableRenderer.on("select", this._onSelect);
+
+    this.summaryRenderer = new SummaryRenderer($("#requests-menu-network-summary-label"), RequestCollection);
+    Prefs.filters.forEach(type => this._onFilterSelection(type));
+
+    $("#toolbar-labels").addEventListener("click", this.requestsMenuSortEvent, false);
+    $("#requests-menu-footer").addEventListener("click", this.requestsMenuFilterEvent, false);
+    this._splitter.addEventListener("mousemove", this._onResize, false);
+    this.freetextFilterBox.addEventListener("input", this._onURLFilter, false);
+    this.freetextFilterBox.addEventListener("command", this._onURLFilter, false);
+    window.addEventListener("resize", this._onResize, false);
+    window.on(EVENTS.SIDEBAR_TOGGLED, this._onSidebarToggled);
+
+    this.requestsMenuSortEvent = utils.getKeyWithEvent(this.sortBy.bind(this));
+    this.requestsMenuFilterEvent = utils.getKeyWithEvent(this._onFilterSelection.bind(this));
+    this._onContextPerfCommand = () => NetMonitorView.toggleFrontendMode();
+
+    window.once("connected", this._onConnect.bind(this));
+  },
+
+  _onConnect: function() {
+    // Wait until after the actor is connected to set up the context menu,
+    // as there's some feature detection involved.
+    NetMonitorView.ContextMenu.initialize();
+
+    if (NetMonitorController.supportsPerfStats) {
+      $("#request-menu-context-perf").addEventListener("command", this._onContextPerfCommand, false);
+      $("#requests-menu-perf-notice-button").addEventListener("command", this._onContextPerfCommand, false);
+      $("#requests-menu-network-summary-button").addEventListener("command", this._onContextPerfCommand, false);
+      $("#requests-menu-network-summary-label").addEventListener("click", this._onContextPerfCommand, false);
+      $("#network-statistics-back-button").addEventListener("command", this._onContextPerfCommand, false);
+    } else {
+      $("#notice-perf-message").hidden = true;
+      $("#request-menu-context-perf").hidden = true;
+      $("#requests-menu-network-summary-button").hidden = true;
+      $("#requests-menu-network-summary-label").hidden = true;
+    }
+
+    if (!NetMonitorController.supportsTransferredResponseSize) {
+      $("#requests-menu-transferred-header-box").hidden = true;
+      $("#requests-menu-item-template .requests-menu-transferred").hidden = true;
+    }
+  },
+
+  /**
+   * Destruction function, called when the network monitor is closed.
+   */
+  destroy: Task.async(function*() {
+    dumpn("Destroying the SourcesView");
+
+    Prefs.filters = RequestCollection.getFilters();
+
+    yield this.tableRenderer.destroy();
+    yield NetMonitorView.ContextMenu.destroy();
+
+    RequestCollection.off("change", this._onRequestUpdate);
+    RequestCollection.off("add", this._onRequestAdd);
+    this._splitter.removeEventListener("mousemove", this._onResize, false);
+    this.freetextFilterBox.removeEventListener("input", this._onURLFilter, false);
+    this.freetextFilterBox.removeEventListener("command", this._onURLFilter, false);
+    this.userInputTimer.cancel();
+    window.removeEventListener("resize", this._onResize, false);
+    window.off(EVENTS.SIDEBAR_TOGGLED, this._onSidebarToggled);
+
+    $("#toolbar-labels").removeEventListener("click", this.requestsMenuSortEvent, false);
+    $("#requests-menu-footer").removeEventListener("click", this.requestsMenuFilterEvent, false);
+    $("#request-menu-context-perf").removeEventListener("command", this._onContextPerfCommand, false);
+
+    $("#requests-menu-perf-notice-button").removeEventListener("command", this._onContextPerfCommand, false);
+    $("#requests-menu-network-summary-button").removeEventListener("command", this._onContextPerfCommand, false);
+    $("#requests-menu-network-summary-label").removeEventListener("click", this._onContextPerfCommand, false);
+    $("#network-statistics-back-button").removeEventListener("command", this._onContextPerfCommand, false);
+  }),
+
+  /**
+   * Specifies if this view may be updated lazily. Currently a proxy for
+   * the table renderer.
+   */
+  set lazyUpdate(value) {
+    this.tableRenderer.lazyUpdate = value;
+  },
+  get lazyUpdate() {
+    return this.tableRenderer.lazyUpdate;
+  },
+
+  /**
+   * Called when a Request instance's property is updated.
+   */
+  _onRequestUpdate: function (model, prop, value) {
+    refreshNetworkDetailsPaneIfNecessary(model);
+  },
+
+  /**
+   * Called when a Request instance is created. Initializes the view.
+   */
+  _onRequestAdd: function ({ id, cloned }) {
+    $("#requests-menu-empty-notice").hidden = true;
+  },
+
+  /**
+   * Called when the table emits a "select" event.
+   */
+  _onSelect: function (model) {
+    this.selectedRequest = model;
+    if (model) {
+      NetMonitorView.Sidebar.showDetails();
+      NetMonitorView.Sidebar.toggle(true);
+    } else {
+      NetMonitorView.Sidebar.toggle(false);
+    }
+  },
+
+  /**
+   * The following methods are used to
+   * interface with the table renderer to manipulate the selected request.
+   */
+  selectFirstRequest: function () {
+    this.tableRenderer.selectFirstRequest();
+  },
+
+  unselectRequest: function () {
+    this.tableRenderer.unselectRequest();
+  },
+
+  selectRequest: function (modelOrId) {
+    this.tableRenderer.selectRequest(modelOrId.id != null ? modelOrId.id : modelOrId);
+  },
+
+  selectRequestByIndex: function (index) {
+    this.tableRenderer.selectRequestByIndex(index);
+  },
+
+  /**
+   * Gets the currently selected request model.
+   */
+  getSelected: function () {
+    return this.selectedRequest;
+  },
+
+  /**
+   * Return current selected index. Used in tests.
+   */
+  getSelectedIndex: function () {
+    return this.tableRenderer.getSelectedIndex();
+  },
+
+  /**
+   * Aliases for previous ViewHelper way of selecting or
+   * returning selected index.
+   * Used to avoid rewriting all tests.
+   * TODO update tests so this isnt needed.
+   */
+  set selectedIndex(val) {
+    this.selectRequestByIndex(val);
+  },
+  get selectedIndex() {
+    return this.getSelectedIndex();
+  },
+  getItemAtIndex: function (i) {
+    return this.tableRenderer.getItemAtIndex(i);
+  },
+  get itemCount() {
+    return RequestCollection.length;
+  },
+
+  /**
+   * Sets the URL filter for all requests. Called after being debounced
+   * by _onURLFilter.
+   */
+  setURLFilter: function () {
+    RequestCollection.setURLFilter(this._currentFreetextFilter);
+  },
+
+  /**
+   * Handles the timeout on the freetext filter textbox
+   */
+  _onURLFilter: function () {
+    this.userInputTimer.cancel();
+    this._currentFreetextFilter = this.freetextFilterBox.value || "";
+    if (this._currentFreetextFilter.length === 0) {
+      this.freetextFilterBox.removeAttribute("filled");
+    } else {
+      this.freetextFilterBox.setAttribute("filled", true);
+    }
+    this.userInputTimer.initWithCallback(this.setURLFilter, FREETEXT_FILTER_SEARCH_DELAY, Ci.nsITimer.TYPE_ONE_SHOT);
+  },
+
+  /**
+   * Filters all network requests in this container by a specified type.
+   * Sets the RequestCollection appropriately and updates the button state.
+   *
+   * @param string aType
+   *        Either "all", "html", "css", "js", "xhr", "fonts", "images", "media"
+   *        "flash" or "other".
+   */
+  _onFilterSelection: function (aType = "all") {
+    if (RequestCollection.hasFilter(aType)) {
+      RequestCollection.removeFilter(aType);
+    } else {
+      RequestCollection.addFilter(aType);
+    }
+  },
+
+  /**
+   * Same as `filterOn`, except that it only allows a single type exclusively.
+   *
+   * @param string aType
+   *        @see RequestsMenuView.prototype.fitlerOn
+   */
+  filterOnlyOn: function(aType = "all") {
+    RequestCollection.setFilter(aType);
+  },
+
+  /**
+   * Updates filter buttons based on RequestCollection filter state, triggered
+   * by `filtered` event on RequestCollection.
+   */
+  _onFilterUpdate: function () {
+    for (let button of $$(".requests-menu-filter-button")) {
+      if (RequestCollection.hasFilter(button.getAttribute("data-key"))) {
+        button.setAttribute("checked", true);
+      } else {
+        button.removeAttribute("checked");
+      }
+    }
+  },
+
+  /**
+   * Sorts all network requests in this container by a specified detail.
+   *
+   * @param string aType
+   *        Either "status", "method", "file", "domain", "type", "transferred",
+   *        "size" or "waterfall".
+   */
+  sortBy: function(aType = "waterfall") {
+    let target = $("#requests-menu-" + aType + "-button");
+    let headers = document.querySelectorAll(".requests-menu-header-button");
+
+    for (let header of headers) {
+      if (header != target) {
+        header.removeAttribute("sorted");
+        header.removeAttribute("tooltiptext");
+      }
+    }
+
+    let direction = "";
+    if (target) {
+      if (target.getAttribute("sorted") == "ascending") {
+        target.setAttribute("sorted", direction = "descending");
+        target.setAttribute("tooltiptext", L10N.getStr("networkMenu.sortedDesc"));
+      } else {
+        target.setAttribute("sorted", direction = "ascending");
+        target.setAttribute("tooltiptext", L10N.getStr("networkMenu.sortedAsc"));
+      }
+    }
+
+    // Sorts the models themselves
+    RequestCollection.sortBy(aType, direction === "descending");
+  },
+
+  /**
+   * Attaches security icon click listener for the given request menu item.
+   *
+   * @param object item
+   *        The network request item to attach the listener to.
+   */
+  attachSecurityIconClickListener: function ({ target }) {
+    let icon = $(".requests-security-state-icon", target);
+    icon.addEventListener("click", this._onSecurityIconClick);
+  },
+
+  /**
+   * A handler that opens the security tab in the details view if secure or
+   * broken security indicator is clicked.
+   */
+  _onSecurityIconClick: function(e) {
+    let state = this.selectedItem.attachment.securityState;
+    if (state !== "insecure") {
+      // Choose the security tab.
+      NetMonitorView.NetworkDetails.widget.selectedIndex = 5;
+    }
+  },
+
+  /**
+   * The resize listener for this container's window.
+   */
+  _onResize: function(e) {
+    // Allow requests to settle down first.
+    setNamedTimeout(
+      "resize-events", RESIZE_REFRESH_RATE, () => this.tableRenderer.refreshWaterfall(true));
+  },
+
+  /**
+   * Called when the sidebar is toggled.
+   */
+  _onSidebarToggled: function () {
+    this.refreshWaterfall(true);
+  },
+
+  /**
+   * The predicate used when deciding whether a popup should be shown
+   * over a request item or not.
+   *
+   * @param nsIDOMNode aTarget
+   *        The element node currently being hovered.
+   * @param object aTooltip
+   *        The current tooltip instance.
+   */
+  _onHover: function(aTarget, aTooltip) {
+    let requestItem = this.getItemForElement(aTarget);
+    if (!requestItem || !requestItem.attachment.responseContent) {
+      return;
+    }
+
+    let hovered = requestItem.attachment;
+    let { url } = hovered;
+    let { mimeType, text, encoding } = hovered.responseContent.content;
+
+    if (mimeType && mimeType.contains("image/") && (
+      aTarget.classList.contains("requests-menu-icon") ||
+      aTarget.classList.contains("requests-menu-file")))
+    {
+      return gNetwork.getString(text).then(aString => {
+        let anchor = this.$(".requests-menu-icon", requestItem.target);
+        let src = "data:" + mimeType + ";" + encoding + "," + aString;
+        aTooltip.setImageContent(src, { maxDim: REQUESTS_TOOLTIP_IMAGE_MAX_DIM });
+        return anchor;
+      });
+    }
+  },
+
+  /**
+   * Calls the table renderer's refreshWaterfall function,
+   * taking an optional boolean `reset` indicating whether or not
+   * the bounding box of the waterfall has changed.
+   */
+  refreshWaterfall: function (reset) {
+    this.tableRenderer.refreshWaterfall(reset);
+  },
+
+  _splitter: null,
+
+  _currentFreetextFilter: "",
+
+  toString: () => "[object RequestsMenuView]"
+});
+
+/**
+ * Refreshes the information displayed in the sidebar, in case this update
+ * may have additional information about a request which isn't shown yet
+ * in the network details pane.
+ *
+ * @param object aRequestItem
+ *        The item to repopulate the sidebar with in case it's selected in
+ *        this requests menu.
+ */
+function refreshNetworkDetailsPaneIfNecessary(requestModel) {
+  let selected = NetMonitorView.RequestsMenu.selectedRequest;
+  if (selected === requestModel) {
+    NetMonitorView.Sidebar.showDetails(requestModel);
+  }
+}
+
+
+NetMonitorView.RequestsMenu = new RequestsMenuView();
diff --git a/browser/devtools/netmonitor/views/sidebar-view.js b/browser/devtools/netmonitor/views/sidebar-view.js
new file mode 100644
index 0000000..ed093b4
--- /dev/null
+++ b/browser/devtools/netmonitor/views/sidebar-view.js
@@ -0,0 +1,158 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+"use strict";
+
+const COLLAPSE_PANE_STRING = L10N.getStr("collapseDetailsPane");
+const EXPAND_PANE_STRING = L10N.getStr("expandDetailsPane");
+
+/**
+ * Functions handling the sidebar details view.
+ */
+function SidebarView() {
+  dumpn("SidebarView was instantiated");
+}
+
+SidebarView.prototype = {
+  initialize: Task.async(function*() {
+    this._body = $("#body");
+    this._detailsPane = $("#details-pane");
+    this._detailsPaneToggleButton = $("#details-pane-toggle");
+    this._onTogglePanesPressed = this._onTogglePanesPressed.bind(this);
+    this._onReset = this._onReset.bind(this);
+    this._onAdd = this._onAdd.bind(this);
+
+    // Set up pane
+    this._detailsPane.setAttribute("width", Prefs.networkDetailsWidth);
+    this._detailsPane.setAttribute("height", Prefs.networkDetailsHeight);
+    this._detailsPaneToggleButton.disabled = true;
+    this.toggle(false);
+
+    this._detailsPaneToggleButton.addEventListener("mousedown", this._onTogglePanesPressed, false);
+    RequestCollection.on("reset", this._onReset);
+    RequestCollection.on("add", this._onAdd);
+    yield NetMonitorView.NetworkDetails.initialize();
+  }),
+
+  destroy: Task.async(function*() {
+             console.log("SIDEBAR****DESTRoY");
+    Prefs.networkDetailsWidth = this._detailsPane.getAttribute("width");
+    Prefs.networkDetailsHeight = this._detailsPane.getAttribute("height");
+
+    this._detailsPaneToggleButton.removeEventListener("mousedown", this._onTogglePanesPressed, false);
+    RequestCollection.off("reset", this._onReset);
+    RequestCollection.off("add", this._onAdd);
+
+    this._detailsPane = null;
+    this._detailsPaneToggleButton = null;
+    yield NetMonitorView.NetworkDetails.destroy();
+  }),
+
+  /**
+   * Gets the visibility state of the network details pane.
+   * @return boolean
+   */
+  get detailsPaneHidden() {
+    return this._detailsPane.hasAttribute("pane-collapsed");
+  },
+
+  /**
+   * Sets the network details pane hidden or visible.
+   *
+   * @param boolean isVisibleaFlags
+   *        true if the pane should be shown, false to hide
+   * @param number aTabIndex [optional]
+   *        The index of the intended selected tab in the details pane.
+   */
+  toggle: function(isVisible, aTabIndex) {
+    let pane = this._detailsPane;
+    let button = this._detailsPaneToggleButton;
+
+    let callback = () => window.emit(EVENTS.SIDEBAR_TOGGLED, isVisible);
+
+    ViewHelpers.togglePane({ visible: isVisible, callback: callback }, pane);
+
+    if (isVisible) {
+      this._body.removeAttribute("pane-collapsed");
+      button.removeAttribute("pane-collapsed");
+      button.setAttribute("tooltiptext", COLLAPSE_PANE_STRING);
+    } else {
+      this._body.setAttribute("pane-collapsed", "");
+      button.setAttribute("pane-collapsed", "");
+      button.setAttribute("tooltiptext", EXPAND_PANE_STRING);
+    }
+
+    if (aTabIndex !== undefined) {
+      $("#event-details-pane").selectedIndex = aTabIndex;
+    }
+  },
+
+  /**
+   * Populates this view with the specified data.
+   *
+   * @param object data
+   *        The data source (this should be the attachment of a request item).
+   * @return object
+   *        Returns a promise that resolves upon population of the subview.
+   */
+  populate: Task.async(function*(data) {
+    if (!data) {
+      data = NetMonitorView.RequestsMenu.selectedRequest || {};
+    }
+    if (this._detailsPane.selectedIndex == 0) {
+      yield NetMonitorView.CustomRequest.populate(data);
+    } else {
+      yield NetMonitorView.NetworkDetails.populate(data);
+    }
+
+    window.emit(EVENTS.SIDEBAR_POPULATED);
+  }),
+
+  /**
+   * Shows the detailed view of the selected request.
+   */
+  showDetails: function () {
+    this._detailsPane.selectedIndex = 1;
+    this.populate();
+  },
+
+  /**
+   * Shows the custom resend request view of the selected request.
+   */
+  showCustom: function () {
+    this._detailsPane.selectedIndex = 0;
+    this.populate();
+  },
+
+  /**
+   * Called when RequestCollection gets a new request. Ensures the view is ready.
+   */
+  _onAdd: function () {
+    $("#details-pane-toggle").disabled = false;
+  },
+
+  /**
+   * Called when RequestCollection is reset. Resets the view.
+   */
+  _onReset: function () {
+    this._detailsPaneToggleButton.disabled = true;
+    this.toggle(false);
+  },
+
+  /**
+   * Handler for the toggle button. Opens the sidebar if its closed,
+   * and selects a request if none are selected. Otherwise, closes
+   * the sidebar.
+   */
+  _onTogglePanesPressed: function () {
+    if (this.detailsPaneHidden) {
+      // If the sidebar is hidden, select the first request in requests view
+      NetMonitorView.RequestsMenu.selectFirstRequest();
+    } else {
+      // If it's already visible, this means we have a request selected, so unselect it.
+      NetMonitorView.RequestsMenu.unselectRequest();
+    }
+  }
+};
+
+NetMonitorView.Sidebar = new SidebarView();
-- 
2.2.1

