# HG changeset patch
# User Brian Grinstead <bgrinstead@mozilla.com>
# Parent  abcf8ad65a03c239fc79bbf1e641bae412545960
Bug 1425874 - WIP - Make <marquee> an actual tag

See http://w3c-test.org/html/obsolete/requirements-for-implementations/the-marquee-element-0/
MozReview-Commit-ID: 5K2UWowUr7b

diff --git a/dom/base/nsGkAtomList.h b/dom/base/nsGkAtomList.h
--- a/dom/base/nsGkAtomList.h
+++ b/dom/base/nsGkAtomList.h
@@ -164,16 +164,17 @@ GK_ATOM(background, "background")
 GK_ATOM(base, "base")
 GK_ATOM(basefont, "basefont")
 GK_ATOM(baseline, "baseline")
 GK_ATOM(bdi, "bdi")
 GK_ATOM(bdo, "bdo")
 GK_ATOM(before, "before")
 GK_ATOM(before_end, "before_end")
 GK_ATOM(before_start, "before_start")
+GK_ATOM(behavior, "behavior")
 GK_ATOM(below, "below")
 GK_ATOM(bgcolor, "bgcolor")
 GK_ATOM(bgsound, "bgsound")
 GK_ATOM(big, "big")
 GK_ATOM(binding, "binding")
 GK_ATOM(bindings, "bindings")
 GK_ATOM(bindToUntrustedContent, "bindToUntrustedContent")
 GK_ATOM(blankrow, "blankrow")
@@ -1217,24 +1218,27 @@ GK_ATOM(scan, "scan")
 GK_ATOM(scheme, "scheme")
 GK_ATOM(scope, "scope")
 GK_ATOM(scoped, "scoped")
 GK_ATOM(screen, "screen")
 GK_ATOM(screenX, "screenX")
 GK_ATOM(screenY, "screenY")
 GK_ATOM(script, "script")
 GK_ATOM(scriptEnabledBeforePrintOrPreview, "scriptEnabledBeforePrintOrPreview")
+GK_ATOM(scroll, "scroll")
+GK_ATOM(scrollamount, "scrollamount")
 GK_ATOM(scrollbar, "scrollbar")
 GK_ATOM(scrollbarbutton, "scrollbarbutton")
 GK_ATOM(scrollbarDownBottom, "scrollbar-down-bottom")
 GK_ATOM(scrollbarDownTop, "scrollbar-down-top")
 GK_ATOM(scrollbarUpBottom, "scrollbar-up-bottom")
 GK_ATOM(scrollbarUpTop, "scrollbar-up-top")
 GK_ATOM(scrollbox, "scrollbox")
 GK_ATOM(scrollcorner, "scrollcorner")
+GK_ATOM(scrolldelay, "scrolldelay")
 GK_ATOM(scrolling, "scrolling")
 GK_ATOM(scrollPosition, "scroll-position")
 GK_ATOM(section, "section")
 GK_ATOM(select, "select")
 GK_ATOM(selectable, "selectable")
 GK_ATOM(selected, "selected")
 GK_ATOM(selectedIndex, "selectedIndex")
 GK_ATOM(selectedindex, "selectedindex")
@@ -1249,16 +1253,17 @@ GK_ATOM(showresizer, "showresizer")
 GK_ATOM(simple, "simple")
 GK_ATOM(simp_chinese_formal, "simp-chinese-formal")
 GK_ATOM(simp_chinese_informal, "simp-chinese-informal")
 GK_ATOM(single, "single")
 GK_ATOM(size, "size")
 GK_ATOM(sizes, "sizes")
 GK_ATOM(sizemode, "sizemode")
 GK_ATOM(sizetopopup, "sizetopopup")
+GK_ATOM(slide, "slide")
 GK_ATOM(slider, "slider")
 GK_ATOM(small, "small")
 GK_ATOM(smooth, "smooth")
 GK_ATOM(snap, "snap")
 GK_ATOM(sort, "sort")
 GK_ATOM(sortActive, "sortActive")
 GK_ATOM(sortDirection, "sortDirection")
 GK_ATOM(sorted, "sorted")
@@ -1377,16 +1382,17 @@ GK_ATOM(treechildren, "treechildren")
 GK_ATOM(treecol, "treecol")
 GK_ATOM(treecolpicker, "treecolpicker")
 GK_ATOM(treecols, "treecols")
 GK_ATOM(treeitem, "treeitem")
 GK_ATOM(treerow, "treerow")
 GK_ATOM(treeseparator, "treeseparator")
 GK_ATOM(triple, "triple")
 GK_ATOM(_true, "true")
+GK_ATOM(truespeed, "truespeed")
 GK_ATOM(tt, "tt")
 GK_ATOM(tty, "tty")
 GK_ATOM(tv, "tv")
 GK_ATOM(type, "type")
 GK_ATOM(typemustmatch, "typemustmatch")
 GK_ATOM(u, "u")
 GK_ATOM(ul, "ul")
 GK_ATOM(underflow, "underflow")
diff --git a/dom/html/HTMLDivElement.cpp b/dom/html/HTMLDivElement.cpp
--- a/dom/html/HTMLDivElement.cpp
+++ b/dom/html/HTMLDivElement.cpp
@@ -29,86 +29,42 @@ HTMLDivElement::WrapNode(JSContext *aCx,
 
 bool
 HTMLDivElement::ParseAttribute(int32_t aNamespaceID,
                                nsAtom* aAttribute,
                                const nsAString& aValue,
                                nsIPrincipal* aMaybeScriptedPrincipal,
                                nsAttrValue& aResult)
 {
-  if (aNamespaceID == kNameSpaceID_None) {
-    if (mNodeInfo->Equals(nsGkAtoms::marquee)) {
-      if ((aAttribute == nsGkAtoms::width) ||
-          (aAttribute == nsGkAtoms::height)) {
-        return aResult.ParseSpecialIntValue(aValue);
-      }
-      if (aAttribute == nsGkAtoms::bgcolor) {
-        return aResult.ParseColor(aValue);
-      }
-      if ((aAttribute == nsGkAtoms::hspace) ||
-          (aAttribute == nsGkAtoms::vspace)) {
-        return aResult.ParseIntWithBounds(aValue, 0);
-      }
-    }
-
-    if (mNodeInfo->Equals(nsGkAtoms::div) &&
-        aAttribute == nsGkAtoms::align) {
-      return ParseDivAlignValue(aValue, aResult);
-    }
+  if (aNamespaceID == kNameSpaceID_None && aAttribute == nsGkAtoms::align) {
+    return ParseDivAlignValue(aValue, aResult);
   }
 
   return nsGenericHTMLElement::ParseAttribute(aNamespaceID, aAttribute, aValue,
                                               aMaybeScriptedPrincipal, aResult);
 }
 
 void
 HTMLDivElement::MapAttributesIntoRule(const nsMappedAttributes* aAttributes,
                                       GenericSpecifiedValues* aData)
 {
   nsGenericHTMLElement::MapDivAlignAttributeInto(aAttributes, aData);
   nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
 }
 
-static void
-MapMarqueeAttributesIntoRule(const nsMappedAttributes* aAttributes, GenericSpecifiedValues* aData)
-{
-  nsGenericHTMLElement::MapImageMarginAttributeInto(aAttributes, aData);
-  nsGenericHTMLElement::MapImageSizeAttributesInto(aAttributes, aData);
-  nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
-  nsGenericHTMLElement::MapBGColorInto(aAttributes, aData);
-}
-
 NS_IMETHODIMP_(bool)
 HTMLDivElement::IsAttributeMapped(const nsAtom* aAttribute) const
 {
-  if (mNodeInfo->Equals(nsGkAtoms::div)) {
-    static const MappedAttributeEntry* const map[] = {
-      sDivAlignAttributeMap,
-      sCommonAttributeMap
-    };
-    return FindAttributeDependence(aAttribute, map);
-  }
-  if (mNodeInfo->Equals(nsGkAtoms::marquee)) {
-    static const MappedAttributeEntry* const map[] = {
-      sImageMarginSizeAttributeMap,
-      sBackgroundColorAttributeMap,
-      sCommonAttributeMap
-    };
-    return FindAttributeDependence(aAttribute, map);
-  }
-
-  return nsGenericHTMLElement::IsAttributeMapped(aAttribute);
+  static const MappedAttributeEntry* const map[] = {
+    sDivAlignAttributeMap,
+    sCommonAttributeMap
+  };
+  return FindAttributeDependence(aAttribute, map);
 }
 
 nsMapRuleToAttributesFunc
 HTMLDivElement::GetAttributeMappingFunction() const
 {
-  if (mNodeInfo->Equals(nsGkAtoms::div)) {
-    return &MapAttributesIntoRule;
-  }
-  if (mNodeInfo->Equals(nsGkAtoms::marquee)) {
-    return &MapMarqueeAttributesIntoRule;
-  }
-  return nsGenericHTMLElement::GetAttributeMappingFunction();
+  return &MapAttributesIntoRule;
 }
 
 } // namespace dom
 } // namespace mozilla
diff --git a/dom/html/HTMLMarqueeElement.cpp b/dom/html/HTMLMarqueeElement.cpp
new file mode 100644
--- /dev/null
+++ b/dom/html/HTMLMarqueeElement.cpp
@@ -0,0 +1,124 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "HTMLMarqueeElement.h"
+#include "nsGenericHTMLElement.h"
+#include "nsStyleConsts.h"
+#include "nsMappedAttributes.h"
+#include "mozilla/dom/HTMLMarqueeElementBinding.h"
+
+NS_IMPL_NS_NEW_HTML_ELEMENT(Marquee)
+
+namespace mozilla {
+namespace dom {
+
+HTMLMarqueeElement::~HTMLMarqueeElement()
+{
+}
+
+NS_IMPL_ELEMENT_CLONE(HTMLMarqueeElement)
+
+JSObject*
+HTMLMarqueeElement::WrapNode(JSContext *aCx, JS::Handle<JSObject*> aGivenProto)
+{
+  return dom::HTMLMarqueeElementBinding::Wrap(aCx, this, aGivenProto);
+}
+
+bool
+HTMLMarqueeElement::ParseAttribute(int32_t aNamespaceID,
+                               nsAtom* aAttribute,
+                               const nsAString& aValue,
+                               nsIPrincipal* aMaybeScriptedPrincipal,
+                               nsAttrValue& aResult)
+{
+  if (aNamespaceID == kNameSpaceID_None) {
+    if ((aAttribute == nsGkAtoms::width) ||
+        (aAttribute == nsGkAtoms::height)) {
+      return aResult.ParseSpecialIntValue(aValue);
+    }
+    if (aAttribute == nsGkAtoms::bgcolor) {
+      return aResult.ParseColor(aValue);
+    }
+    if (aAttribute == nsGkAtoms::behavior) {
+      nsString alternateStr;
+      nsGkAtoms::alternate->ToString(alternateStr);
+      nsString slideStr;
+      nsGkAtoms::slide->ToString(slideStr);
+      nsString scrollStr;
+      nsGkAtoms::scroll->ToString(scrollStr);
+
+      if (nsContentUtils::EqualsIgnoreASCIICase(aValue, alternateStr)) {
+        aResult.ParseStringOrAtom(alternateStr);
+      } else if (nsContentUtils::EqualsIgnoreASCIICase(aValue, slideStr)) {
+        aResult.ParseStringOrAtom(slideStr);
+      } else {
+        aResult.ParseStringOrAtom(scrollStr);
+      }
+      return true;
+    }
+    if ((aAttribute == nsGkAtoms::hspace) ||
+        (aAttribute == nsGkAtoms::vspace)) {
+      return aResult.ParseIntWithBounds(aValue, 0);
+    }
+    if (aAttribute == nsGkAtoms::loop) {
+      return aResult.ParseIntWithBounds(aValue, -1);
+    }
+    if (aAttribute == nsGkAtoms::scrollamount) {
+      if (!aResult.ParseIntWithBounds(aValue, 0)/*|| aResult.GetIntegerValue() == 0*/) {
+        aResult.SetTo(kDefaultScrollAmount);
+      }
+      return true;
+    }
+    if (aAttribute == nsGkAtoms::scrolldelay) {
+      if (!aResult.ParseIntWithBounds(aValue, 0)/*|| aResult.GetIntegerValue() == 0*/) {
+        aResult.SetTo(kDefaultScrollDelayMS);
+      }
+      return true;
+    }
+  }
+
+  return nsGenericHTMLElement::ParseAttribute(aNamespaceID, aAttribute, aValue,
+                                              aMaybeScriptedPrincipal, aResult);
+}
+
+void
+HTMLMarqueeElement::MapAttributesIntoRule(const nsMappedAttributes* aAttributes, GenericSpecifiedValues* aData)
+{
+  nsGenericHTMLElement::MapImageMarginAttributeInto(aAttributes, aData);
+  nsGenericHTMLElement::MapImageSizeAttributesInto(aAttributes, aData);
+  nsGenericHTMLElement::MapCommonAttributesInto(aAttributes, aData);
+  nsGenericHTMLElement::MapBGColorInto(aAttributes, aData);
+}
+
+NS_IMETHODIMP_(bool)
+HTMLMarqueeElement::IsAttributeMapped(const nsAtom* aAttribute) const
+{
+  static const MappedAttributeEntry* const map[] = {
+    sImageMarginSizeAttributeMap,
+    sBackgroundColorAttributeMap,
+    sCommonAttributeMap
+  };
+  return FindAttributeDependence(aAttribute, map);
+}
+
+nsMapRuleToAttributesFunc
+HTMLMarqueeElement::GetAttributeMappingFunction() const
+{
+  return &MapAttributesIntoRule;
+}
+
+// These are still implemented as <method exposeToUntrusedContent="true"> in XBL:
+// void
+// HTMLMarqueeElement::Start()
+// {
+// }
+// void
+// HTMLMarqueeElement::Stop()
+// {
+// }
+
+} // namespace dom
+} // namespace mozilla
diff --git a/dom/html/HTMLMarqueeElement.h b/dom/html/HTMLMarqueeElement.h
new file mode 100644
--- /dev/null
+++ b/dom/html/HTMLMarqueeElement.h
@@ -0,0 +1,165 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+#ifndef HTMLMarqueeElement_h___
+#define HTMLMarqueeElement_h___
+
+#include "mozilla/Attributes.h"
+#include "nsGenericHTMLElement.h"
+#include "nsContentUtils.h"
+
+namespace mozilla {
+namespace dom {
+
+class HTMLMarqueeElement final : public nsGenericHTMLElement
+{
+public:
+  explicit HTMLMarqueeElement(already_AddRefed<mozilla::dom::NodeInfo>& aNodeInfo)
+    : nsGenericHTMLElement(aNodeInfo)
+  {
+  }
+
+  static const int kDefaultScrollAmount = 6;
+  static const int kDefaultScrollDelayMS = 85;
+
+  void GetBehavior(DOMString& aBehavior)
+  {
+    if (!mAttrsAndChildren.GetAttr(nsGkAtoms::behavior)) {
+      nsGkAtoms::scroll->ToString(aBehavior);
+    } else {
+      GetHTMLAttr(nsGkAtoms::behavior, aBehavior);
+    }
+  }
+  void SetBehavior(const nsAString& aBehavior)
+  {
+    nsString alternateStr;
+    nsGkAtoms::alternate->ToString(alternateStr);
+    nsString slideStr;
+    nsGkAtoms::slide->ToString(slideStr);
+    nsString scrollStr;
+    nsGkAtoms::scroll->ToString(scrollStr);
+    if (nsContentUtils::EqualsIgnoreASCIICase(aBehavior, alternateStr)) {
+      SetHTMLAttr(nsGkAtoms::behavior, alternateStr);
+    } else if (nsContentUtils::EqualsIgnoreASCIICase(aBehavior, slideStr)) {
+      SetHTMLAttr(nsGkAtoms::behavior, slideStr);
+    } else {
+      SetHTMLAttr(nsGkAtoms::behavior, scrollStr);
+    }
+  }
+  void GetBgColor(DOMString& aBgColor)
+  {
+    GetHTMLAttr(nsGkAtoms::bgcolor, aBgColor);
+  }
+  void SetBgColor(const nsAString& aBgColor)
+  {
+    SetHTMLAttr(nsGkAtoms::bgcolor, aBgColor);
+  }
+  void GetDirection(DOMString& aDirection)
+  {
+    GetHTMLAttr(nsGkAtoms::direction, aDirection);
+  }
+  void SetDirection(const nsAString& aDirection)
+  {
+    SetHTMLAttr(nsGkAtoms::direction, aDirection);
+  }
+  void GetHeight(DOMString& aHeight)
+  {
+    GetHTMLAttr(nsGkAtoms::height, aHeight);
+  }
+  void SetHeight(const nsAString& aHeight)
+  {
+    SetHTMLAttr(nsGkAtoms::height, aHeight);
+  }
+  uint32_t Hspace()
+  {
+    return GetIntAttr(nsGkAtoms::hspace, 0);
+  }
+  void SetHspace(uint32_t aValue)
+  {
+    mozilla::IgnoredErrorResult rv;
+    SetUnsignedIntAttr(nsGkAtoms::hspace, aValue, 0, rv);
+  }
+  int32_t Loop()
+  {
+    return GetIntAttr(nsGkAtoms::loop, -1);
+  }
+  void SetLoop(int32_t aValue)
+  {
+    mozilla::IgnoredErrorResult rv;
+    SetHTMLIntAttr(nsGkAtoms::loop, aValue, rv);
+  }
+  uint32_t ScrollAmount()
+  {
+    return GetUnsignedIntAttr(nsGkAtoms::scrollamount, kDefaultScrollAmount);
+  }
+  void SetScrollAmount(uint32_t aValue)
+  {
+    mozilla::IgnoredErrorResult rv;
+    SetUnsignedIntAttr(nsGkAtoms::scrollamount, aValue, kDefaultScrollAmount, rv);
+  }
+  uint32_t ScrollDelay()
+  {
+    return GetUnsignedIntAttr(nsGkAtoms::scrolldelay, kDefaultScrollDelayMS);
+  }
+  void SetScrollDelay(uint32_t aValue)
+  {
+    mozilla::IgnoredErrorResult rv;
+    SetUnsignedIntAttr(nsGkAtoms::scrolldelay, aValue, kDefaultScrollDelayMS, rv);
+  }
+  bool TrueSpeed() const
+  {
+    return GetBoolAttr(nsGkAtoms::truespeed);
+  }
+  void SetTrueSpeed(bool aValue)
+  {
+    mozilla::IgnoredErrorResult rv;
+    SetHTMLBoolAttr(nsGkAtoms::truespeed, aValue, rv);
+  }
+  void GetWidth(DOMString& aWidth)
+  {
+    GetHTMLAttr(nsGkAtoms::width, aWidth);
+  }
+  void SetWidth(const nsAString& aWidth)
+  {
+    SetHTMLAttr(nsGkAtoms::width, aWidth);
+  }
+  uint32_t Vspace()
+  {
+    return GetIntAttr(nsGkAtoms::vspace, 0);
+  }
+  void SetVspace(uint32_t aValue)
+  {
+    mozilla::IgnoredErrorResult rv;
+    SetUnsignedIntAttr(nsGkAtoms::vspace, aValue, 0, rv);
+  }
+
+  // These are still implemented as <method exposeToUntrusedContent="true"> in XBL:
+  // void Start();
+  // void Stop();
+
+  virtual bool ParseAttribute(int32_t aNamespaceID,
+                              nsAtom* aAttribute,
+                              const nsAString& aValue,
+                              nsIPrincipal* aMaybeScriptedPrincipal,
+                              nsAttrValue& aResult) override;
+  NS_IMETHOD_(bool) IsAttributeMapped(const nsAtom* aAttribute) const override;
+  virtual nsMapRuleToAttributesFunc GetAttributeMappingFunction() const override;
+  virtual nsresult Clone(mozilla::dom::NodeInfo *aNodeInfo, nsINode **aResult,
+                         bool aPreallocateChildren) const override;
+
+protected:
+  virtual ~HTMLMarqueeElement();
+
+  virtual JSObject* WrapNode(JSContext *aCx, JS::Handle<JSObject*> aGivenProto) override;
+
+private:
+  static void MapAttributesIntoRule(const nsMappedAttributes* aAttributes,
+                                    GenericSpecifiedValues* aGenericData);
+};
+
+} // namespace dom
+} // namespace mozilla
+
+#endif /* HTMLMarqueeElement_h___ */
diff --git a/dom/html/moz.build b/dom/html/moz.build
--- a/dom/html/moz.build
+++ b/dom/html/moz.build
@@ -73,16 +73,17 @@ EXPORTS.mozilla.dom += [
     'HTMLIFrameElement.h',
     'HTMLImageElement.h',
     'HTMLInputElement.h',
     'HTMLLabelElement.h',
     'HTMLLegendElement.h',
     'HTMLLIElement.h',
     'HTMLLinkElement.h',
     'HTMLMapElement.h',
+    'HTMLMarqueeElement.h',
     'HTMLMediaElement.h',
     'HTMLMenuElement.h',
     'HTMLMenuItemElement.h',
     'HTMLMetaElement.h',
     'HTMLMeterElement.h',
     'HTMLModElement.h',
     'HTMLObjectElement.h',
     'HTMLOptGroupElement.h',
@@ -152,16 +153,17 @@ UNIFIED_SOURCES += [
     'HTMLIFrameElement.cpp',
     'HTMLImageElement.cpp',
     'HTMLInputElement.cpp',
     'HTMLLabelElement.cpp',
     'HTMLLegendElement.cpp',
     'HTMLLIElement.cpp',
     'HTMLLinkElement.cpp',
     'HTMLMapElement.cpp',
+    'HTMLMarqueeElement.cpp',
     'HTMLMediaElement.cpp',
     'HTMLMenuElement.cpp',
     'HTMLMenuItemElement.cpp',
     'HTMLMetaElement.cpp',
     'HTMLMeterElement.cpp',
     'HTMLModElement.cpp',
     'HTMLObjectElement.cpp',
     'HTMLOptGroupElement.cpp',
diff --git a/dom/html/nsGenericHTMLElement.h b/dom/html/nsGenericHTMLElement.h
--- a/dom/html/nsGenericHTMLElement.h
+++ b/dom/html/nsGenericHTMLElement.h
@@ -1570,16 +1570,17 @@ NS_DECLARE_NS_NEW_HTML_ELEMENT(Heading)
 NS_DECLARE_NS_NEW_HTML_ELEMENT_AS_SHARED(Html)
 NS_DECLARE_NS_NEW_HTML_ELEMENT(IFrame)
 NS_DECLARE_NS_NEW_HTML_ELEMENT(Image)
 NS_DECLARE_NS_NEW_HTML_ELEMENT(Input)
 NS_DECLARE_NS_NEW_HTML_ELEMENT(LI)
 NS_DECLARE_NS_NEW_HTML_ELEMENT(Label)
 NS_DECLARE_NS_NEW_HTML_ELEMENT(Legend)
 NS_DECLARE_NS_NEW_HTML_ELEMENT(Link)
+NS_DECLARE_NS_NEW_HTML_ELEMENT(Marquee)
 NS_DECLARE_NS_NEW_HTML_ELEMENT(Map)
 NS_DECLARE_NS_NEW_HTML_ELEMENT(Menu)
 NS_DECLARE_NS_NEW_HTML_ELEMENT(MenuItem)
 NS_DECLARE_NS_NEW_HTML_ELEMENT(Meta)
 NS_DECLARE_NS_NEW_HTML_ELEMENT(Meter)
 NS_DECLARE_NS_NEW_HTML_ELEMENT(Object)
 NS_DECLARE_NS_NEW_HTML_ELEMENT(OptGroup)
 NS_DECLARE_NS_NEW_HTML_ELEMENT(Option)
diff --git a/dom/html/test/test_bug389797.html b/dom/html/test/test_bug389797.html
--- a/dom/html/test/test_bug389797.html
+++ b/dom/html/test/test_bug389797.html
@@ -161,17 +161,17 @@ HTML_TAG("keygen", "Span");
 HTML_TAG("label", "Label");
 HTML_TAG("legend", "Legend");
 HTML_TAG("li", "LI");
 HTML_TAG("link", "Link");
 HTML_TAG("listing", "Pre");
 HTML_TAG("main", "");
 HTML_TAG("map", "Map");
 HTML_TAG("mark", "");
-HTML_TAG("marquee", "Div");
+HTML_TAG("marquee", "Marquee");
 HTML_TAG("menu", "Menu");
 HTML_TAG("meta", "Meta");
 HTML_TAG("meter", "Meter");
 HTML_TAG("multicol", "Unknown");
 HTML_TAG("nav", "")
 HTML_TAG("nobr", "");
 HTML_TAG("noembed", "");
 HTML_TAG("noframes", "");
diff --git a/dom/tests/mochitest/general/test_interfaces.js b/dom/tests/mochitest/general/test_interfaces.js
--- a/dom/tests/mochitest/general/test_interfaces.js
+++ b/dom/tests/mochitest/general/test_interfaces.js
@@ -458,16 +458,18 @@ var interfaceNamesInGlobalScope =
     "HTMLLegendElement",
 // IMPORTANT: Do not change this list without review from a DOM peer!
     "HTMLLIElement",
 // IMPORTANT: Do not change this list without review from a DOM peer!
     "HTMLLinkElement",
 // IMPORTANT: Do not change this list without review from a DOM peer!
     "HTMLMapElement",
 // IMPORTANT: Do not change this list without review from a DOM peer!
+    "HTMLMarqueeElement",
+// IMPORTANT: Do not change this list without review from a DOM peer!
     "HTMLMediaElement",
 // IMPORTANT: Do not change this list without review from a DOM peer!
     "HTMLMenuElement",
 // IMPORTANT: Do not change this list without review from a DOM peer!
     "HTMLMenuItemElement",
 // IMPORTANT: Do not change this list without review from a DOM peer!
     "HTMLMetaElement",
 // IMPORTANT: Do not change this list without review from a DOM peer!
diff --git a/dom/tests/mochitest/webcomponents/htmlconstructor_builtin_tests.js b/dom/tests/mochitest/webcomponents/htmlconstructor_builtin_tests.js
--- a/dom/tests/mochitest/webcomponents/htmlconstructor_builtin_tests.js
+++ b/dom/tests/mochitest/webcomponents/htmlconstructor_builtin_tests.js
@@ -65,17 +65,17 @@
   ['label', 'Label'],
   ['legend', 'Legend'],
   ['li', 'LI'],
   ['link', 'Link'],
   ['listing', 'Pre'],
   ['main', ''],
   ['map', 'Map'],
   ['mark', ''],
-  ['marquee', 'Div'],
+  ['marquee', 'Marquee'],
   ['menu', 'Menu'],
   ['menuitem', 'MenuItem'],
   ['meta', 'Meta'],
   ['meter', 'Meter'],
   ['nav', ''],
   ['nobr', ''],
   ['noembed', ''],
   ['noframes', ''],
diff --git a/dom/webidl/HTMLMarqueeElement.webidl b/dom/webidl/HTMLMarqueeElement.webidl
new file mode 100644
--- /dev/null
+++ b/dom/webidl/HTMLMarqueeElement.webidl
@@ -0,0 +1,35 @@
+/* -*- Mode: IDL; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/.
+ *
+ * The origin of this IDL file is
+ * http://www.whatwg.org/specs/web-apps/current-work/#the-map-element
+ * Â© Copyright 2004-2011 Apple Computer, Inc., Mozilla Foundation, and
+ * Opera Software ASA. You are granted a license to use, reproduce
+ * and create derivative works of this document.
+ */
+
+// https://html.spec.whatwg.org/#htmlmarqueeelement
+
+[HTMLConstructor]
+interface HTMLMarqueeElement : HTMLElement {
+  [CEReactions] attribute DOMString behavior;
+  [CEReactions] attribute DOMString bgColor;
+  [CEReactions] attribute DOMString direction;
+  [CEReactions] attribute DOMString height;
+  [CEReactions] attribute unsigned long hspace;
+  [CEReactions] attribute long loop;
+  [CEReactions] attribute unsigned long scrollAmount;
+  [CEReactions] attribute unsigned long scrollDelay;
+  [CEReactions] attribute boolean trueSpeed;
+  [CEReactions] attribute unsigned long vspace;
+  [CEReactions] attribute DOMString width;
+
+  //attribute EventHandler onbounce;
+  //attribute EventHandler onfinish;
+  //attribute EventHandler onstart;
+
+  //void start();
+  //void stop();
+};
\ No newline at end of file
diff --git a/dom/webidl/moz.build b/dom/webidl/moz.build
--- a/dom/webidl/moz.build
+++ b/dom/webidl/moz.build
@@ -574,16 +574,17 @@ WEBIDL_FILES = [
     'HTMLIFrameElement.webidl',
     'HTMLImageElement.webidl',
     'HTMLInputElement.webidl',
     'HTMLLabelElement.webidl',
     'HTMLLegendElement.webidl',
     'HTMLLIElement.webidl',
     'HTMLLinkElement.webidl',
     'HTMLMapElement.webidl',
+    'HTMLMarqueeElement.webidl',
     'HTMLMediaElement.webidl',
     'HTMLMenuElement.webidl',
     'HTMLMenuItemElement.webidl',
     'HTMLMetaElement.webidl',
     'HTMLMeterElement.webidl',
     'HTMLModElement.webidl',
     'HTMLObjectElement.webidl',
     'HTMLOListElement.webidl',
diff --git a/layout/style/xbl-marquee/xbl-marquee.xml b/layout/style/xbl-marquee/xbl-marquee.xml
--- a/layout/style/xbl-marquee/xbl-marquee.xml
+++ b/layout/style/xbl-marquee/xbl-marquee.xml
@@ -11,135 +11,16 @@
 
 
   <binding id="marquee" bindToUntrustedContent="true">
 
     <resources>
       <stylesheet src="chrome://xbl-marquee/content/xbl-marquee.css"/>
     </resources>
     <implementation>
-
-      <property name="scrollAmount" exposeToUntrustedContent="true">
-        <getter>
-          <![CDATA[
-          this._mutationActor(this._mutationObserver.takeRecords());
-          return this._scrollAmount;
-          ]]>
-        </getter>
-        <setter>
-          <![CDATA[
-          var val = parseInt(val);
-          if (val < 0) {
-            return;
-          }
-          if (isNaN(val)) {
-            val = 0;
-          }
-          this.setAttribute("scrollamount", val);
-          ]]>
-        </setter>
-      </property>
-
-      <property name="scrollDelay" exposeToUntrustedContent="true">
-        <getter>
-          <![CDATA[
-          this._mutationActor(this._mutationObserver.takeRecords());
-          var val = parseInt(this.getAttribute("scrolldelay"));
-
-          if (val <= 0 || isNaN(val)) {
-            return this._scrollDelay;
-          }
-
-          return val;
-          ]]>
-        </getter>
-        <setter>
-          var val = parseInt(val);
-          if (val > 0 ) {
-            this.setAttribute("scrolldelay", val);
-          }
-        </setter>
-      </property>
-
-      <property name="trueSpeed" exposeToUntrustedContent="true">
-        <getter>
-          <![CDATA[
-          if (!this.hasAttribute("truespeed")) {
-            return false;
-          }
-
-          return true;
-          ]]>
-        </getter>
-        <setter>
-          <![CDATA[
-          if (val) {
-            this.setAttribute("truespeed", "");
-          } else {
-            this.removeAttribute('truespeed');
-          }
-          ]]>
-        </setter>
-      </property>
-
-      <property name="direction" exposeToUntrustedContent="true">
-        <getter>
-          this._mutationActor(this._mutationObserver.takeRecords());
-          return this._direction;
-        </getter>
-        <setter>
-          <![CDATA[
-          if (typeof val == 'string') {
-            val = val.toLowerCase();
-          } else {
-            return;
-          }
-          if (val != 'left' && val != 'right' && val != 'up' && val != 'down') {
-            val = 'left';
-          }
-
-          this.setAttribute("direction", val);
-          ]]>
-        </setter>
-      </property>
-
-      <property name="behavior" exposeToUntrustedContent="true">
-        <getter>
-          this._mutationActor(this._mutationObserver.takeRecords());
-          return this._behavior;
-        </getter>
-        <setter>
-          if (typeof val == 'string') {
-            val = val.toLowerCase();
-          }
-          if (val == "alternate" || val == "slide" || val == 'scroll') {
-            this.setAttribute("behavior", val);
-          }
-        </setter>
-      </property>
-
-
-      <property name="loop" exposeToUntrustedContent="true">
-        <getter>
-          <![CDATA[
-          this._mutationActor(this._mutationObserver.takeRecords());
-          return this._loop;
-          ]]>
-        </getter>
-        <setter>
-          <![CDATA[
-          var val = parseInt(val);
-          if (val == -1 || val > 0) {
-            this.setAttribute("loop", val);
-          }
-          ]]>
-        </setter>
-      </property>
-
-
       <property name="onstart" exposeToUntrustedContent="true">
         <getter>
           return this.getAttribute("onstart");
         </getter>
         <setter>
           this._setEventListener("start", val, true);
           this.setAttribute("onstart", val);
         </setter>
@@ -168,114 +49,26 @@
       <property name="outerDiv"
         onget="return document.getAnonymousNodes(this)[0]"
       />
 
       <property name="innerDiv"
         onget="return document.getAnonymousElementByAttribute(this, 'class', 'innerDiv');"
       />
 
-      <property name="height" exposeToUntrustedContent="true"
-        onget="return this.getAttribute('height');"
-        onset="this.setAttribute('height', val);"
-      />
-
-      <property name="width" exposeToUntrustedContent="true"
-        onget="return this.getAttribute('width');"
-        onset="this.setAttribute('width', val);"
-      />
-
-      <method name="_set_scrollDelay">
-        <parameter name="aValue"/>
-        <body>
-        <![CDATA[
-          aValue = parseInt(aValue);
-          if (aValue <= 0) {
-            return;
-          } else if (isNaN(aValue)) {
-            this._scrollDelay = 85;
-          } else if (aValue < 60) {
-            if (this.trueSpeed == true) {
-              this._scrollDelay = aValue;
-            } else {
-              this._scrollDelay = 60;
-            }
-          } else {
-            this._scrollDelay = aValue;
-          }
-        ]]>
-        </body>
-      </method>
-
-      <method name="_set_scrollAmount">
-        <parameter name="aValue"/>
-        <body>
-        <![CDATA[
-          aValue = parseInt(aValue);
-          if (isNaN(aValue)) {
-            this._scrollAmount = 6;
-          } else if (aValue < 0) {
-            return;
-          } else {
-            this._scrollAmount = aValue;
+      <property name="scrollDelayWithTruespeed">
+        <getter>
+          <![CDATA[
+          if (this.scrollDelay < 60 && !this.trueSpeed) {
+            return 60;
           }
-        ]]>
-        </body>
-      </method>
-
-      <method name="_set_behavior">
-        <parameter name="aValue"/>
-        <body>
-        <![CDATA[
-          if (typeof aValue == 'string') {
-            aValue = aValue.toLowerCase();
-          }
-          if (aValue != 'alternate' && aValue != 'slide' && aValue != 'scroll') {
-            this._behavior = 'scroll';
-          } else {
-            this._behavior = aValue;
-          }
-        ]]>
-        </body>
-      </method>
-
-      <method name="_set_direction">
-        <parameter name="aValue"/>
-        <body>
-        <![CDATA[
-          if (typeof aValue == 'string') {
-            aValue = aValue.toLowerCase();
-          }
-          if (aValue != 'left' && aValue != 'right' && aValue != 'up' && aValue != 'down') {
-            aValue = 'left';
-          }
-
-          if (aValue != this._direction) {
-            this.startNewDirection = true;
-          }
-          this._direction = aValue;
-        ]]>
-        </body>
-      </method>
-
-      <method name="_set_loop">
-        <parameter name="aValue"/>
-        <body>
-          <![CDATA[
-          var aValue = parseInt(aValue);
-          if (aValue == 0) {
-            return;
-          }
-          if (isNaN(aValue) || aValue <= -1) {
-            aValue = -1;
-          }
-          this._loop = aValue;
+          return this.scrollDelay;
           ]]>
-        </body>
-      </method>
+        </getter>
+      </property>
 
       <method name="_setEventListener">
         <parameter name="aName"/>
         <parameter name="aValue"/>
         <parameter name="aIgnoreNextCall"/>
         <body>
           <![CDATA[
           // _setEventListener is only used for setting the attribute event
@@ -353,17 +146,17 @@
       </method>
 
       <method name="start" exposeToUntrustedContent="true">
         <body>
         <![CDATA[
           if (this.runId == 0) {
             var myThis = this;
             var lambda = function myTimeOutFunction(){myThis._doMove(false);}
-            this.runId = window.setTimeout(lambda, this._scrollDelay - this._deltaStartStop);
+            this.runId = window.setTimeout(lambda, this.scrollDelayWithTruespeed - this._deltaStartStop);
             this._deltaStartStop = 0;
           }
         ]]>
         </body>
       </method>
 
       <method name="stop" exposeToUntrustedContent="true">
         <body>
@@ -379,160 +172,161 @@
       </method>
 
       <method name="_doMove">
         <parameter name="aResetPosition"/>
         <body>
         <![CDATA[
           this._lastMoveDate = Date.now();
 
-          //startNewDirection is true at first load and whenever the direction is changed
-          if (this.startNewDirection) {
-            this.startNewDirection = false; //we only want this to run once every scroll direction change
+          // invalidateCache is true at first load and whenever an attribute
+          // is changed
+          if (this.invalidateCache) {
+            this.invalidateCache = false; //we only want this to run once every scroll direction change
 
             var corrvalue = 0;
 
-            switch (this._direction)
+            switch (this._currentDirection)
             {
               case "up":
                 var height = document.defaultView.getComputedStyle(this).height;
                 this.outerDiv.style.height = height;
                 if (this.originalHeight > this.outerDiv.offsetHeight) {
                     corrvalue = this.originalHeight - this.outerDiv.offsetHeight;
                 }
                 this.innerDiv.style.padding = height + " 0";
                 this.dirsign = 1;
-                this.startAt = (this._behavior == 'alternate') ? (this.originalHeight - corrvalue) : 0;
-                this.stopAt  = (this._behavior == 'alternate' || this._behavior == 'slide') ? 
+                this.startAt = (this.behavior == 'alternate') ? (this.originalHeight - corrvalue) : 0;
+                this.stopAt  = (this.behavior == 'alternate' || this.behavior == 'slide') ? 
                                 (parseInt(height) + corrvalue) : (this.originalHeight + parseInt(height));
               break;
 
               case "down":
                 var height = document.defaultView.getComputedStyle(this).height;
                 this.outerDiv.style.height = height;
                 if (this.originalHeight > this.outerDiv.offsetHeight) {
                     corrvalue = this.originalHeight - this.outerDiv.offsetHeight;
                 }
                 this.innerDiv.style.padding = height + " 0";
                 this.dirsign = -1;
-                this.startAt  = (this._behavior == 'alternate') ?
+                this.startAt  = (this.behavior == 'alternate') ?
                                 (parseInt(height) + corrvalue) : (this.originalHeight + parseInt(height));
-                this.stopAt = (this._behavior == 'alternate' || this._behavior == 'slide') ? 
+                this.stopAt = (this.behavior == 'alternate' || this.behavior == 'slide') ? 
                               (this.originalHeight - corrvalue) : 0;
               break;
 
               case "right":
                 if (this.innerDiv.offsetWidth > this.outerDiv.offsetWidth) {
                     corrvalue = this.innerDiv.offsetWidth - this.outerDiv.offsetWidth;
                 }
                 this.dirsign = -1;
-                this.stopAt  = (this._behavior == 'alternate' || this._behavior == 'slide') ? 
+                this.stopAt  = (this.behavior == 'alternate' || this.behavior == 'slide') ? 
                                (this.innerDiv.offsetWidth - corrvalue) : 0;
-                this.startAt = this.outerDiv.offsetWidth + ((this._behavior == 'alternate') ? 
+                this.startAt = this.outerDiv.offsetWidth + ((this.behavior == 'alternate') ? 
                                corrvalue : (this.innerDiv.offsetWidth + this.stopAt));   
               break;
 
               case "left":
               default:
                 if (this.innerDiv.offsetWidth > this.outerDiv.offsetWidth) {
                     corrvalue = this.innerDiv.offsetWidth - this.outerDiv.offsetWidth;
                 }
                 this.dirsign = 1;
-                this.startAt = (this._behavior == 'alternate') ? (this.innerDiv.offsetWidth - corrvalue) : 0;
+                this.startAt = (this.behavior == 'alternate') ? (this.innerDiv.offsetWidth - corrvalue) : 0;
                 this.stopAt  = this.outerDiv.offsetWidth + 
-                               ((this._behavior == 'alternate' || this._behavior == 'slide') ? 
+                               ((this.behavior == 'alternate' || this.behavior == 'slide') ? 
                                corrvalue : (this.innerDiv.offsetWidth + this.startAt));
             }
 
             if (aResetPosition) {
               this.newPosition = this.startAt;
               this._fireEvent("start", false, false);
             }
           } //end if
 
-          this.newPosition = this.newPosition + (this.dirsign * this._scrollAmount);
+          this.newPosition = this.newPosition + (this.dirsign * this.scrollAmount);
 
           if ((this.dirsign == 1 && this.newPosition > this.stopAt) ||
               (this.dirsign == -1 && this.newPosition < this.stopAt))
           {
-            switch (this._behavior) 
+            switch (this.behavior) 
             {
               case 'alternate':
                 // lets start afresh
-                this.startNewDirection = true;
+                this.invalidateCache = true;
 
                 // swap direction
                 const swap = {left: "right", down: "up", up: "down", right: "left"};
-                this._direction = swap[this._direction];
+                this._currentDirection = swap[this._currentDirection] || "left";
                 this.newPosition = this.stopAt;
 
-                if ((this._direction == "up") || (this._direction == "down")) {
+                if ((this._currentDirection == "up") || (this._currentDirection == "down")) {
                   this.outerDiv.scrollTop = this.newPosition;
                 } else {
                   this.outerDiv.scrollLeft = this.newPosition;
                 }
 
-                if (this._loop != 1) {
+                if (this._currentLoop != 1) {
                   this._fireEvent("bounce", false, true);
                 }
               break;
 
               case 'slide':
-                if (this._loop > 1) {
+                if (this._currentLoop > 1) {
                   this.newPosition = this.startAt;
                 }
               break;
 
               default:
                 this.newPosition = this.startAt;
 
-                if ((this._direction == "up") || (this._direction == "down")) {
+                if ((this._currentDirection == "up") || (this._currentDirection == "down")) {
                   this.outerDiv.scrollTop = this.newPosition;
                 } else {
                   this.outerDiv.scrollLeft = this.newPosition;
                 }
 
-                //dispatch start event, even when this._loop == 1, comp. with IE6
+                //dispatch start event, even when this._currentLoop == 1, comp. with IE6
                 this._fireEvent("start", false, false);
             }
 
-            if (this._loop > 1) {
-              this._loop--;
-            } else if (this._loop == 1) {
-              if ((this._direction == "up") || (this._direction == "down")) {
+            if (this._currentLoop > 1) {
+              this._currentLoop--;
+            } else if (this._currentLoop == 1) {
+              if ((this._currentDirection == "up") || (this._currentDirection == "down")) {
                 this.outerDiv.scrollTop = this.stopAt;
               } else {
                 this.outerDiv.scrollLeft = this.stopAt;
               }
               this.stop();
               this._fireEvent("finish", false, true);
               return;
             }
           }
           else {
-            if ((this._direction == "up") || (this._direction == "down")) {
+            if ((this._currentDirection == "up") || (this._currentDirection == "down")) {
               this.outerDiv.scrollTop = this.newPosition;
             } else {
               this.outerDiv.scrollLeft = this.newPosition;
             }
           }
 
           var myThis = this;
           var lambda = function myTimeOutFunction(){myThis._doMove(false);}
-          this.runId = window.setTimeout(lambda, this._scrollDelay);
+          this.runId = window.setTimeout(lambda, this.scrollDelayWithTruespeed);
         ]]>
         </body>
       </method>
 
       <method name="init">
         <body>
         <![CDATA[
           this.stop();
 
-          if ((this._direction != "up") && (this._direction != "down")) {
+          if ((this._currentDirection != "up") && (this._currentDirection != "down")) {
             var width = window.getComputedStyle(this).width;
             this.innerDiv.parentNode.style.margin = '0 ' + width;
 
             //XXX Adding the margin sometimes causes the marquee to widen, 
             // see testcase from bug bug 364434: 
             // https://bugzilla.mozilla.org/attachment.cgi?id=249233
             // Just add a fixed width with current marquee's width for now
             if (width != window.getComputedStyle(this).width) {
@@ -559,55 +353,23 @@
           while (aMutations.length > 0) {
             var mutation = aMutations.shift();
             var attrName = mutation.attributeName.toLowerCase();
             var oldValue = mutation.oldValue;
             var target = mutation.target;
             var newValue = target.getAttribute(attrName);
 
             if (oldValue != newValue) {
+              target.invalidateCache = true;
               switch (attrName) {
                 case "loop":
-                  target._set_loop(newValue);
-                  if (target.rundId == 0) {
-                    target.start();
-                  }
-                  break;
-                case "scrollamount":
-                  target._set_scrollAmount(newValue);
-                  break;
-                case "scrolldelay":
-                  target._set_scrollDelay(newValue);
-                  target.stop();
-                  target.start();
-                  break;
-                case "truespeed":
-                  //needed to update target._scrollDelay
-                  var myThis = target;
-                  var lambda = function() {myThis._set_scrollDelay(myThis.getAttribute('scrolldelay'));}
-                  window.setTimeout(lambda, 0);
-                  break;
-                case "behavior":
-                  target._set_behavior(newValue);
-                  target.startNewDirection = true;
-                  if ((oldValue == "slide" && target.newPosition == target.stopAt) ||
-                      newValue == "alternate" || newValue == "slide") {
-                    target.stop();
-                    target._doMove(true);
-                  }
+                  target._currentLoop = newValue || -1;
                   break;
                 case "direction":
-                  if (!newValue) {
-                    newValue = "left";
-                  }
-                  target._set_direction(newValue);
-                  break;
-                case "width":
-                case "height":
-                  target.startNewDirection = true;
+                  target._currentDirection = newValue || "left";
                   break;
                 case "onstart":
                   target._setEventListener("start", newValue);
                   break;
                 case "onfinish":
                   target._setEventListener("finish", newValue);
                   break;
                 case "onbounce":
@@ -618,47 +380,38 @@
           }
         ]]>
         </body>
       </method>
 
       <constructor>
         <![CDATA[
           // Set up state.
-          this._scrollAmount = 6;
-          this._scrollDelay = 85;
-          this._direction = "left";
-          this._behavior = "scroll";
-          this._loop = -1;
+          this._currentDirection = this.direction || "left";
+          this._currentLoop = this.loop;
           this.dirsign = 1;
           this.startAt = 0;
           this.stopAt = 0;
           this.newPosition = 0;
           this.runId = 0;
           this.originalHeight = 0;
-          this.startNewDirection = true;
+          this.invalidateCache = true;
 
           // hack needed to fix js error, see bug 386470
           var myThis = this;
           var lambda = function myScopeFunction() { if (myThis.init) myThis.init(); }
 
-          this._set_direction(this.getAttribute('direction'));
-          this._set_behavior(this.getAttribute('behavior'));
-          this._set_scrollDelay(this.getAttribute('scrolldelay'));
-          this._set_scrollAmount(this.getAttribute('scrollamount'));
-          this._set_loop(this.getAttribute('loop'));
           this._setEventListener("start", this.getAttribute("onstart"));
           this._setEventListener("finish", this.getAttribute("onfinish"));
           this._setEventListener("bounce", this.getAttribute("onbounce"));
-          this.startNewDirection = true;
 
           this._mutationObserver = new MutationObserver(this._mutationActor);
           this._mutationObserver.observe(this, { attributes: true,
             attributeOldValue: true,
-            attributeFilter: ['loop', 'scrollamount', 'scrolldelay', '', 'truespeed', 'behavior',
+            attributeFilter: ['loop', '', 'behavior',
               'direction', 'width', 'height', 'onstart', 'onfinish', 'onbounce'] });
 
           // init needs to be run after the page has loaded in order to calculate
           // the correct height/width
           if (document.readyState == "complete") {
             lambda();
           } else {
             window.addEventListener("load", lambda);
diff --git a/parser/html/nsHtml5ElementName.cpp b/parser/html/nsHtml5ElementName.cpp
--- a/parser/html/nsHtml5ElementName.cpp
+++ b/parser/html/nsHtml5ElementName.cpp
@@ -761,17 +761,17 @@ nsHtml5ElementName::initializeStatics()
                                       nsHtml5TreeBuilder::IFRAME | SPECIAL);
   ELT_LINE = new nsHtml5ElementName(nsGkAtoms::line,
                                     nsGkAtoms::line,
                                     NS_NewHTMLUnknownElement,
                                     NS_NewSVGLineElement,
                                     nsHtml5TreeBuilder::OTHER);
   ELT_MARQUEE = new nsHtml5ElementName(nsGkAtoms::marquee,
                                        nsGkAtoms::marquee,
-                                       NS_NewHTMLDivElement,
+                                       NS_NewHTMLMarqueeElement,
                                        NS_NewSVGUnknownElement,
                                        nsHtml5TreeBuilder::MARQUEE_OR_APPLET |
                                          SPECIAL | SCOPING);
   ELT_POLYLINE = new nsHtml5ElementName(nsGkAtoms::polyline,
                                         nsGkAtoms::polyline,
                                         NS_NewHTMLUnknownElement,
                                         NS_NewSVGPolylineElement,
                                         nsHtml5TreeBuilder::OTHER);
diff --git a/parser/htmlparser/nsHTMLTagList.h b/parser/htmlparser/nsHTMLTagList.h
--- a/parser/htmlparser/nsHTMLTagList.h
+++ b/parser/htmlparser/nsHTMLTagList.h
@@ -115,17 +115,17 @@ HTML_TAG(keygen, Span, Span)
 HTML_TAG(label, Label, Label)
 HTML_TAG(legend, Legend, Legend)
 HTML_TAG(li, LI, LI)
 HTML_TAG(link, Link, Link)
 HTML_TAG(listing, Pre, Pre)
 HTML_HTMLELEMENT_TAG(main)
 HTML_TAG(map, Map, Map)
 HTML_HTMLELEMENT_TAG(mark)
-HTML_TAG(marquee, Div, Div)
+HTML_TAG(marquee, Marquee, Marquee)
 HTML_TAG(menu, Menu, Menu)
 HTML_TAG(menuitem, MenuItem, MenuItem)
 HTML_TAG(meta, Meta, Meta)
 HTML_TAG(meter, Meter, Meter)
 HTML_TAG(multicol, Unknown, Unknown)
 HTML_HTMLELEMENT_TAG(nav)
 HTML_HTMLELEMENT_TAG(nobr)
 HTML_HTMLELEMENT_TAG(noembed)
