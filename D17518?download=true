# HG changeset patch
# Parent  d3101938da16bfab22a72c2cf9a95d7bc1469b77

diff --git a/browser/base/content/browser.css b/browser/base/content/browser.css
--- a/browser/base/content/browser.css
+++ b/browser/base/content/browser.css
@@ -703,17 +703,17 @@ html|input.urlbar-input {
   display: none;
 }
 
 #PopupAutoComplete[firstresultstyle="insecureWarning"] {
   min-width: 200px;
 }
 
 #PopupAutoComplete > richlistbox > richlistitem[originaltype="insecureWarning"] {
-  -moz-binding: url("chrome://global/content/bindings/autocomplete.xml#autocomplete-richlistitem-insecure-field");
+  -moz-binding: none;
   height: auto;
 }
 
 #PopupAutoComplete > richlistbox > richlistitem[originaltype="insecureWarning"] > .ac-site-icon {
   margin-inline-start: 0;
   display: initial;
 }
 
diff --git a/toolkit/content/customElements.js b/toolkit/content/customElements.js
--- a/toolkit/content/customElements.js
+++ b/toolkit/content/customElements.js
@@ -310,16 +310,71 @@ const BaseControlMixin = Base => {
   }
 
   Base.implementCustomInterface(BaseControl,
                                 [Ci.nsIDOMXULControlElement]);
   return BaseControl;
 };
 MozElements.BaseControl = BaseControlMixin(MozXULElement);
 
+const BaseTextMixin = Base => class extends Base {
+  set label(val) {
+    this.setAttribute("label", val);
+    return val;
+  }
+
+  get label() {
+    return this.getAttribute("label");
+  }
+
+  set crop(val) {
+    this.setAttribute("crop", val);
+    return val;
+  }
+
+  get crop() {
+    return this.getAttribute("crop");
+  }
+
+  set image(val) {
+    this.setAttribute("image", val);
+    return val;
+  }
+
+  get image() {
+    return this.getAttribute("image");
+  }
+
+  set command(val) {
+    this.setAttribute("command", val);
+    return val;
+  }
+
+  get command() {
+    return this.getAttribute("command");
+  }
+
+  set accessKey(val) {
+    // Always store on the control
+    this.setAttribute("accesskey", val);
+    // If there is a label, change the accesskey on the labelElement
+    // if it's also set there
+    if (this.labelElement) {
+      this.labelElement.accessKey = val;
+    }
+    return val;
+  }
+
+  get accessKey() {
+    return this.labelElement ? this.labelElement.accessKey : this.getAttribute("accesskey");
+  }
+};
+
+MozElements.BaseText = BaseTextMixin(MozXULElement);
+
 // Attach the base class to the window so other scripts can use it:
 window.BaseControlMixin = BaseControlMixin;
 window.MozElementMixin = MozElementMixin;
 window.MozXULElement = MozXULElement;
 window.MozElements = MozElements;
 
 customElements.setElementCreationCallback("browser", () => {
   Services.scriptloader.loadSubScript("chrome://global/content/elements/browser-custom-element.js", window);
@@ -328,27 +383,28 @@ customElements.setElementCreationCallbac
 // For now, don't load any elements in the extension dummy document.
 // We will want to load <browser> when that's migrated (bug 1441935).
 const isDummyDocument = document.documentURI == "chrome://extensions/content/dummy.xul";
 if (!isDummyDocument) {
   for (let script of [
     "chrome://global/content/elements/general.js",
     "chrome://global/content/elements/notificationbox.js",
     "chrome://global/content/elements/radio.js",
+    "chrome://global/content/elements/richlistbox.js",
+    "chrome://global/content/elements/autocomplete-richlistitem.js",
     "chrome://global/content/elements/textbox.js",
     "chrome://global/content/elements/tabbox.js",
     "chrome://global/content/elements/tree.js",
   ]) {
     Services.scriptloader.loadSubScript(script, window);
   }
 
   for (let [tag, script] of [
     ["findbar", "chrome://global/content/elements/findbar.js"],
     ["menulist", "chrome://global/content/elements/menulist.js"],
-    ["richlistbox", "chrome://global/content/elements/richlistbox.js"],
     ["stringbundle", "chrome://global/content/elements/stringbundle.js"],
     ["printpreview-toolbar", "chrome://global/content/printPreviewToolbar.js"],
     ["editor", "chrome://global/content/elements/editor.js"],
   ]) {
     customElements.setElementCreationCallback(tag, () => {
       Services.scriptloader.loadSubScript(script, window);
     });
   }
diff --git a/toolkit/content/jar.mn b/toolkit/content/jar.mn
--- a/toolkit/content/jar.mn
+++ b/toolkit/content/jar.mn
@@ -80,16 +80,17 @@ toolkit.jar:
    content/global/bindings/tabbox.xml          (widgets/tabbox.xml)
    content/global/bindings/text.xml            (widgets/text.xml)
 *  content/global/bindings/textbox.xml         (widgets/textbox.xml)
    content/global/bindings/timekeeper.js       (widgets/timekeeper.js)
    content/global/bindings/timepicker.js       (widgets/timepicker.js)
    content/global/bindings/toolbarbutton.xml   (widgets/toolbarbutton.xml)
    content/global/bindings/tree.xml            (widgets/tree.xml)
 *  content/global/bindings/wizard.xml          (widgets/wizard.xml)
+   content/global/elements/autocomplete-richlistitem.js     (widgets/autocomplete-richlistitem.js)
    content/global/elements/browser-custom-element.js          (widgets/browser-custom-element.js)
    content/global/elements/datetimebox.js      (widgets/datetimebox.js)
    content/global/elements/findbar.js          (widgets/findbar.js)
    content/global/elements/editor.js           (widgets/editor.js)
    content/global/elements/general.js          (widgets/general.js)
    content/global/elements/notificationbox.js  (widgets/notificationbox.js)
    content/global/elements/pluginProblem.js    (widgets/pluginProblem.js)
    content/global/elements/radio.js            (widgets/radio.js)
diff --git a/toolkit/content/widgets/autocomplete-richlistitem.js b/toolkit/content/widgets/autocomplete-richlistitem.js
--- a/toolkit/content/widgets/autocomplete-richlistitem.js
+++ b/toolkit/content/widgets/autocomplete-richlistitem.js
@@ -1,1072 +1,1028 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+  * License, v. 2.0. If a copy of the MPL was not distributed with this
+  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-  <binding id="autocomplete-richlistitem-insecure-field" extends="chrome://global/content/bindings/autocomplete.xml#autocomplete-richlistitem">
-    <content align="center"
-             onoverflow="this._onOverflow();"
-             onunderflow="this._onUnderflow();">
-      <xul:image anonid="type-icon"
-                 class="ac-type-icon"
-                 xbl:inherits="selected,current,type"/>
-      <xul:image anonid="site-icon"
-                 class="ac-site-icon"
-                 xbl:inherits="src=image,selected,type"/>
-      <xul:vbox class="ac-title"
-                align="left"
-                xbl:inherits="">
-        <xul:description class="ac-text-overflow-container">
-          <xul:description anonid="title-text"
-                           class="ac-title-text"
-                           xbl:inherits="selected"/>
-        </xul:description>
-      </xul:vbox>
-      <xul:hbox anonid="tags"
-                class="ac-tags"
-                align="center"
-                xbl:inherits="selected">
-        <xul:description class="ac-text-overflow-container">
-          <xul:description anonid="tags-text"
-                           class="ac-tags-text"
-                           xbl:inherits="selected"/>
-        </xul:description>
-      </xul:hbox>
-      <xul:hbox anonid="separator"
-                class="ac-separator"
-                align="center"
-                xbl:inherits="selected,actiontype,type">
-        <xul:description class="ac-separator-text">—</xul:description>
-      </xul:hbox>
-      <xul:hbox class="ac-url"
-                align="center"
-                xbl:inherits="selected,actiontype">
-        <xul:description class="ac-text-overflow-container">
-          <xul:description anonid="url-text"
-                           class="ac-url-text"
-                           xbl:inherits="selected"/>
-        </xul:description>
-      </xul:hbox>
-      <xul:hbox class="ac-action"
-                align="center"
-                xbl:inherits="selected,actiontype">
-        <xul:description class="ac-text-overflow-container">
-          <xul:description anonid="action-text"
-                           class="ac-action-text"
-                           xbl:inherits="selected"/>
-        </xul:description>
-      </xul:hbox>
-    </content>
+"use strict";
+
+// This is loaded into all XUL windows. Wrap in a block to prevent
+// leaking to window scope.
+{
+
+ChromeUtils.import("resource://gre/modules/Services.jsm");
+
+class MozAutocompleteRichlistitem extends MozElements.MozRichlistitem {
+  constructor() {
+    super();
+
+    /**
+     * This overrides listitem's mousedown handler because we want to set the
+     * selected item even when the shift or accel keys are pressed.
+     */
+    this.addEventListener("mousedown", (event) => {
+      // Call this.control only once since it's not a simple getter.
+      let control = this.control;
+      if (!control || control.disabled) {
+        return;
+      }
+      if (!this.selected) {
+        control.selectItem(this);
+      }
+      control.currentItem = this;
+    });
+
+    this.addEventListener("mouseover", (event) => {
+      // The point of implementing this handler is to allow drags to change
+      // the selected item.  If the user mouses down on an item, it becomes
+      // selected.  If they then drag the mouse to another item, select it.
+      // Handle all three primary mouse buttons: right, left, and wheel, since
+      // all three change the selection on mousedown.
+      let mouseDown = event.buttons & 0b111;
+      if (!mouseDown) {
+        return;
+      }
+      // Call this.control only once since it's not a simple getter.
+      let control = this.control;
+      if (!control || control.disabled) {
+        return;
+      }
+      if (!this.selected) {
+        control.selectItem(this);
+      }
+      control.currentItem = this;
+    });
+
+    this.addEventListener("overflow", () => this._onOverflow());
+    this.addEventListener("underflow", () => this._onUnderflow());
+  }
+
+  connectedCallback() {
+    if (this.delayConnectedCallback()) {
+      return;
+    }
+
+    this.textContent = "";
+    this.appendChild(MozXULElement.parseXULToFragment(this._markup));
+
+    this.setAttribute("align", "center");
+
+    this._boundaryCutoff = null;
+    this._inOverflow = false;
+
+    this._updateAttributes();
+    this._adjustAcItem();
+  }
 
-    <handlers>
-      <handler event="click" button="0"><![CDATA[
-        let baseURL = this.Services.urlFormatter.formatURLPref("app.support.baseURL");
-        window.openTrustedLinkIn(baseURL + "insecure-password", "tab", {
-          relatedToCurrent: true,
-        });
-      ]]></handler>
-    </handlers>
+  static get observedAttributes() {
+    return [
+      "actiontype",
+      "current",
+      "selected",
+      "image",
+      "type",
+    ];
+  }
 
-    <implementation>
-      <constructor><![CDATA[
-        // Unlike other autocomplete items, the height of the insecure warning
-        // increases by wrapping. So "forceHandleUnderflow" is for container to
-        // recalculate an item's height and width.
-        this.classList.add("forceHandleUnderflow");
-      ]]></constructor>
+  attributeChangedCallback(name, oldValue, newValue) {
+    if (this.isConnectedAndReady && oldValue != newValue &&
+        this.constructor.observedAttributes.includes(name)) {
+      this._updateAttributes();
+    }
+  }
+
+  _updateAttributes() {
+    const map = new Map([
+      [ this.querySelector(".ac-type-icon"), [ "selected", "current", "type" ] ],
+      [ this.querySelector(".ac-site-icon"), [ "src=image", "selected", "type" ] ],
+      [ this.querySelector(".ac-title"), [ "selected" ] ],
+      [ this.querySelector(".ac-title-text"), [ "selected" ] ],
+      [ this.querySelector(".ac-tags"), [ "selected" ] ],
+      [ this.querySelector(".ac-tags-text"), [ "selected" ] ],
+      [ this.querySelector(".ac-separator"), [ "selected", "actiontype", "type" ] ],
+      [ this.querySelector(".ac-url"), [ "selected", "actiontype" ] ],
+      [ this.querySelector(".ac-url-text"), [ "selected" ] ],
+      [ this.querySelector(".ac-action"), [ "selected", "actiontype" ] ],
+      [ this.querySelector(".ac-action-text"), [ "selected" ] ],
+    ]);
 
-      <property name="_learnMoreString">
-        <getter><![CDATA[
-          if (!this.__learnMoreString) {
-            this.__learnMoreString =
-              this.Services.strings.createBundle("chrome://passwordmgr/locale/passwordmgr.properties").
-              GetStringFromName("insecureFieldWarningLearnMore");
-          }
-          return this.__learnMoreString;
-        ]]></getter>
-      </property>
+    for (let [ el, attrs ] of map.entries()) {
+      for (let attr of attrs) {
+        this.inheritAttribute(el, attr);
+      }
+    }
+  }
 
-      <!-- Override _getSearchTokens to have the Learn More text emphasized -->
-      <method name="_getSearchTokens">
-        <parameter name="aSearch"/>
-        <body>
-          <![CDATA[
-            return [this._learnMoreString.toLowerCase()];
-          ]]>
-        </body>
-      </method>
+  get _markup() {
+    return `
+      <image class="ac-type-icon"></image>
+      <image class="ac-site-icon"></image>
+      <hbox class="ac-title" align="center">
+        <description class="ac-text-overflow-container">
+          <description class="ac-title-text"></description>
+        </description>
+      </hbox>
+      <hbox class="ac-tags" align="center">
+        <description class="ac-text-overflow-container">
+          <description class="ac-tags-text"></description>
+        </description>
+      </hbox>
+      <hbox class="ac-separator" align="center">
+        <description class="ac-separator-text"></description>
+      </hbox>
+      <hbox class="ac-url" align="center">
+        <description class="ac-text-overflow-container">
+          <description class="ac-url-text"></description>
+        </description>
+      </hbox>
+      <hbox class="ac-action" align="center">
+        <description class="ac-text-overflow-container">
+          <description class="ac-action-text"></description>
+        </description>
+      </hbox>
+    `;
+  }
 
-    </implementation>
-  </binding>
-
-  <binding id="autocomplete-richlistitem" extends="chrome://global/content/bindings/richlistbox.xml#richlistitem">
+  get _typeIcon() {
+    return this.querySelector(".ac-type-icon");
+  }
 
-    <content align="center"
-             onoverflow="this._onOverflow();"
-             onunderflow="this._onUnderflow();">
-      <xul:image anonid="type-icon"
-                 class="ac-type-icon"
-                 xbl:inherits="selected,current,type"/>
-      <xul:image anonid="site-icon"
-                 class="ac-site-icon"
-                 xbl:inherits="src=image,selected,type"/>
-      <xul:hbox class="ac-title"
-                align="center"
-                xbl:inherits="selected">
-        <xul:description class="ac-text-overflow-container">
-          <xul:description anonid="title-text"
-                           class="ac-title-text"
-                           xbl:inherits="selected"/>
-        </xul:description>
-      </xul:hbox>
-      <xul:hbox anonid="tags"
-                class="ac-tags"
-                align="center"
-                xbl:inherits="selected">
-        <xul:description class="ac-text-overflow-container">
-          <xul:description anonid="tags-text"
-                           class="ac-tags-text"
-                           xbl:inherits="selected"/>
-        </xul:description>
-      </xul:hbox>
-      <xul:hbox anonid="separator"
-                class="ac-separator"
-                align="center"
-                xbl:inherits="selected,actiontype,type">
-        <xul:description class="ac-separator-text">—</xul:description>
-      </xul:hbox>
-      <xul:hbox class="ac-url"
-                align="center"
-                xbl:inherits="selected,actiontype">
-        <xul:description class="ac-text-overflow-container">
-          <xul:description anonid="url-text"
-                           class="ac-url-text"
-                           xbl:inherits="selected"/>
-        </xul:description>
-      </xul:hbox>
-      <xul:hbox class="ac-action"
-                align="center"
-                xbl:inherits="selected,actiontype">
-        <xul:description class="ac-text-overflow-container">
-          <xul:description anonid="action-text"
-                           class="ac-action-text"
-                           xbl:inherits="selected"/>
-        </xul:description>
-      </xul:hbox>
-    </content>
+  get _titleText() {
+    return this.querySelector(".ac-title-text");
+  }
+
+  get _tags() {
+    return this.querySelector(".ac-tags");
+  }
+
+  get _tagsText() {
+    return this.querySelector(".ac-tags-text");
+  }
+
+  get _separator() {
+    return this.querySelector(".ac-separator");
+  }
+
+  get _urlText() {
+    return this.querySelector(".ac-url-text");
+  }
+
+  get _actionText() {
+    return this.querySelector(".ac-action-text");
+  }
+
+  get label() {
+    // This property is a string that is read aloud by screen readers,
+    // so it must not contain anything that should not be user-facing.
+
+    let parts = [
+      this.getAttribute("title"),
+      this.getAttribute("displayurl"),
+    ];
+    let label = parts.filter(str => str).join(" ");
+
+    // allow consumers that have extended popups to override
+    // the label values for the richlistitems
+    let panel = this.parentNode.parentNode;
+    if (panel.createResultLabel) {
+      return panel.createResultLabel(this, label);
+    }
+
+    return label;
+  }
+
+  get _stringBundle() {
+    if (!this.__stringBundle) {
+      this.__stringBundle = Services.strings.createBundle(
+        "chrome://global/locale/autocomplete.properties"
+      );
+    }
+    return this.__stringBundle;
+  }
+
+  get boundaryCutoff() {
+    if (!this._boundaryCutoff) {
+      this._boundaryCutoff = Services.prefs.
+        getIntPref("toolkit.autocomplete.richBoundaryCutoff");
+    }
+    return this._boundaryCutoff;
+  }
+
+  _cleanup() {
+    this.removeAttribute("url");
+    this.removeAttribute("image");
+    this.removeAttribute("title");
+    this.removeAttribute("text");
+    this.removeAttribute("displayurl");
+  }
+
+  _onOverflow() {
+    this._inOverflow = true;
+    this._handleOverflow();
+  }
 
-    <implementation implements="nsIDOMXULSelectControlItemElement">
-      <constructor>
-        <![CDATA[
-          this._typeIcon = document.getAnonymousElementByAttribute(
-            this, "anonid", "type-icon"
-          );
-          this._siteIcon = document.getAnonymousElementByAttribute(
-            this, "anonid", "site-icon"
-          );
-          this._titleText = document.getAnonymousElementByAttribute(
-            this, "anonid", "title-text"
-          );
-          this._tags = document.getAnonymousElementByAttribute(
-            this, "anonid", "tags"
-          );
-          this._tagsText = document.getAnonymousElementByAttribute(
-            this, "anonid", "tags-text"
-          );
-          this._separator = document.getAnonymousElementByAttribute(
-            this, "anonid", "separator"
-          );
-          this._urlText = document.getAnonymousElementByAttribute(
-            this, "anonid", "url-text"
-          );
-          this._actionText = document.getAnonymousElementByAttribute(
-            this, "anonid", "action-text"
-          );
-          this._adjustAcItem();
-        ]]>
-      </constructor>
+  _onUnderflow() {
+    this._inOverflow = false;
+    this._handleOverflow();
+  }
+
+  _getBoundaryIndices(aText, aSearchTokens) {
+    // Short circuit for empty search ([""] == "")
+    if (aSearchTokens == "")
+      return [0, aText.length];
+
+    // Find which regions of text match the search terms
+    let regions = [];
+    for (let search of Array.prototype.slice.call(aSearchTokens)) {
+      let matchIndex = -1;
+      let searchLen = search.length;
+
+      // Find all matches of the search terms, but stop early for perf
+      let lowerText = aText.substr(0, this.boundaryCutoff).toLowerCase();
+      while ((matchIndex = lowerText.indexOf(search, matchIndex + 1)) >= 0) {
+        regions.push([matchIndex, matchIndex + searchLen]);
+      }
+    }
+
+    // Sort the regions by start position then end position
+    regions = regions.sort((a, b) => {
+      let start = a[0] - b[0];
+      return (start == 0) ? a[1] - b[1] : start;
+    });
 
-      <property name="Services" readonly="true">
-        <getter><![CDATA[
-          let module = {};
-          if (window.Services) {
-            module.Services = window.Services;
-          } else {
-            ChromeUtils.import("resource://gre/modules/Services.jsm", module);
-          }
-          Object.defineProperty(this, "Services", {
-            configurable: true,
-            enumerable: true,
-            writable: true,
-            value: module.Services,
-          });
-          return module.Services;
-        ]]></getter>
-      </property>
+    // Generate the boundary indices from each region
+    let start = 0;
+    let end = 0;
+    let boundaries = [];
+    let len = regions.length;
+    for (let i = 0; i < len; i++) {
+      // We have a new boundary if the start of the next is past the end
+      let region = regions[i];
+      if (region[0] > end) {
+        // First index is the beginning of match
+        boundaries.push(start);
+        // Second index is the beginning of non-match
+        boundaries.push(end);
+
+        // Track the new region now that we've stored the previous one
+        start = region[0];
+      }
+
+      // Push back the end index for the current or new region
+      end = Math.max(end, region[1]);
+    }
 
-      <method name="_cleanup">
-        <body>
-        <![CDATA[
-          this.removeAttribute("url");
-          this.removeAttribute("image");
-          this.removeAttribute("title");
-          this.removeAttribute("text");
-          this.removeAttribute("displayurl");
-        ]]>
-        </body>
-      </method>
+    // Add the last region
+    boundaries.push(start);
+    boundaries.push(end);
+
+    // Put on the end boundary if necessary
+    if (end < aText.length)
+      boundaries.push(aText.length);
+
+    // Skip the first item because it's always 0
+    return boundaries.slice(1);
+  }
 
-      <property name="label" readonly="true">
-        <getter>
-          <![CDATA[
-            // This property is a string that is read aloud by screen readers,
-            // so it must not contain anything that should not be user-facing.
+  _getSearchTokens(aSearch) {
+    let search = aSearch.toLowerCase();
+    return search.split(/\s+/);
+  }
+
+  _setUpDescription(aDescriptionElement, aText, aNoEmphasis) {
+    // Get rid of all previous text
+    if (!aDescriptionElement) {
+      return;
+    }
+    while (aDescriptionElement.hasChildNodes())
+      aDescriptionElement.firstChild.remove();
 
-            let parts = [
-              this.getAttribute("title"),
-              this.getAttribute("displayurl"),
-            ];
-            let label = parts.filter(str => str).join(" ");
+    // If aNoEmphasis is specified, don't add any emphasis
+    if (aNoEmphasis) {
+      aDescriptionElement.appendChild(document.createTextNode(aText));
+      return;
+    }
 
-            // allow consumers that have extended popups to override
-            // the label values for the richlistitems
-            let panel = this.parentNode.parentNode;
-            if (panel.createResultLabel) {
-              return panel.createResultLabel(this, label);
-            }
+    // Get the indices that separate match and non-match text
+    let search = this.getAttribute("text");
+    let tokens = this._getSearchTokens(search);
+    let indices = this._getBoundaryIndices(aText, tokens);
 
-            return label;
-          ]]>
-        </getter>
-      </property>
+    this._appendDescriptionSpans(indices, aText, aDescriptionElement,
+      aDescriptionElement);
+  }
 
-      <property name="_stringBundle">
-        <getter><![CDATA[
-          if (!this.__stringBundle) {
-            this.__stringBundle = this.Services.strings.createBundle("chrome://global/locale/autocomplete.properties");
-          }
-          return this.__stringBundle;
-        ]]></getter>
-      </property>
+  _appendDescriptionSpans(indices, text, spansParentElement, descriptionElement) {
+    let next;
+    let start = 0;
+    let len = indices.length;
+    // Even indexed boundaries are matches, so skip the 0th if it's empty
+    for (let i = indices[0] == 0 ? 1 : 0; i < len; i++) {
+      next = indices[i];
+      let spanText = text.substr(start, next - start);
+      start = next;
 
-      <field name="_boundaryCutoff">null</field>
+      if (i % 2 == 0) {
+        // Emphasize the text for even indices
+        let span = spansParentElement.appendChild(
+          document.createElementNS("http://www.w3.org/1999/xhtml", "span"));
+        this._setUpEmphasisSpan(span, descriptionElement);
+        span.textContent = spanText;
+      } else {
+        // Otherwise, it's plain text
+        spansParentElement.appendChild(document.createTextNode(spanText));
+      }
+    }
+  }
+
+  _setUpTags(tags) {
+    while (this._tagsText.hasChildNodes()) {
+      this._tagsText.firstChild.remove();
+    }
+
+    let anyTagsMatch = false;
 
-      <property name="boundaryCutoff" readonly="true">
-        <getter>
-          <![CDATA[
-          if (!this._boundaryCutoff) {
-            this._boundaryCutoff =
-              Cc["@mozilla.org/preferences-service;1"].
-              getService(Ci.nsIPrefBranch).
-              getIntPref("toolkit.autocomplete.richBoundaryCutoff");
-          }
-          return this._boundaryCutoff;
-          ]]>
-        </getter>
-      </property>
+    // Include only tags that match the search string.
+    for (let tag of tags) {
+      // Check if the tag matches the search string.
+      let search = this.getAttribute("text");
+      let tokens = this._getSearchTokens(search);
+      let indices = this._getBoundaryIndices(tag, tokens);
 
-      <field name="_inOverflow">false</field>
+      if (indices.length == 2 &&
+        indices[0] == 0 &&
+        indices[1] == tag.length) {
+        // The tag doesn't match the search string, so don't include it.
+        continue;
+      }
+
+      anyTagsMatch = true;
 
-      <method name="_onOverflow">
-        <body>
-          <![CDATA[
-          this._inOverflow = true;
-          this._handleOverflow();
-          ]]>
-        </body>
-      </method>
+      let tagSpan =
+        document.createElementNS("http://www.w3.org/1999/xhtml", "span");
+      tagSpan.classList.add("ac-tag");
+      this._tagsText.appendChild(tagSpan);
+
+      this._appendDescriptionSpans(indices, tag, tagSpan, this._tagsText);
+    }
+
+    return anyTagsMatch;
+  }
 
-      <method name="_onUnderflow">
-        <body>
-          <![CDATA[
-          this._inOverflow = false;
-          this._handleOverflow();
-          ]]>
-        </body>
-      </method>
-
-      <method name="_getBoundaryIndices">
-        <parameter name="aText"/>
-        <parameter name="aSearchTokens"/>
-        <body>
-          <![CDATA[
-          // Short circuit for empty search ([""] == "")
-          if (aSearchTokens == "")
-            return [0, aText.length];
-
-          // Find which regions of text match the search terms
-          let regions = [];
-          for (let search of Array.prototype.slice.call(aSearchTokens)) {
-            let matchIndex = -1;
-            let searchLen = search.length;
+  _setUpEmphasisSpan(aSpan, aDescriptionElement) {
+    aSpan.classList.add("ac-emphasize-text");
+    switch (aDescriptionElement) {
+      case this._titleText:
+        aSpan.classList.add("ac-emphasize-text-title");
+        break;
+      case this._tagsText:
+        aSpan.classList.add("ac-emphasize-text-tag");
+        break;
+      case this._urlText:
+        aSpan.classList.add("ac-emphasize-text-url");
+        break;
+      case this._actionText:
+        aSpan.classList.add("ac-emphasize-text-action");
+        break;
+    }
+  }
 
-            // Find all matches of the search terms, but stop early for perf
-            let lowerText = aText.substr(0, this.boundaryCutoff).toLowerCase();
-            while ((matchIndex = lowerText.indexOf(search, matchIndex + 1)) >= 0) {
-              regions.push([matchIndex, matchIndex + searchLen]);
-            }
-          }
-
-          // Sort the regions by start position then end position
-          regions = regions.sort((a, b) => {
-            let start = a[0] - b[0];
-            return (start == 0) ? a[1] - b[1] : start;
-          });
+  /**
+   * This will generate an array of emphasis pairs for use with
+   * _setUpEmphasisedSections(). Each pair is a tuple (array) that
+   * represents a block of text - containing the text of that block, and a
+   * boolean for whether that block should have an emphasis styling applied
+   * to it.
+   *
+   * These pairs are generated by parsing a localised string (aSourceString)
+   * with parameters, in the format that is used by
+   * nsIStringBundle.formatStringFromName():
+   *
+   * "textA %1$S textB textC %2$S"
+   *
+   * Or:
+   *
+   * "textA %S"
+   *
+   * Where "%1$S", "%2$S", and "%S" are intended to be replaced by provided
+   * replacement strings. These are specified an array of tuples
+   * (aReplacements), each containing the replacement text and a boolean for
+   * whether that text should have an emphasis styling applied. This is used
+   * as a 1-based array - ie, "%1$S" is replaced by the item in the first
+   * index of aReplacements, "%2$S" by the second, etc. "%S" will always
+   * match the first index.
+   */
+  _generateEmphasisPairs(aSourceString, aReplacements) {
+    let pairs = [];
 
-          // Generate the boundary indices from each region
-          let start = 0;
-          let end = 0;
-          let boundaries = [];
-          let len = regions.length;
-          for (let i = 0; i < len; i++) {
-            // We have a new boundary if the start of the next is past the end
-            let region = regions[i];
-            if (region[0] > end) {
-              // First index is the beginning of match
-              boundaries.push(start);
-              // Second index is the beginning of non-match
-              boundaries.push(end);
+    // Split on %S, %1$S, %2$S, etc. ie:
+    //   "textA %S"
+    //     becomes ["textA ", "%S"]
+    //   "textA %1$S textB textC %2$S"
+    //     becomes ["textA ", "%1$S", " textB textC ", "%2$S"]
+    let parts = aSourceString.split(/(%(?:[0-9]+\$)?S)/);
+
+    for (let part of parts) {
+      // The above regex will actually give us an empty string at the
+      // end - we don't want that, as we don't want to later generate an
+      // empty text node for it.
+      if (part.length === 0)
+        continue;
 
-              // Track the new region now that we've stored the previous one
-              start = region[0];
-            }
+      // Determine if this token is a replacement token or a normal text
+      // token. If it is a replacement token, we want to extract the
+      // numerical number. However, we still want to match on "$S".
+      let match = part.match(/^%(?:([0-9]+)\$)?S$/);
+
+      if (match) {
+        // "%S" doesn't have a numerical number in it, but will always
+        // be assumed to be 1. Furthermore, the input string specifies
+        // these with a 1-based index, but we want a 0-based index.
+        let index = (match[1] || 1) - 1;
+
+        if (index >= 0 && index < aReplacements.length) {
+          pairs.push([...aReplacements[index]]);
+        }
+      } else {
+        pairs.push([part]);
+      }
+    }
 
-            // Push back the end index for the current or new region
-            end = Math.max(end, region[1]);
-          }
+    return pairs;
+  }
 
-          // Add the last region
-          boundaries.push(start);
-          boundaries.push(end);
+  /**
+   * _setUpEmphasisedSections() has the same use as _setUpDescription,
+   * except instead of taking a string and highlighting given tokens, it takes
+   * an array of pairs generated by _generateEmphasisPairs(). This allows
+   * control over emphasising based on specific blocks of text, rather than
+   * search for substrings.
+   */
+  _setUpEmphasisedSections(aDescriptionElement, aTextPairs) {
+    // Get rid of all previous text
+    while (aDescriptionElement.hasChildNodes())
+      aDescriptionElement.firstChild.remove();
 
-          // Put on the end boundary if necessary
-          if (end < aText.length)
-            boundaries.push(aText.length);
+    for (let [text, emphasise] of aTextPairs) {
+      if (emphasise) {
+        let span = aDescriptionElement.appendChild(
+          document.createElementNS("http://www.w3.org/1999/xhtml", "span"));
+        span.textContent = text;
+        switch (emphasise) {
+          case "match":
+            this._setUpEmphasisSpan(span, aDescriptionElement);
+            break;
+        }
+      } else {
+        aDescriptionElement.appendChild(document.createTextNode(text));
+      }
+    }
+  }
 
-          // Skip the first item because it's always 0
-          return boundaries.slice(1);
-          ]]>
-        </body>
-      </method>
+  _unescapeUrl(url) {
+    return Services.textToSubURI.unEscapeURIForUI("UTF-8", url);
+  }
 
-      <method name="_getSearchTokens">
-        <parameter name="aSearch"/>
-        <body>
-          <![CDATA[
-          let search = aSearch.toLowerCase();
-          return search.split(/\s+/);
-          ]]>
-        </body>
-      </method>
+  _reuseAcItem() {
+    let action = this._parseActionUrl(this.getAttribute("url"));
+    let popup = this.parentNode.parentNode;
+
+    // If the item is a searchengine action, then it should
+    // only be reused if the engine name is the same as the
+    // popup's override engine name, if any.
+    if (!action ||
+      action.type != "searchengine" ||
+      !popup.overrideSearchEngineName ||
+      action.params.engineName == popup.overrideSearchEngineName) {
+
+      this.collapsed = false;
 
-      <method name="_setUpDescription">
-        <parameter name="aDescriptionElement"/>
-        <parameter name="aText"/>
-        <parameter name="aNoEmphasis"/>
-        <body>
-          <![CDATA[
-          // Get rid of all previous text
-          if (!aDescriptionElement) {
-            return;
-          }
-          while (aDescriptionElement.hasChildNodes())
-            aDescriptionElement.firstChild.remove();
+      // The popup may have changed size between now and the last
+      // time the item was shown, so always handle over/underflow.
+      let dwu = window.windowUtils;
+      let popupWidth = dwu.getBoundsWithoutFlushing(this.parentNode).width;
+      if (!this._previousPopupWidth || this._previousPopupWidth != popupWidth) {
+        this._previousPopupWidth = popupWidth;
+        this.handleOverUnderflow();
+      }
 
-          // If aNoEmphasis is specified, don't add any emphasis
-          if (aNoEmphasis) {
-            aDescriptionElement.appendChild(document.createTextNode(aText));
-            return;
-          }
+      return true;
+    }
+
+    return false;
+  }
 
-          // Get the indices that separate match and non-match text
-          let search = this.getAttribute("text");
-          let tokens = this._getSearchTokens(search);
-          let indices = this._getBoundaryIndices(aText, tokens);
+  _adjustAcItem() {
+    let originalUrl = this.getAttribute("ac-value");
+    let title = this.getAttribute("ac-comment");
+    this.setAttribute("url", originalUrl);
+    this.setAttribute("image", this.getAttribute("ac-image"));
+    this.setAttribute("title", title);
+    this.setAttribute("text", this.getAttribute("ac-text"));
 
-          this._appendDescriptionSpans(indices, aText, aDescriptionElement,
-                                       aDescriptionElement);
-          ]]>
-        </body>
-      </method>
+    let popup = this.parentNode.parentNode;
+    let titleLooksLikeUrl = false;
+    let displayUrl = originalUrl;
+    let emphasiseUrl = true;
+    let trimDisplayUrl = true;
+
+    let type = this.getAttribute("originaltype");
+    let types = new Set(type.split(/\s+/));
+    let initialTypes = new Set(types);
+    // Remove types that should ultimately not be in the `type` string.
+    types.delete("action");
+    types.delete("autofill");
+    types.delete("heuristic");
+    type = [...types][0] || "";
+
+    let action;
 
-      <method name="_appendDescriptionSpans">
-        <parameter name="indices"/>
-        <parameter name="text"/>
-        <parameter name="spansParentElement"/>
-        <parameter name="descriptionElement"/>
-        <body>
-          <![CDATA[
-          let next;
-          let start = 0;
-          let len = indices.length;
-          // Even indexed boundaries are matches, so skip the 0th if it's empty
-          for (let i = indices[0] == 0 ? 1 : 0; i < len; i++) {
-            next = indices[i];
-            let spanText = text.substr(start, next - start);
-            start = next;
+    if (initialTypes.has("autofill") && !initialTypes.has("action")) {
+      // Treat autofills as visiturl actions, unless they are already also
+      // actions.
+      action = {
+        type: "visiturl",
+        params: { url: title },
+      };
+    }
+
+    this.removeAttribute("actiontype");
+    this.classList.remove(
+      "overridable-action",
+      "emptySearchQuery",
+      "aliasOffer"
+    );
+
+    // If the type includes an action, set up the item appropriately.
+    if (initialTypes.has("action") || action) {
+      action = action || this._parseActionUrl(originalUrl);
+      this.setAttribute("actiontype", action.type);
 
-            if (i % 2 == 0) {
-              // Emphasize the text for even indices
-              let span = spansParentElement.appendChild(
-                document.createElementNS("http://www.w3.org/1999/xhtml", "span"));
-              this._setUpEmphasisSpan(span, descriptionElement);
-              span.textContent = spanText;
-            } else {
-              // Otherwise, it's plain text
-              spansParentElement.appendChild(document.createTextNode(spanText));
-            }
+      switch (action.type) {
+        case "switchtab":
+          {
+            this.classList.add("overridable-action");
+            displayUrl = action.params.url;
+            let desc = this._stringBundle.GetStringFromName("switchToTab2");
+            this._setUpDescription(this._actionText, desc, true);
+            break;
           }
-          ]]>
-        </body>
-      </method>
+        case "remotetab":
+          {
+            displayUrl = action.params.url;
+            let desc = action.params.deviceName;
+            this._setUpDescription(this._actionText, desc, true);
+            break;
+          }
+        case "searchengine":
+          {
+            emphasiseUrl = false;
 
-      <method name="_setUpTags">
-        <parameter name="tags"/>
-        <body>
-          <![CDATA[
-          while (this._tagsText.hasChildNodes()) {
-            this._tagsText.firstChild.remove();
-          }
-
-          let anyTagsMatch = false;
+            // The order here is not localizable, we default to appending
+            // "- Search with Engine" to the search string, to be able to
+            // properly generate emphasis pairs. That said, no localization
+            // changed the order while it was possible, so doesn't look like
+            // there's a strong need for that.
+            let {
+              engineName,
+              searchSuggestion,
+              searchQuery,
+              alias,
+            } = action.params;
 
-          // Include only tags that match the search string.
-          for (let tag of tags) {
-            // Check if the tag matches the search string.
-            let search = this.getAttribute("text");
-            let tokens = this._getSearchTokens(search);
-            let indices = this._getBoundaryIndices(tag, tokens);
-
-            if (indices.length == 2 &&
-                indices[0] == 0 &&
-                indices[1] == tag.length) {
-              // The tag doesn't match the search string, so don't include it.
-              continue;
+            // Override the engine name if the popup defines an override.
+            let override = popup.overrideSearchEngineName;
+            if (override && override != engineName) {
+              engineName = override;
+              action.params.engineName = override;
+              let newURL =
+                PlacesUtils.mozActionURI(action.type, action.params);
+              this.setAttribute("url", newURL);
             }
 
-            anyTagsMatch = true;
-
-            let tagSpan =
-              document.createElementNS("http://www.w3.org/1999/xhtml", "span");
-            tagSpan.classList.add("ac-tag");
-            this._tagsText.appendChild(tagSpan);
-
-            this._appendDescriptionSpans(indices, tag, tagSpan, this._tagsText);
-          }
-
-          return anyTagsMatch;
-          ]]>
-        </body>
-      </method>
-
-      <method name="_setUpEmphasisSpan">
-        <parameter name="aSpan"/>
-        <parameter name="aDescriptionElement"/>
-        <body>
-          <![CDATA[
-          aSpan.classList.add("ac-emphasize-text");
-          switch (aDescriptionElement) {
-            case this._titleText:
-              aSpan.classList.add("ac-emphasize-text-title");
-              break;
-            case this._tagsText:
-              aSpan.classList.add("ac-emphasize-text-tag");
-              break;
-            case this._urlText:
-              aSpan.classList.add("ac-emphasize-text-url");
-              break;
-            case this._actionText:
-              aSpan.classList.add("ac-emphasize-text-action");
-              break;
-          }
-          ]]>
-        </body>
-      </method>
-
-      <!--
-        This will generate an array of emphasis pairs for use with
-        _setUpEmphasisedSections(). Each pair is a tuple (array) that
-        represents a block of text - containing the text of that block, and a
-        boolean for whether that block should have an emphasis styling applied
-        to it.
-
-        These pairs are generated by parsing a localised string (aSourceString)
-        with parameters, in the format that is used by
-        nsIStringBundle.formatStringFromName():
-
-          "textA %1$S textB textC %2$S"
-
-        Or:
-
-          "textA %S"
-
-        Where "%1$S", "%2$S", and "%S" are intended to be replaced by provided
-        replacement strings. These are specified an array of tuples
-        (aReplacements), each containing the replacement text and a boolean for
-        whether that text should have an emphasis styling applied. This is used
-        as a 1-based array - ie, "%1$S" is replaced by the item in the first
-        index of aReplacements, "%2$S" by the second, etc. "%S" will always
-        match the first index.
-      -->
-      <method name="_generateEmphasisPairs">
-        <parameter name="aSourceString"/>
-        <parameter name="aReplacements"/>
-        <body>
-          <![CDATA[
-            let pairs = [];
-
-            // Split on %S, %1$S, %2$S, etc. ie:
-            //   "textA %S"
-            //     becomes ["textA ", "%S"]
-            //   "textA %1$S textB textC %2$S"
-            //     becomes ["textA ", "%1$S", " textB textC ", "%2$S"]
-            let parts = aSourceString.split(/(%(?:[0-9]+\$)?S)/);
-
-            for (let part of parts) {
-              // The above regex will actually give us an empty string at the
-              // end - we don't want that, as we don't want to later generate an
-              // empty text node for it.
-              if (part.length === 0)
-                continue;
-
-              // Determine if this token is a replacement token or a normal text
-              // token. If it is a replacement token, we want to extract the
-              // numerical number. However, we still want to match on "$S".
-              let match = part.match(/^%(?:([0-9]+)\$)?S$/);
-
-              if (match) {
-                // "%S" doesn't have a numerical number in it, but will always
-                // be assumed to be 1. Furthermore, the input string specifies
-                // these with a 1-based index, but we want a 0-based index.
-                let index = (match[1] || 1) - 1;
-
-                if (index >= 0 && index < aReplacements.length) {
-                  pairs.push([...aReplacements[index]]);
-                }
-              } else {
-                pairs.push([part]);
-              }
-            }
-
-            return pairs;
-          ]]>
-        </body>
-      </method>
-
-      <!--
-        _setUpEmphasisedSections() has the same use as _setUpDescription,
-        except instead of taking a string and highlighting given tokens, it takes
-        an array of pairs generated by _generateEmphasisPairs(). This allows
-        control over emphasising based on specific blocks of text, rather than
-        search for substrings.
-      -->
-      <method name="_setUpEmphasisedSections">
-        <parameter name="aDescriptionElement"/>
-        <parameter name="aTextPairs"/>
-        <body>
-          <![CDATA[
-          // Get rid of all previous text
-          while (aDescriptionElement.hasChildNodes())
-            aDescriptionElement.firstChild.remove();
-
-          for (let [text, emphasise] of aTextPairs) {
-            if (emphasise) {
-              let span = aDescriptionElement.appendChild(
-                document.createElementNS("http://www.w3.org/1999/xhtml", "span"));
-              span.textContent = text;
-              switch (emphasise) {
-                case "match":
-                  this._setUpEmphasisSpan(span, aDescriptionElement);
-                  break;
-              }
-            } else {
-              aDescriptionElement.appendChild(document.createTextNode(text));
-            }
-          }
-          ]]>
-        </body>
-      </method>
-
-      <method name="_unescapeUrl">
-        <parameter name="url"/>
-        <body>
-          <![CDATA[
-          return this.Services.textToSubURI.unEscapeURIForUI("UTF-8", url);
-          ]]>
-        </body>
-      </method>
+            let engineStr =
+              this._stringBundle.formatStringFromName("searchWithEngine", [engineName], 1);
+            this._setUpDescription(this._actionText, engineStr, true);
 
-      <method name="_reuseAcItem">
-        <body>
-          <![CDATA[
-            let action = this._parseActionUrl(this.getAttribute("url"));
-            let popup = this.parentNode.parentNode;
-
-            // If the item is a searchengine action, then it should
-            // only be reused if the engine name is the same as the
-            // popup's override engine name, if any.
-            if (!action ||
-                action.type != "searchengine" ||
-                !popup.overrideSearchEngineName ||
-                action.params.engineName == popup.overrideSearchEngineName) {
-
-              this.collapsed = false;
-
-              // The popup may have changed size between now and the last
-              // time the item was shown, so always handle over/underflow.
-              let dwu = window.windowUtils;
-              let popupWidth = dwu.getBoundsWithoutFlushing(this.parentNode).width;
-              if (!this._previousPopupWidth || this._previousPopupWidth != popupWidth) {
-                this._previousPopupWidth = popupWidth;
-                this.handleOverUnderflow();
-              }
-
-              return true;
-            }
-
-            return false;
-          ]]>
-        </body>
-      </method>
-
-
-      <method name="_adjustAcItem">
-        <body>
-          <![CDATA[
-          let originalUrl = this.getAttribute("ac-value");
-          let title = this.getAttribute("ac-comment");
-          this.setAttribute("url", originalUrl);
-          this.setAttribute("image", this.getAttribute("ac-image"));
-          this.setAttribute("title", title);
-          this.setAttribute("text", this.getAttribute("ac-text"));
-
-          let popup = this.parentNode.parentNode;
-          let titleLooksLikeUrl = false;
-          let displayUrl = originalUrl;
-          let emphasiseUrl = true;
-          let trimDisplayUrl = true;
-
-          let type = this.getAttribute("originaltype");
-          let types = new Set(type.split(/\s+/));
-          let initialTypes = new Set(types);
-          // Remove types that should ultimately not be in the `type` string.
-          types.delete("action");
-          types.delete("autofill");
-          types.delete("heuristic");
-          type = [...types][0] || "";
-
-          let action;
-
-          if (initialTypes.has("autofill") && !initialTypes.has("action")) {
-            // Treat autofills as visiturl actions, unless they are already also
-            // actions.
-            action = {
-              type: "visiturl",
-              params: { url: title },
-            };
-          }
-
-          this.removeAttribute("actiontype");
-          this.classList.remove(
-            "overridable-action",
-            "emptySearchQuery",
-            "aliasOffer"
-          );
-
-          // If the type includes an action, set up the item appropriately.
-          if (initialTypes.has("action") || action) {
-            action = action || this._parseActionUrl(originalUrl);
-            this.setAttribute("actiontype", action.type);
-
-            switch (action.type) {
-            case "switchtab": {
-              this.classList.add("overridable-action");
-              displayUrl = action.params.url;
-              let desc = this._stringBundle.GetStringFromName("switchToTab2");
-              this._setUpDescription(this._actionText, desc, true);
-              break;
-            }
-            case "remotetab": {
-              displayUrl = action.params.url;
-              let desc = action.params.deviceName;
-              this._setUpDescription(this._actionText, desc, true);
-              break;
-            }
-            case "searchengine": {
-              emphasiseUrl = false;
-
-              // The order here is not localizable, we default to appending
-              // "- Search with Engine" to the search string, to be able to
-              // properly generate emphasis pairs. That said, no localization
-              // changed the order while it was possible, so doesn't look like
-              // there's a strong need for that.
-              let {
-                engineName,
-                searchSuggestion,
-                searchQuery,
-                alias,
-              } = action.params;
-
-              // Override the engine name if the popup defines an override.
-              let override = popup.overrideSearchEngineName;
-              if (override && override != engineName) {
-                engineName = override;
-                action.params.engineName = override;
-                let newURL =
-                  PlacesUtils.mozActionURI(action.type, action.params);
-                this.setAttribute("url", newURL);
-              }
-
-              let engineStr =
-                this._stringBundle.formatStringFromName("searchWithEngine",
-                                                        [engineName], 1);
-              this._setUpDescription(this._actionText, engineStr, true);
-
-              // Make the title by generating an array of pairs and its
-              // corresponding interpolation string (e.g., "%1$S") to pass to
-              // _generateEmphasisPairs.
-              let pairs;
-              if (searchSuggestion) {
-                // Check if the search query appears in the suggestion.  It may
-                // not.  If it does, then emphasize the query in the suggestion
-                // and otherwise just include the suggestion without emphasis.
-                let idx = searchSuggestion.indexOf(searchQuery);
-                if (idx >= 0) {
-                  pairs = [
-                    [searchSuggestion.substring(0, idx), ""],
-                    [searchQuery, "match"],
-                    [searchSuggestion.substring(idx + searchQuery.length), ""],
-                  ];
-                } else {
-                  pairs = [
-                    [searchSuggestion, ""],
-                  ];
-                }
-              } else if (alias &&
-                         !searchQuery.trim() &&
-                         !initialTypes.has("heuristic")) {
-                // For non-heuristic alias results that have an empty query, we
-                // want to show "@engine -- Search with Engine" to make it clear
-                // that the user can search by selecting the result and using
-                // the alias.  Normally we hide the "Search with Engine" part
-                // until the result is selected or moused over, but not here.
-                // Add the aliasOffer class so we can detect this in the CSS.
-                this.classList.add("aliasOffer");
+            // Make the title by generating an array of pairs and its
+            // corresponding interpolation string (e.g., "%1$S") to pass to
+            // _generateEmphasisPairs.
+            let pairs;
+            if (searchSuggestion) {
+              // Check if the search query appears in the suggestion.  It may
+              // not.  If it does, then emphasize the query in the suggestion
+              // and otherwise just include the suggestion without emphasis.
+              let idx = searchSuggestion.indexOf(searchQuery);
+              if (idx >= 0) {
                 pairs = [
-                  [alias, ""],
+                  [searchSuggestion.substring(0, idx), ""],
+                  [searchQuery, "match"],
+                  [searchSuggestion.substring(idx + searchQuery.length), ""],
                 ];
               } else {
-                // Add the emptySearchQuery class if the search query is the
-                // empty string.  We use it to hide .ac-separator in CSS.
-                if (!searchQuery.trim()) {
-                  this.classList.add("emptySearchQuery");
-                }
                 pairs = [
-                  [searchQuery, ""],
+                  [searchSuggestion, ""],
                 ];
               }
-              let interpStr = pairs.map((pair, i) => `%${i + 1}$S`).join("");
-              title = this._generateEmphasisPairs(interpStr, pairs);
-
-              // If this is a default search match, we remove the image so we
-              // can style it ourselves with a generic search icon.
-              // We don't do this when matching an aliased search engine,
-              // because the icon helps with recognising which engine will be
-              // used (when using the default engine, we don't need that
-              // recognition).
-              if (!action.params.alias && !initialTypes.has("favicon")) {
-                this.removeAttribute("image");
+            } else if (alias &&
+              !searchQuery.trim() &&
+              !initialTypes.has("heuristic")) {
+              // For non-heuristic alias results that have an empty query, we
+              // want to show "@engine -- Search with Engine" to make it clear
+              // that the user can search by selecting the result and using
+              // the alias.  Normally we hide the "Search with Engine" part
+              // until the result is selected or moused over, but not here.
+              // Add the aliasOffer class so we can detect this in the CSS.
+              this.classList.add("aliasOffer");
+              pairs = [
+                [alias, ""],
+              ];
+            } else {
+              // Add the emptySearchQuery class if the search query is the
+              // empty string.  We use it to hide .ac-separator in CSS.
+              if (!searchQuery.trim()) {
+                this.classList.add("emptySearchQuery");
               }
-              break;
+              pairs = [
+                [searchQuery, ""],
+              ];
             }
-            case "visiturl": {
-              emphasiseUrl = false;
-              displayUrl = action.params.url;
-              titleLooksLikeUrl = true;
-              let visitStr = this._stringBundle.GetStringFromName("visit");
-              this._setUpDescription(this._actionText, visitStr, true);
-              break;
-            }
-            case "extension": {
-              let content = action.params.content;
-              displayUrl = content;
-              trimDisplayUrl = false;
-              this._setUpDescription(this._actionText, content, true);
-              break;
-            }
-            }
-          }
+            let interpStr = pairs.map((pair, i) => `%${i + 1}$S`).join("");
+            title = this._generateEmphasisPairs(interpStr, pairs);
 
-          if (trimDisplayUrl) {
-            let input = popup.input;
-            if (typeof input.trimValue == "function")
-              displayUrl = input.trimValue(displayUrl);
-            displayUrl = this._unescapeUrl(displayUrl);
-          }
-          // For performance reasons we may want to limit the displayUrl size.
-          if (popup.textRunsMaxLen && displayUrl) {
-            displayUrl = displayUrl.substr(0, popup.textRunsMaxLen);
-          }
-          this.setAttribute("displayurl", displayUrl);
-
-          // Show the domain as the title if we don't have a title.
-          if (!title) {
-            titleLooksLikeUrl = true;
-            try {
-              let uri = this.Services.io.newURI(originalUrl);
-              // Not all valid URLs have a domain.
-              if (uri.host)
-                title = uri.host;
-            } catch (e) {}
-            if (!title)
-              title = displayUrl;
-          }
-
-          this._tags.setAttribute("empty", "true");
-
-          if (type == "tag" || type == "bookmark-tag") {
-            // The title is separated from the tags by an endash
-            let tags;
-            [, title, tags] = title.match(/^(.+) \u2013 (.+)$/);
-
-            // Each tag is split by a comma in an undefined order, so sort it
-            let sortedTags = tags.split(/\s*,\s*/).sort((a, b) => {
-              return a.localeCompare(a);
-            });
-
-            let anyTagsMatch = this._setUpTags(sortedTags);
-            if (anyTagsMatch) {
-              this._tags.removeAttribute("empty");
-            }
-            if (type == "bookmark-tag") {
-              type = "bookmark";
+            // If this is a default search match, we remove the image so we
+            // can style it ourselves with a generic search icon.
+            // We don't do this when matching an aliased search engine,
+            // because the icon helps with recognising which engine will be
+            // used (when using the default engine, we don't need that
+            // recognition).
+            if (!action.params.alias && !initialTypes.has("favicon")) {
+              this.removeAttribute("image");
             }
-          } else if (type == "keyword") {
-            // Note that this is a moz-action with action.type == keyword.
+            break;
+          }
+        case "visiturl":
+          {
             emphasiseUrl = false;
-            let keywordArg = this.getAttribute("text").replace(/^[^\s]+\s*/, "");
-            if (!keywordArg) {
-              // Treat keyword searches without arguments as visiturl actions.
-              type = "visiturl";
-              this.setAttribute("actiontype", "visiturl");
-              let visitStr = this._stringBundle.GetStringFromName("visit");
-              this._setUpDescription(this._actionText, visitStr, true);
-            } else {
-              let pairs = [[title, ""], [keywordArg, "match"]];
-              let interpStr =
-                this._stringBundle.GetStringFromName("bookmarkKeywordSearch");
-              title = this._generateEmphasisPairs(interpStr, pairs);
-              // The action box will be visible since this is a moz-action, but
-              // we want it to appear as if it were not visible, so set its text
-              // to the empty string.
-              this._setUpDescription(this._actionText, "", false);
-            }
+            displayUrl = action.params.url;
+            titleLooksLikeUrl = true;
+            let visitStr = this._stringBundle.GetStringFromName("visit");
+            this._setUpDescription(this._actionText, visitStr, true);
+            break;
+          }
+        case "extension":
+          {
+            let content = action.params.content;
+            displayUrl = content;
+            trimDisplayUrl = false;
+            this._setUpDescription(this._actionText, content, true);
+            break;
           }
+      }
+    }
 
-          this.setAttribute("type", type);
+    if (trimDisplayUrl) {
+      let input = popup.input;
+      if (typeof input.trimValue == "function")
+        displayUrl = input.trimValue(displayUrl);
+      displayUrl = this._unescapeUrl(displayUrl);
+    }
+    // For performance reasons we may want to limit the displayUrl size.
+    if (popup.textRunsMaxLen && displayUrl) {
+      displayUrl = displayUrl.substr(0, popup.textRunsMaxLen);
+    }
+    this.setAttribute("displayurl", displayUrl);
 
-          if (titleLooksLikeUrl) {
-            this._titleText.setAttribute("lookslikeurl", "true");
-          } else {
-            this._titleText.removeAttribute("lookslikeurl");
-          }
+    // Show the domain as the title if we don't have a title.
+    if (!title) {
+      titleLooksLikeUrl = true;
+      try {
+        let uri = Services.io.newURI(originalUrl);
+        // Not all valid URLs have a domain.
+        if (uri.host)
+          title = uri.host;
+      } catch (e) {}
+      if (!title)
+        title = displayUrl;
+    }
+
+    this._tags.setAttribute("empty", "true");
+
+    if (type == "tag" || type == "bookmark-tag") {
+      // The title is separated from the tags by an endash
+      let tags;
+      [, title, tags] = title.match(/^(.+) \u2013 (.+)$/);
+
+      // Each tag is split by a comma in an undefined order, so sort it
+      let sortedTags = tags.split(/\s*,\s*/).sort((a, b) => {
+        return a.localeCompare(a);
+      });
 
-          if (Array.isArray(title)) {
-            // For performance reasons we may want to limit the title size.
-            if (popup.textRunsMaxLen) {
-              title.forEach(t => {
-                // Limit all the even items.
-                for (let i = 0; i < t.length; i += 2) {
-                  t[i] = t[i].substr(0, popup.textRunsMaxLen);
-                }
-              });
-            }
-            this._setUpEmphasisedSections(this._titleText, title);
-          } else {
-            // For performance reasons we may want to limit the title size.
-            if (popup.textRunsMaxLen && title) {
-              title = title.substr(0, popup.textRunsMaxLen);
-            }
-            this._setUpDescription(this._titleText, title, false);
-          }
-          this._setUpDescription(this._urlText, displayUrl, !emphasiseUrl);
+      let anyTagsMatch = this._setUpTags(sortedTags);
+      if (anyTagsMatch) {
+        this._tags.removeAttribute("empty");
+      }
+      if (type == "bookmark-tag") {
+        type = "bookmark";
+      }
+    } else if (type == "keyword") {
+      // Note that this is a moz-action with action.type == keyword.
+      emphasiseUrl = false;
+      let keywordArg = this.getAttribute("text").replace(/^[^\s]+\s*/, "");
+      if (!keywordArg) {
+        // Treat keyword searches without arguments as visiturl actions.
+        type = "visiturl";
+        this.setAttribute("actiontype", "visiturl");
+        let visitStr = this._stringBundle.GetStringFromName("visit");
+        this._setUpDescription(this._actionText, visitStr, true);
+      } else {
+        let pairs = [
+          [title, ""],
+          [keywordArg, "match"],
+        ];
+        let interpStr =
+          this._stringBundle.GetStringFromName("bookmarkKeywordSearch");
+        title = this._generateEmphasisPairs(interpStr, pairs);
+        // The action box will be visible since this is a moz-action, but
+        // we want it to appear as if it were not visible, so set its text
+        // to the empty string.
+        this._setUpDescription(this._actionText, "", false);
+      }
+    }
+
+    this.setAttribute("type", type);
+
+    if (titleLooksLikeUrl) {
+      this._titleText.setAttribute("lookslikeurl", "true");
+    } else {
+      this._titleText.removeAttribute("lookslikeurl");
+    }
 
-          // Removing the max-width may be jarring when the item is visible, but
-          // we have no other choice to properly crop the text.
-          // Removing max-widths may cause overflow or underflow events, that
-          // will set the _inOverflow property. In case both the old and the new
-          // text are overflowing, the overflow event won't happen, and we must
-          // enforce an _handleOverflow() call to update the max-widths.
-          let wasInOverflow = this._inOverflow;
-          this._removeMaxWidths();
-          if (wasInOverflow && this._inOverflow) {
-            this._handleOverflow();
+    if (Array.isArray(title)) {
+      // For performance reasons we may want to limit the title size.
+      if (popup.textRunsMaxLen) {
+        title.forEach(t => {
+          // Limit all the even items.
+          for (let i = 0; i < t.length; i += 2) {
+            t[i] = t[i].substr(0, popup.textRunsMaxLen);
           }
-          ]]>
-        </body>
-      </method>
+        });
+      }
+      this._setUpEmphasisedSections(this._titleText, title);
+    } else {
+      // For performance reasons we may want to limit the title size.
+      if (popup.textRunsMaxLen && title) {
+        title = title.substr(0, popup.textRunsMaxLen);
+      }
+      this._setUpDescription(this._titleText, title, false);
+    }
+    this._setUpDescription(this._urlText, displayUrl, !emphasiseUrl);
+
+    // Removing the max-width may be jarring when the item is visible, but
+    // we have no other choice to properly crop the text.
+    // Removing max-widths may cause overflow or underflow events, that
+    // will set the _inOverflow property. In case both the old and the new
+    // text are overflowing, the overflow event won't happen, and we must
+    // enforce an _handleOverflow() call to update the max-widths.
+    let wasInOverflow = this._inOverflow;
+    this._removeMaxWidths();
+    if (wasInOverflow && this._inOverflow) {
+      this._handleOverflow();
+    }
+  }
 
-      <method name="_removeMaxWidths">
-        <body>
-          <![CDATA[
-          if (this._hasMaxWidths) {
-            this._titleText.style.removeProperty("max-width");
-            this._tagsText.style.removeProperty("max-width");
-            this._urlText.style.removeProperty("max-width");
-            this._actionText.style.removeProperty("max-width");
-            this._hasMaxWidths = false;
-          }
-          ]]>
-        </body>
-      </method>
+  _removeMaxWidths() {
+    if (this._hasMaxWidths) {
+      this._titleText.style.removeProperty("max-width");
+      this._tagsText.style.removeProperty("max-width");
+      this._urlText.style.removeProperty("max-width");
+      this._actionText.style.removeProperty("max-width");
+      this._hasMaxWidths = false;
+    }
+  }
+
+  /**
+   * This method truncates the displayed strings as necessary.
+   */
+  _handleOverflow() {
+    let itemRect = this.parentNode.getBoundingClientRect();
+    let titleRect = this._titleText.getBoundingClientRect();
+    let tagsRect = this._tagsText.getBoundingClientRect();
+    let separatorRect = this._separator.getBoundingClientRect();
+    let urlRect = this._urlText.getBoundingClientRect();
+    let actionRect = this._actionText.getBoundingClientRect();
+    let separatorURLActionWidth =
+      separatorRect.width + Math.max(urlRect.width, actionRect.width);
+
+    // Total width for the title and URL/action is the width of the item
+    // minus the start of the title text minus a little optional extra padding.
+    // This extra padding amount is basically arbitrary but keeps the text
+    // from getting too close to the popup's edge.
+    let dir = this.getAttribute("dir");
+    let titleStart = dir == "rtl" ? itemRect.right - titleRect.right :
+      titleRect.left - itemRect.left;
+
+    let popup = this.parentNode.parentNode;
+    let itemWidth = itemRect.width - titleStart - popup.overflowPadding -
+      (popup.margins ? popup.margins.end : 0);
 
-      <!-- This method truncates the displayed strings as necessary. -->
-      <method name="_handleOverflow">
-        <body><![CDATA[
-          let itemRect = this.parentNode.getBoundingClientRect();
-          let titleRect = this._titleText.getBoundingClientRect();
-          let tagsRect = this._tagsText.getBoundingClientRect();
-          let separatorRect = this._separator.getBoundingClientRect();
-          let urlRect = this._urlText.getBoundingClientRect();
-          let actionRect = this._actionText.getBoundingClientRect();
-          let separatorURLActionWidth =
-            separatorRect.width + Math.max(urlRect.width, actionRect.width);
+    if (this._tags.hasAttribute("empty")) {
+      // The tags box is not displayed in this case.
+      tagsRect.width = 0;
+    }
+
+    let titleTagsWidth = titleRect.width + tagsRect.width;
+    if (titleTagsWidth + separatorURLActionWidth > itemWidth) {
+      // Title + tags + URL/action overflows the item width.
+
+      // The percentage of the item width allocated to the title and tags.
+      let titleTagsPct = 0.66;
+
+      let titleTagsAvailable = itemWidth - separatorURLActionWidth;
+      let titleTagsMaxWidth = Math.max(
+        titleTagsAvailable,
+        itemWidth * titleTagsPct
+      );
+      if (titleTagsWidth > titleTagsMaxWidth) {
+        // Title + tags overflows the max title + tags width.
+
+        // The percentage of the title + tags width allocated to the
+        // title.
+        let titlePct = 0.33;
 
-          // Total width for the title and URL/action is the width of the item
-          // minus the start of the title text minus a little optional extra padding.
-          // This extra padding amount is basically arbitrary but keeps the text
-          // from getting too close to the popup's edge.
-          let dir = this.getAttribute("dir");
-          let titleStart = dir == "rtl" ? itemRect.right - titleRect.right
-                                        : titleRect.left - itemRect.left;
-
-          let popup = this.parentNode.parentNode;
-          let itemWidth = itemRect.width - titleStart - popup.overflowPadding -
-                          (popup.margins ? popup.margins.end : 0);
-
-          if (this._tags.hasAttribute("empty")) {
-            // The tags box is not displayed in this case.
-            tagsRect.width = 0;
-          }
-
-          let titleTagsWidth = titleRect.width + tagsRect.width;
-          if (titleTagsWidth + separatorURLActionWidth > itemWidth) {
-            // Title + tags + URL/action overflows the item width.
-
-            // The percentage of the item width allocated to the title and tags.
-            let titleTagsPct = 0.66;
+        let titleAvailable = titleTagsMaxWidth - tagsRect.width;
+        let titleMaxWidth = Math.max(
+          titleAvailable,
+          titleTagsMaxWidth * titlePct
+        );
+        let tagsAvailable = titleTagsMaxWidth - titleRect.width;
+        let tagsMaxWidth = Math.max(
+          tagsAvailable,
+          titleTagsMaxWidth * (1 - titlePct)
+        );
+        this._titleText.style.maxWidth = titleMaxWidth + "px";
+        this._tagsText.style.maxWidth = tagsMaxWidth + "px";
+      }
+      let urlActionMaxWidth = Math.max(
+        itemWidth - titleTagsWidth,
+        itemWidth * (1 - titleTagsPct)
+      );
+      urlActionMaxWidth -= separatorRect.width;
+      this._urlText.style.maxWidth = urlActionMaxWidth + "px";
+      this._actionText.style.maxWidth = urlActionMaxWidth + "px";
+      this._hasMaxWidths = true;
+    }
+  }
 
-            let titleTagsAvailable = itemWidth - separatorURLActionWidth;
-            let titleTagsMaxWidth = Math.max(
-              titleTagsAvailable,
-              itemWidth * titleTagsPct
-            );
-            if (titleTagsWidth > titleTagsMaxWidth) {
-              // Title + tags overflows the max title + tags width.
+  handleOverUnderflow() {
+    this._removeMaxWidths();
+    this._handleOverflow();
+  }
 
-              // The percentage of the title + tags width allocated to the
-              // title.
-              let titlePct = 0.33;
+  _parseActionUrl(aUrl) {
+    if (!aUrl.startsWith("moz-action:"))
+      return null;
+
+    // URL is in the format moz-action:ACTION,PARAMS
+    // Where PARAMS is a JSON encoded object.
+    let [, type, params] = aUrl.match(/^moz-action:([^,]+),(.*)$/);
+
+    let action = {
+      type,
+    };
 
-              let titleAvailable = titleTagsMaxWidth - tagsRect.width;
-              let titleMaxWidth = Math.max(
-                titleAvailable,
-                titleTagsMaxWidth * titlePct
-              );
-              let tagsAvailable = titleTagsMaxWidth - titleRect.width;
-              let tagsMaxWidth = Math.max(
-                tagsAvailable,
-                titleTagsMaxWidth * (1 - titlePct)
-              );
-              this._titleText.style.maxWidth = titleMaxWidth + "px";
-              this._tagsText.style.maxWidth = tagsMaxWidth + "px";
-            }
-            let urlActionMaxWidth = Math.max(
-              itemWidth - titleTagsWidth,
-              itemWidth * (1 - titleTagsPct)
-            );
-            urlActionMaxWidth -= separatorRect.width;
-            this._urlText.style.maxWidth = urlActionMaxWidth + "px";
-            this._actionText.style.maxWidth = urlActionMaxWidth + "px";
-            this._hasMaxWidths = true;
-          }
-        ]]></body>
-      </method>
+    try {
+      action.params = JSON.parse(params);
+      for (let key in action.params) {
+        action.params[key] = decodeURIComponent(action.params[key]);
+      }
+    } catch (e) {
+      // If this failed, we assume that params is not a JSON object, and
+      // is instead just a flat string. This may happen for legacy
+      // search components.
+      action.params = {
+        url: params,
+      };
+    }
+
+    return action;
+  }
+}
+
+MozXULElement.implementCustomInterface(
+  MozAutocompleteRichlistitem,
+  [Ci.nsIDOMXULSelectControlItemElement]
+);
+
+class MozAutocompleteRichlistitemInsecureWarning extends MozAutocompleteRichlistitem {
+  constructor() {
+    super();
+
+    this.addEventListener("click", (event) => {
+      if (event.button != 0) {
+        return;
+      }
 
-      <method name="handleOverUnderflow">
-        <body>
-          <![CDATA[
-          this._removeMaxWidths();
-          this._handleOverflow();
-          ]]>
-        </body>
-      </method>
+      let baseURL = Services.urlFormatter.formatURLPref("app.support.baseURL");
+      window.openTrustedLinkIn(baseURL + "insecure-password", "tab", {
+        relatedToCurrent: true,
+      });
+    });
+  }
 
-      <method name="_parseActionUrl">
-        <parameter name="aUrl"/>
-        <body><![CDATA[
-          if (!aUrl.startsWith("moz-action:"))
-            return null;
+  connectedCallback() {
+    if (this.delayConnectedCallback()) {
+      return;
+    }
+
+    super.connectedCallback();
+
+    // Unlike other autocomplete items, the height of the insecure warning
+    // increases by wrapping. So "forceHandleUnderflow" is for container to
+    // recalculate an item's height and width.
+    this.classList.add("forceHandleUnderflow");
+  }
 
-          // URL is in the format moz-action:ACTION,PARAMS
-          // Where PARAMS is a JSON encoded object.
-          let [, type, params] = aUrl.match(/^moz-action:([^,]+),(.*)$/);
-
-          let action = {
-            type,
-          };
+  static get observedAttributes() {
+    return [
+      "actiontype",
+      "current",
+      "selected",
+      "image",
+      "type",
+    ];
+  }
 
-          try {
-            action.params = JSON.parse(params);
-            for (let key in action.params) {
-              action.params[key] = decodeURIComponent(action.params[key]);
-            }
-          } catch (e) {
-            // If this failed, we assume that params is not a JSON object, and
-            // is instead just a flat string. This may happen for legacy
-            // search components.
-            action.params = {
-              url: params,
-            };
-          }
+  _updateAttributes() {
+    const map = new Map([
+      [ this.querySelector(".ac-type-icon"), [ "selected", "current", "type" ] ],
+      [ this.querySelector(".ac-site-icon"), [ "src=image", "selected", "type" ] ],
+      [ this.querySelector(".ac-title-text"), [ "selected" ] ],
+      [ this.querySelector(".ac-tags-text"), [ "selected" ] ],
+      [ this.querySelector(".ac-separator"), [ "selected", "actiontype", "type" ] ],
+      [ this.querySelector(".ac-url"), [ "selected", "actiontype" ] ],
+      [ this.querySelector(".ac-url-text"), [ "selected" ] ],
+      [ this.querySelector(".ac-action"), [ "selected", "actiontype" ] ],
+      [ this.querySelector(".ac-action-text"), [ "selected" ] ],
+    ]);
+
+    for (let [ el, attrs ] of map.entries()) {
+      for (let attr of attrs) {
+        this.inheritAttribute(el, attr);
+      }
+    }
+  }
 
-          return action;
-        ]]></body>
-      </method>
-    </implementation>
-
-    <handlers>
-      <!--
-        This overrides listitem's mousedown handler because we want to set the
-        selected item even when the shift or accel keys are pressed.
-      -->
-      <handler event="mousedown"><![CDATA[
-        // Call this.control only once since it's not a simple getter.
-        let control = this.control;
-        if (!control || control.disabled) {
-          return;
-        }
-        if (!this.selected) {
-          control.selectItem(this);
-        }
-        control.currentItem = this;
-      ]]></handler>
+  get _markup() {
+    return `
+      <image class="ac-type-icon"></image>
+      <image class="ac-site-icon"></image>
+      <vbox class="ac-title" align="left">
+        <description class="ac-text-overflow-container">
+          <description class="ac-title-text"></description>
+        </description>
+      </vbox>
+      <hbox class="ac-tags" align="center">
+        <description class="ac-text-overflow-container">
+          <description class="ac-tags-text"></description>
+        </description>
+      </hbox>
+      <hbox class="ac-separator" align="center">
+        <description class="ac-separator-text"></description>
+      </hbox>
+      <hbox class="ac-url" align="center">
+        <description class="ac-text-overflow-container">
+          <description class="ac-url-text"></description>
+        </description>
+      </hbox>
+      <hbox class="ac-action" align="center">
+        <description class="ac-text-overflow-container">
+          <description class="ac-action-text"></description>
+        </description>
+      </hbox>
+    `;
+  }
 
-      <handler event="mouseover"><![CDATA[
-        // The point of implementing this handler is to allow drags to change
-        // the selected item.  If the user mouses down on an item, it becomes
-        // selected.  If they then drag the mouse to another item, select it.
-        // Handle all three primary mouse buttons: right, left, and wheel, since
-        // all three change the selection on mousedown.
-        let mouseDown = event.buttons & 0b111;
-        if (!mouseDown) {
-          return;
-        }
-        // Call this.control only once since it's not a simple getter.
-        let control = this.control;
-        if (!control || control.disabled) {
-          return;
-        }
-        if (!this.selected) {
-          control.selectItem(this);
-        }
-        control.currentItem = this;
-      ]]></handler>
-    </handlers>
-  </binding>
+  get _learnMoreString() {
+    if (!this.__learnMoreString) {
+      this.__learnMoreString = Services.strings.createBundle(
+        "chrome://passwordmgr/locale/passwordmgr.properties"
+      ).
+      GetStringFromName("insecureFieldWarningLearnMore");
+    }
+    return this.__learnMoreString;
+  }
+
+  /**
+   * Override _getSearchTokens to have the Learn More text emphasized
+   */
+  _getSearchTokens(aSearch) {
+    return [this._learnMoreString.toLowerCase()];
+  }
+}
+
+customElements.define(
+  "autocomplete-richlistitem-insecure-warning",
+  MozAutocompleteRichlistitemInsecureWarning,
+  { extends: "richlistitem" }
+);
+
+}
diff --git a/toolkit/content/widgets/autocomplete.xml b/toolkit/content/widgets/autocomplete.xml
--- a/toolkit/content/widgets/autocomplete.xml
+++ b/toolkit/content/widgets/autocomplete.xml
@@ -1048,17 +1048,19 @@
               ];
               // Reuse the item when its style is exactly equal to the previous style or
               // neither of their style are in the UNREUSEABLE_STYLES.
               reusable = originalType === style ||
                 !(UNREUSEABLE_STYLES.includes(style) || UNREUSEABLE_STYLES.includes(originalType));
 
             } else {
               // need to create a new item
-              item = document.createXULElement("richlistitem");
+              let options = style == "insecureWarning" ?
+                { is: "autocomplete-richlistitem-insecure-warning" } : null;
+              item = document.createXULElement("richlistitem", options);
             }
 
             item.setAttribute("dir", this.style.direction);
             item.setAttribute("ac-image", image);
             item.setAttribute("ac-value", value);
             item.setAttribute("ac-label", label);
             item.setAttribute("ac-comment", comment);
             item.setAttribute("ac-text", trimmedSearchString);
@@ -1221,122 +1223,25 @@
           this.mInput.mIgnoreFocus = true;
           this.mInput._focus();
           this.mInput.mIgnoreFocus = false;
         }
       ]]></handler>
     </handlers>
   </binding>
 
-  <binding id="autocomplete-richlistitem-insecure-field" extends="chrome://global/content/bindings/autocomplete.xml#autocomplete-richlistitem">
-    <content align="center"
-             onoverflow="this._onOverflow();"
-             onunderflow="this._onUnderflow();">
-      <xul:image anonid="type-icon"
-                 class="ac-type-icon"
-                 xbl:inherits="selected,current,type"/>
-      <xul:image anonid="site-icon"
-                 class="ac-site-icon"
-                 xbl:inherits="src=image,selected,type"/>
-      <xul:vbox class="ac-title"
-                align="left"
-                xbl:inherits="">
-        <xul:description class="ac-text-overflow-container">
-          <xul:description anonid="title-text"
-                           class="ac-title-text"
-                           xbl:inherits="selected"/>
-        </xul:description>
-      </xul:vbox>
-      <xul:hbox anonid="tags"
-                class="ac-tags"
-                align="center"
-                xbl:inherits="selected">
-        <xul:description class="ac-text-overflow-container">
-          <xul:description anonid="tags-text"
-                           class="ac-tags-text"
-                           xbl:inherits="selected"/>
-        </xul:description>
-      </xul:hbox>
-      <xul:hbox anonid="separator"
-                class="ac-separator"
-                align="center"
-                xbl:inherits="selected,actiontype,type">
-        <xul:description class="ac-separator-text">—</xul:description>
-      </xul:hbox>
-      <xul:hbox class="ac-url"
-                align="center"
-                xbl:inherits="selected,actiontype">
-        <xul:description class="ac-text-overflow-container">
-          <xul:description anonid="url-text"
-                           class="ac-url-text"
-                           xbl:inherits="selected"/>
-        </xul:description>
-      </xul:hbox>
-      <xul:hbox class="ac-action"
-                align="center"
-                xbl:inherits="selected,actiontype">
-        <xul:description class="ac-text-overflow-container">
-          <xul:description anonid="action-text"
-                           class="ac-action-text"
-                           xbl:inherits="selected"/>
-        </xul:description>
-      </xul:hbox>
-    </content>
-
-    <handlers>
-      <handler event="click" button="0"><![CDATA[
-        let baseURL = this.Services.urlFormatter.formatURLPref("app.support.baseURL");
-        window.openTrustedLinkIn(baseURL + "insecure-password", "tab", {
-          relatedToCurrent: true,
-        });
-      ]]></handler>
-    </handlers>
-
-    <implementation>
-      <constructor><![CDATA[
-        // Unlike other autocomplete items, the height of the insecure warning
-        // increases by wrapping. So "forceHandleUnderflow" is for container to
-        // recalculate an item's height and width.
-        this.classList.add("forceHandleUnderflow");
-      ]]></constructor>
-
-      <property name="_learnMoreString">
-        <getter><![CDATA[
-          if (!this.__learnMoreString) {
-            this.__learnMoreString =
-              this.Services.strings.createBundle("chrome://passwordmgr/locale/passwordmgr.properties").
-              GetStringFromName("insecureFieldWarningLearnMore");
-          }
-          return this.__learnMoreString;
-        ]]></getter>
-      </property>
-
-      <!-- Override _getSearchTokens to have the Learn More text emphasized -->
-      <method name="_getSearchTokens">
-        <parameter name="aSearch"/>
-        <body>
-          <![CDATA[
-            return [this._learnMoreString.toLowerCase()];
-          ]]>
-        </body>
-      </method>
-
-    </implementation>
-  </binding>
-
   <binding id="autocomplete-richlistitem" extends="chrome://global/content/bindings/richlistbox.xml#richlistitem">
 
     <content align="center"
              onoverflow="this._onOverflow();"
              onunderflow="this._onUnderflow();">
       <xul:image anonid="type-icon"
                  class="ac-type-icon"
                  xbl:inherits="selected,current,type"/>
-      <xul:image anonid="site-icon"
-                 class="ac-site-icon"
+      <xul:image class="ac-site-icon"
                  xbl:inherits="src=image,selected,type"/>
       <xul:hbox class="ac-title"
                 align="center"
                 xbl:inherits="selected">
         <xul:description class="ac-text-overflow-container">
           <xul:description anonid="title-text"
                            class="ac-title-text"
                            xbl:inherits="selected"/>
@@ -1379,19 +1284,16 @@
     </content>
 
     <implementation implements="nsIDOMXULSelectControlItemElement">
       <constructor>
         <![CDATA[
           this._typeIcon = document.getAnonymousElementByAttribute(
             this, "anonid", "type-icon"
           );
-          this._siteIcon = document.getAnonymousElementByAttribute(
-            this, "anonid", "site-icon"
-          );
           this._titleText = document.getAnonymousElementByAttribute(
             this, "anonid", "title-text"
           );
           this._tags = document.getAnonymousElementByAttribute(
             this, "anonid", "tags"
           );
           this._tagsText = document.getAnonymousElementByAttribute(
             this, "anonid", "tags-text"
diff --git a/toolkit/content/widgets/richlistbox.js b/toolkit/content/widgets/richlistbox.js
--- a/toolkit/content/widgets/richlistbox.js
+++ b/toolkit/content/widgets/richlistbox.js
@@ -1,16 +1,19 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 "use strict";
 
 // This is loaded into chrome windows with the subscript loader. If you need to
 // define globals, wrap in a block to prevent leaking onto `window`.
 
+/**
+ * XUL:richlistbox element.
+ */
 MozElements.RichListBox = class RichListBox extends MozElements.BaseControl {
   constructor() {
     super();
 
     this.selectedItems = new ChromeNodeList();
     this._currentIndex = null;
     this._lastKeyTime = 0;
     this._incrementalString = "";
@@ -833,8 +836,166 @@ MozElements.RichListBox = class RichList
 };
 
 MozXULElement.implementCustomInterface(MozElements.RichListBox, [
   Ci.nsIDOMXULSelectControlElement,
   Ci.nsIDOMXULMultiSelectControlElement,
 ]);
 
 customElements.define("richlistbox", MozElements.RichListBox);
+
+/**
+ * XUL:richlistitem element.
+ */
+MozElements.MozRichlistitem = class MozRichlistitem extends MozElements.BaseText {
+  constructor() {
+    super();
+
+    this.selectedByMouseOver = false;
+
+    /**
+     * If there is no modifier key, we select on mousedown, not
+     * click, so that drags work correctly.
+     */
+    this.addEventListener("mousedown", (event) => {
+      var control = this.control;
+      if (!control || control.disabled)
+        return;
+      if ((!event.ctrlKey || (/Mac/.test(navigator.platform) && event.button == 2)) &&
+        !event.shiftKey && !event.metaKey) {
+        if (!this.selected) {
+          control.selectItem(this);
+        }
+        control.currentItem = this;
+      }
+    });
+
+    /**
+     * On a click (up+down on the same item), deselect everything
+     * except this item.
+     */
+    this.addEventListener("click", (event) => {
+      if (event.button != 0) {
+        return;
+      }
+
+      var control = this.control;
+      if (!control || control.disabled)
+        return;
+      control._userSelecting = true;
+      if (control.selType != "multiple") {
+        control.selectItem(this);
+      } else if (event.ctrlKey || event.metaKey) {
+        control.toggleItemSelection(this);
+        control.currentItem = this;
+      } else if (event.shiftKey) {
+        control.selectItemRange(null, this);
+        control.currentItem = this;
+      } else {
+        /* We want to deselect all the selected items except what was
+          clicked, UNLESS it was a right-click.  We have to do this
+          in click rather than mousedown so that you can drag a
+          selected group of items */
+
+        // use selectItemRange instead of selectItem, because this
+        // doesn't de- and reselect this item if it is selected
+        control.selectItemRange(this, this);
+      }
+      control._userSelecting = false;
+    });
+  }
+
+  /**
+   * nsIDOMXULSelectControlItemElement
+   */
+  get label() {
+    const XULNS =
+      "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
+    return Array.map(this.getElementsByTagNameNS(XULNS, "label"),
+        label => label.value)
+      .join(" ");
+  }
+
+  set searchLabel(val) {
+    if (val !== null)
+      this.setAttribute("searchlabel", val);
+    else
+      // fall back to the label property (default value)
+      this.removeAttribute("searchlabel");
+    return val;
+  }
+
+  get searchLabel() {
+    return this.hasAttribute("searchlabel") ?
+      this.getAttribute("searchlabel") : this.label;
+  }
+  /**
+   * nsIDOMXULSelectControlItemElement
+   */
+  set value(val) {
+    this.setAttribute("value", val);
+    return val;
+  }
+
+  get value() {
+    return this.getAttribute("value");
+  }
+
+  /**
+   * nsIDOMXULSelectControlItemElement
+   */
+  set selected(val) {
+    if (val)
+      this.setAttribute("selected", "true");
+    else
+      this.removeAttribute("selected");
+
+    return val;
+  }
+
+  get selected() {
+    return this.getAttribute("selected") == "true";
+  }
+  /**
+   * nsIDOMXULSelectControlItemElement
+   */
+  get control() {
+    var parent = this.parentNode;
+    while (parent) {
+      if (parent.localName == "richlistbox")
+        return parent;
+      parent = parent.parentNode;
+    }
+    return null;
+  }
+
+  set current(val) {
+    if (val)
+      this.setAttribute("current", "true");
+    else
+      this.removeAttribute("current");
+    return val;
+  }
+
+  get current() {
+    return this.getAttribute("current") == "true";
+  }
+  disconnectedCallback() {
+    var control = this.control;
+    if (!control)
+      return;
+    // When we are destructed and we are current or selected, unselect ourselves
+    // so that richlistbox's selection doesn't point to something not in the DOM.
+    // We don't want to reset last-selected, so we set _suppressOnSelect.
+    if (this.selected) {
+      var suppressSelect = control._suppressOnSelect;
+      control._suppressOnSelect = true;
+      control.removeItemFromSelection(this);
+      control._suppressOnSelect = suppressSelect;
+    }
+    if (this.current)
+      control.currentItem = null;
+  }
+};
+
+MozXULElement.implementCustomInterface(
+  MozElements.MozRichlistitem, [Ci.nsIDOMXULSelectControlItemElement]
+);
